# Comparing `tmp/openfga-sdk-0.4.1.tar.gz` & `tmp/openfga-sdk-0.4.2.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "openfga-sdk-0.4.1.tar", last modified: Tue Feb 13 17:43:30 2024, max compression
+gzip compressed data, was "openfga-sdk-0.4.2.tar", last modified: Thu Apr  4 22:49:34 2024, max compression
```

## Comparing `openfga-sdk-0.4.1.tar` & `openfga-sdk-0.4.2.tar`

### file list

```diff
@@ -1,130 +1,133 @@
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-13 17:43:30.530606 openfga-sdk-0.4.1/
--rw-r--r--   0 runner    (1001) docker     (127)    10176 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/LICENSE
--rw-r--r--   0 runner    (1001) docker     (127)   136821 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/NOTICE.txt
--rw-r--r--   0 runner    (1001) docker     (127)    42587 2024-02-13 17:43:30.530606 openfga-sdk-0.4.1/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (127)    41756 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/README.md
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-13 17:43:30.514607 openfga-sdk-0.4.1/openfga_sdk/
--rw-r--r--   0 runner    (1001) docker     (127)     5410 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-13 17:43:30.514607 openfga-sdk-0.4.1/openfga_sdk/api/
--rw-r--r--   0 runner    (1001) docker     (127)       99 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/api/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)   126250 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/api/open_fga_api.py
--rw-r--r--   0 runner    (1001) docker     (127)    30637 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/api_client.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-13 17:43:30.514607 openfga-sdk-0.4.1/openfga_sdk/client/
--rw-r--r--   0 runner    (1001) docker     (127)      607 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/client/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    32784 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/client/client.py
--rw-r--r--   0 runner    (1001) docker     (127)     1749 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/client/configuration.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-13 17:43:30.518607 openfga-sdk-0.4.1/openfga_sdk/client/models/
--rw-r--r--   0 runner    (1001) docker     (127)     1202 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/client/models/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1158 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/client/models/assertion.py
--rw-r--r--   0 runner    (1001) docker     (127)     1576 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/client/models/batch_check_response.py
--rw-r--r--   0 runner    (1001) docker     (127)     2491 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/client/models/check_request.py
--rw-r--r--   0 runner    (1001) docker     (127)      848 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/client/models/expand_request.py
--rw-r--r--   0 runner    (1001) docker     (127)     2125 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/client/models/list_objects_request.py
--rw-r--r--   0 runner    (1001) docker     (127)     2193 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/client/models/list_relations_request.py
--rw-r--r--   0 runner    (1001) docker     (127)      678 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/client/models/read_changes_request.py
--rw-r--r--   0 runner    (1001) docker     (127)     2421 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/client/models/tuple.py
--rw-r--r--   0 runner    (1001) docker     (127)     1886 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/client/models/write_request.py
--rw-r--r--   0 runner    (1001) docker     (127)     1028 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/client/models/write_response.py
--rw-r--r--   0 runner    (1001) docker     (127)     1468 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/client/models/write_single_response.py
--rw-r--r--   0 runner    (1001) docker     (127)     1573 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/client/models/write_transaction_opts.py
--rw-r--r--   0 runner    (1001) docker     (127)    21318 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/configuration.py
--rw-r--r--   0 runner    (1001) docker     (127)     5694 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/credentials.py
--rw-r--r--   0 runner    (1001) docker     (127)     6822 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/exceptions.py
--rw-r--r--   0 runner    (1001) docker     (127)     2388 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/help.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-13 17:43:30.526606 openfga-sdk-0.4.1/openfga_sdk/models/
--rw-r--r--   0 runner    (1001) docker     (127)     4763 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4493 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/aborted_message_response.py
--rw-r--r--   0 runner    (1001) docker     (127)     3657 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/any.py
--rw-r--r--   0 runner    (1001) docker     (127)     4891 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/assertion.py
--rw-r--r--   0 runner    (1001) docker     (127)     6299 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/assertion_tuple_key.py
--rw-r--r--   0 runner    (1001) docker     (127)     6724 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/authorization_model.py
--rw-r--r--   0 runner    (1001) docker     (127)     7610 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/check_request.py
--rw-r--r--   0 runner    (1001) docker     (127)     6347 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/check_request_tuple_key.py
--rw-r--r--   0 runner    (1001) docker     (127)     4604 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/check_response.py
--rw-r--r--   0 runner    (1001) docker     (127)     3916 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/computed.py
--rw-r--r--   0 runner    (1001) docker     (127)     5817 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/condition.py
--rw-r--r--   0 runner    (1001) docker     (127)     4958 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/condition_param_type_ref.py
--rw-r--r--   0 runner    (1001) docker     (127)     4103 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/contextual_tuple_keys.py
--rw-r--r--   0 runner    (1001) docker     (127)     3930 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/create_store_request.py
--rw-r--r--   0 runner    (1001) docker     (127)     6480 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/create_store_response.py
--rw-r--r--   0 runner    (1001) docker     (127)     4706 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/difference.py
--rw-r--r--   0 runner    (1001) docker     (127)     7342 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/error_code.py
--rw-r--r--   0 runner    (1001) docker     (127)     5018 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/expand_request.py
--rw-r--r--   0 runner    (1001) docker     (127)     5352 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/expand_request_tuple_key.py
--rw-r--r--   0 runner    (1001) docker     (127)     3768 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/expand_response.py
--rw-r--r--   0 runner    (1001) docker     (127)     7159 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/get_store_response.py
--rw-r--r--   0 runner    (1001) docker     (127)     3819 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/internal_error_code.py
--rw-r--r--   0 runner    (1001) docker     (127)     4607 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/internal_error_message_response.py
--rw-r--r--   0 runner    (1001) docker     (127)     5206 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/leaf.py
--rw-r--r--   0 runner    (1001) docker     (127)     8876 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/list_objects_request.py
--rw-r--r--   0 runner    (1001) docker     (127)     4022 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/list_objects_response.py
--rw-r--r--   0 runner    (1001) docker     (127)     5242 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/list_stores_response.py
--rw-r--r--   0 runner    (1001) docker     (127)     3873 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/metadata.py
--rw-r--r--   0 runner    (1001) docker     (127)     6402 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/node.py
--rw-r--r--   0 runner    (1001) docker     (127)     3869 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/nodes.py
--rw-r--r--   0 runner    (1001) docker     (127)     3495 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/not_found_error_code.py
--rw-r--r--   0 runner    (1001) docker     (127)     3256 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/null_value.py
--rw-r--r--   0 runner    (1001) docker     (127)     4460 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/object_relation.py
--rw-r--r--   0 runner    (1001) docker     (127)     4643 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/path_unknown_error_message_response.py
--rw-r--r--   0 runner    (1001) docker     (127)     5142 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/read_assertions_response.py
--rw-r--r--   0 runner    (1001) docker     (127)     4232 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/read_authorization_model_response.py
--rw-r--r--   0 runner    (1001) docker     (127)     5577 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/read_authorization_models_response.py
--rw-r--r--   0 runner    (1001) docker     (127)     5134 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/read_changes_response.py
--rw-r--r--   0 runner    (1001) docker     (127)     5428 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/read_request.py
--rw-r--r--   0 runner    (1001) docker     (127)     5863 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/read_request_tuple_key.py
--rw-r--r--   0 runner    (1001) docker     (127)     5170 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/read_response.py
--rw-r--r--   0 runner    (1001) docker     (127)     4303 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/relation_metadata.py
--rw-r--r--   0 runner    (1001) docker     (127)     6190 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/relation_reference.py
--rw-r--r--   0 runner    (1001) docker     (127)     5517 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/relationship_condition.py
--rw-r--r--   0 runner    (1001) docker     (127)     4940 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/status.py
--rw-r--r--   0 runner    (1001) docker     (127)     6895 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/store.py
--rw-r--r--   0 runner    (1001) docker     (127)     4652 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/tuple.py
--rw-r--r--   0 runner    (1001) docker     (127)     5731 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/tuple_change.py
--rw-r--r--   0 runner    (1001) docker     (127)     6880 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/tuple_key.py
--rw-r--r--   0 runner    (1001) docker     (127)     6411 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/tuple_key_without_condition.py
--rw-r--r--   0 runner    (1001) docker     (127)     3323 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/tuple_operation.py
--rw-r--r--   0 runner    (1001) docker     (127)     5059 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/tuple_to_userset.py
--rw-r--r--   0 runner    (1001) docker     (127)     5327 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/type_definition.py
--rw-r--r--   0 runner    (1001) docker     (127)     3684 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/type_name.py
--rw-r--r--   0 runner    (1001) docker     (127)     3866 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/users.py
--rw-r--r--   0 runner    (1001) docker     (127)     7712 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/userset.py
--rw-r--r--   0 runner    (1001) docker     (127)     3723 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/userset_tree.py
--rw-r--r--   0 runner    (1001) docker     (127)     4820 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/userset_tree_difference.py
--rw-r--r--   0 runner    (1001) docker     (127)     4983 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/userset_tree_tuple_to_userset.py
--rw-r--r--   0 runner    (1001) docker     (127)     3902 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/usersets.py
--rw-r--r--   0 runner    (1001) docker     (127)     4607 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/validation_error_message_response.py
--rw-r--r--   0 runner    (1001) docker     (127)     4130 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/write_assertions_request.py
--rw-r--r--   0 runner    (1001) docker     (127)     6200 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/write_authorization_model_request.py
--rw-r--r--   0 runner    (1001) docker     (127)     4430 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/write_authorization_model_response.py
--rw-r--r--   0 runner    (1001) docker     (127)     5468 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/write_request.py
--rw-r--r--   0 runner    (1001) docker     (127)     4151 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/write_request_deletes.py
--rw-r--r--   0 runner    (1001) docker     (127)     4095 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/models/write_request_writes.py
--rw-r--r--   0 runner    (1001) docker     (127)     2940 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/oauth2.py
--rw-r--r--   0 runner    (1001) docker     (127)    10640 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/rest.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-13 17:43:30.526606 openfga-sdk-0.4.1/openfga_sdk/sync/
--rw-r--r--   0 runner    (1001) docker     (127)      501 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/sync/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    30111 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/sync/api_client.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-13 17:43:30.526606 openfga-sdk-0.4.1/openfga_sdk/sync/client/
--rw-r--r--   0 runner    (1001) docker     (127)      393 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/sync/client/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    32455 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/sync/client/client.py
--rw-r--r--   0 runner    (1001) docker     (127)     2916 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/sync/oauth2.py
--rw-r--r--   0 runner    (1001) docker     (127)   125686 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/sync/open_fga_api.py
--rw-r--r--   0 runner    (1001) docker     (127)    12905 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/sync/rest.py
--rw-r--r--   0 runner    (1001) docker     (127)      629 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/openfga_sdk/validation.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-13 17:43:30.514607 openfga-sdk-0.4.1/openfga_sdk.egg-info/
--rw-r--r--   0 runner    (1001) docker     (127)    42587 2024-02-13 17:43:30.000000 openfga-sdk-0.4.1/openfga_sdk.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (127)     4275 2024-02-13 17:43:30.000000 openfga-sdk-0.4.1/openfga_sdk.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (127)        1 2024-02-13 17:43:30.000000 openfga-sdk-0.4.1/openfga_sdk.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (127)       65 2024-02-13 17:43:30.000000 openfga-sdk-0.4.1/openfga_sdk.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (127)       12 2024-02-13 17:43:30.000000 openfga-sdk-0.4.1/openfga_sdk.egg-info/top_level.txt
--rw-r--r--   0 runner    (1001) docker     (127)       69 2024-02-13 17:43:30.530606 openfga-sdk-0.4.1/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (127)     1934 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-13 17:43:30.530606 openfga-sdk-0.4.1/test/
--rw-r--r--   0 runner    (1001) docker     (127)    98648 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/test/test_client.py
--rw-r--r--   0 runner    (1001) docker     (127)    97936 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/test/test_client_sync.py
--rw-r--r--   0 runner    (1001) docker     (127)     6287 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/test/test_credentials.py
--rw-r--r--   0 runner    (1001) docker     (127)     4589 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/test/test_oauth2.py
--rw-r--r--   0 runner    (1001) docker     (127)     4552 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/test/test_oauth2_sync.py
--rw-r--r--   0 runner    (1001) docker     (127)    52066 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/test/test_open_fga_api.py
--rw-r--r--   0 runner    (1001) docker     (127)    51386 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/test/test_open_fga_api_sync.py
--rw-r--r--   0 runner    (1001) docker     (127)     1848 2024-02-13 17:43:21.000000 openfga-sdk-0.4.1/test/test_validation.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-04 22:49:34.224685 openfga-sdk-0.4.2/
+-rw-r--r--   0 runner    (1001) docker     (127)    10176 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (127)   135454 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/NOTICE.txt
+-rw-r--r--   0 runner    (1001) docker     (127)    44246 2024-04-04 22:49:34.224685 openfga-sdk-0.4.2/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (127)    43272 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/README.md
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-04 22:49:34.204685 openfga-sdk-0.4.2/openfga_sdk/
+-rw-r--r--   0 runner    (1001) docker     (127)     5336 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-04 22:49:34.208685 openfga-sdk-0.4.2/openfga_sdk/api/
+-rw-r--r--   0 runner    (1001) docker     (127)       52 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/api/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)   124866 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/api/open_fga_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    29404 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/api_client.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-04 22:49:34.208685 openfga-sdk-0.4.2/openfga_sdk/client/
+-rw-r--r--   0 runner    (1001) docker     (127)      550 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/client/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    33561 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/client/client.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1880 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/client/configuration.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-04 22:49:34.208685 openfga-sdk-0.4.2/openfga_sdk/client/models/
+-rw-r--r--   0 runner    (1001) docker     (127)     1186 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/client/models/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1140 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/client/models/assertion.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1597 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/client/models/batch_check_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2526 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/client/models/check_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)      830 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/client/models/expand_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2137 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/client/models/list_objects_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2205 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/client/models/list_relations_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)      660 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/client/models/read_changes_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2474 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/client/models/tuple.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1857 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/client/models/write_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1016 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/client/models/write_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1504 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/client/models/write_single_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1596 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/client/models/write_transaction_opts.py
+-rw-r--r--   0 runner    (1001) docker     (127)    22550 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/configuration.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5784 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/credentials.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6529 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/exceptions.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2210 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/help.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-04 22:49:34.220685 openfga-sdk-0.4.2/openfga_sdk/models/
+-rw-r--r--   0 runner    (1001) docker     (127)     4881 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4192 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/aborted_message_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3414 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/any.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4534 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/assertion.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6008 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/assertion_tuple_key.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6428 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/authorization_model.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7208 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/check_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6056 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/check_request_tuple_key.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4275 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/check_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3645 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/computed.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6117 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/condition.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4279 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/condition_metadata.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4666 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/condition_param_type_ref.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3832 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/contextual_tuple_keys.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3659 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/create_store_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6084 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/create_store_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4349 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/difference.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7632 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/error_code.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4749 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/expand_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5087 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/expand_request_tuple_key.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3525 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/expand_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6729 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/get_store_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3717 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/internal_error_code.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4306 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/internal_error_message_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4956 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/leaf.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8504 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/list_objects_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3751 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/list_objects_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4937 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/list_stores_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4965 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/metadata.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6056 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/node.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3598 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/nodes.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3337 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/not_found_error_code.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3059 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/null_value.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4159 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/object_relation.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4342 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/path_unknown_error_message_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4941 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/read_assertions_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3989 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/read_authorization_model_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5371 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/read_authorization_models_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4791 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/read_changes_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5178 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/read_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5656 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/read_request_tuple_key.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4865 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/read_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5459 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/relation_metadata.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5850 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/relation_reference.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5178 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/relationship_condition.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3469 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/source_info.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4595 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/status.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6465 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/store.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4295 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/tuple.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5397 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/tuple_change.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6650 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/tuple_key.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6120 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/tuple_key_without_condition.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3126 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/tuple_operation.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4752 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/tuple_to_userset.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4985 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/type_definition.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3590 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/type_name.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3595 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/users.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7332 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/userset.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3480 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/userset_tree.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4463 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/userset_tree_difference.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4626 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/userset_tree_tuple_to_userset.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3631 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/usersets.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4306 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/validation_error_message_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3859 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/write_assertions_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5966 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/write_authorization_model_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4225 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/write_authorization_model_response.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5218 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/write_request.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3880 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/write_request_deletes.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3824 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/models/write_request_writes.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4490 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/oauth2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9954 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/rest.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-04 22:49:34.220685 openfga-sdk-0.4.2/openfga_sdk/sync/
+-rw-r--r--   0 runner    (1001) docker     (127)      469 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/sync/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    29241 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/sync/api_client.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-04 22:49:34.220685 openfga-sdk-0.4.2/openfga_sdk/sync/client/
+-rw-r--r--   0 runner    (1001) docker     (127)      361 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/sync/client/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    33113 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/sync/client/client.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4454 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/sync/oauth2.py
+-rw-r--r--   0 runner    (1001) docker     (127)   124326 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/sync/open_fga_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12881 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/sync/rest.py
+-rw-r--r--   0 runner    (1001) docker     (127)      612 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/openfga_sdk/validation.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-04 22:49:34.224685 openfga-sdk-0.4.2/openfga_sdk.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (127)    44246 2024-04-04 22:49:34.000000 openfga-sdk-0.4.2/openfga_sdk.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (127)     4377 2024-04-04 22:49:34.000000 openfga-sdk-0.4.2/openfga_sdk.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (127)        1 2024-04-04 22:49:34.000000 openfga-sdk-0.4.2/openfga_sdk.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (127)       83 2024-04-04 22:49:34.000000 openfga-sdk-0.4.2/openfga_sdk.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (127)       12 2024-04-04 22:49:34.000000 openfga-sdk-0.4.2/openfga_sdk.egg-info/top_level.txt
+-rw-r--r--   0 runner    (1001) docker     (127)      419 2024-04-04 22:49:34.224685 openfga-sdk-0.4.2/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (127)     1869 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-04 22:49:34.224685 openfga-sdk-0.4.2/test/
+-rw-r--r--   0 runner    (1001) docker     (127)   107961 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/test/test_client.py
+-rw-r--r--   0 runner    (1001) docker     (127)   107215 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/test/test_client_sync.py
+-rw-r--r--   0 runner    (1001) docker     (127)    16134 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/test/test_configuration.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6357 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/test/test_credentials.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9367 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/test/test_oauth2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9267 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/test/test_oauth2_sync.py
+-rw-r--r--   0 runner    (1001) docker     (127)    57752 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/test/test_open_fga_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    57120 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/test/test_open_fga_api_sync.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2069 2024-04-04 22:49:24.000000 openfga-sdk-0.4.2/test/test_validation.py
```

### Comparing `openfga-sdk-0.4.1/LICENSE` & `openfga-sdk-0.4.2/LICENSE`

 * *Files identical despite different names*

### Comparing `openfga-sdk-0.4.1/NOTICE.txt` & `openfga-sdk-0.4.2/NOTICE.txt`

 * *Files 1% similar despite different names*

```diff
@@ -39,15 +39,14 @@
 
 - aiohttp (3.8.3) [MIT, Apache-2.0]
 - flake8 (5.0.4) [MIT]
 - mock (4.0.3) [BSD-2-Clause]
 - pytest-cov (2.8.1) [MIT]
 - python-dateutil (2.8.2) [Multi-license: Apache-2.0 OR BSD-3-Clause]
 - setuptools (66.0.0) [MIT, MPL-2.0, GPL-3.0-only, BSD-3-Clause, Apache-2.0, Python-2.0]
-- six (1.16.0) [MIT]
 - urllib3 (1.26.14) [MIT, Apache-2.0, Python-2.0]
 
 
 --------------------------------------------------------------------------------
 Package Title: aiohttp (3.8.3)
 --------------------------------------------------------------------------------
 
@@ -444,41 +443,14 @@
    7. This License Agreement shall be governed by and interpreted in all respects by the law of the State of Virginia, excluding conflict of law provisions. Nothing in this License Agreement shall be deemed to create any relationship of agency, partnership, or joint venture between CNRI and Licensee. This License Agreement does not grant permission to use CNRI trademarks or trade name in a trademark sense to endorse or promote products or services of Licensee, or any third party.
    8. By clicking on the "ACCEPT" button where indicated, or by copying, installing or otherwise using Python 1.6b1, Licensee agrees to be bound by the terms and conditions of this License Agreement.
 Copyright (c) 1991 - 1995, Stichting Mathematisch Centrum Amsterdam, The Netherlands. All rights reserved.
 Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of Stichting Mathematisch Centrum or CWI not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.
 STICHTING MATHEMATISCH CENTRUM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL STICHTING MATHEMATISCH CENTRUM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
 
---------------------------------------------------------------------------------
-Package Title: six (1.16.0)
---------------------------------------------------------------------------------
-
-* Declared Licenses *
-MIT
-
-Copyright (c) 2010-2020 Benjamin Peterson
-
-Permission is hereby granted, free of charge, to any person obtaining a copy of
-this software and associated documentation files (the "Software"), to deal in
-the Software without restriction, including without limitation the rights to
-use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-the Software, and to permit persons to whom the Software is furnished to do so,
-subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-
 
 --------------------------------------------------------------------------------
 Package Title: urllib3 (1.26.14)
 --------------------------------------------------------------------------------
 
 * Declared Licenses *
 MIT
@@ -608,33 +580,33 @@
 
 * Apache-2.0 *
 
 Apache License
 Version 2.0, January 2004
 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
    1. Definitions.
-      
+
       "License" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.
-      
+
       "Licensor" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.
-      
+
       "Legal Entity" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, "control" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.
-      
+
       "You" (or "Your") shall mean an individual or Legal Entity exercising permissions granted by this License.
-      
+
       "Source" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.
-      
+
       "Object" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.
-      
+
       "Work" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).
-      
+
       "Derivative Works" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.
-      
+
       "Contribution" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, "submitted" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as "Not a Contribution."
-      
+
       "Contributor" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.
    2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.
    3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.
    4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:
       (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and
       (b) You must cause any modified files to carry prominent notices stating that You changed the files; and
       (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and
```

### Comparing `openfga-sdk-0.4.1/PKG-INFO` & `openfga-sdk-0.4.2/README.md`

 * *Files 1% similar despite different names*

```diff
@@ -1,34 +1,14 @@
-Metadata-Version: 2.1
-Name: openfga-sdk
-Version: 0.4.1
-Summary: A high performance and flexible authorization/permission engine built for developers and inspired by Google Zanzibar.
-Home-page: https://github.com/openfga/python-sdk
-Author: OpenFGA (https://openfga.dev)
-Author-email: community@openfga.dev
-License: Apache-2.0
-Keywords: openfga,authorization,fga,fine-grained-authorization,rebac,zanzibar
-Classifier: Development Status :: 5 - Production/Stable
-Classifier: Intended Audience :: Developers
-Classifier: License :: OSI Approved :: Apache Software License
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11
-Classifier: Programming Language :: Python :: 3.12
-Requires-Python: >=3.10
-Description-Content-Type: text/markdown
-License-File: LICENSE
-License-File: NOTICE.txt
-
 # Python SDK for OpenFGA
 
 [![pypi](https://img.shields.io/pypi/v/openfga_sdk.svg?style=flat)](https://pypi.org/project/openfga_sdk)
 [![Release](https://img.shields.io/github/v/release/openfga/python-sdk?sort=semver&color=green)](https://github.com/openfga/python-sdk/releases)
 [![License](https://img.shields.io/badge/License-Apache_2.0-blue.svg)](./LICENSE)
 [![FOSSA Status](https://app.fossa.com/api/projects/git%2Bgithub.com%2Fopenfga%2Fpython-sdk.svg?type=shield)](https://app.fossa.com/projects/git%2Bgithub.com%2Fopenfga%2Fpython-sdk?ref=badge_shield)
-[![Discord Server](https://img.shields.io/discord/759188666072825867?color=7289da&logo=discord "Discord Server")](https://discord.gg/8naAwJfWN6)
+[![Join our community](https://img.shields.io/badge/slack-cncf_%23openfga-40abb8.svg?logo=slack)](https://openfga.dev/community)
 [![Twitter](https://img.shields.io/twitter/follow/openfga?color=%23179CF0&logo=twitter&style=flat-square "@openfga on Twitter")](https://twitter.com/openfga)
 
 This is an autogenerated python SDK for OpenFGA. It provides a wrapper around the [OpenFGA API definition](https://openfga.dev/api).
 
 ## Table of Contents
 
 - [About OpenFGA](#about)
@@ -57,14 +37,15 @@
       - [Batch Check](#batch-check)
       - [Expand](#expand)
       - [List Objects](#list-objects)
       - [List Relations](#list-relations)
     - [Assertions](#assertions)
       - [Read Assertions](#read-assertions)
       - [Write Assertions](#write-assertions)
+  - [Retries](#retries)
   - [API Endpoints](#api-endpoints)
   - [Models](#models)
 - [Contributing](#contributing)
   - [Issues](#issues)
   - [Pull Requests](#pull-requests)
 - [License](#license)
 
@@ -76,15 +57,15 @@
 
 
 ## Resources
 
 - [OpenFGA Documentation](https://openfga.dev/docs)
 - [OpenFGA API Documentation](https://openfga.dev/api/service)
 - [Twitter](https://twitter.com/openfga)
-- [OpenFGA Discord Community](https://discord.gg/8naAwJfWN6)
+- [OpenFGA Community](https://openfga.dev/community)
 - [Zanzibar Academy](https://zanzibar.academy)
 - [Google's Zanzibar Paper (2019)](https://research.google/pubs/pub48190/)
 
 ## Installation
 
 ### pip install
 
@@ -133,17 +114,17 @@
 
 ## Getting Started
 
 ### Initializing the API Client
 
 [Learn how to initialize your SDK](https://openfga.dev/docs/getting-started/setup-sdk-client)
 
-The documentation below refers to the `OpenFgaClient`, to read the documentation for `OpenFgaApi`, check out the [`v0.1.1` documentation](https://github.com/openfga/python-sdk/tree/v0.1.1#readme).
+We strongly recommend you initialize the `OpenFgaClient` only once and then re-use it throughout your app, otherwise you will incur the cost of having to re-initialize multiple times or at every request, the cost of reduced connection pooling and re-use, and would be particularly costly in the client credentials flow, as that flow will be preformed on every request.
 
-> The OpenFgaClient will by default retry API requests up to 15 times on 429 and 5xx errors.
+> The `OpenFgaClient` will by default retry API requests up to 15 times on 429 and 5xx errors.
 
 #### No Credentials
 
 ```python
 from openfga_sdk import ClientConfiguration, OpenFgaClient
 
 
@@ -972,14 +953,40 @@
     expectation=True,
 )]
 
 response = await fga_client.write_assertions(body, options)
 ```
 
 
+### Retries
+
+If a network request fails with a 429 or 5xx error from the server, the SDK will automatically retry the request up to 15 times with a minimum wait time of 100 milliseconds between each attempt.
+
+To customize this behavior, create a `RetryParams` object and assign values to the `max_retry` and `min_wait_in_ms` constructor parameters. `max_retry` determines the maximum number of retries (up to 15), while `min_wait_in_ms` sets the minimum wait time between retries in milliseconds.
+
+Apply your custom retry values by passing the object to the `ClientConfiguration` constructor's `retry_params` parameter.
+
+```python
+from openfga_sdk import ClientConfiguration, OpenFgaClient
+from openfga_sdk.configuration import RetryParams
+from os import environ
+
+async def main():
+    # Configure the client with custom retry settings
+    config = ClientConfiguration(
+        api_url=environ.get("FGA_API_URL"),
+        retry_params=RetryParams(max_retry=3, min_wait_in_ms=250)
+    )
+
+    # Create a client instance and read authorization models
+    async with OpenFgaClient(config) as client:
+        return await client.read_authorization_models()
+```
+
+
 ### API Endpoints
 
 Class | Method | HTTP request | Description
 ------------ | ------------- | ------------- | -------------
 *OpenFgaApi* | [**check**](https://github.com/openfga/python-sdk/blob/main/docs/OpenFgaApi.md#check) | **POST** /stores/{store_id}/check | Check whether a user is authorized to access an object
 *OpenFgaApi* | [**create_store**](https://github.com/openfga/python-sdk/blob/main/docs/OpenFgaApi.md#create_store) | **POST** /stores | Create a store
 *OpenFgaApi* | [**delete_store**](https://github.com/openfga/python-sdk/blob/main/docs/OpenFgaApi.md#delete_store) | **DELETE** /stores/{store_id} | Delete a store
@@ -993,28 +1000,30 @@
 *OpenFgaApi* | [**read_authorization_models**](https://github.com/openfga/python-sdk/blob/main/docs/OpenFgaApi.md#read_authorization_models) | **GET** /stores/{store_id}/authorization-models | Return all the authorization models for a particular store
 *OpenFgaApi* | [**read_changes**](https://github.com/openfga/python-sdk/blob/main/docs/OpenFgaApi.md#read_changes) | **GET** /stores/{store_id}/changes | Return a list of all the tuple changes
 *OpenFgaApi* | [**write**](https://github.com/openfga/python-sdk/blob/main/docs/OpenFgaApi.md#write) | **POST** /stores/{store_id}/write | Add or delete tuples from the store
 *OpenFgaApi* | [**write_assertions**](https://github.com/openfga/python-sdk/blob/main/docs/OpenFgaApi.md#write_assertions) | **PUT** /stores/{store_id}/assertions/{authorization_model_id} | Upsert assertions for an authorization model ID
 *OpenFgaApi* | [**write_authorization_model**](https://github.com/openfga/python-sdk/blob/main/docs/OpenFgaApi.md#write_authorization_model) | **POST** /stores/{store_id}/authorization-models | Create a new authorization model
 
 
+
 ### Models
 
 ## Documentation For Models
 
  - [AbortedMessageResponse](https://github.com/openfga/python-sdk/blob/main/docs/AbortedMessageResponse.md)
  - [Any](https://github.com/openfga/python-sdk/blob/main/docs/Any.md)
  - [Assertion](https://github.com/openfga/python-sdk/blob/main/docs/Assertion.md)
  - [AssertionTupleKey](https://github.com/openfga/python-sdk/blob/main/docs/AssertionTupleKey.md)
  - [AuthorizationModel](https://github.com/openfga/python-sdk/blob/main/docs/AuthorizationModel.md)
  - [CheckRequest](https://github.com/openfga/python-sdk/blob/main/docs/CheckRequest.md)
  - [CheckRequestTupleKey](https://github.com/openfga/python-sdk/blob/main/docs/CheckRequestTupleKey.md)
  - [CheckResponse](https://github.com/openfga/python-sdk/blob/main/docs/CheckResponse.md)
  - [Computed](https://github.com/openfga/python-sdk/blob/main/docs/Computed.md)
  - [Condition](https://github.com/openfga/python-sdk/blob/main/docs/Condition.md)
+ - [ConditionMetadata](https://github.com/openfga/python-sdk/blob/main/docs/ConditionMetadata.md)
  - [ConditionParamTypeRef](https://github.com/openfga/python-sdk/blob/main/docs/ConditionParamTypeRef.md)
  - [ContextualTupleKeys](https://github.com/openfga/python-sdk/blob/main/docs/ContextualTupleKeys.md)
  - [CreateStoreRequest](https://github.com/openfga/python-sdk/blob/main/docs/CreateStoreRequest.md)
  - [CreateStoreResponse](https://github.com/openfga/python-sdk/blob/main/docs/CreateStoreResponse.md)
  - [Difference](https://github.com/openfga/python-sdk/blob/main/docs/Difference.md)
  - [ErrorCode](https://github.com/openfga/python-sdk/blob/main/docs/ErrorCode.md)
  - [ExpandRequest](https://github.com/openfga/python-sdk/blob/main/docs/ExpandRequest.md)
@@ -1040,14 +1049,15 @@
  - [ReadChangesResponse](https://github.com/openfga/python-sdk/blob/main/docs/ReadChangesResponse.md)
  - [ReadRequest](https://github.com/openfga/python-sdk/blob/main/docs/ReadRequest.md)
  - [ReadRequestTupleKey](https://github.com/openfga/python-sdk/blob/main/docs/ReadRequestTupleKey.md)
  - [ReadResponse](https://github.com/openfga/python-sdk/blob/main/docs/ReadResponse.md)
  - [RelationMetadata](https://github.com/openfga/python-sdk/blob/main/docs/RelationMetadata.md)
  - [RelationReference](https://github.com/openfga/python-sdk/blob/main/docs/RelationReference.md)
  - [RelationshipCondition](https://github.com/openfga/python-sdk/blob/main/docs/RelationshipCondition.md)
+ - [SourceInfo](https://github.com/openfga/python-sdk/blob/main/docs/SourceInfo.md)
  - [Status](https://github.com/openfga/python-sdk/blob/main/docs/Status.md)
  - [Store](https://github.com/openfga/python-sdk/blob/main/docs/Store.md)
  - [Tuple](https://github.com/openfga/python-sdk/blob/main/docs/Tuple.md)
  - [TupleChange](https://github.com/openfga/python-sdk/blob/main/docs/TupleChange.md)
  - [TupleKey](https://github.com/openfga/python-sdk/blob/main/docs/TupleKey.md)
  - [TupleKeyWithoutCondition](https://github.com/openfga/python-sdk/blob/main/docs/TupleKeyWithoutCondition.md)
  - [TupleOperation](https://github.com/openfga/python-sdk/blob/main/docs/TupleOperation.md)
@@ -1085,7 +1095,8 @@
 [OpenFGA](https://github.com/openfga)
 
 ## License
 
 This project is licensed under the Apache-2.0 license. See the [LICENSE](https://github.com/openfga/python-sdk/blob/main/LICENSE) file for more info.
 
 The code in this repo was auto generated by [OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator) from a template based on the [python legacy template](https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/python-legacy), licensed under the [Apache License 2.0](https://github.com/OpenAPITools/openapi-generator/blob/master/LICENSE).
+
```

### Comparing `openfga-sdk-0.4.1/README.md` & `openfga-sdk-0.4.2/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,38 @@
+Metadata-Version: 2.1
+Name: openfga-sdk
+Version: 0.4.2
+Summary: A high performance and flexible authorization/permission engine built for developers and inspired by Google Zanzibar.
+Home-page: https://github.com/openfga/python-sdk
+Author: OpenFGA (https://openfga.dev)
+Author-email: community@openfga.dev
+License: Apache-2.0
+Keywords: openfga,authorization,fga,fine-grained-authorization,rebac,zanzibar
+Classifier: Development Status :: 5 - Production/Stable
+Classifier: Intended Audience :: Developers
+Classifier: License :: OSI Approved :: Apache Software License
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: 3.12
+Requires-Python: >=3.10
+Description-Content-Type: text/markdown
+License-File: LICENSE
+License-File: NOTICE.txt
+Requires-Dist: aiohttp<4,>=3.9.3
+Requires-Dist: python-dateutil<3,>=2.9.0
+Requires-Dist: setuptools>=69.1.1
+Requires-Dist: urllib3<3,>=1.25.11
+
 # Python SDK for OpenFGA
 
 [![pypi](https://img.shields.io/pypi/v/openfga_sdk.svg?style=flat)](https://pypi.org/project/openfga_sdk)
 [![Release](https://img.shields.io/github/v/release/openfga/python-sdk?sort=semver&color=green)](https://github.com/openfga/python-sdk/releases)
 [![License](https://img.shields.io/badge/License-Apache_2.0-blue.svg)](./LICENSE)
 [![FOSSA Status](https://app.fossa.com/api/projects/git%2Bgithub.com%2Fopenfga%2Fpython-sdk.svg?type=shield)](https://app.fossa.com/projects/git%2Bgithub.com%2Fopenfga%2Fpython-sdk?ref=badge_shield)
-[![Discord Server](https://img.shields.io/discord/759188666072825867?color=7289da&logo=discord "Discord Server")](https://discord.gg/8naAwJfWN6)
+[![Join our community](https://img.shields.io/badge/slack-cncf_%23openfga-40abb8.svg?logo=slack)](https://openfga.dev/community)
 [![Twitter](https://img.shields.io/twitter/follow/openfga?color=%23179CF0&logo=twitter&style=flat-square "@openfga on Twitter")](https://twitter.com/openfga)
 
 This is an autogenerated python SDK for OpenFGA. It provides a wrapper around the [OpenFGA API definition](https://openfga.dev/api).
 
 ## Table of Contents
 
 - [About OpenFGA](#about)
@@ -37,14 +61,15 @@
       - [Batch Check](#batch-check)
       - [Expand](#expand)
       - [List Objects](#list-objects)
       - [List Relations](#list-relations)
     - [Assertions](#assertions)
       - [Read Assertions](#read-assertions)
       - [Write Assertions](#write-assertions)
+  - [Retries](#retries)
   - [API Endpoints](#api-endpoints)
   - [Models](#models)
 - [Contributing](#contributing)
   - [Issues](#issues)
   - [Pull Requests](#pull-requests)
 - [License](#license)
 
@@ -56,15 +81,15 @@
 
 
 ## Resources
 
 - [OpenFGA Documentation](https://openfga.dev/docs)
 - [OpenFGA API Documentation](https://openfga.dev/api/service)
 - [Twitter](https://twitter.com/openfga)
-- [OpenFGA Discord Community](https://discord.gg/8naAwJfWN6)
+- [OpenFGA Community](https://openfga.dev/community)
 - [Zanzibar Academy](https://zanzibar.academy)
 - [Google's Zanzibar Paper (2019)](https://research.google/pubs/pub48190/)
 
 ## Installation
 
 ### pip install
 
@@ -113,17 +138,17 @@
 
 ## Getting Started
 
 ### Initializing the API Client
 
 [Learn how to initialize your SDK](https://openfga.dev/docs/getting-started/setup-sdk-client)
 
-The documentation below refers to the `OpenFgaClient`, to read the documentation for `OpenFgaApi`, check out the [`v0.1.1` documentation](https://github.com/openfga/python-sdk/tree/v0.1.1#readme).
+We strongly recommend you initialize the `OpenFgaClient` only once and then re-use it throughout your app, otherwise you will incur the cost of having to re-initialize multiple times or at every request, the cost of reduced connection pooling and re-use, and would be particularly costly in the client credentials flow, as that flow will be preformed on every request.
 
-> The OpenFgaClient will by default retry API requests up to 15 times on 429 and 5xx errors.
+> The `OpenFgaClient` will by default retry API requests up to 15 times on 429 and 5xx errors.
 
 #### No Credentials
 
 ```python
 from openfga_sdk import ClientConfiguration, OpenFgaClient
 
 
@@ -952,14 +977,40 @@
     expectation=True,
 )]
 
 response = await fga_client.write_assertions(body, options)
 ```
 
 
+### Retries
+
+If a network request fails with a 429 or 5xx error from the server, the SDK will automatically retry the request up to 15 times with a minimum wait time of 100 milliseconds between each attempt.
+
+To customize this behavior, create a `RetryParams` object and assign values to the `max_retry` and `min_wait_in_ms` constructor parameters. `max_retry` determines the maximum number of retries (up to 15), while `min_wait_in_ms` sets the minimum wait time between retries in milliseconds.
+
+Apply your custom retry values by passing the object to the `ClientConfiguration` constructor's `retry_params` parameter.
+
+```python
+from openfga_sdk import ClientConfiguration, OpenFgaClient
+from openfga_sdk.configuration import RetryParams
+from os import environ
+
+async def main():
+    # Configure the client with custom retry settings
+    config = ClientConfiguration(
+        api_url=environ.get("FGA_API_URL"),
+        retry_params=RetryParams(max_retry=3, min_wait_in_ms=250)
+    )
+
+    # Create a client instance and read authorization models
+    async with OpenFgaClient(config) as client:
+        return await client.read_authorization_models()
+```
+
+
 ### API Endpoints
 
 Class | Method | HTTP request | Description
 ------------ | ------------- | ------------- | -------------
 *OpenFgaApi* | [**check**](https://github.com/openfga/python-sdk/blob/main/docs/OpenFgaApi.md#check) | **POST** /stores/{store_id}/check | Check whether a user is authorized to access an object
 *OpenFgaApi* | [**create_store**](https://github.com/openfga/python-sdk/blob/main/docs/OpenFgaApi.md#create_store) | **POST** /stores | Create a store
 *OpenFgaApi* | [**delete_store**](https://github.com/openfga/python-sdk/blob/main/docs/OpenFgaApi.md#delete_store) | **DELETE** /stores/{store_id} | Delete a store
@@ -973,28 +1024,30 @@
 *OpenFgaApi* | [**read_authorization_models**](https://github.com/openfga/python-sdk/blob/main/docs/OpenFgaApi.md#read_authorization_models) | **GET** /stores/{store_id}/authorization-models | Return all the authorization models for a particular store
 *OpenFgaApi* | [**read_changes**](https://github.com/openfga/python-sdk/blob/main/docs/OpenFgaApi.md#read_changes) | **GET** /stores/{store_id}/changes | Return a list of all the tuple changes
 *OpenFgaApi* | [**write**](https://github.com/openfga/python-sdk/blob/main/docs/OpenFgaApi.md#write) | **POST** /stores/{store_id}/write | Add or delete tuples from the store
 *OpenFgaApi* | [**write_assertions**](https://github.com/openfga/python-sdk/blob/main/docs/OpenFgaApi.md#write_assertions) | **PUT** /stores/{store_id}/assertions/{authorization_model_id} | Upsert assertions for an authorization model ID
 *OpenFgaApi* | [**write_authorization_model**](https://github.com/openfga/python-sdk/blob/main/docs/OpenFgaApi.md#write_authorization_model) | **POST** /stores/{store_id}/authorization-models | Create a new authorization model
 
 
+
 ### Models
 
 ## Documentation For Models
 
  - [AbortedMessageResponse](https://github.com/openfga/python-sdk/blob/main/docs/AbortedMessageResponse.md)
  - [Any](https://github.com/openfga/python-sdk/blob/main/docs/Any.md)
  - [Assertion](https://github.com/openfga/python-sdk/blob/main/docs/Assertion.md)
  - [AssertionTupleKey](https://github.com/openfga/python-sdk/blob/main/docs/AssertionTupleKey.md)
  - [AuthorizationModel](https://github.com/openfga/python-sdk/blob/main/docs/AuthorizationModel.md)
  - [CheckRequest](https://github.com/openfga/python-sdk/blob/main/docs/CheckRequest.md)
  - [CheckRequestTupleKey](https://github.com/openfga/python-sdk/blob/main/docs/CheckRequestTupleKey.md)
  - [CheckResponse](https://github.com/openfga/python-sdk/blob/main/docs/CheckResponse.md)
  - [Computed](https://github.com/openfga/python-sdk/blob/main/docs/Computed.md)
  - [Condition](https://github.com/openfga/python-sdk/blob/main/docs/Condition.md)
+ - [ConditionMetadata](https://github.com/openfga/python-sdk/blob/main/docs/ConditionMetadata.md)
  - [ConditionParamTypeRef](https://github.com/openfga/python-sdk/blob/main/docs/ConditionParamTypeRef.md)
  - [ContextualTupleKeys](https://github.com/openfga/python-sdk/blob/main/docs/ContextualTupleKeys.md)
  - [CreateStoreRequest](https://github.com/openfga/python-sdk/blob/main/docs/CreateStoreRequest.md)
  - [CreateStoreResponse](https://github.com/openfga/python-sdk/blob/main/docs/CreateStoreResponse.md)
  - [Difference](https://github.com/openfga/python-sdk/blob/main/docs/Difference.md)
  - [ErrorCode](https://github.com/openfga/python-sdk/blob/main/docs/ErrorCode.md)
  - [ExpandRequest](https://github.com/openfga/python-sdk/blob/main/docs/ExpandRequest.md)
@@ -1020,14 +1073,15 @@
  - [ReadChangesResponse](https://github.com/openfga/python-sdk/blob/main/docs/ReadChangesResponse.md)
  - [ReadRequest](https://github.com/openfga/python-sdk/blob/main/docs/ReadRequest.md)
  - [ReadRequestTupleKey](https://github.com/openfga/python-sdk/blob/main/docs/ReadRequestTupleKey.md)
  - [ReadResponse](https://github.com/openfga/python-sdk/blob/main/docs/ReadResponse.md)
  - [RelationMetadata](https://github.com/openfga/python-sdk/blob/main/docs/RelationMetadata.md)
  - [RelationReference](https://github.com/openfga/python-sdk/blob/main/docs/RelationReference.md)
  - [RelationshipCondition](https://github.com/openfga/python-sdk/blob/main/docs/RelationshipCondition.md)
+ - [SourceInfo](https://github.com/openfga/python-sdk/blob/main/docs/SourceInfo.md)
  - [Status](https://github.com/openfga/python-sdk/blob/main/docs/Status.md)
  - [Store](https://github.com/openfga/python-sdk/blob/main/docs/Store.md)
  - [Tuple](https://github.com/openfga/python-sdk/blob/main/docs/Tuple.md)
  - [TupleChange](https://github.com/openfga/python-sdk/blob/main/docs/TupleChange.md)
  - [TupleKey](https://github.com/openfga/python-sdk/blob/main/docs/TupleKey.md)
  - [TupleKeyWithoutCondition](https://github.com/openfga/python-sdk/blob/main/docs/TupleKeyWithoutCondition.md)
  - [TupleOperation](https://github.com/openfga/python-sdk/blob/main/docs/TupleOperation.md)
@@ -1065,7 +1119,8 @@
 [OpenFGA](https://github.com/openfga)
 
 ## License
 
 This project is licensed under the Apache-2.0 license. See the [LICENSE](https://github.com/openfga/python-sdk/blob/main/LICENSE) file for more info.
 
 The code in this repo was auto generated by [OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator) from a template based on the [python legacy template](https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/python-legacy), licensed under the [Apache License 2.0](https://github.com/OpenAPITools/openapi-generator/blob/master/LICENSE).
+
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/__init__.py` & `openfga-sdk-0.4.2/openfga_sdk/models/__init__.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,84 +1,72 @@
-# coding: utf-8
-
-# flake8: noqa
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
-__version__ = "0.4.1"
-
-from openfga_sdk.client.client import OpenFgaClient
-from openfga_sdk.client.configuration import ClientConfiguration
-
-# import apis into sdk package
-from openfga_sdk.api.open_fga_api import OpenFgaApi
-
-# import ApiClient
-from openfga_sdk.api_client import ApiClient
-from openfga_sdk.configuration import Configuration
-from openfga_sdk.exceptions import OpenApiException
-from openfga_sdk.exceptions import FgaValidationException
-from openfga_sdk.exceptions import ApiValueError
-from openfga_sdk.exceptions import ApiKeyError
-from openfga_sdk.exceptions import ApiAttributeError
-from openfga_sdk.exceptions import ApiException
-# import models into sdk package
 from openfga_sdk.models.aborted_message_response import AbortedMessageResponse
 from openfga_sdk.models.any import Any
 from openfga_sdk.models.assertion import Assertion
 from openfga_sdk.models.assertion_tuple_key import AssertionTupleKey
 from openfga_sdk.models.authorization_model import AuthorizationModel
 from openfga_sdk.models.check_request import CheckRequest
 from openfga_sdk.models.check_request_tuple_key import CheckRequestTupleKey
 from openfga_sdk.models.check_response import CheckResponse
 from openfga_sdk.models.computed import Computed
 from openfga_sdk.models.condition import Condition
+from openfga_sdk.models.condition_metadata import ConditionMetadata
 from openfga_sdk.models.condition_param_type_ref import ConditionParamTypeRef
 from openfga_sdk.models.contextual_tuple_keys import ContextualTupleKeys
 from openfga_sdk.models.create_store_request import CreateStoreRequest
 from openfga_sdk.models.create_store_response import CreateStoreResponse
 from openfga_sdk.models.difference import Difference
 from openfga_sdk.models.error_code import ErrorCode
 from openfga_sdk.models.expand_request import ExpandRequest
 from openfga_sdk.models.expand_request_tuple_key import ExpandRequestTupleKey
 from openfga_sdk.models.expand_response import ExpandResponse
 from openfga_sdk.models.get_store_response import GetStoreResponse
 from openfga_sdk.models.internal_error_code import InternalErrorCode
-from openfga_sdk.models.internal_error_message_response import InternalErrorMessageResponse
+from openfga_sdk.models.internal_error_message_response import (
+    InternalErrorMessageResponse,
+)
 from openfga_sdk.models.leaf import Leaf
 from openfga_sdk.models.list_objects_request import ListObjectsRequest
 from openfga_sdk.models.list_objects_response import ListObjectsResponse
 from openfga_sdk.models.list_stores_response import ListStoresResponse
 from openfga_sdk.models.metadata import Metadata
 from openfga_sdk.models.node import Node
 from openfga_sdk.models.nodes import Nodes
 from openfga_sdk.models.not_found_error_code import NotFoundErrorCode
 from openfga_sdk.models.null_value import NullValue
 from openfga_sdk.models.object_relation import ObjectRelation
-from openfga_sdk.models.path_unknown_error_message_response import PathUnknownErrorMessageResponse
+from openfga_sdk.models.path_unknown_error_message_response import (
+    PathUnknownErrorMessageResponse,
+)
 from openfga_sdk.models.read_assertions_response import ReadAssertionsResponse
-from openfga_sdk.models.read_authorization_model_response import ReadAuthorizationModelResponse
-from openfga_sdk.models.read_authorization_models_response import ReadAuthorizationModelsResponse
+from openfga_sdk.models.read_authorization_model_response import (
+    ReadAuthorizationModelResponse,
+)
+from openfga_sdk.models.read_authorization_models_response import (
+    ReadAuthorizationModelsResponse,
+)
 from openfga_sdk.models.read_changes_response import ReadChangesResponse
 from openfga_sdk.models.read_request import ReadRequest
 from openfga_sdk.models.read_request_tuple_key import ReadRequestTupleKey
 from openfga_sdk.models.read_response import ReadResponse
 from openfga_sdk.models.relation_metadata import RelationMetadata
 from openfga_sdk.models.relation_reference import RelationReference
 from openfga_sdk.models.relationship_condition import RelationshipCondition
+from openfga_sdk.models.source_info import SourceInfo
 from openfga_sdk.models.status import Status
 from openfga_sdk.models.store import Store
 from openfga_sdk.models.tuple import Tuple
 from openfga_sdk.models.tuple_change import TupleChange
 from openfga_sdk.models.tuple_key import TupleKey
 from openfga_sdk.models.tuple_key_without_condition import TupleKeyWithoutCondition
 from openfga_sdk.models.tuple_operation import TupleOperation
@@ -87,14 +75,20 @@
 from openfga_sdk.models.type_name import TypeName
 from openfga_sdk.models.users import Users
 from openfga_sdk.models.userset import Userset
 from openfga_sdk.models.userset_tree import UsersetTree
 from openfga_sdk.models.userset_tree_difference import UsersetTreeDifference
 from openfga_sdk.models.userset_tree_tuple_to_userset import UsersetTreeTupleToUserset
 from openfga_sdk.models.usersets import Usersets
-from openfga_sdk.models.validation_error_message_response import ValidationErrorMessageResponse
+from openfga_sdk.models.validation_error_message_response import (
+    ValidationErrorMessageResponse,
+)
 from openfga_sdk.models.write_assertions_request import WriteAssertionsRequest
-from openfga_sdk.models.write_authorization_model_request import WriteAuthorizationModelRequest
-from openfga_sdk.models.write_authorization_model_response import WriteAuthorizationModelResponse
+from openfga_sdk.models.write_authorization_model_request import (
+    WriteAuthorizationModelRequest,
+)
+from openfga_sdk.models.write_authorization_model_response import (
+    WriteAuthorizationModelResponse,
+)
 from openfga_sdk.models.write_request import WriteRequest
 from openfga_sdk.models.write_request_deletes import WriteRequestDeletes
 from openfga_sdk.models.write_request_writes import WriteRequestWrites
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/api/open_fga_api.py` & `openfga-sdk-0.4.2/openfga_sdk/sync/open_fga_api.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,68 +1,57 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
+from openfga_sdk.exceptions import ApiValueError, FgaValidationException
+from openfga_sdk.sync.api_client import ApiClient
+from openfga_sdk.sync.oauth2 import OAuth2Client
 
-import re  # noqa: F401
-
-# python 2 and python 3 compatibility library
-import six
-
-from openfga_sdk.api_client import ApiClient
-from openfga_sdk.oauth2 import OAuth2Client
-from openfga_sdk.exceptions import (  # noqa: F401
-    FgaValidationException,
-    ApiValueError
-)
 
-
-class OpenFgaApi(object):
+class OpenFgaApi:
     """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
         self._oauth2_client = None
         if api_client.configuration is not None:
             credentials = api_client.configuration.credentials
-            if credentials is not None and credentials.method == 'client_credentials':
+            if credentials is not None and credentials.method == "client_credentials":
                 self._oauth2_client = OAuth2Client(credentials)
 
-    async def __aenter__(self):
+    def __enter__(self):
         return self
 
-    async def __aexit__(self, exc_type, exc_value, traceback):
-        await self.close()
+    def __exit__(self):
+        self.close()
 
-    async def close(self):
-        await self.api_client.close()
+    def close(self):
+        self.api_client.close()
 
-    async def check(self, body, **kwargs):  # noqa: E501
-        """Check whether a user is authorized to access an object  # noqa: E501
+    def check(self, body, **kwargs):
+        """Check whether a user is authorized to access an object
 
-        The Check API queries to check if the user has a certain relationship with an object in a certain store. A `contextual_tuples` object may also be included in the body of the request. This object contains one field `tuple_keys`, which is an array of tuple keys. Each of these tuples may have an associated `condition`. You may also provide an `authorization_model_id` in the body. This will be used to assert that the input `tuple_key` is valid for the model specified. If not specified, the assertion will be made against the latest authorization model ID. It is strongly recommended to specify authorization model id for better performance. You may also provide a `context` object that will be used to evaluate the conditioned tuples in the system. It is strongly recommended to provide a value for all the input parameters of all the conditions, to ensure that all tuples be evaluated correctly. The response will return whether the relationship exists in the field `allowed`.  ## Example In order to check if user `user:anne` of type `user` has a `reader` relationship with object `document:2021-budget` given the following contextual tuple ```json {   \"user\": \"user:anne\",   \"relation\": \"member\",   \"object\": \"time_slot:office_hours\" } ``` the Check API can be used with the following request body: ```json {   \"tuple_key\": {     \"user\": \"user:anne\",     \"relation\": \"reader\",     \"object\": \"document:2021-budget\"   },   \"contextual_tuples\": {     \"tuple_keys\": [       {         \"user\": \"user:anne\",         \"relation\": \"member\",         \"object\": \"time_slot:office_hours\"       }     ]   },   \"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\" } ``` OpenFGA's response will include `{ \"allowed\": true }` if there is a relationship and `{ \"allowed\": false }` if there isn't.  # noqa: E501
+        The Check API queries to check if the user has a certain relationship with an object in a certain store. A `contextual_tuples` object may also be included in the body of the request. This object contains one field `tuple_keys`, which is an array of tuple keys. Each of these tuples may have an associated `condition`. You may also provide an `authorization_model_id` in the body. This will be used to assert that the input `tuple_key` is valid for the model specified. If not specified, the assertion will be made against the latest authorization model ID. It is strongly recommended to specify authorization model id for better performance. You may also provide a `context` object that will be used to evaluate the conditioned tuples in the system. It is strongly recommended to provide a value for all the input parameters of all the conditions, to ensure that all tuples be evaluated correctly. The response will return whether the relationship exists in the field `allowed`.  ## Example In order to check if user `user:anne` of type `user` has a `reader` relationship with object `document:2021-budget` given the following contextual tuple ```json {   \"user\": \"user:anne\",   \"relation\": \"member\",   \"object\": \"time_slot:office_hours\" } ``` the Check API can be used with the following request body: ```json {   \"tuple_key\": {     \"user\": \"user:anne\",     \"relation\": \"reader\",     \"object\": \"document:2021-budget\"   },   \"contextual_tuples\": {     \"tuple_keys\": [       {         \"user\": \"user:anne\",         \"relation\": \"member\",         \"object\": \"time_slot:office_hours\"       }     ]   },   \"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\" } ``` OpenFGA's response will include `{ \"allowed\": true }` if there is a relationship and `{ \"allowed\": false }` if there isn't.
 
-        >>> thread = await api.check(body)
+        >>> thread = api.check(body)
 
         :param body: (required)
         :type body: CheckRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
@@ -73,21 +62,21 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: CheckResponse
         """
-        kwargs['_return_http_data_only'] = True
-        return await (self.check_with_http_info(body, **kwargs))  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return self.check_with_http_info(body, **kwargs)
 
-    async def check_with_http_info(self, body, **kwargs):  # noqa: E501
-        """Check whether a user is authorized to access an object  # noqa: E501
+    def check_with_http_info(self, body, **kwargs):
+        """Check whether a user is authorized to access an object
 
-        The Check API queries to check if the user has a certain relationship with an object in a certain store. A `contextual_tuples` object may also be included in the body of the request. This object contains one field `tuple_keys`, which is an array of tuple keys. Each of these tuples may have an associated `condition`. You may also provide an `authorization_model_id` in the body. This will be used to assert that the input `tuple_key` is valid for the model specified. If not specified, the assertion will be made against the latest authorization model ID. It is strongly recommended to specify authorization model id for better performance. You may also provide a `context` object that will be used to evaluate the conditioned tuples in the system. It is strongly recommended to provide a value for all the input parameters of all the conditions, to ensure that all tuples be evaluated correctly. The response will return whether the relationship exists in the field `allowed`.  ## Example In order to check if user `user:anne` of type `user` has a `reader` relationship with object `document:2021-budget` given the following contextual tuple ```json {   \"user\": \"user:anne\",   \"relation\": \"member\",   \"object\": \"time_slot:office_hours\" } ``` the Check API can be used with the following request body: ```json {   \"tuple_key\": {     \"user\": \"user:anne\",     \"relation\": \"reader\",     \"object\": \"document:2021-budget\"   },   \"contextual_tuples\": {     \"tuple_keys\": [       {         \"user\": \"user:anne\",         \"relation\": \"member\",         \"object\": \"time_slot:office_hours\"       }     ]   },   \"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\" } ``` OpenFGA's response will include `{ \"allowed\": true }` if there is a relationship and `{ \"allowed\": false }` if there isn't.  # noqa: E501
+        The Check API queries to check if the user has a certain relationship with an object in a certain store. A `contextual_tuples` object may also be included in the body of the request. This object contains one field `tuple_keys`, which is an array of tuple keys. Each of these tuples may have an associated `condition`. You may also provide an `authorization_model_id` in the body. This will be used to assert that the input `tuple_key` is valid for the model specified. If not specified, the assertion will be made against the latest authorization model ID. It is strongly recommended to specify authorization model id for better performance. You may also provide a `context` object that will be used to evaluate the conditioned tuples in the system. It is strongly recommended to provide a value for all the input parameters of all the conditions, to ensure that all tuples be evaluated correctly. The response will return whether the relationship exists in the field `allowed`.  ## Example In order to check if user `user:anne` of type `user` has a `reader` relationship with object `document:2021-budget` given the following contextual tuple ```json {   \"user\": \"user:anne\",   \"relation\": \"member\",   \"object\": \"time_slot:office_hours\" } ``` the Check API can be used with the following request body: ```json {   \"tuple_key\": {     \"user\": \"user:anne\",     \"relation\": \"reader\",     \"object\": \"document:2021-budget\"   },   \"contextual_tuples\": {     \"tuple_keys\": [       {         \"user\": \"user:anne\",         \"relation\": \"member\",         \"object\": \"time_slot:office_hours\"       }     ]   },   \"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\" } ``` OpenFGA's response will include `{ \"allowed\": true }` if there is a relationship and `{ \"allowed\": false }` if there isn't.
 
         >>> thread = api.check_with_http_info(body)
 
         :param body: (required)
         :type body: CheckRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
@@ -112,107 +101,117 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: tuple(CheckResponse, status_code(int), headers(HTTPHeaderDict))
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-            'body'
-
-        ]
+        all_params = ["body"]
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method check" % key
+                    "Got an unexpected keyword argument '%s'" " to method check" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
         # verify the required parameter 'body' is set
-        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
-            raise ApiValueError("Missing the required parameter `body` when calling `check`")  # noqa: E501
+        if (
+            self.api_client.client_side_validation
+            and local_var_params.get("body") is None
+        ):
+            raise ApiValueError(
+                "Missing the required parameter `body` when calling `check`"
+            )
 
         collection_formats = {}
 
         path_params = {}
 
         if self.api_client._get_store_id() is None:
-            raise ApiValueError("Store ID expected in api_client's configuration when calling `check`")  # noqa: E501
+            raise ApiValueError(
+                "Store ID expected in api_client's configuration when calling `check`"
+            )
         store_id = self.api_client._get_store_id()
 
         query_params = []
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in local_var_params:
-            body_params = local_var_params['body']
+        if "body" in local_var_params:
+            body_params = local_var_params["body"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # HTTP header `Content-Type`
-        content_types_list = local_var_params.get('_content_type', self.api_client.select_header_content_type(['application/json'], 'POST', body_params))  # noqa: E501
+        content_types_list = local_var_params.get(
+            "_content_type",
+            self.api_client.select_header_content_type(
+                ["application/json"], "POST", body_params
+            ),
+        )
         if content_types_list:
-            header_params['Content-Type'] = content_types_list
+            header_params["Content-Type"] = content_types_list
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {
             200: "CheckResponse",
             400: "ValidationErrorMessageResponse",
             404: "PathUnknownErrorMessageResponse",
             409: "AbortedMessageResponse",
             500: "InternalErrorMessageResponse",
         }
 
-        return await (self.api_client.call_api(
-            '/stores/{store_id}/check'.replace('{store_id}', store_id), 'POST',
+        return self.api_client.call_api(
+            "/stores/{store_id}/check".replace("{store_id}", store_id),
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client))
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    async def create_store(self, body, **kwargs):  # noqa: E501
-        """Create a store  # noqa: E501
+    def create_store(self, body, **kwargs):
+        """Create a store
 
-        Create a unique OpenFGA store which will be used to store authorization models and relationship tuples.  # noqa: E501
+        Create a unique OpenFGA store which will be used to store authorization models and relationship tuples.
 
-        >>> thread = await api.create_store(body)
+        >>> thread = api.create_store(body)
 
         :param body: (required)
         :type body: CreateStoreRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
@@ -223,21 +222,21 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: CreateStoreResponse
         """
-        kwargs['_return_http_data_only'] = True
-        return await (self.create_store_with_http_info(body, **kwargs))  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return self.create_store_with_http_info(body, **kwargs)
 
-    async def create_store_with_http_info(self, body, **kwargs):  # noqa: E501
-        """Create a store  # noqa: E501
+    def create_store_with_http_info(self, body, **kwargs):
+        """Create a store
 
-        Create a unique OpenFGA store which will be used to store authorization models and relationship tuples.  # noqa: E501
+        Create a unique OpenFGA store which will be used to store authorization models and relationship tuples.
 
         >>> thread = api.create_store_with_http_info(body)
 
         :param body: (required)
         :type body: CreateStoreRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
@@ -262,100 +261,104 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: tuple(CreateStoreResponse, status_code(int), headers(HTTPHeaderDict))
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-            'body'
-
-        ]
+        all_params = ["body"]
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_store" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in local_var_params:
-            body_params = local_var_params['body']
+        if "body" in local_var_params:
+            body_params = local_var_params["body"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # HTTP header `Content-Type`
-        content_types_list = local_var_params.get('_content_type', self.api_client.select_header_content_type(['application/json'], 'POST', body_params))  # noqa: E501
+        content_types_list = local_var_params.get(
+            "_content_type",
+            self.api_client.select_header_content_type(
+                ["application/json"], "POST", body_params
+            ),
+        )
         if content_types_list:
-            header_params['Content-Type'] = content_types_list
+            header_params["Content-Type"] = content_types_list
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {
             201: "CreateStoreResponse",
             400: "ValidationErrorMessageResponse",
             404: "PathUnknownErrorMessageResponse",
             409: "AbortedMessageResponse",
             500: "InternalErrorMessageResponse",
         }
 
-        return await (self.api_client.call_api(
-            '/stores', 'POST',
+        return self.api_client.call_api(
+            "/stores",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client))
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    async def delete_store(self, **kwargs):  # noqa: E501
-        """Delete a store  # noqa: E501
+    def delete_store(self, **kwargs):
+        """Delete a store
 
-        Delete an OpenFGA store. This does not delete the data associated with the store, like tuples or authorization models.  # noqa: E501
+        Delete an OpenFGA store. This does not delete the data associated with the store, like tuples or authorization models.
 
-        >>> thread = await api.delete_store()
+        >>> thread = api.delete_store()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :type _preload_content: bool, optional
@@ -364,21 +367,21 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
-        kwargs['_return_http_data_only'] = True
-        return await (self.delete_store_with_http_info(**kwargs))  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return self.delete_store_with_http_info(**kwargs)
 
-    async def delete_store_with_http_info(self, **kwargs):  # noqa: E501
-        """Delete a store  # noqa: E501
+    def delete_store_with_http_info(self, **kwargs):
+        """Delete a store
 
-        Delete an OpenFGA store. This does not delete the data associated with the store, like tuples or authorization models.  # noqa: E501
+        Delete an OpenFGA store. This does not delete the data associated with the store, like tuples or authorization models.
 
         >>> thread = api.delete_store_with_http_info()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
         :param _return_http_data_only: response data without head status code
                                        and headers
@@ -401,89 +404,92 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-        ]
+        all_params = []
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete_store" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
 
         collection_formats = {}
 
         path_params = {}
 
         if self.api_client._get_store_id() is None:
-            raise ApiValueError("Store ID expected in api_client's configuration when calling `delete_store`")  # noqa: E501
+            raise ApiValueError(
+                "Store ID expected in api_client's configuration when calling `delete_store`"
+            )
         store_id = self.api_client._get_store_id()
 
         query_params = []
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {}
 
-        return await (self.api_client.call_api(
-            '/stores/{store_id}'.replace('{store_id}', store_id), 'DELETE',
+        return self.api_client.call_api(
+            "/stores/{store_id}".replace("{store_id}", store_id),
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client))
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    async def expand(self, body, **kwargs):  # noqa: E501
-        """Expand all relationships in userset tree format, and following userset rewrite rules.  Useful to reason about and debug a certain relationship  # noqa: E501
+    def expand(self, body, **kwargs):
+        """Expand all relationships in userset tree format, and following userset rewrite rules.  Useful to reason about and debug a certain relationship
 
-        The Expand API will return all users and usersets that have certain relationship with an object in a certain store. This is different from the `/stores/{store_id}/read` API in that both users and computed usersets are returned. Body parameters `tuple_key.object` and `tuple_key.relation` are all required. The response will return a tree whose leaves are the specific users and usersets. Union, intersection and difference operator are located in the intermediate nodes.  ## Example To expand all users that have the `reader` relationship with object `document:2021-budget`, use the Expand API with the following request body ```json {   \"tuple_key\": {     \"object\": \"document:2021-budget\",     \"relation\": \"reader\"   },   \"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\" } ``` OpenFGA's response will be a userset tree of the users and usersets that have read access to the document. ```json {   \"tree\":{     \"root\":{       \"type\":\"document:2021-budget#reader\",       \"union\":{         \"nodes\":[           {             \"type\":\"document:2021-budget#reader\",             \"leaf\":{               \"users\":{                 \"users\":[                   \"user:bob\"                 ]               }             }           },           {             \"type\":\"document:2021-budget#reader\",             \"leaf\":{               \"computed\":{                 \"userset\":\"document:2021-budget#writer\"               }             }           }         ]       }     }   } } ``` The caller can then call expand API for the `writer` relationship for the `document:2021-budget`.  # noqa: E501
+        The Expand API will return all users and usersets that have certain relationship with an object in a certain store. This is different from the `/stores/{store_id}/read` API in that both users and computed usersets are returned. Body parameters `tuple_key.object` and `tuple_key.relation` are all required. The response will return a tree whose leaves are the specific users and usersets. Union, intersection and difference operator are located in the intermediate nodes.  ## Example To expand all users that have the `reader` relationship with object `document:2021-budget`, use the Expand API with the following request body ```json {   \"tuple_key\": {     \"object\": \"document:2021-budget\",     \"relation\": \"reader\"   },   \"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\" } ``` OpenFGA's response will be a userset tree of the users and usersets that have read access to the document. ```json {   \"tree\":{     \"root\":{       \"type\":\"document:2021-budget#reader\",       \"union\":{         \"nodes\":[           {             \"type\":\"document:2021-budget#reader\",             \"leaf\":{               \"users\":{                 \"users\":[                   \"user:bob\"                 ]               }             }           },           {             \"type\":\"document:2021-budget#reader\",             \"leaf\":{               \"computed\":{                 \"userset\":\"document:2021-budget#writer\"               }             }           }         ]       }     }   } } ``` The caller can then call expand API for the `writer` relationship for the `document:2021-budget`.
 
-        >>> thread = await api.expand(body)
+        >>> thread = api.expand(body)
 
         :param body: (required)
         :type body: ExpandRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
@@ -494,21 +500,21 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ExpandResponse
         """
-        kwargs['_return_http_data_only'] = True
-        return await (self.expand_with_http_info(body, **kwargs))  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return self.expand_with_http_info(body, **kwargs)
 
-    async def expand_with_http_info(self, body, **kwargs):  # noqa: E501
-        """Expand all relationships in userset tree format, and following userset rewrite rules.  Useful to reason about and debug a certain relationship  # noqa: E501
+    def expand_with_http_info(self, body, **kwargs):
+        """Expand all relationships in userset tree format, and following userset rewrite rules.  Useful to reason about and debug a certain relationship
 
-        The Expand API will return all users and usersets that have certain relationship with an object in a certain store. This is different from the `/stores/{store_id}/read` API in that both users and computed usersets are returned. Body parameters `tuple_key.object` and `tuple_key.relation` are all required. The response will return a tree whose leaves are the specific users and usersets. Union, intersection and difference operator are located in the intermediate nodes.  ## Example To expand all users that have the `reader` relationship with object `document:2021-budget`, use the Expand API with the following request body ```json {   \"tuple_key\": {     \"object\": \"document:2021-budget\",     \"relation\": \"reader\"   },   \"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\" } ``` OpenFGA's response will be a userset tree of the users and usersets that have read access to the document. ```json {   \"tree\":{     \"root\":{       \"type\":\"document:2021-budget#reader\",       \"union\":{         \"nodes\":[           {             \"type\":\"document:2021-budget#reader\",             \"leaf\":{               \"users\":{                 \"users\":[                   \"user:bob\"                 ]               }             }           },           {             \"type\":\"document:2021-budget#reader\",             \"leaf\":{               \"computed\":{                 \"userset\":\"document:2021-budget#writer\"               }             }           }         ]       }     }   } } ``` The caller can then call expand API for the `writer` relationship for the `document:2021-budget`.  # noqa: E501
+        The Expand API will return all users and usersets that have certain relationship with an object in a certain store. This is different from the `/stores/{store_id}/read` API in that both users and computed usersets are returned. Body parameters `tuple_key.object` and `tuple_key.relation` are all required. The response will return a tree whose leaves are the specific users and usersets. Union, intersection and difference operator are located in the intermediate nodes.  ## Example To expand all users that have the `reader` relationship with object `document:2021-budget`, use the Expand API with the following request body ```json {   \"tuple_key\": {     \"object\": \"document:2021-budget\",     \"relation\": \"reader\"   },   \"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\" } ``` OpenFGA's response will be a userset tree of the users and usersets that have read access to the document. ```json {   \"tree\":{     \"root\":{       \"type\":\"document:2021-budget#reader\",       \"union\":{         \"nodes\":[           {             \"type\":\"document:2021-budget#reader\",             \"leaf\":{               \"users\":{                 \"users\":[                   \"user:bob\"                 ]               }             }           },           {             \"type\":\"document:2021-budget#reader\",             \"leaf\":{               \"computed\":{                 \"userset\":\"document:2021-budget#writer\"               }             }           }         ]       }     }   } } ``` The caller can then call expand API for the `writer` relationship for the `document:2021-budget`.
 
         >>> thread = api.expand_with_http_info(body)
 
         :param body: (required)
         :type body: ExpandRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
@@ -533,107 +539,117 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: tuple(ExpandResponse, status_code(int), headers(HTTPHeaderDict))
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-            'body'
-
-        ]
+        all_params = ["body"]
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method expand" % key
+                    "Got an unexpected keyword argument '%s'" " to method expand" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
         # verify the required parameter 'body' is set
-        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
-            raise ApiValueError("Missing the required parameter `body` when calling `expand`")  # noqa: E501
+        if (
+            self.api_client.client_side_validation
+            and local_var_params.get("body") is None
+        ):
+            raise ApiValueError(
+                "Missing the required parameter `body` when calling `expand`"
+            )
 
         collection_formats = {}
 
         path_params = {}
 
         if self.api_client._get_store_id() is None:
-            raise ApiValueError("Store ID expected in api_client's configuration when calling `expand`")  # noqa: E501
+            raise ApiValueError(
+                "Store ID expected in api_client's configuration when calling `expand`"
+            )
         store_id = self.api_client._get_store_id()
 
         query_params = []
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in local_var_params:
-            body_params = local_var_params['body']
+        if "body" in local_var_params:
+            body_params = local_var_params["body"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # HTTP header `Content-Type`
-        content_types_list = local_var_params.get('_content_type', self.api_client.select_header_content_type(['application/json'], 'POST', body_params))  # noqa: E501
+        content_types_list = local_var_params.get(
+            "_content_type",
+            self.api_client.select_header_content_type(
+                ["application/json"], "POST", body_params
+            ),
+        )
         if content_types_list:
-            header_params['Content-Type'] = content_types_list
+            header_params["Content-Type"] = content_types_list
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {
             200: "ExpandResponse",
             400: "ValidationErrorMessageResponse",
             404: "PathUnknownErrorMessageResponse",
             409: "AbortedMessageResponse",
             500: "InternalErrorMessageResponse",
         }
 
-        return await (self.api_client.call_api(
-            '/stores/{store_id}/expand'.replace('{store_id}', store_id), 'POST',
+        return self.api_client.call_api(
+            "/stores/{store_id}/expand".replace("{store_id}", store_id),
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client))
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    async def get_store(self, **kwargs):  # noqa: E501
-        """Get a store  # noqa: E501
+    def get_store(self, **kwargs):
+        """Get a store
 
-        Returns an OpenFGA store by its identifier  # noqa: E501
+        Returns an OpenFGA store by its identifier
 
-        >>> thread = await api.get_store()
+        >>> thread = api.get_store()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :type _preload_content: bool, optional
@@ -642,21 +658,21 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GetStoreResponse
         """
-        kwargs['_return_http_data_only'] = True
-        return await (self.get_store_with_http_info(**kwargs))  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return self.get_store_with_http_info(**kwargs)
 
-    async def get_store_with_http_info(self, **kwargs):  # noqa: E501
-        """Get a store  # noqa: E501
+    def get_store_with_http_info(self, **kwargs):
+        """Get a store
 
-        Returns an OpenFGA store by its identifier  # noqa: E501
+        Returns an OpenFGA store by its identifier
 
         >>> thread = api.get_store_with_http_info()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
         :param _return_http_data_only: response data without head status code
                                        and headers
@@ -679,95 +695,98 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: tuple(GetStoreResponse, status_code(int), headers(HTTPHeaderDict))
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-        ]
+        all_params = []
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_store" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
 
         collection_formats = {}
 
         path_params = {}
 
         if self.api_client._get_store_id() is None:
-            raise ApiValueError("Store ID expected in api_client's configuration when calling `get_store`")  # noqa: E501
+            raise ApiValueError(
+                "Store ID expected in api_client's configuration when calling `get_store`"
+            )
         store_id = self.api_client._get_store_id()
 
         query_params = []
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {
             200: "GetStoreResponse",
             400: "ValidationErrorMessageResponse",
             404: "PathUnknownErrorMessageResponse",
             409: "AbortedMessageResponse",
             500: "InternalErrorMessageResponse",
         }
 
-        return await (self.api_client.call_api(
-            '/stores/{store_id}'.replace('{store_id}', store_id), 'GET',
+        return self.api_client.call_api(
+            "/stores/{store_id}".replace("{store_id}", store_id),
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client))
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    async def list_objects(self, body, **kwargs):  # noqa: E501
-        """List all objects of the given type that the user has a relation with  # noqa: E501
+    def list_objects(self, body, **kwargs):
+        """List all objects of the given type that the user has a relation with
 
-        The ListObjects API returns a list of all the objects of the given type that the user has a relation with. To achieve this, both the store tuples and the authorization model are used. An `authorization_model_id` may be specified in the body. If it is not specified, the latest authorization model ID will be used. It is strongly recommended to specify authorization model id for better performance. You may also specify `contextual_tuples` that will be treated as regular tuples. Each of these tuples may have an associated `condition`. You may also provide a `context` object that will be used to evaluate the conditioned tuples in the system. It is strongly recommended to provide a value for all the input parameters of all the conditions, to ensure that all tuples be evaluated correctly. The response will contain the related objects in an array in the \"objects\" field of the response and they will be strings in the object format `<type>:<id>` (e.g. \"document:roadmap\"). The number of objects in the response array will be limited by the execution timeout specified in the flag OPENFGA_LIST_OBJECTS_DEADLINE and by the upper bound specified in the flag OPENFGA_LIST_OBJECTS_MAX_RESULTS, whichever is hit first. The objects given will not be sorted, and therefore two identical calls can give a given different set of objects.  # noqa: E501
+        The ListObjects API returns a list of all the objects of the given type that the user has a relation with. To achieve this, both the store tuples and the authorization model are used. An `authorization_model_id` may be specified in the body. If it is not specified, the latest authorization model ID will be used. It is strongly recommended to specify authorization model id for better performance. You may also specify `contextual_tuples` that will be treated as regular tuples. Each of these tuples may have an associated `condition`. You may also provide a `context` object that will be used to evaluate the conditioned tuples in the system. It is strongly recommended to provide a value for all the input parameters of all the conditions, to ensure that all tuples be evaluated correctly. The response will contain the related objects in an array in the \"objects\" field of the response and they will be strings in the object format `<type>:<id>` (e.g. \"document:roadmap\"). The number of objects in the response array will be limited by the execution timeout specified in the flag OPENFGA_LIST_OBJECTS_DEADLINE and by the upper bound specified in the flag OPENFGA_LIST_OBJECTS_MAX_RESULTS, whichever is hit first. The objects given will not be sorted, and therefore two identical calls can give a given different set of objects.
 
-        >>> thread = await api.list_objects(body)
+        >>> thread = api.list_objects(body)
 
         :param body: (required)
         :type body: ListObjectsRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
@@ -778,21 +797,21 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ListObjectsResponse
         """
-        kwargs['_return_http_data_only'] = True
-        return await (self.list_objects_with_http_info(body, **kwargs))  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return self.list_objects_with_http_info(body, **kwargs)
 
-    async def list_objects_with_http_info(self, body, **kwargs):  # noqa: E501
-        """List all objects of the given type that the user has a relation with  # noqa: E501
+    def list_objects_with_http_info(self, body, **kwargs):
+        """List all objects of the given type that the user has a relation with
 
-        The ListObjects API returns a list of all the objects of the given type that the user has a relation with. To achieve this, both the store tuples and the authorization model are used. An `authorization_model_id` may be specified in the body. If it is not specified, the latest authorization model ID will be used. It is strongly recommended to specify authorization model id for better performance. You may also specify `contextual_tuples` that will be treated as regular tuples. Each of these tuples may have an associated `condition`. You may also provide a `context` object that will be used to evaluate the conditioned tuples in the system. It is strongly recommended to provide a value for all the input parameters of all the conditions, to ensure that all tuples be evaluated correctly. The response will contain the related objects in an array in the \"objects\" field of the response and they will be strings in the object format `<type>:<id>` (e.g. \"document:roadmap\"). The number of objects in the response array will be limited by the execution timeout specified in the flag OPENFGA_LIST_OBJECTS_DEADLINE and by the upper bound specified in the flag OPENFGA_LIST_OBJECTS_MAX_RESULTS, whichever is hit first. The objects given will not be sorted, and therefore two identical calls can give a given different set of objects.  # noqa: E501
+        The ListObjects API returns a list of all the objects of the given type that the user has a relation with. To achieve this, both the store tuples and the authorization model are used. An `authorization_model_id` may be specified in the body. If it is not specified, the latest authorization model ID will be used. It is strongly recommended to specify authorization model id for better performance. You may also specify `contextual_tuples` that will be treated as regular tuples. Each of these tuples may have an associated `condition`. You may also provide a `context` object that will be used to evaluate the conditioned tuples in the system. It is strongly recommended to provide a value for all the input parameters of all the conditions, to ensure that all tuples be evaluated correctly. The response will contain the related objects in an array in the \"objects\" field of the response and they will be strings in the object format `<type>:<id>` (e.g. \"document:roadmap\"). The number of objects in the response array will be limited by the execution timeout specified in the flag OPENFGA_LIST_OBJECTS_DEADLINE and by the upper bound specified in the flag OPENFGA_LIST_OBJECTS_MAX_RESULTS, whichever is hit first. The objects given will not be sorted, and therefore two identical calls can give a given different set of objects.
 
         >>> thread = api.list_objects_with_http_info(body)
 
         :param body: (required)
         :type body: ListObjectsRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
@@ -817,107 +836,118 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: tuple(ListObjectsResponse, status_code(int), headers(HTTPHeaderDict))
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-            'body'
-
-        ]
+        all_params = ["body"]
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
                     "Got an unexpected keyword argument '%s'"
                     " to method list_objects" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
         # verify the required parameter 'body' is set
-        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
-            raise ApiValueError("Missing the required parameter `body` when calling `list_objects`")  # noqa: E501
+        if (
+            self.api_client.client_side_validation
+            and local_var_params.get("body") is None
+        ):
+            raise ApiValueError(
+                "Missing the required parameter `body` when calling `list_objects`"
+            )
 
         collection_formats = {}
 
         path_params = {}
 
         if self.api_client._get_store_id() is None:
-            raise ApiValueError("Store ID expected in api_client's configuration when calling `list_objects`")  # noqa: E501
+            raise ApiValueError(
+                "Store ID expected in api_client's configuration when calling `list_objects`"
+            )
         store_id = self.api_client._get_store_id()
 
         query_params = []
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in local_var_params:
-            body_params = local_var_params['body']
+        if "body" in local_var_params:
+            body_params = local_var_params["body"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # HTTP header `Content-Type`
-        content_types_list = local_var_params.get('_content_type', self.api_client.select_header_content_type(['application/json'], 'POST', body_params))  # noqa: E501
+        content_types_list = local_var_params.get(
+            "_content_type",
+            self.api_client.select_header_content_type(
+                ["application/json"], "POST", body_params
+            ),
+        )
         if content_types_list:
-            header_params['Content-Type'] = content_types_list
+            header_params["Content-Type"] = content_types_list
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {
             200: "ListObjectsResponse",
             400: "ValidationErrorMessageResponse",
             404: "PathUnknownErrorMessageResponse",
             409: "AbortedMessageResponse",
             500: "InternalErrorMessageResponse",
         }
 
-        return await (self.api_client.call_api(
-            '/stores/{store_id}/list-objects'.replace('{store_id}', store_id), 'POST',
+        return self.api_client.call_api(
+            "/stores/{store_id}/list-objects".replace("{store_id}", store_id),
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client))
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    async def list_stores(self, **kwargs):  # noqa: E501
-        """List all stores  # noqa: E501
+    def list_stores(self, **kwargs):
+        """List all stores
 
-        Returns a paginated list of OpenFGA stores and a continuation token to get additional stores. The continuation token will be empty if there are no more stores.   # noqa: E501
+        Returns a paginated list of OpenFGA stores and a continuation token to get additional stores. The continuation token will be empty if there are no more stores.
 
-        >>> thread = await api.list_stores()
+        >>> thread = api.list_stores()
 
         :param page_size:(optional)
         :type page_size: int, optional
         :param continuation_token:(optional)
         :type continuation_token: str, optional
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
@@ -930,21 +960,21 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ListStoresResponse
         """
-        kwargs['_return_http_data_only'] = True
-        return await (self.list_stores_with_http_info(**kwargs))  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return self.list_stores_with_http_info(**kwargs)
 
-    async def list_stores_with_http_info(self, **kwargs):  # noqa: E501
-        """List all stores  # noqa: E501
+    def list_stores_with_http_info(self, **kwargs):
+        """List all stores
 
-        Returns a paginated list of OpenFGA stores and a continuation token to get additional stores. The continuation token will be empty if there are no more stores.   # noqa: E501
+        Returns a paginated list of OpenFGA stores and a continuation token to get additional stores. The continuation token will be empty if there are no more stores.
 
         >>> thread = api.list_stores_with_http_info()
 
         :param page_size:(optional)
         :type page_size: int, optional
         :param continuation_token:(optional)
         :type continuation_token: str, optional
@@ -971,97 +1001,98 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: tuple(ListStoresResponse, status_code(int), headers(HTTPHeaderDict))
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-            'page_size',
-            'continuation_token'
-        ]
+        all_params = ["page_size", "continuation_token"]
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
                     "Got an unexpected keyword argument '%s'"
                     " to method list_stores" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if local_var_params.get('page_size') is not None:  # noqa: E501
-            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501
-        if local_var_params.get('continuation_token') is not None:  # noqa: E501
-            query_params.append(('continuation_token', local_var_params['continuation_token']))  # noqa: E501
+        if local_var_params.get("page_size") is not None:
+            query_params.append(("page_size", local_var_params["page_size"]))
+        if local_var_params.get("continuation_token") is not None:
+            query_params.append(
+                ("continuation_token", local_var_params["continuation_token"])
+            )
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {
             200: "ListStoresResponse",
             400: "ValidationErrorMessageResponse",
             404: "PathUnknownErrorMessageResponse",
             409: "AbortedMessageResponse",
             500: "InternalErrorMessageResponse",
         }
 
-        return await (self.api_client.call_api(
-            '/stores', 'GET',
+        return self.api_client.call_api(
+            "/stores",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client))
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    async def read(self, body, **kwargs):  # noqa: E501
-        """Get tuples from the store that matches a query, without following userset rewrite rules  # noqa: E501
+    def read(self, body, **kwargs):
+        """Get tuples from the store that matches a query, without following userset rewrite rules
 
-        The Read API will return the tuples for a certain store that match a query filter specified in the body of the request.  The API doesn't guarantee order by any field.  It is different from the `/stores/{store_id}/expand` API in that it only returns relationship tuples that are stored in the system and satisfy the query.  In the body: 1. `tuple_key` is optional. If not specified, it will return all tuples in the store. 2. `tuple_key.object` is mandatory if `tuple_key` is specified. It can be a full object (e.g., `type:object_id`) or type only (e.g., `type:`). 3. `tuple_key.user` is mandatory if tuple_key is specified in the case the `tuple_key.object` is a type only. ## Examples ### Query for all objects in a type definition To query for all objects that `user:bob` has `reader` relationship in the `document` type definition, call read API with body of ```json {  \"tuple_key\": {      \"user\": \"user:bob\",      \"relation\": \"reader\",      \"object\": \"document:\"   } } ``` The API will return tuples and a continuation token, something like ```json {   \"tuples\": [     {       \"key\": {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-06T15:32:11.128Z\"     }   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` This means that `user:bob` has a `reader` relationship with 1 document `document:2021-budget`. Note that this API, unlike the List Objects API, does not evaluate the tuples in the store. The continuation token will be empty if there are no more tuples to query. ### Query for all stored relationship tuples that have a particular relation and object To query for all users that have `reader` relationship with `document:2021-budget`, call read API with body of  ```json {   \"tuple_key\": {      \"object\": \"document:2021-budget\",      \"relation\": \"reader\"    } } ``` The API will return something like  ```json {   \"tuples\": [     {       \"key\": {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-06T15:32:11.128Z\"     }   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` This means that `document:2021-budget` has 1 `reader` (`user:bob`).  Note that, even if the model said that all `writers` are also `readers`, the API will not return writers such as `user:anne` because it only returns tuples and does not evaluate them. ### Query for all users with all relationships for a particular document To query for all users that have any relationship with `document:2021-budget`, call read API with body of  ```json {   \"tuple_key\": {       \"object\": \"document:2021-budget\"    } } ``` The API will return something like  ```json {   \"tuples\": [     {       \"key\": {         \"user\": \"user:anne\",         \"relation\": \"writer\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-05T13:42:12.356Z\"     },     {       \"key\": {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-06T15:32:11.128Z\"     }   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` This means that `document:2021-budget` has 1 `reader` (`user:bob`) and 1 `writer` (`user:anne`).   # noqa: E501
+        The Read API will return the tuples for a certain store that match a query filter specified in the body of the request.  The API doesn't guarantee order by any field.  It is different from the `/stores/{store_id}/expand` API in that it only returns relationship tuples that are stored in the system and satisfy the query.  In the body: 1. `tuple_key` is optional. If not specified, it will return all tuples in the store. 2. `tuple_key.object` is mandatory if `tuple_key` is specified. It can be a full object (e.g., `type:object_id`) or type only (e.g., `type:`). 3. `tuple_key.user` is mandatory if tuple_key is specified in the case the `tuple_key.object` is a type only. ## Examples ### Query for all objects in a type definition To query for all objects that `user:bob` has `reader` relationship in the `document` type definition, call read API with body of ```json {  \"tuple_key\": {      \"user\": \"user:bob\",      \"relation\": \"reader\",      \"object\": \"document:\"   } } ``` The API will return tuples and a continuation token, something like ```json {   \"tuples\": [     {       \"key\": {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-06T15:32:11.128Z\"     }   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` This means that `user:bob` has a `reader` relationship with 1 document `document:2021-budget`. Note that this API, unlike the List Objects API, does not evaluate the tuples in the store. The continuation token will be empty if there are no more tuples to query. ### Query for all stored relationship tuples that have a particular relation and object To query for all users that have `reader` relationship with `document:2021-budget`, call read API with body of  ```json {   \"tuple_key\": {      \"object\": \"document:2021-budget\",      \"relation\": \"reader\"    } } ``` The API will return something like  ```json {   \"tuples\": [     {       \"key\": {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-06T15:32:11.128Z\"     }   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` This means that `document:2021-budget` has 1 `reader` (`user:bob`).  Note that, even if the model said that all `writers` are also `readers`, the API will not return writers such as `user:anne` because it only returns tuples and does not evaluate them. ### Query for all users with all relationships for a particular document To query for all users that have any relationship with `document:2021-budget`, call read API with body of  ```json {   \"tuple_key\": {       \"object\": \"document:2021-budget\"    } } ``` The API will return something like  ```json {   \"tuples\": [     {       \"key\": {         \"user\": \"user:anne\",         \"relation\": \"writer\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-05T13:42:12.356Z\"     },     {       \"key\": {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-06T15:32:11.128Z\"     }   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` This means that `document:2021-budget` has 1 `reader` (`user:bob`) and 1 `writer` (`user:anne`).
 
-        >>> thread = await api.read(body)
+        >>> thread = api.read(body)
 
         :param body: (required)
         :type body: ReadRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
@@ -1072,21 +1103,21 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ReadResponse
         """
-        kwargs['_return_http_data_only'] = True
-        return await (self.read_with_http_info(body, **kwargs))  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return self.read_with_http_info(body, **kwargs)
 
-    async def read_with_http_info(self, body, **kwargs):  # noqa: E501
-        """Get tuples from the store that matches a query, without following userset rewrite rules  # noqa: E501
+    def read_with_http_info(self, body, **kwargs):
+        """Get tuples from the store that matches a query, without following userset rewrite rules
 
-        The Read API will return the tuples for a certain store that match a query filter specified in the body of the request.  The API doesn't guarantee order by any field.  It is different from the `/stores/{store_id}/expand` API in that it only returns relationship tuples that are stored in the system and satisfy the query.  In the body: 1. `tuple_key` is optional. If not specified, it will return all tuples in the store. 2. `tuple_key.object` is mandatory if `tuple_key` is specified. It can be a full object (e.g., `type:object_id`) or type only (e.g., `type:`). 3. `tuple_key.user` is mandatory if tuple_key is specified in the case the `tuple_key.object` is a type only. ## Examples ### Query for all objects in a type definition To query for all objects that `user:bob` has `reader` relationship in the `document` type definition, call read API with body of ```json {  \"tuple_key\": {      \"user\": \"user:bob\",      \"relation\": \"reader\",      \"object\": \"document:\"   } } ``` The API will return tuples and a continuation token, something like ```json {   \"tuples\": [     {       \"key\": {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-06T15:32:11.128Z\"     }   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` This means that `user:bob` has a `reader` relationship with 1 document `document:2021-budget`. Note that this API, unlike the List Objects API, does not evaluate the tuples in the store. The continuation token will be empty if there are no more tuples to query. ### Query for all stored relationship tuples that have a particular relation and object To query for all users that have `reader` relationship with `document:2021-budget`, call read API with body of  ```json {   \"tuple_key\": {      \"object\": \"document:2021-budget\",      \"relation\": \"reader\"    } } ``` The API will return something like  ```json {   \"tuples\": [     {       \"key\": {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-06T15:32:11.128Z\"     }   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` This means that `document:2021-budget` has 1 `reader` (`user:bob`).  Note that, even if the model said that all `writers` are also `readers`, the API will not return writers such as `user:anne` because it only returns tuples and does not evaluate them. ### Query for all users with all relationships for a particular document To query for all users that have any relationship with `document:2021-budget`, call read API with body of  ```json {   \"tuple_key\": {       \"object\": \"document:2021-budget\"    } } ``` The API will return something like  ```json {   \"tuples\": [     {       \"key\": {         \"user\": \"user:anne\",         \"relation\": \"writer\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-05T13:42:12.356Z\"     },     {       \"key\": {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-06T15:32:11.128Z\"     }   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` This means that `document:2021-budget` has 1 `reader` (`user:bob`) and 1 `writer` (`user:anne`).   # noqa: E501
+        The Read API will return the tuples for a certain store that match a query filter specified in the body of the request.  The API doesn't guarantee order by any field.  It is different from the `/stores/{store_id}/expand` API in that it only returns relationship tuples that are stored in the system and satisfy the query.  In the body: 1. `tuple_key` is optional. If not specified, it will return all tuples in the store. 2. `tuple_key.object` is mandatory if `tuple_key` is specified. It can be a full object (e.g., `type:object_id`) or type only (e.g., `type:`). 3. `tuple_key.user` is mandatory if tuple_key is specified in the case the `tuple_key.object` is a type only. ## Examples ### Query for all objects in a type definition To query for all objects that `user:bob` has `reader` relationship in the `document` type definition, call read API with body of ```json {  \"tuple_key\": {      \"user\": \"user:bob\",      \"relation\": \"reader\",      \"object\": \"document:\"   } } ``` The API will return tuples and a continuation token, something like ```json {   \"tuples\": [     {       \"key\": {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-06T15:32:11.128Z\"     }   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` This means that `user:bob` has a `reader` relationship with 1 document `document:2021-budget`. Note that this API, unlike the List Objects API, does not evaluate the tuples in the store. The continuation token will be empty if there are no more tuples to query. ### Query for all stored relationship tuples that have a particular relation and object To query for all users that have `reader` relationship with `document:2021-budget`, call read API with body of  ```json {   \"tuple_key\": {      \"object\": \"document:2021-budget\",      \"relation\": \"reader\"    } } ``` The API will return something like  ```json {   \"tuples\": [     {       \"key\": {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-06T15:32:11.128Z\"     }   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` This means that `document:2021-budget` has 1 `reader` (`user:bob`).  Note that, even if the model said that all `writers` are also `readers`, the API will not return writers such as `user:anne` because it only returns tuples and does not evaluate them. ### Query for all users with all relationships for a particular document To query for all users that have any relationship with `document:2021-budget`, call read API with body of  ```json {   \"tuple_key\": {       \"object\": \"document:2021-budget\"    } } ``` The API will return something like  ```json {   \"tuples\": [     {       \"key\": {         \"user\": \"user:anne\",         \"relation\": \"writer\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-05T13:42:12.356Z\"     },     {       \"key\": {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-06T15:32:11.128Z\"     }   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` This means that `document:2021-budget` has 1 `reader` (`user:bob`) and 1 `writer` (`user:anne`).
 
         >>> thread = api.read_with_http_info(body)
 
         :param body: (required)
         :type body: ReadRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
@@ -1111,107 +1142,117 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: tuple(ReadResponse, status_code(int), headers(HTTPHeaderDict))
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-            'body'
-
-        ]
+        all_params = ["body"]
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method read" % key
+                    "Got an unexpected keyword argument '%s'" " to method read" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
         # verify the required parameter 'body' is set
-        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
-            raise ApiValueError("Missing the required parameter `body` when calling `read`")  # noqa: E501
+        if (
+            self.api_client.client_side_validation
+            and local_var_params.get("body") is None
+        ):
+            raise ApiValueError(
+                "Missing the required parameter `body` when calling `read`"
+            )
 
         collection_formats = {}
 
         path_params = {}
 
         if self.api_client._get_store_id() is None:
-            raise ApiValueError("Store ID expected in api_client's configuration when calling `read`")  # noqa: E501
+            raise ApiValueError(
+                "Store ID expected in api_client's configuration when calling `read`"
+            )
         store_id = self.api_client._get_store_id()
 
         query_params = []
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in local_var_params:
-            body_params = local_var_params['body']
+        if "body" in local_var_params:
+            body_params = local_var_params["body"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # HTTP header `Content-Type`
-        content_types_list = local_var_params.get('_content_type', self.api_client.select_header_content_type(['application/json'], 'POST', body_params))  # noqa: E501
+        content_types_list = local_var_params.get(
+            "_content_type",
+            self.api_client.select_header_content_type(
+                ["application/json"], "POST", body_params
+            ),
+        )
         if content_types_list:
-            header_params['Content-Type'] = content_types_list
+            header_params["Content-Type"] = content_types_list
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {
             200: "ReadResponse",
             400: "ValidationErrorMessageResponse",
             404: "PathUnknownErrorMessageResponse",
             409: "AbortedMessageResponse",
             500: "InternalErrorMessageResponse",
         }
 
-        return await (self.api_client.call_api(
-            '/stores/{store_id}/read'.replace('{store_id}', store_id), 'POST',
+        return self.api_client.call_api(
+            "/stores/{store_id}/read".replace("{store_id}", store_id),
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client))
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    async def read_assertions(self, authorization_model_id, **kwargs):  # noqa: E501
-        """Read assertions for an authorization model ID  # noqa: E501
+    def read_assertions(self, authorization_model_id, **kwargs):
+        """Read assertions for an authorization model ID
 
-        The ReadAssertions API will return, for a given authorization model id, all the assertions stored for it. An assertion is an object that contains a tuple key, and the expectation of whether a call to the Check API of that tuple key will return true or false.   # noqa: E501
+        The ReadAssertions API will return, for a given authorization model id, all the assertions stored for it. An assertion is an object that contains a tuple key, and the expectation of whether a call to the Check API of that tuple key will return true or false.
 
-        >>> thread = await api.read_assertions(authorization_model_id)
+        >>> thread = api.read_assertions(authorization_model_id)
 
         :param authorization_model_id: (required)
         :type authorization_model_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
@@ -1222,21 +1263,21 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ReadAssertionsResponse
         """
-        kwargs['_return_http_data_only'] = True
-        return await (self.read_assertions_with_http_info(authorization_model_id, **kwargs))  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return self.read_assertions_with_http_info(authorization_model_id, **kwargs)
 
-    async def read_assertions_with_http_info(self, authorization_model_id, **kwargs):  # noqa: E501
-        """Read assertions for an authorization model ID  # noqa: E501
+    def read_assertions_with_http_info(self, authorization_model_id, **kwargs):
+        """Read assertions for an authorization model ID
 
-        The ReadAssertions API will return, for a given authorization model id, all the assertions stored for it. An assertion is an object that contains a tuple key, and the expectation of whether a call to the Check API of that tuple key will return true or false.   # noqa: E501
+        The ReadAssertions API will return, for a given authorization model id, all the assertions stored for it. An assertion is an object that contains a tuple key, and the expectation of whether a call to the Check API of that tuple key will return true or false.
 
         >>> thread = api.read_assertions_with_http_info(authorization_model_id)
 
         :param authorization_model_id: (required)
         :type authorization_model_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
@@ -1261,104 +1302,113 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: tuple(ReadAssertionsResponse, status_code(int), headers(HTTPHeaderDict))
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-            'authorization_model_id'
-
-        ]
+        all_params = ["authorization_model_id"]
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
                     "Got an unexpected keyword argument '%s'"
                     " to method read_assertions" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
         # verify the required parameter 'authorization_model_id' is set
-        if self.api_client.client_side_validation and local_var_params.get('authorization_model_id') is None:  # noqa: E501
-            raise ApiValueError("Missing the required parameter `authorization_model_id` when calling `read_assertions`")  # noqa: E501
+        if (
+            self.api_client.client_side_validation
+            and local_var_params.get("authorization_model_id") is None
+        ):
+            raise ApiValueError(
+                "Missing the required parameter `authorization_model_id` when calling `read_assertions`"
+            )
 
         collection_formats = {}
 
         path_params = {}
 
         if self.api_client._get_store_id() is None:
-            raise ApiValueError("Store ID expected in api_client's configuration when calling `read_assertions`")  # noqa: E501
+            raise ApiValueError(
+                "Store ID expected in api_client's configuration when calling `read_assertions`"
+            )
         store_id = self.api_client._get_store_id()
 
-        if 'authorization_model_id' in local_var_params:
-            path_params['authorization_model_id'] = local_var_params['authorization_model_id']  # noqa: E501
+        if "authorization_model_id" in local_var_params:
+            path_params["authorization_model_id"] = local_var_params[
+                "authorization_model_id"
+            ]
 
         query_params = []
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {
             200: "ReadAssertionsResponse",
             400: "ValidationErrorMessageResponse",
             404: "PathUnknownErrorMessageResponse",
             409: "AbortedMessageResponse",
             500: "InternalErrorMessageResponse",
         }
 
-        return await (self.api_client.call_api(
-            '/stores/{store_id}/assertions/{authorization_model_id}'.replace(
-                '{store_id}', store_id), 'GET',
+        return self.api_client.call_api(
+            "/stores/{store_id}/assertions/{authorization_model_id}".replace(
+                "{store_id}", store_id
+            ),
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client))
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    async def read_authorization_model(self, id, **kwargs):  # noqa: E501
-        """Return a particular version of an authorization model  # noqa: E501
+    def read_authorization_model(self, id, **kwargs):
+        """Return a particular version of an authorization model
 
-        The ReadAuthorizationModel API returns an authorization model by its identifier. The response will return the authorization model for the particular version.  ## Example To retrieve the authorization model with ID `01G5JAVJ41T49E9TT3SKVS7X1J` for the store, call the GET authorization-models by ID API with `01G5JAVJ41T49E9TT3SKVS7X1J` as the `id` path parameter.  The API will return: ```json {   \"authorization_model\":{     \"id\":\"01G5JAVJ41T49E9TT3SKVS7X1J\",     \"type_definitions\":[       {         \"type\":\"user\"       },       {         \"type\":\"document\",         \"relations\":{           \"reader\":{             \"union\":{               \"child\":[                 {                   \"this\":{}                 },                 {                   \"computedUserset\":{                     \"object\":\"\",                     \"relation\":\"writer\"                   }                 }               ]             }           },           \"writer\":{             \"this\":{}           }         }       }     ]   } } ``` In the above example, there are 2 types (`user` and `document`). The `document` type has 2 relations (`writer` and `reader`).  # noqa: E501
+        The ReadAuthorizationModel API returns an authorization model by its identifier. The response will return the authorization model for the particular version.  ## Example To retrieve the authorization model with ID `01G5JAVJ41T49E9TT3SKVS7X1J` for the store, call the GET authorization-models by ID API with `01G5JAVJ41T49E9TT3SKVS7X1J` as the `id` path parameter.  The API will return: ```json {   \"authorization_model\":{     \"id\":\"01G5JAVJ41T49E9TT3SKVS7X1J\",     \"type_definitions\":[       {         \"type\":\"user\"       },       {         \"type\":\"document\",         \"relations\":{           \"reader\":{             \"union\":{               \"child\":[                 {                   \"this\":{}                 },                 {                   \"computedUserset\":{                     \"object\":\"\",                     \"relation\":\"writer\"                   }                 }               ]             }           },           \"writer\":{             \"this\":{}           }         }       }     ]   } } ``` In the above example, there are 2 types (`user` and `document`). The `document` type has 2 relations (`writer` and `reader`).
 
-        >>> thread = await api.read_authorization_model(id)
+        >>> thread = api.read_authorization_model(id)
 
         :param id: (required)
         :type id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
@@ -1369,21 +1419,21 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ReadAuthorizationModelResponse
         """
-        kwargs['_return_http_data_only'] = True
-        return await (self.read_authorization_model_with_http_info(id, **kwargs))  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return self.read_authorization_model_with_http_info(id, **kwargs)
 
-    async def read_authorization_model_with_http_info(self, id, **kwargs):  # noqa: E501
-        """Return a particular version of an authorization model  # noqa: E501
+    def read_authorization_model_with_http_info(self, id, **kwargs):
+        """Return a particular version of an authorization model
 
-        The ReadAuthorizationModel API returns an authorization model by its identifier. The response will return the authorization model for the particular version.  ## Example To retrieve the authorization model with ID `01G5JAVJ41T49E9TT3SKVS7X1J` for the store, call the GET authorization-models by ID API with `01G5JAVJ41T49E9TT3SKVS7X1J` as the `id` path parameter.  The API will return: ```json {   \"authorization_model\":{     \"id\":\"01G5JAVJ41T49E9TT3SKVS7X1J\",     \"type_definitions\":[       {         \"type\":\"user\"       },       {         \"type\":\"document\",         \"relations\":{           \"reader\":{             \"union\":{               \"child\":[                 {                   \"this\":{}                 },                 {                   \"computedUserset\":{                     \"object\":\"\",                     \"relation\":\"writer\"                   }                 }               ]             }           },           \"writer\":{             \"this\":{}           }         }       }     ]   } } ``` In the above example, there are 2 types (`user` and `document`). The `document` type has 2 relations (`writer` and `reader`).  # noqa: E501
+        The ReadAuthorizationModel API returns an authorization model by its identifier. The response will return the authorization model for the particular version.  ## Example To retrieve the authorization model with ID `01G5JAVJ41T49E9TT3SKVS7X1J` for the store, call the GET authorization-models by ID API with `01G5JAVJ41T49E9TT3SKVS7X1J` as the `id` path parameter.  The API will return: ```json {   \"authorization_model\":{     \"id\":\"01G5JAVJ41T49E9TT3SKVS7X1J\",     \"type_definitions\":[       {         \"type\":\"user\"       },       {         \"type\":\"document\",         \"relations\":{           \"reader\":{             \"union\":{               \"child\":[                 {                   \"this\":{}                 },                 {                   \"computedUserset\":{                     \"object\":\"\",                     \"relation\":\"writer\"                   }                 }               ]             }           },           \"writer\":{             \"this\":{}           }         }       }     ]   } } ``` In the above example, there are 2 types (`user` and `document`). The `document` type has 2 relations (`writer` and `reader`).
 
         >>> thread = api.read_authorization_model_with_http_info(id)
 
         :param id: (required)
         :type id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
@@ -1408,103 +1458,111 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: tuple(ReadAuthorizationModelResponse, status_code(int), headers(HTTPHeaderDict))
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-            'id'
-
-        ]
+        all_params = ["id"]
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
                     "Got an unexpected keyword argument '%s'"
                     " to method read_authorization_model" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and local_var_params.get('id') is None:  # noqa: E501
-            raise ApiValueError("Missing the required parameter `id` when calling `read_authorization_model`")  # noqa: E501
+        if (
+            self.api_client.client_side_validation
+            and local_var_params.get("id") is None
+        ):
+            raise ApiValueError(
+                "Missing the required parameter `id` when calling `read_authorization_model`"
+            )
 
         collection_formats = {}
 
         path_params = {}
 
         if self.api_client._get_store_id() is None:
-            raise ApiValueError("Store ID expected in api_client's configuration when calling `read_authorization_model`")  # noqa: E501
+            raise ApiValueError(
+                "Store ID expected in api_client's configuration when calling `read_authorization_model`"
+            )
         store_id = self.api_client._get_store_id()
 
-        if 'id' in local_var_params:
-            path_params['id'] = local_var_params['id']  # noqa: E501
+        if "id" in local_var_params:
+            path_params["id"] = local_var_params["id"]
 
         query_params = []
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {
             200: "ReadAuthorizationModelResponse",
             400: "ValidationErrorMessageResponse",
             404: "PathUnknownErrorMessageResponse",
             409: "AbortedMessageResponse",
             500: "InternalErrorMessageResponse",
         }
 
-        return await (self.api_client.call_api(
-            '/stores/{store_id}/authorization-models/{id}'.replace('{store_id}', store_id), 'GET',
+        return self.api_client.call_api(
+            "/stores/{store_id}/authorization-models/{id}".replace(
+                "{store_id}", store_id
+            ),
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client))
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    async def read_authorization_models(self, **kwargs):  # noqa: E501
-        """Return all the authorization models for a particular store  # noqa: E501
+    def read_authorization_models(self, **kwargs):
+        """Return all the authorization models for a particular store
 
-        The ReadAuthorizationModels API will return all the authorization models for a certain store. OpenFGA's response will contain an array of all authorization models, sorted in descending order of creation.  ## Example Assume that a store's authorization model has been configured twice. To get all the authorization models that have been created in this store, call GET authorization-models. The API will return a response that looks like: ```json {   \"authorization_models\": [     {       \"id\": \"01G50QVV17PECNVAHX1GG4Y5NC\",       \"type_definitions\": [...]     },     {       \"id\": \"01G4ZW8F4A07AKQ8RHSVG9RW04\",       \"type_definitions\": [...]     },   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` If there are no more authorization models available, the `continuation_token` field will be empty ```json {   \"authorization_models\": [     {       \"id\": \"01G50QVV17PECNVAHX1GG4Y5NC\",       \"type_definitions\": [...]     },     {       \"id\": \"01G4ZW8F4A07AKQ8RHSVG9RW04\",       \"type_definitions\": [...]     },   ],   \"continuation_token\": \"\" } ```   # noqa: E501
+        The ReadAuthorizationModels API will return all the authorization models for a certain store. OpenFGA's response will contain an array of all authorization models, sorted in descending order of creation.  ## Example Assume that a store's authorization model has been configured twice. To get all the authorization models that have been created in this store, call GET authorization-models. The API will return a response that looks like: ```json {   \"authorization_models\": [     {       \"id\": \"01G50QVV17PECNVAHX1GG4Y5NC\",       \"type_definitions\": [...]     },     {       \"id\": \"01G4ZW8F4A07AKQ8RHSVG9RW04\",       \"type_definitions\": [...]     },   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` If there are no more authorization models available, the `continuation_token` field will be empty ```json {   \"authorization_models\": [     {       \"id\": \"01G50QVV17PECNVAHX1GG4Y5NC\",       \"type_definitions\": [...]     },     {       \"id\": \"01G4ZW8F4A07AKQ8RHSVG9RW04\",       \"type_definitions\": [...]     },   ],   \"continuation_token\": \"\" } ```
 
-        >>> thread = await api.read_authorization_models()
+        >>> thread = api.read_authorization_models()
 
         :param page_size:(optional)
         :type page_size: int, optional
         :param continuation_token:(optional)
         :type continuation_token: str, optional
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
@@ -1517,21 +1575,21 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ReadAuthorizationModelsResponse
         """
-        kwargs['_return_http_data_only'] = True
-        return await (self.read_authorization_models_with_http_info(**kwargs))  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return self.read_authorization_models_with_http_info(**kwargs)
 
-    async def read_authorization_models_with_http_info(self, **kwargs):  # noqa: E501
-        """Return all the authorization models for a particular store  # noqa: E501
+    def read_authorization_models_with_http_info(self, **kwargs):
+        """Return all the authorization models for a particular store
 
-        The ReadAuthorizationModels API will return all the authorization models for a certain store. OpenFGA's response will contain an array of all authorization models, sorted in descending order of creation.  ## Example Assume that a store's authorization model has been configured twice. To get all the authorization models that have been created in this store, call GET authorization-models. The API will return a response that looks like: ```json {   \"authorization_models\": [     {       \"id\": \"01G50QVV17PECNVAHX1GG4Y5NC\",       \"type_definitions\": [...]     },     {       \"id\": \"01G4ZW8F4A07AKQ8RHSVG9RW04\",       \"type_definitions\": [...]     },   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` If there are no more authorization models available, the `continuation_token` field will be empty ```json {   \"authorization_models\": [     {       \"id\": \"01G50QVV17PECNVAHX1GG4Y5NC\",       \"type_definitions\": [...]     },     {       \"id\": \"01G4ZW8F4A07AKQ8RHSVG9RW04\",       \"type_definitions\": [...]     },   ],   \"continuation_token\": \"\" } ```   # noqa: E501
+        The ReadAuthorizationModels API will return all the authorization models for a certain store. OpenFGA's response will contain an array of all authorization models, sorted in descending order of creation.  ## Example Assume that a store's authorization model has been configured twice. To get all the authorization models that have been created in this store, call GET authorization-models. The API will return a response that looks like: ```json {   \"authorization_models\": [     {       \"id\": \"01G50QVV17PECNVAHX1GG4Y5NC\",       \"type_definitions\": [...]     },     {       \"id\": \"01G4ZW8F4A07AKQ8RHSVG9RW04\",       \"type_definitions\": [...]     },   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` If there are no more authorization models available, the `continuation_token` field will be empty ```json {   \"authorization_models\": [     {       \"id\": \"01G50QVV17PECNVAHX1GG4Y5NC\",       \"type_definitions\": [...]     },     {       \"id\": \"01G4ZW8F4A07AKQ8RHSVG9RW04\",       \"type_definitions\": [...]     },   ],   \"continuation_token\": \"\" } ```
 
         >>> thread = api.read_authorization_models_with_http_info()
 
         :param page_size:(optional)
         :type page_size: int, optional
         :param continuation_token:(optional)
         :type continuation_token: str, optional
@@ -1558,101 +1616,104 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: tuple(ReadAuthorizationModelsResponse, status_code(int), headers(HTTPHeaderDict))
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-            'page_size',
-            'continuation_token'
-        ]
+        all_params = ["page_size", "continuation_token"]
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
                     "Got an unexpected keyword argument '%s'"
                     " to method read_authorization_models" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
 
         collection_formats = {}
 
         path_params = {}
 
         if self.api_client._get_store_id() is None:
-            raise ApiValueError("Store ID expected in api_client's configuration when calling `read_authorization_models`")  # noqa: E501
+            raise ApiValueError(
+                "Store ID expected in api_client's configuration when calling `read_authorization_models`"
+            )
         store_id = self.api_client._get_store_id()
 
         query_params = []
-        if local_var_params.get('page_size') is not None:  # noqa: E501
-            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501
-        if local_var_params.get('continuation_token') is not None:  # noqa: E501
-            query_params.append(('continuation_token', local_var_params['continuation_token']))  # noqa: E501
+        if local_var_params.get("page_size") is not None:
+            query_params.append(("page_size", local_var_params["page_size"]))
+        if local_var_params.get("continuation_token") is not None:
+            query_params.append(
+                ("continuation_token", local_var_params["continuation_token"])
+            )
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {
             200: "ReadAuthorizationModelsResponse",
             400: "ValidationErrorMessageResponse",
             404: "PathUnknownErrorMessageResponse",
             409: "AbortedMessageResponse",
             500: "InternalErrorMessageResponse",
         }
 
-        return await (self.api_client.call_api(
-            '/stores/{store_id}/authorization-models'.replace('{store_id}', store_id), 'GET',
+        return self.api_client.call_api(
+            "/stores/{store_id}/authorization-models".replace("{store_id}", store_id),
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client))
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    async def read_changes(self, **kwargs):  # noqa: E501
-        """Return a list of all the tuple changes  # noqa: E501
+    def read_changes(self, **kwargs):
+        """Return a list of all the tuple changes
 
-        The ReadChanges API will return a paginated list of tuple changes (additions and deletions) that occurred in a given store, sorted by ascending time. The response will include a continuation token that is used to get the next set of changes. If there are no changes after the provided continuation token, the same token will be returned in order for it to be used when new changes are recorded. If the store never had any tuples added or removed, this token will be empty. You can use the `type` parameter to only get the list of tuple changes that affect objects of that type. When reading a write tuple change, if it was conditioned, the condition will be returned. When reading a delete tuple change, the condition will NOT be returned regardless of whether it was originally conditioned or not.   # noqa: E501
+        The ReadChanges API will return a paginated list of tuple changes (additions and deletions) that occurred in a given store, sorted by ascending time. The response will include a continuation token that is used to get the next set of changes. If there are no changes after the provided continuation token, the same token will be returned in order for it to be used when new changes are recorded. If the store never had any tuples added or removed, this token will be empty. You can use the `type` parameter to only get the list of tuple changes that affect objects of that type. When reading a write tuple change, if it was conditioned, the condition will be returned. When reading a delete tuple change, the condition will NOT be returned regardless of whether it was originally conditioned or not.
 
-        >>> thread = await api.read_changes()
+        >>> thread = api.read_changes()
 
         :param type:(optional)
         :type type: str, optional
         :param page_size:(optional)
         :type page_size: int, optional
         :param continuation_token:(optional)
         :type continuation_token: str, optional
@@ -1667,21 +1728,21 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ReadChangesResponse
         """
-        kwargs['_return_http_data_only'] = True
-        return await (self.read_changes_with_http_info(**kwargs))  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return self.read_changes_with_http_info(**kwargs)
 
-    async def read_changes_with_http_info(self, **kwargs):  # noqa: E501
-        """Return a list of all the tuple changes  # noqa: E501
+    def read_changes_with_http_info(self, **kwargs):
+        """Return a list of all the tuple changes
 
-        The ReadChanges API will return a paginated list of tuple changes (additions and deletions) that occurred in a given store, sorted by ascending time. The response will include a continuation token that is used to get the next set of changes. If there are no changes after the provided continuation token, the same token will be returned in order for it to be used when new changes are recorded. If the store never had any tuples added or removed, this token will be empty. You can use the `type` parameter to only get the list of tuple changes that affect objects of that type. When reading a write tuple change, if it was conditioned, the condition will be returned. When reading a delete tuple change, the condition will NOT be returned regardless of whether it was originally conditioned or not.   # noqa: E501
+        The ReadChanges API will return a paginated list of tuple changes (additions and deletions) that occurred in a given store, sorted by ascending time. The response will include a continuation token that is used to get the next set of changes. If there are no changes after the provided continuation token, the same token will be returned in order for it to be used when new changes are recorded. If the store never had any tuples added or removed, this token will be empty. You can use the `type` parameter to only get the list of tuple changes that affect objects of that type. When reading a write tuple change, if it was conditioned, the condition will be returned. When reading a delete tuple change, the condition will NOT be returned regardless of whether it was originally conditioned or not.
 
         >>> thread = api.read_changes_with_http_info()
 
         :param type:(optional)
         :type type: str, optional
         :param page_size:(optional)
         :type page_size: int, optional
@@ -1710,104 +1771,106 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: tuple(ReadChangesResponse, status_code(int), headers(HTTPHeaderDict))
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-            'type',
-            'page_size',
-            'continuation_token'
-        ]
+        all_params = ["type", "page_size", "continuation_token"]
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
                     "Got an unexpected keyword argument '%s'"
                     " to method read_changes" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
 
         collection_formats = {}
 
         path_params = {}
 
         if self.api_client._get_store_id() is None:
-            raise ApiValueError("Store ID expected in api_client's configuration when calling `read_changes`")  # noqa: E501
+            raise ApiValueError(
+                "Store ID expected in api_client's configuration when calling `read_changes`"
+            )
         store_id = self.api_client._get_store_id()
 
         query_params = []
-        if local_var_params.get('type') is not None:  # noqa: E501
-            query_params.append(('type', local_var_params['type']))  # noqa: E501
-        if local_var_params.get('page_size') is not None:  # noqa: E501
-            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501
-        if local_var_params.get('continuation_token') is not None:  # noqa: E501
-            query_params.append(('continuation_token', local_var_params['continuation_token']))  # noqa: E501
+        if local_var_params.get("type") is not None:
+            query_params.append(("type", local_var_params["type"]))
+        if local_var_params.get("page_size") is not None:
+            query_params.append(("page_size", local_var_params["page_size"]))
+        if local_var_params.get("continuation_token") is not None:
+            query_params.append(
+                ("continuation_token", local_var_params["continuation_token"])
+            )
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {
             200: "ReadChangesResponse",
             400: "ValidationErrorMessageResponse",
             404: "PathUnknownErrorMessageResponse",
             409: "AbortedMessageResponse",
             500: "InternalErrorMessageResponse",
         }
 
-        return await (self.api_client.call_api(
-            '/stores/{store_id}/changes'.replace('{store_id}', store_id), 'GET',
+        return self.api_client.call_api(
+            "/stores/{store_id}/changes".replace("{store_id}", store_id),
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client))
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    async def write(self, body, **kwargs):  # noqa: E501
-        """Add or delete tuples from the store  # noqa: E501
+    def write(self, body, **kwargs):
+        """Add or delete tuples from the store
 
-        The Write API will update the tuples for a certain store. Tuples and type definitions allow OpenFGA to determine whether a relationship exists between an object and an user. In the body, `writes` adds new tuples and `deletes` removes existing tuples. When deleting a tuple, any `condition` specified with it is ignored. The API is not idempotent: if, later on, you try to add the same tuple key (even if the `condition` is different), or if you try to delete a non-existing tuple, it will throw an error. An `authorization_model_id` may be specified in the body. If it is, it will be used to assert that each written tuple (not deleted) is valid for the model specified. If it is not specified, the latest authorization model ID will be used. ## Example ### Adding relationships To add `user:anne` as a `writer` for `document:2021-budget`, call write API with the following  ```json {   \"writes\": {     \"tuple_keys\": [       {         \"user\": \"user:anne\",         \"relation\": \"writer\",         \"object\": \"document:2021-budget\"       }     ]   },   \"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\" } ``` ### Removing relationships To remove `user:bob` as a `reader` for `document:2021-budget`, call write API with the following  ```json {   \"deletes\": {     \"tuple_keys\": [       {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       }     ]   } } ```   # noqa: E501
+        The Write API will update the tuples for a certain store. Tuples and type definitions allow OpenFGA to determine whether a relationship exists between an object and an user. In the body, `writes` adds new tuples and `deletes` removes existing tuples. When deleting a tuple, any `condition` specified with it is ignored. The API is not idempotent: if, later on, you try to add the same tuple key (even if the `condition` is different), or if you try to delete a non-existing tuple, it will throw an error. An `authorization_model_id` may be specified in the body. If it is, it will be used to assert that each written tuple (not deleted) is valid for the model specified. If it is not specified, the latest authorization model ID will be used. ## Example ### Adding relationships To add `user:anne` as a `writer` for `document:2021-budget`, call write API with the following  ```json {   \"writes\": {     \"tuple_keys\": [       {         \"user\": \"user:anne\",         \"relation\": \"writer\",         \"object\": \"document:2021-budget\"       }     ]   },   \"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\" } ``` ### Removing relationships To remove `user:bob` as a `reader` for `document:2021-budget`, call write API with the following  ```json {   \"deletes\": {     \"tuple_keys\": [       {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       }     ]   } } ```
 
-        >>> thread = await api.write(body)
+        >>> thread = api.write(body)
 
         :param body: (required)
         :type body: WriteRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
@@ -1818,21 +1881,21 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: object
         """
-        kwargs['_return_http_data_only'] = True
-        return await (self.write_with_http_info(body, **kwargs))  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return self.write_with_http_info(body, **kwargs)
 
-    async def write_with_http_info(self, body, **kwargs):  # noqa: E501
-        """Add or delete tuples from the store  # noqa: E501
+    def write_with_http_info(self, body, **kwargs):
+        """Add or delete tuples from the store
 
-        The Write API will update the tuples for a certain store. Tuples and type definitions allow OpenFGA to determine whether a relationship exists between an object and an user. In the body, `writes` adds new tuples and `deletes` removes existing tuples. When deleting a tuple, any `condition` specified with it is ignored. The API is not idempotent: if, later on, you try to add the same tuple key (even if the `condition` is different), or if you try to delete a non-existing tuple, it will throw an error. An `authorization_model_id` may be specified in the body. If it is, it will be used to assert that each written tuple (not deleted) is valid for the model specified. If it is not specified, the latest authorization model ID will be used. ## Example ### Adding relationships To add `user:anne` as a `writer` for `document:2021-budget`, call write API with the following  ```json {   \"writes\": {     \"tuple_keys\": [       {         \"user\": \"user:anne\",         \"relation\": \"writer\",         \"object\": \"document:2021-budget\"       }     ]   },   \"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\" } ``` ### Removing relationships To remove `user:bob` as a `reader` for `document:2021-budget`, call write API with the following  ```json {   \"deletes\": {     \"tuple_keys\": [       {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       }     ]   } } ```   # noqa: E501
+        The Write API will update the tuples for a certain store. Tuples and type definitions allow OpenFGA to determine whether a relationship exists between an object and an user. In the body, `writes` adds new tuples and `deletes` removes existing tuples. When deleting a tuple, any `condition` specified with it is ignored. The API is not idempotent: if, later on, you try to add the same tuple key (even if the `condition` is different), or if you try to delete a non-existing tuple, it will throw an error. An `authorization_model_id` may be specified in the body. If it is, it will be used to assert that each written tuple (not deleted) is valid for the model specified. If it is not specified, the latest authorization model ID will be used. ## Example ### Adding relationships To add `user:anne` as a `writer` for `document:2021-budget`, call write API with the following  ```json {   \"writes\": {     \"tuple_keys\": [       {         \"user\": \"user:anne\",         \"relation\": \"writer\",         \"object\": \"document:2021-budget\"       }     ]   },   \"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\" } ``` ### Removing relationships To remove `user:bob` as a `reader` for `document:2021-budget`, call write API with the following  ```json {   \"deletes\": {     \"tuple_keys\": [       {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       }     ]   } } ```
 
         >>> thread = api.write_with_http_info(body)
 
         :param body: (required)
         :type body: WriteRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
@@ -1857,107 +1920,117 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-            'body'
-
-        ]
+        all_params = ["body"]
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method write" % key
+                    "Got an unexpected keyword argument '%s'" " to method write" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
         # verify the required parameter 'body' is set
-        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
-            raise ApiValueError("Missing the required parameter `body` when calling `write`")  # noqa: E501
+        if (
+            self.api_client.client_side_validation
+            and local_var_params.get("body") is None
+        ):
+            raise ApiValueError(
+                "Missing the required parameter `body` when calling `write`"
+            )
 
         collection_formats = {}
 
         path_params = {}
 
         if self.api_client._get_store_id() is None:
-            raise ApiValueError("Store ID expected in api_client's configuration when calling `write`")  # noqa: E501
+            raise ApiValueError(
+                "Store ID expected in api_client's configuration when calling `write`"
+            )
         store_id = self.api_client._get_store_id()
 
         query_params = []
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in local_var_params:
-            body_params = local_var_params['body']
+        if "body" in local_var_params:
+            body_params = local_var_params["body"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # HTTP header `Content-Type`
-        content_types_list = local_var_params.get('_content_type', self.api_client.select_header_content_type(['application/json'], 'POST', body_params))  # noqa: E501
+        content_types_list = local_var_params.get(
+            "_content_type",
+            self.api_client.select_header_content_type(
+                ["application/json"], "POST", body_params
+            ),
+        )
         if content_types_list:
-            header_params['Content-Type'] = content_types_list
+            header_params["Content-Type"] = content_types_list
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {
             200: "object",
             400: "ValidationErrorMessageResponse",
             404: "PathUnknownErrorMessageResponse",
             409: "AbortedMessageResponse",
             500: "InternalErrorMessageResponse",
         }
 
-        return await (self.api_client.call_api(
-            '/stores/{store_id}/write'.replace('{store_id}', store_id), 'POST',
+        return self.api_client.call_api(
+            "/stores/{store_id}/write".replace("{store_id}", store_id),
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client))
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    async def write_assertions(self, authorization_model_id, body, **kwargs):  # noqa: E501
-        """Upsert assertions for an authorization model ID  # noqa: E501
+    def write_assertions(self, authorization_model_id, body, **kwargs):
+        """Upsert assertions for an authorization model ID
 
-        The WriteAssertions API will upsert new assertions for an authorization model id, or overwrite the existing ones. An assertion is an object that contains a tuple key, and the expectation of whether a call to the Check API of that tuple key will return true or false.   # noqa: E501
+        The WriteAssertions API will upsert new assertions for an authorization model id, or overwrite the existing ones. An assertion is an object that contains a tuple key, and the expectation of whether a call to the Check API of that tuple key will return true or false.
 
-        >>> thread = await api.write_assertions(authorization_model_id, body)
+        >>> thread = api.write_assertions(authorization_model_id, body)
 
         :param authorization_model_id: (required)
         :type authorization_model_id: str
         :param body: (required)
         :type body: WriteAssertionsRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
@@ -1970,21 +2043,23 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
-        kwargs['_return_http_data_only'] = True
-        return await (self.write_assertions_with_http_info(authorization_model_id, body, **kwargs))  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return self.write_assertions_with_http_info(
+            authorization_model_id, body, **kwargs
+        )
 
-    async def write_assertions_with_http_info(self, authorization_model_id, body, **kwargs):  # noqa: E501
-        """Upsert assertions for an authorization model ID  # noqa: E501
+    def write_assertions_with_http_info(self, authorization_model_id, body, **kwargs):
+        """Upsert assertions for an authorization model ID
 
-        The WriteAssertions API will upsert new assertions for an authorization model id, or overwrite the existing ones. An assertion is an object that contains a tuple key, and the expectation of whether a call to the Check API of that tuple key will return true or false.   # noqa: E501
+        The WriteAssertions API will upsert new assertions for an authorization model id, or overwrite the existing ones. An assertion is an object that contains a tuple key, and the expectation of whether a call to the Check API of that tuple key will return true or false.
 
         >>> thread = api.write_assertions_with_http_info(authorization_model_id, body)
 
         :param authorization_model_id: (required)
         :type authorization_model_id: str
         :param body: (required)
         :type body: WriteAssertionsRequest
@@ -2011,110 +2086,127 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-            'authorization_model_id',
-
-            'body'
-
-        ]
+        all_params = ["authorization_model_id", "body"]
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
                     "Got an unexpected keyword argument '%s'"
                     " to method write_assertions" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
         # verify the required parameter 'authorization_model_id' is set
-        if self.api_client.client_side_validation and local_var_params.get('authorization_model_id') is None:  # noqa: E501
-            raise ApiValueError("Missing the required parameter `authorization_model_id` when calling `write_assertions`")  # noqa: E501
+        if (
+            self.api_client.client_side_validation
+            and local_var_params.get("authorization_model_id") is None
+        ):
+            raise ApiValueError(
+                "Missing the required parameter `authorization_model_id` when calling `write_assertions`"
+            )
         # verify the required parameter 'body' is set
-        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
-            raise ApiValueError("Missing the required parameter `body` when calling `write_assertions`")  # noqa: E501
+        if (
+            self.api_client.client_side_validation
+            and local_var_params.get("body") is None
+        ):
+            raise ApiValueError(
+                "Missing the required parameter `body` when calling `write_assertions`"
+            )
 
         collection_formats = {}
 
         path_params = {}
 
         if self.api_client._get_store_id() is None:
-            raise ApiValueError("Store ID expected in api_client's configuration when calling `write_assertions`")  # noqa: E501
+            raise ApiValueError(
+                "Store ID expected in api_client's configuration when calling `write_assertions`"
+            )
         store_id = self.api_client._get_store_id()
 
-        if 'authorization_model_id' in local_var_params:
-            path_params['authorization_model_id'] = local_var_params['authorization_model_id']  # noqa: E501
+        if "authorization_model_id" in local_var_params:
+            path_params["authorization_model_id"] = local_var_params[
+                "authorization_model_id"
+            ]
 
         query_params = []
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in local_var_params:
-            body_params = local_var_params['body']
+        if "body" in local_var_params:
+            body_params = local_var_params["body"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # HTTP header `Content-Type`
-        content_types_list = local_var_params.get('_content_type', self.api_client.select_header_content_type(['application/json'], 'PUT', body_params))  # noqa: E501
+        content_types_list = local_var_params.get(
+            "_content_type",
+            self.api_client.select_header_content_type(
+                ["application/json"], "PUT", body_params
+            ),
+        )
         if content_types_list:
-            header_params['Content-Type'] = content_types_list
+            header_params["Content-Type"] = content_types_list
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {}
 
-        return await (self.api_client.call_api(
-            '/stores/{store_id}/assertions/{authorization_model_id}'.replace(
-                '{store_id}', store_id), 'PUT',
+        return self.api_client.call_api(
+            "/stores/{store_id}/assertions/{authorization_model_id}".replace(
+                "{store_id}", store_id
+            ),
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client))
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    async def write_authorization_model(self, body, **kwargs):  # noqa: E501
-        """Create a new authorization model  # noqa: E501
+    def write_authorization_model(self, body, **kwargs):
+        """Create a new authorization model
 
-        The WriteAuthorizationModel API will add a new authorization model to a store. Each item in the `type_definitions` array is a type definition as specified in the field `type_definition`. The response will return the authorization model's ID in the `id` field.  ## Example To add an authorization model with `user` and `document` type definitions, call POST authorization-models API with the body:  ```json {   \"type_definitions\":[     {       \"type\":\"user\"     },     {       \"type\":\"document\",       \"relations\":{         \"reader\":{           \"union\":{             \"child\":[               {                 \"this\":{}               },               {                 \"computedUserset\":{                   \"object\":\"\",                   \"relation\":\"writer\"                 }               }             ]           }         },         \"writer\":{           \"this\":{}         }       }     }   ] } ``` OpenFGA's response will include the version id for this authorization model, which will look like  ``` {\"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\"} ```   # noqa: E501
+        The WriteAuthorizationModel API will add a new authorization model to a store. Each item in the `type_definitions` array is a type definition as specified in the field `type_definition`. The response will return the authorization model's ID in the `id` field.  ## Example To add an authorization model with `user` and `document` type definitions, call POST authorization-models API with the body:  ```json {   \"type_definitions\":[     {       \"type\":\"user\"     },     {       \"type\":\"document\",       \"relations\":{         \"reader\":{           \"union\":{             \"child\":[               {                 \"this\":{}               },               {                 \"computedUserset\":{                   \"object\":\"\",                   \"relation\":\"writer\"                 }               }             ]           }         },         \"writer\":{           \"this\":{}         }       }     }   ] } ``` OpenFGA's response will include the version id for this authorization model, which will look like  ``` {\"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\"} ```
 
-        >>> thread = await api.write_authorization_model(body)
+        >>> thread = api.write_authorization_model(body)
 
         :param body: (required)
         :type body: WriteAuthorizationModelRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
@@ -2125,21 +2217,21 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: WriteAuthorizationModelResponse
         """
-        kwargs['_return_http_data_only'] = True
-        return await (self.write_authorization_model_with_http_info(body, **kwargs))  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return self.write_authorization_model_with_http_info(body, **kwargs)
 
-    async def write_authorization_model_with_http_info(self, body, **kwargs):  # noqa: E501
-        """Create a new authorization model  # noqa: E501
+    def write_authorization_model_with_http_info(self, body, **kwargs):
+        """Create a new authorization model
 
-        The WriteAuthorizationModel API will add a new authorization model to a store. Each item in the `type_definitions` array is a type definition as specified in the field `type_definition`. The response will return the authorization model's ID in the `id` field.  ## Example To add an authorization model with `user` and `document` type definitions, call POST authorization-models API with the body:  ```json {   \"type_definitions\":[     {       \"type\":\"user\"     },     {       \"type\":\"document\",       \"relations\":{         \"reader\":{           \"union\":{             \"child\":[               {                 \"this\":{}               },               {                 \"computedUserset\":{                   \"object\":\"\",                   \"relation\":\"writer\"                 }               }             ]           }         },         \"writer\":{           \"this\":{}         }       }     }   ] } ``` OpenFGA's response will include the version id for this authorization model, which will look like  ``` {\"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\"} ```   # noqa: E501
+        The WriteAuthorizationModel API will add a new authorization model to a store. Each item in the `type_definitions` array is a type definition as specified in the field `type_definition`. The response will return the authorization model's ID in the `id` field.  ## Example To add an authorization model with `user` and `document` type definitions, call POST authorization-models API with the body:  ```json {   \"type_definitions\":[     {       \"type\":\"user\"     },     {       \"type\":\"document\",       \"relations\":{         \"reader\":{           \"union\":{             \"child\":[               {                 \"this\":{}               },               {                 \"computedUserset\":{                   \"object\":\"\",                   \"relation\":\"writer\"                 }               }             ]           }         },         \"writer\":{           \"this\":{}         }       }     }   ] } ``` OpenFGA's response will include the version id for this authorization model, which will look like  ``` {\"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\"} ```
 
         >>> thread = api.write_authorization_model_with_http_info(body)
 
         :param body: (required)
         :type body: WriteAuthorizationModelRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
@@ -2164,93 +2256,104 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: tuple(WriteAuthorizationModelResponse, status_code(int), headers(HTTPHeaderDict))
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-            'body'
-
-        ]
+        all_params = ["body"]
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
                     "Got an unexpected keyword argument '%s'"
                     " to method write_authorization_model" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
         # verify the required parameter 'body' is set
-        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
-            raise ApiValueError("Missing the required parameter `body` when calling `write_authorization_model`")  # noqa: E501
+        if (
+            self.api_client.client_side_validation
+            and local_var_params.get("body") is None
+        ):
+            raise ApiValueError(
+                "Missing the required parameter `body` when calling `write_authorization_model`"
+            )
 
         collection_formats = {}
 
         path_params = {}
 
         if self.api_client._get_store_id() is None:
-            raise ApiValueError("Store ID expected in api_client's configuration when calling `write_authorization_model`")  # noqa: E501
+            raise ApiValueError(
+                "Store ID expected in api_client's configuration when calling `write_authorization_model`"
+            )
         store_id = self.api_client._get_store_id()
 
         query_params = []
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in local_var_params:
-            body_params = local_var_params['body']
+        if "body" in local_var_params:
+            body_params = local_var_params["body"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # HTTP header `Content-Type`
-        content_types_list = local_var_params.get('_content_type', self.api_client.select_header_content_type(['application/json'], 'POST', body_params))  # noqa: E501
+        content_types_list = local_var_params.get(
+            "_content_type",
+            self.api_client.select_header_content_type(
+                ["application/json"], "POST", body_params
+            ),
+        )
         if content_types_list:
-            header_params['Content-Type'] = content_types_list
+            header_params["Content-Type"] = content_types_list
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {
             201: "WriteAuthorizationModelResponse",
             400: "ValidationErrorMessageResponse",
             404: "PathUnknownErrorMessageResponse",
             409: "AbortedMessageResponse",
             500: "InternalErrorMessageResponse",
         }
 
-        return await (self.api_client.call_api(
-            '/stores/{store_id}/authorization-models'.replace('{store_id}', store_id), 'POST',
+        return self.api_client.call_api(
+            "/stores/{store_id}/authorization-models".replace("{store_id}", store_id),
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client))
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/api_client.py` & `openfga-sdk-0.4.2/openfga_sdk/sync/api_client.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,56 +1,55 @@
-# coding: utf-8
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
-import asyncio
 import atexit
 import datetime
-from dateutil.parser import parse
 import json
 import math
-import mimetypes
-from multiprocessing.pool import ThreadPool
-import os
 import random
 import re
-import tempfile
+import time
+import urllib
+from multiprocessing.pool import ThreadPool
 
-# python 2 and python 3 compatibility library
-import six
-from six.moves.urllib.parse import quote
+from dateutil.parser import parse
 
-from openfga_sdk.configuration import Configuration
 import openfga_sdk.models
-from openfga_sdk import rest, oauth2
-from openfga_sdk.exceptions import ApiValueError, ApiException, FgaValidationException, RateLimitExceededError
-
+from openfga_sdk.configuration import Configuration
+from openfga_sdk.exceptions import (
+    ApiException,
+    ApiValueError,
+    FgaValidationException,
+    RateLimitExceededError,
+    ServiceException,
+)
+from openfga_sdk.sync import oauth2, rest
 
-DEFAULT_USER_AGENT = 'openfga-sdk python/0.4.1'
+DEFAULT_USER_AGENT = "openfga-sdk python/0.4.2"
 
 
 def random_time(loop_count, min_wait_in_ms):
     """
     Helper function to return the time (in s) to wait before retry
     """
-    minimum = math.ceil(2 ** loop_count * min_wait_in_ms)
+    minimum = math.ceil(2**loop_count * min_wait_in_ms)
     maximum = math.ceil(2 ** (loop_count + 1) * min_wait_in_ms)
     return random.randrange(minimum, maximum) / 1000
 
 
-class ApiClient(object):
+class ApiClient:
     """Generic API client for OpenAPI client library builds.
 
     OpenAPI generic API client. This client handles the client-
     server communication, and is invariant across implementations. Specifics of
     the methods and models for each application are generated from the OpenAPI
     templates.
 
@@ -64,211 +63,255 @@
         the API.
     :param cookie: a cookie to include in the header when making calls
         to the API
     :param pool_threads: The number of threads to use for async requests
         to the API. More threads means more concurrent API requests.
     """
 
-    PRIMITIVE_TYPES = (float, bool, bytes, six.text_type) + six.integer_types
+    PRIMITIVE_TYPES = (float, bool, bytes, str, int)
     NATIVE_TYPES_MAPPING = {
-        'int': int,
-        'long': int if six.PY3 else long,  # noqa: F821
-        'float': float,
-        'str': str,
-        'bool': bool,
-        'date': datetime.date,
-        'datetime': datetime.datetime,
-        'object': object,
+        "int": int,
+        "long": int,
+        "float": float,
+        "str": str,
+        "bool": bool,
+        "date": datetime.date,
+        "datetime": datetime.datetime,
+        "object": object,
     }
     _pool = None
 
-    def __init__(self, configuration=None, header_name=None, header_value=None,
-                 cookie=None, pool_threads=1):
+    def __init__(
+        self,
+        configuration=None,
+        header_name=None,
+        header_value=None,
+        cookie=None,
+        pool_threads=1,
+    ):
         if configuration is None:
             configuration = Configuration.get_default_copy()
         self.configuration = configuration
         self.pool_threads = pool_threads
 
         self.rest_client = rest.RESTClientObject(configuration)
         self.default_headers = {}
         if header_name is not None:
             self.default_headers[header_name] = header_value
         self.cookie = cookie
         # Set default User-Agent.
         self.user_agent = DEFAULT_USER_AGENT
         self.client_side_validation = configuration.client_side_validation
 
-    async def __aenter__(self):
+    def __enter__(self):
         return self
 
-    async def __aexit__(self, exc_type, exc_value, traceback):
-        await self.close()
+    def __exit__(self, exc_type, exc_value, traceback):
+        self.close()
 
-    async def close(self):
-        await self.rest_client.close()
+    def close(self):
         if self._pool:
             self._pool.close()
             self._pool.join()
             self._pool = None
-            if hasattr(atexit, 'unregister'):
+            if hasattr(atexit, "unregister"):
                 atexit.unregister(self.close)
 
     @property
     def pool(self):
         """Create thread pool on first request
-         avoids instantiating unused threadpool for blocking clients.
+        avoids instantiating unused threadpool for blocking clients.
         """
         if self._pool is None:
             atexit.register(self.close)
             self._pool = ThreadPool(self.pool_threads)
         return self._pool
 
     @property
     def user_agent(self):
         """User agent for this API client"""
-        return self.default_headers['User-Agent']
+        return self.default_headers["User-Agent"]
 
     @user_agent.setter
     def user_agent(self, value):
-        self.default_headers['User-Agent'] = value
+        self.default_headers["User-Agent"] = value
 
     def set_default_header(self, header_name, header_value):
         self.default_headers[header_name] = header_value
 
-    async def __call_api(
-            self, resource_path, method, path_params=None,
-            query_params=None, header_params=None, body=None, post_params=None,
-            response_types_map=None, auth_settings=None,
-            _return_http_data_only=None, collection_formats=None,
-            _preload_content=True, _request_timeout=None, _host=None,
-            _request_auth=None, _retry_params=None, _oauth2_client=None):
+    def __call_api(
+        self,
+        resource_path,
+        method,
+        path_params=None,
+        query_params=None,
+        header_params=None,
+        body=None,
+        post_params=None,
+        response_types_map=None,
+        auth_settings=None,
+        _return_http_data_only=None,
+        collection_formats=None,
+        _preload_content=True,
+        _request_timeout=None,
+        _host=None,
+        _request_auth=None,
+        _retry_params=None,
+        _oauth2_client=None,
+    ):
 
         self.configuration.is_valid()
         config = self.configuration
 
         # header parameters
         header_params = header_params or {}
         header_params.update(self.default_headers)
         if self.cookie:
-            header_params['Cookie'] = self.cookie
+            header_params["Cookie"] = self.cookie
         if header_params:
             header_params = self.sanitize_for_serialization(header_params)
-            header_params = dict(self.parameters_to_tuples(header_params,
-                                                           collection_formats))
+            header_params = dict(
+                self.parameters_to_tuples(header_params, collection_formats)
+            )
 
         # path parameters
         if path_params:
             path_params = self.sanitize_for_serialization(path_params)
-            path_params = self.parameters_to_tuples(path_params,
-                                                    collection_formats)
+            path_params = self.parameters_to_tuples(path_params, collection_formats)
             for k, v in path_params:
                 # specified safe chars, encode everything
                 resource_path = resource_path.replace(
-                    '{%s}' % k,
-                    quote(str(v), safe=config.safe_chars_for_path_param)
+                    "{%s}" % k,
+                    urllib.parse.quote(str(v), safe=config.safe_chars_for_path_param),
                 )
 
         # query parameters
         if query_params:
             query_params = self.sanitize_for_serialization(query_params)
-            query_params = self.parameters_to_tuples(query_params,
-                                                     collection_formats)
+            query_params = self.parameters_to_tuples(query_params, collection_formats)
 
         # post parameters
         if post_params:
             post_params = post_params if post_params else []
             post_params = self.sanitize_for_serialization(post_params)
-            post_params = self.parameters_to_tuples(post_params,
-                                                    collection_formats)
+            post_params = self.parameters_to_tuples(post_params, collection_formats)
 
         # auth setting
-        await self.update_params_for_auth(
-            header_params, query_params, auth_settings,
-            request_auth=_request_auth, oauth2_client=_oauth2_client)
+        self.update_params_for_auth(
+            header_params,
+            query_params,
+            auth_settings,
+            request_auth=_request_auth,
+            oauth2_client=_oauth2_client,
+        )
 
         # body
         if body:
             body = self.sanitize_for_serialization(body)
 
         # request url
         if _host is None:
             if self.configuration.api_url is not None:
                 url = self.configuration.api_url + resource_path
             else:
-                url = self.configuration.api_scheme + '://' + self.configuration.api_host + resource_path
+                url = (
+                    self.configuration.api_scheme
+                    + "://"
+                    + self.configuration.api_host
+                    + resource_path
+                )
         else:
             # use server/host defined in path or operation instead
-            url = self.configuration.api_scheme + '://' + _host + resource_path
+            url = self.configuration.api_scheme + "://" + _host + resource_path
 
-        max_retry = self.configuration.retry_params.max_retry if (
-            self.configuration.retry_params is not None and self.configuration.retry_params.max_retry is not None) else 0
-        min_wait_in_ms = self.configuration.retry_params.min_wait_in_ms if (
-            self.configuration.retry_params is not None and self.configuration.retry_params.min_wait_in_ms is not None) else 0
+        max_retry = (
+            self.configuration.retry_params.max_retry
+            if (
+                self.configuration.retry_params is not None
+                and self.configuration.retry_params.max_retry is not None
+            )
+            else 0
+        )
+        min_wait_in_ms = (
+            self.configuration.retry_params.min_wait_in_ms
+            if (
+                self.configuration.retry_params is not None
+                and self.configuration.retry_params.min_wait_in_ms is not None
+            )
+            else 0
+        )
         if _retry_params is not None:
             if _retry_params.max_retry is not None:
                 max_retry = _retry_params.max_retry
             if _retry_params.min_wait_in_ms is not None:
                 max_retry = _retry_params.min_wait_in_ms
         for x in range(max_retry + 1):
             try:
                 # perform request and return response
-                response_data = await self.request(
-                    method, url, query_params=query_params, headers=header_params,
-                    post_params=post_params, body=body,
+                response_data = self.request(
+                    method,
+                    url,
+                    query_params=query_params,
+                    headers=header_params,
+                    post_params=post_params,
+                    body=body,
                     _preload_content=_preload_content,
-                    _request_timeout=_request_timeout)
-            except RateLimitExceededError as e:
-                if x < max_retry:
-                    await asyncio.sleep(random_time(x, min_wait_in_ms))
-
+                    _request_timeout=_request_timeout,
+                )
+            except (RateLimitExceededError, ServiceException) as e:
+                if x < max_retry and e.status != 501:
+                    time.sleep(random_time(x, min_wait_in_ms))
                     continue
-                e.body = e.body.decode('utf-8') if six.PY3 else e.body
+                e.body = e.body.decode("utf-8")
                 response_type = response_types_map.get(e.status, None)
                 if response_type is not None:
-                    e.parsed_exception = self.__deserialize(json.loads(e.body), response_type)
+                    e.parsed_exception = self.__deserialize(
+                        json.loads(e.body), response_type
+                    )
                     e.body = None
                 raise e
             except ApiException as e:
-                e.body = e.body.decode('utf-8') if six.PY3 else e.body
+                e.body = e.body.decode("utf-8")
                 response_type = response_types_map.get(e.status, None)
                 if response_type is not None:
-                    e.parsed_exception = self.__deserialize(json.loads(e.body), response_type)
+                    e.parsed_exception = self.__deserialize(
+                        json.loads(e.body), response_type
+                    )
                     e.body = None
                 raise e
 
             self.last_response = response_data
 
             return_data = response_data
 
             if not _preload_content:
                 return return_data
 
             response_type = response_types_map.get(response_data.status, None)
 
-            if six.PY3 and response_type not in ["file", "bytes"]:
+            if response_type not in ["file", "bytes"]:
                 match = None
-                content_type = response_data.getheader('content-type')
+                content_type = response_data.getheader("content-type")
                 if content_type is not None:
                     match = re.search(r"charset=([a-zA-Z\-\d]+)[\s\;]?", content_type)
                 encoding = match.group(1) if match else "utf-8"
                 if response_data.data is not None:
                     response_data.data = response_data.data.decode(encoding)
 
             # deserialize response data
 
             if response_type:
                 return_data = self.deserialize(response_data, response_type)
             else:
                 return_data = None
 
             if _return_http_data_only:
-                return (return_data)
+                return return_data
             else:
-                return (return_data, response_data.status,
-                        response_data.getheaders())
+                return (return_data, response_data.status, response_data.headers)
 
     def sanitize_for_serialization(self, obj):
         """Builds a JSON POST object.
 
         If obj is None, return None.
         If obj is str, int, long, float, bool, return directly.
         If obj is datetime.datetime, datetime.date
@@ -281,36 +324,37 @@
         :return: The serialized form of data.
         """
         if obj is None:
             return None
         elif isinstance(obj, self.PRIMITIVE_TYPES):
             return obj
         elif isinstance(obj, list):
-            return [self.sanitize_for_serialization(sub_obj)
-                    for sub_obj in obj]
+            return [self.sanitize_for_serialization(sub_obj) for sub_obj in obj]
         elif isinstance(obj, tuple):
-            return tuple(self.sanitize_for_serialization(sub_obj)
-                         for sub_obj in obj)
+            return tuple(self.sanitize_for_serialization(sub_obj) for sub_obj in obj)
         elif isinstance(obj, (datetime.datetime, datetime.date)):
             return obj.isoformat()
 
         if isinstance(obj, dict):
             obj_dict = obj
         else:
             # Convert model obj to dict except
             # attributes `openapi_types`, `attribute_map`
             # and attributes which value is not None.
             # Convert attribute name to json key in
             # model definition for request.
-            obj_dict = {obj.attribute_map[attr]: getattr(obj, attr)
-                        for attr, _ in six.iteritems(obj.openapi_types)
-                        if getattr(obj, attr) is not None}
-
-        return {key: self.sanitize_for_serialization(val)
-                for key, val in six.iteritems(obj_dict)}
+            obj_dict = {
+                obj.attribute_map[attr]: getattr(obj, attr)
+                for attr, _ in obj.openapi_types.items()
+                if getattr(obj, attr) is not None
+            }
+
+        return {
+            key: self.sanitize_for_serialization(val) for key, val in obj_dict.items()
+        }
 
     def deserialize(self, response, response_type):
         """Deserializes response into an object.
 
         :param response: RESTResponse object to be deserialized.
         :param response_type: class literal for
             deserialized object, or string of class name.
@@ -334,23 +378,21 @@
 
         :return: object.
         """
         if data is None:
             return None
 
         if type(klass) is str:
-            if klass.startswith('list['):
-                sub_kls = re.match(r'list\[(.*)\]', klass).group(1)
-                return [self.__deserialize(sub_data, sub_kls)
-                        for sub_data in data]
-
-            if klass.startswith('dict['):
-                sub_kls = re.match(r'dict\[([^,]*), (.*)\]', klass).group(2)
-                return {k: self.__deserialize(v, sub_kls)
-                        for k, v in six.iteritems(data)}
+            if klass.startswith("list["):
+                sub_kls = re.match(r"list\[(.*)\]", klass).group(1)
+                return [self.__deserialize(sub_data, sub_kls) for sub_data in data]
+
+            if klass.startswith("dict["):
+                sub_kls = re.match(r"dict\[([^,]*), (.*)\]", klass).group(2)
+                return {k: self.__deserialize(v, sub_kls) for k, v in data.items()}
 
             # convert str to class
             if klass in self.NATIVE_TYPES_MAPPING:
                 klass = self.NATIVE_TYPES_MAPPING[klass]
             else:
                 klass = getattr(openfga_sdk.models, klass)
 
@@ -361,22 +403,36 @@
         elif klass == datetime.date:
             return self.__deserialize_date(data)
         elif klass == datetime.datetime:
             return self.__deserialize_datetime(data)
         else:
             return self.__deserialize_model(data, klass)
 
-    async def call_api(self, resource_path, method,
-                       path_params=None, query_params=None, header_params=None,
-                       body=None, post_params=None, files=None,
-                       response_types_map=None, auth_settings=None,
-                       async_req=None, _return_http_data_only=None,
-                       collection_formats=None, _preload_content=True,
-                       _request_timeout=None, _host=None, _request_auth=None,
-                       _retry_params=None, _oauth2_client=None):
+    def call_api(
+        self,
+        resource_path,
+        method,
+        path_params=None,
+        query_params=None,
+        header_params=None,
+        body=None,
+        post_params=None,
+        files=None,
+        response_types_map=None,
+        auth_settings=None,
+        async_req=None,
+        _return_http_data_only=None,
+        collection_formats=None,
+        _preload_content=True,
+        _request_timeout=None,
+        _host=None,
+        _request_auth=None,
+        _retry_params=None,
+        _oauth2_client=None,
+    ):
         """Makes the HTTP request (synchronous) and returns deserialized data.
 
         To make an async_req request, set the async_req parameter.
 
         :param resource_path: Path to method endpoint.
         :param method: Method to call.
         :param path_params: Path parameters in the url.
@@ -410,90 +466,132 @@
             If async_req parameter is True,
             the request will be called asynchronously.
             The method will return the request thread.
             If parameter async_req is False or missing,
             then the method will return the response directly.
         """
         if not async_req:
-            return await (self.__call_api(resource_path, method,
-                                          path_params, query_params, header_params,
-                                          body, post_params,
-                                          response_types_map, auth_settings,
-                                          _return_http_data_only, collection_formats,
-                                          _preload_content, _request_timeout, _host,
-                                          _request_auth, _retry_params, _oauth2_client))
-
-        return self.pool.apply_async(self.__call_api, (resource_path,
-                                                       method, path_params,
-                                                       query_params,
-                                                       header_params, body,
-                                                       post_params,
-                                                       response_types_map,
-                                                       auth_settings,
-                                                       _return_http_data_only,
-                                                       collection_formats,
-                                                       _preload_content,
-                                                       _request_timeout,
-                                                       _host, _request_auth,
-                                                       _retry_params,
-                                                       _oauth2_client))
-
-    async def request(self, method, url, query_params=None, headers=None,
-                      post_params=None, body=None, _preload_content=True,
-                      _request_timeout=None):
+            return self.__call_api(
+                resource_path,
+                method,
+                path_params,
+                query_params,
+                header_params,
+                body,
+                post_params,
+                response_types_map,
+                auth_settings,
+                _return_http_data_only,
+                collection_formats,
+                _preload_content,
+                _request_timeout,
+                _host,
+                _request_auth,
+                _retry_params,
+                _oauth2_client,
+            )
+
+        return self.pool.apply_async(
+            self.__call_api,
+            (
+                resource_path,
+                method,
+                path_params,
+                query_params,
+                header_params,
+                body,
+                post_params,
+                response_types_map,
+                auth_settings,
+                _return_http_data_only,
+                collection_formats,
+                _preload_content,
+                _request_timeout,
+                _host,
+                _request_auth,
+                _retry_params,
+                _oauth2_client,
+            ),
+        )
+
+    def request(
+        self,
+        method,
+        url,
+        query_params=None,
+        headers=None,
+        post_params=None,
+        body=None,
+        _preload_content=True,
+        _request_timeout=None,
+    ):
         """Makes the HTTP request using RESTClient."""
         if method == "GET":
-            return await (self.rest_client.GET(url,
-                                               query_params=query_params,
-                                               _preload_content=_preload_content,
-                                               _request_timeout=_request_timeout,
-                                               headers=headers))
+            return self.rest_client.GET(
+                url,
+                query_params=query_params,
+                _preload_content=_preload_content,
+                _request_timeout=_request_timeout,
+                headers=headers,
+            )
         elif method == "HEAD":
-            return await (self.rest_client.HEAD(url,
-                                                query_params=query_params,
-                                                _preload_content=_preload_content,
-                                                _request_timeout=_request_timeout,
-                                                headers=headers))
+            return self.rest_client.HEAD(
+                url,
+                query_params=query_params,
+                _preload_content=_preload_content,
+                _request_timeout=_request_timeout,
+                headers=headers,
+            )
         elif method == "OPTIONS":
-            return await (self.rest_client.OPTIONS(url,
-                                                   query_params=query_params,
-                                                   headers=headers,
-                                                   _preload_content=_preload_content,
-                                                   _request_timeout=_request_timeout))
+            return self.rest_client.OPTIONS(
+                url,
+                query_params=query_params,
+                headers=headers,
+                _preload_content=_preload_content,
+                _request_timeout=_request_timeout,
+            )
         elif method == "POST":
-            return await (self.rest_client.POST(url,
-                                                query_params=query_params,
-                                                headers=headers,
-                                                post_params=post_params,
-                                                _preload_content=_preload_content,
-                                                _request_timeout=_request_timeout,
-                                                body=body))
+            return self.rest_client.POST(
+                url,
+                query_params=query_params,
+                headers=headers,
+                post_params=post_params,
+                _preload_content=_preload_content,
+                _request_timeout=_request_timeout,
+                body=body,
+            )
         elif method == "PUT":
-            return await (self.rest_client.PUT(url,
-                                               query_params=query_params,
-                                               headers=headers,
-                                               post_params=post_params,
-                                               _preload_content=_preload_content,
-                                               _request_timeout=_request_timeout,
-                                               body=body))
+            return self.rest_client.PUT(
+                url,
+                query_params=query_params,
+                headers=headers,
+                post_params=post_params,
+                _preload_content=_preload_content,
+                _request_timeout=_request_timeout,
+                body=body,
+            )
         elif method == "PATCH":
-            return await (self.rest_client.PATCH(url,
-                                                 query_params=query_params,
-                                                 headers=headers,
-                                                 post_params=post_params,
-                                                 _preload_content=_preload_content,
-                                                 _request_timeout=_request_timeout,
-                                                 body=body))
+            return self.rest_client.PATCH(
+                url,
+                query_params=query_params,
+                headers=headers,
+                post_params=post_params,
+                _preload_content=_preload_content,
+                _request_timeout=_request_timeout,
+                body=body,
+            )
         elif method == "DELETE":
-            return await (self.rest_client.DELETE(url,
-                                                  query_params=query_params,
-                                                  headers=headers,
-                                                  _preload_content=_preload_content,
-                                                  _request_timeout=_request_timeout,
-                                                  body=body))
+            return self.rest_client.DELETE(
+                url,
+                query_params=query_params,
+                headers=headers,
+                _preload_content=_preload_content,
+                _request_timeout=_request_timeout,
+                body=body,
+            )
         else:
             raise ApiValueError(
                 "http method must be `GET`, `HEAD`, `OPTIONS`,"
                 " `POST`, `PATCH`, `PUT` or `DELETE`."
             )
 
     def parameters_to_tuples(self, params, collection_formats):
@@ -502,30 +600,29 @@
         :param params: Parameters as dict or list of two-tuples
         :param dict collection_formats: Parameter collection formats
         :return: Parameters as list of tuples, collections formatted
         """
         new_params = []
         if collection_formats is None:
             collection_formats = {}
-        for k, v in six.iteritems(params) if isinstance(params, dict) else params:  # noqa: E501
+        for k, v in params.items() if isinstance(params, dict) else params:
             if k in collection_formats:
                 collection_format = collection_formats[k]
-                if collection_format == 'multi':
+                if collection_format == "multi":
                     new_params.extend((k, value) for value in v)
                 else:
-                    if collection_format == 'ssv':
-                        delimiter = ' '
-                    elif collection_format == 'tsv':
-                        delimiter = '\t'
-                    elif collection_format == 'pipes':
-                        delimiter = '|'
+                    if collection_format == "ssv":
+                        delimiter = " "
+                    elif collection_format == "tsv":
+                        delimiter = "\t"
+                    elif collection_format == "pipes":
+                        delimiter = "|"
                     else:  # csv is the default
-                        delimiter = ','
-                    new_params.append(
-                        (k, delimiter.join(str(value) for value in v)))
+                        delimiter = ","
+                    new_params.append((k, delimiter.join(str(value) for value in v)))
             else:
                 new_params.append((k, v))
         return new_params
 
     def select_header_accept(self, accepts):
         """Returns `Accept` based on an array of accepts provided.
 
@@ -533,63 +630,70 @@
         :return: Accept (e.g. application/json).
         """
         if not accepts:
             return
 
         accepts = [x.lower() for x in accepts]
 
-        if 'application/json' in accepts:
-            return 'application/json'
+        if "application/json" in accepts:
+            return "application/json"
         else:
-            return ', '.join(accepts)
+            return ", ".join(accepts)
 
     def select_header_content_type(self, content_types, method=None, body=None):
         """Returns `Content-Type` based on an array of content_types provided.
 
         :param content_types: List of content-types.
         :param method: http method (e.g. POST, PATCH).
         :param body: http body to send.
         :return: Content-Type (e.g. application/json).
         """
         if not content_types:
             return None
 
         content_types = [x.lower() for x in content_types]
 
-        if (method == 'PATCH' and
-                'application/json-patch+json' in content_types and
-                isinstance(body, list)):
-            return 'application/json-patch+json'
+        if (
+            method == "PATCH"
+            and "application/json-patch+json" in content_types
+            and isinstance(body, list)
+        ):
+            return "application/json-patch+json"
 
-        if 'application/json' in content_types or '*/*' in content_types:
-            return 'application/json'
+        if "application/json" in content_types or "*/*" in content_types:
+            return "application/json"
         else:
             return content_types[0]
 
-    async def update_params_for_auth(self, headers, queries, auth_settings,
-                                     request_auth=None, oauth2_client=None):
+    def update_params_for_auth(
+        self, headers, queries, auth_settings, request_auth=None, oauth2_client=None
+    ):
         """Updates header and query params based on authentication setting.
 
         :param headers: Header parameters dict to be updated.
         :param queries: Query parameters tuple list to be updated.
         :param auth_settings: Authentication setting identifiers list.
         :param request_auth: if set, the provided settings will
                              override the token in the configuration.
         :param oauth2_client: if set, will be used for credential exchange.
         """
         credentials = self.configuration.credentials
         if credentials is not None:
-            if credentials.method == 'none':
+            if credentials.method == "none":
                 pass
-            if credentials.method == 'api_token':
-                headers['Authorization'] = 'Bearer {}'.format(credentials.configuration.api_token)
-            if credentials.method == 'client_credentials':
+            if credentials.method == "api_token":
+                headers["Authorization"] = (
+                    f"Bearer {credentials.configuration.api_token}"
+                )
+            if credentials.method == "client_credentials":
                 if oauth2_client is None:
                     oauth2_client = oauth2.OAuth2Client(credentials)
-                oauth2_headers = await oauth2_client.get_authentication_header(self.rest_client)
+                oauth2_headers = oauth2_client.get_authentication_header(
+                    self.rest_client
+                )
                 for key, value in oauth2_headers.items():
                     headers[key] = value
 
         if not auth_settings:
             return
 
         if request_auth:
@@ -604,37 +708,35 @@
     def _apply_auth_params(self, headers, queries, auth_setting):
         """Updates the request parameters based on a single auth_setting
 
         :param headers: Header parameters dict to be updated.
         :param queries: Query parameters tuple list to be updated.
         :param auth_setting: auth settings for the endpoint
         """
-        if auth_setting['in'] == 'cookie':
-            headers['Cookie'] = auth_setting['value']
-        elif auth_setting['in'] == 'header':
-            headers[auth_setting['key']] = auth_setting['value']
-        elif auth_setting['in'] == 'query':
-            queries.append((auth_setting['key'], auth_setting['value']))
+        if auth_setting["in"] == "cookie":
+            headers["Cookie"] = auth_setting["value"]
+        elif auth_setting["in"] == "header":
+            headers[auth_setting["key"]] = auth_setting["value"]
+        elif auth_setting["in"] == "query":
+            queries.append((auth_setting["key"], auth_setting["value"]))
         else:
-            raise ApiValueError(
-                'Authentication token must be in `query` or `header`'
-            )
+            raise ApiValueError("Authentication token must be in `query` or `header`")
 
     def __deserialize_primitive(self, data, klass):
         """Deserializes string to primitive type.
 
         :param data: str.
         :param klass: class literal.
 
         :return: int, long, float, str, bool.
         """
         try:
             return klass(data)
         except UnicodeEncodeError:
-            return six.text_type(data)
+            return str(data)
         except TypeError:
             return data
 
     def __deserialize_object(self, value):
         """Return an original value.
 
         :return: object.
@@ -649,16 +751,15 @@
         """
         try:
             return parse(string).date()
         except ImportError:
             return string
         except ValueError:
             raise rest.ApiException(
-                status=0,
-                reason="Failed to parse `{0}` as date object".format(string)
+                status=0, reason=f"Failed to parse `{string}` as date object"
             )
 
     def __deserialize_datetime(self, string):
         """Deserializes string to datetime.
 
         The string should be in iso8601 datetime format.
 
@@ -668,39 +769,41 @@
         try:
             return parse(string)
         except ImportError:
             return string
         except ValueError:
             raise rest.ApiException(
                 status=0,
-                reason=(
-                    "Failed to parse `{0}` as datetime object"
-                    .format(string)
-                )
+                reason=(f"Failed to parse `{string}` as datetime object"),
             )
 
     def __deserialize_model(self, data, klass):
         """Deserializes list or dict to model.
 
         :param data: dict, list.
         :param klass: class literal.
         :return: model object.
         """
         has_discriminator = False
-        if (hasattr(klass, 'get_real_child_model') and klass.discriminator_value_class_map):
+        if (
+            hasattr(klass, "get_real_child_model")
+            and klass.discriminator_value_class_map
+        ):
             has_discriminator = True
 
         if not klass.openapi_types and has_discriminator is False:
             return data
 
         kwargs = {}
-        if (data is not None and
-                klass.openapi_types is not None and
-                isinstance(data, (list, dict))):
-            for attr, attr_type in six.iteritems(klass.openapi_types):
+        if (
+            data is not None
+            and klass.openapi_types is not None
+            and isinstance(data, (list, dict))
+        ):
+            for attr, attr_type in klass.openapi_types.items():
                 if klass.attribute_map[attr] in data:
                     value = data[klass.attribute_map[attr]]
                     kwargs[attr] = self.__deserialize(value, attr_type)
 
         kwargs["local_vars_configuration"] = self.configuration
         instance = klass(**kwargs)
 
@@ -713,18 +816,16 @@
     def _get_store_id(self):
         """
         Verify that the store id has been configured and not empty string.
         It will return the store ID.
         Otherwise, raise FgaValidationException
         """
         configuration = self.configuration
-        if configuration.store_id is None or configuration.store_id == '':
-            raise FgaValidationException(
-                'store_id is required but not configured'
-            )
+        if configuration.store_id is None or configuration.store_id == "":
+            raise FgaValidationException("store_id is required but not configured")
         return configuration.store_id
 
     def set_store_id(self, value):
         """
         Update the store ID in the configuration
         """
         self.configuration.store_id = value
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/client/__init__.py` & `openfga-sdk-0.4.2/openfga_sdk/client/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,18 +1,15 @@
-# flake8: noqa
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
-# import openfga client + configurations
 from openfga_sdk.client.client import OpenFgaClient
 from openfga_sdk.client.configuration import ClientConfiguration
 from openfga_sdk.client.models.check_request import ClientCheckRequest
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/client/client.py` & `openfga-sdk-0.4.2/openfga_sdk/client/client.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,65 +1,75 @@
-# coding: utf-8
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 import asyncio
 import uuid
-from typing import List
 
-from openfga_sdk.api_client import ApiClient
 from openfga_sdk.api.open_fga_api import OpenFgaApi
+from openfga_sdk.api_client import ApiClient
 from openfga_sdk.client.configuration import ClientConfiguration
 from openfga_sdk.client.models.assertion import ClientAssertion
-from openfga_sdk.client.models.check_request import ClientCheckRequest, construct_check_request
 from openfga_sdk.client.models.batch_check_response import BatchCheckResponse
-from openfga_sdk.client.models.tuple import ClientTuple, convert_tuple_keys
-from openfga_sdk.client.models.write_request import ClientWriteRequest
-from openfga_sdk.client.models.write_response import ClientWriteResponse
+from openfga_sdk.client.models.check_request import (
+    ClientCheckRequest,
+    construct_check_request,
+)
 from openfga_sdk.client.models.expand_request import ClientExpandRequest
 from openfga_sdk.client.models.list_objects_request import ClientListObjectsRequest
 from openfga_sdk.client.models.list_relations_request import ClientListRelationsRequest
-from openfga_sdk.client.models.write_single_response import construct_write_single_response
-from openfga_sdk.client.models.write_transaction_opts import WriteTransactionOpts
 from openfga_sdk.client.models.read_changes_request import ClientReadChangesRequest
+from openfga_sdk.client.models.tuple import ClientTuple, convert_tuple_keys
+from openfga_sdk.client.models.write_request import ClientWriteRequest
+from openfga_sdk.client.models.write_response import ClientWriteResponse
+from openfga_sdk.client.models.write_single_response import (
+    construct_write_single_response,
+)
+from openfga_sdk.client.models.write_transaction_opts import WriteTransactionOpts
 from openfga_sdk.exceptions import FgaValidationException
 from openfga_sdk.models.assertion import Assertion
 from openfga_sdk.models.check_request import CheckRequest
 from openfga_sdk.models.contextual_tuple_keys import ContextualTupleKeys
 from openfga_sdk.models.create_store_request import CreateStoreRequest
 from openfga_sdk.models.expand_request import ExpandRequest
 from openfga_sdk.models.expand_request_tuple_key import ExpandRequestTupleKey
 from openfga_sdk.models.list_objects_request import ListObjectsRequest
-from openfga_sdk.models.read_authorization_model_response import ReadAuthorizationModelResponse
+from openfga_sdk.models.read_authorization_model_response import (
+    ReadAuthorizationModelResponse,
+)
 from openfga_sdk.models.read_request import ReadRequest
 from openfga_sdk.models.read_request_tuple_key import ReadRequestTupleKey
 from openfga_sdk.models.tuple_key import TupleKey
 from openfga_sdk.models.write_assertions_request import WriteAssertionsRequest
-from openfga_sdk.models.write_authorization_model_request import WriteAuthorizationModelRequest
+from openfga_sdk.models.write_authorization_model_request import (
+    WriteAuthorizationModelRequest,
+)
 from openfga_sdk.models.write_request import WriteRequest
 from openfga_sdk.validation import is_well_formed_ulid_string
 
 CLIENT_METHOD_HEADER = "X-OpenFGA-Client-Method"
 CLIENT_BULK_REQUEST_ID_HEADER = "X-OpenFGA-Client-Bulk-Request-Id"
 
 
 def _chuck_array(array, max_size):
     """
     Helper function to chuck array into arrays of max_size
     """
-    return [array[i * max_size:(i + 1) * max_size] for i in range((len(array) + max_size - 1) // max_size)]
+    return [
+        array[i * max_size : (i + 1) * max_size]
+        for i in range((len(array) + max_size - 1) // max_size)
+    ]
 
 
 def set_heading_if_not_set(options: dict[str, int | str], name: str, value: str):
     """
     Set heading to the value if it is not set
     """
     if options is None:
@@ -102,15 +112,15 @@
 def _check_allowed(response: BatchCheckResponse):
     """
     Helper function to return whether the response is check is allowed
     """
     return response.allowed
 
 
-class OpenFgaClient():
+class OpenFgaClient:
     """
     OpenFgaClient is the entry point for invoking calls against the OpenFGA API.
     """
 
     def __init__(self, configuration: ClientConfiguration):
         self._client_configuration = configuration
         self._api_client = ApiClient(configuration)
@@ -133,15 +143,17 @@
         authorization_model_id = self._client_configuration.authorization_model_id
         if options is not None and "authorization_model_id" in options:
             authorization_model_id = options["authorization_model_id"]
         if authorization_model_id is None or authorization_model_id == "":
             return None
         if is_well_formed_ulid_string(authorization_model_id) is False:
             raise FgaValidationException(
-                "authorization_model_id ('%s') is not in a valid ulid format" % authorization_model_id)
+                "authorization_model_id ('%s') is not in a valid ulid format"
+                % authorization_model_id
+            )
         return authorization_model_id
 
     def set_store_id(self, value):
         """
         Update the store ID in the configuration
         """
         self._api_client.set_store_id(value)
@@ -192,28 +204,27 @@
         options = set_heading_if_not_set(options, CLIENT_METHOD_HEADER, "ListStores")
         kwargs = options_to_kwargs(options)
         api_response = await self._api.list_stores(
             **kwargs,
         )
         return api_response
 
-    async def create_store(self, body: CreateStoreRequest, options: dict[str, int | str] = None):
+    async def create_store(
+        self, body: CreateStoreRequest, options: dict[str, int | str] = None
+    ):
         """
         Create the stores in the system
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
         :param retryParams.minWaitInMs(options) - Override the minimum wait before a retry is initiated
         """
         options = set_heading_if_not_set(options, CLIENT_METHOD_HEADER, "CreateStore")
         kwargs = options_to_kwargs(options)
-        api_response = await self._api.create_store(
-            body,
-            **kwargs
-        )
+        api_response = await self._api.create_store(body, **kwargs)
         return api_response
 
     async def get_store(self, options: dict[str, int | str] = None):
         """
         Get the store info in the system. Store id is from the configuration.
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
@@ -250,31 +261,37 @@
         """
         Return all the authorization models for a particular store.
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
         :param retryParams.minWaitInMs(options) - Override the minimum wait before a retry is initiated
         """
-        options = set_heading_if_not_set(options, CLIENT_METHOD_HEADER, "ReadAuthorizationModels")
+        options = set_heading_if_not_set(
+            options, CLIENT_METHOD_HEADER, "ReadAuthorizationModels"
+        )
         kwargs = options_to_kwargs(options)
         api_response = await self._api.read_authorization_models(
             **kwargs,
         )
         return api_response
 
-    async def write_authorization_model(self, body: WriteAuthorizationModelRequest, options: dict[str, int | str] = None):
+    async def write_authorization_model(
+        self, body: WriteAuthorizationModelRequest, options: dict[str, int | str] = None
+    ):
         """
         Write authorization model.
         :param body - WriteAuthorizationModelRequest
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
         :param retryParams.minWaitInMs(options) - Override the minimum wait before a retry is initiated
         """
-        options = set_heading_if_not_set(options, CLIENT_METHOD_HEADER, "WriteAuthorizationModel")
+        options = set_heading_if_not_set(
+            options, CLIENT_METHOD_HEADER, "WriteAuthorizationModel"
+        )
         kwargs = options_to_kwargs(options)
         api_response = await self._api.write_authorization_model(
             body,
             **kwargs,
         )
         return api_response
 
@@ -282,42 +299,49 @@
         """
         Read an authorization model.
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
         :param retryParams.minWaitInMs(options) - Override the minimum wait before a retry is initiated
         """
-        options = set_heading_if_not_set(options, CLIENT_METHOD_HEADER, "ReadAuthorizationModel")
+        options = set_heading_if_not_set(
+            options, CLIENT_METHOD_HEADER, "ReadAuthorizationModel"
+        )
         kwargs = options_to_kwargs(options)
         authorization_model_id = self._get_authorization_model_id(options)
         api_response = await self._api.read_authorization_model(
             authorization_model_id,
             **kwargs,
         )
         return api_response
 
-    async def read_latest_authorization_model(self, options: dict[str, int | str] = None):
+    async def read_latest_authorization_model(
+        self, options: dict[str, int | str] = None
+    ):
         """
         Convenient method of reading the latest authorization model
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
         :param retryParams.minWaitInMs(options) - Override the minimum wait before a retry is initiated
         """
         options = set_heading_if_not_set(
-            options, CLIENT_METHOD_HEADER, "ReadLatestAuthoriationModel")
+            options, CLIENT_METHOD_HEADER, "ReadLatestAuthoriationModel"
+        )
         options["page_size"] = 1
         api_response = await self.read_authorization_models(options)
         return ReadAuthorizationModelResponse(api_response.authorization_models[0])
 
     #######################
     # Relationship Tuples
     #######################
 
-    async def read_changes(self, body: ClientReadChangesRequest, options: dict[str, str] = None):
+    async def read_changes(
+        self, body: ClientReadChangesRequest, options: dict[str, str] = None
+    ):
         """
         Read changes for specified type
         :param body - the type we want to look for change
         :param page_size(options) - Number of items returned per request
         :param continuation_token(options) - No continuation_token by default
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
@@ -351,60 +375,79 @@
                 page_size = options.get("page_size")
                 options.pop("page_size")
             if options.get("continuation_token"):
                 continuation_token = options.get("continuation_token")
                 options.pop("continuation_token")
         kwargs = options_to_kwargs(options)
 
-        if body is None or (body.object is None and body.relation is None and body.user is None):
+        if body is None or (
+            body.object is None and body.relation is None and body.user is None
+        ):
             tuple_key = None
         else:
             tuple_key = body
 
         api_response = await self._api.read(
             ReadRequest(
                 tuple_key=tuple_key,
                 page_size=page_size,
                 continuation_token=continuation_token,
             ),
             **kwargs,
         )
         return api_response
 
-    async def _write_single_batch(self, batch: List[ClientTuple], is_write: bool, options: dict[str, str] = None):
+    async def _write_single_batch(
+        self, batch: list[ClientTuple], is_write: bool, options: dict[str, str] = None
+    ):
         try:
             write_batch = None
             delete_batch = None
             if is_write:
                 write_batch = batch
             else:
                 delete_batch = batch
-            await self._write_with_transaction(ClientWriteRequest(writes=write_batch, deletes=delete_batch), options)
+            await self._write_with_transaction(
+                ClientWriteRequest(writes=write_batch, deletes=delete_batch), options
+            )
             return [construct_write_single_response(i, True, None) for i in batch]
         except Exception as err:
             return [construct_write_single_response(i, False, err) for i in batch]
 
-    async def _write_batches(self, tuple_keys: List[ClientTuple], transaction: WriteTransactionOpts, is_write: bool, options: dict[str, str] = None):
+    async def _write_batches(
+        self,
+        tuple_keys: list[ClientTuple],
+        transaction: WriteTransactionOpts,
+        is_write: bool,
+        options: dict[str, str] = None,
+    ):
         """
         Internal function for write/delete batches
         """
         chunks = _chuck_array(tuple_keys, transaction.max_per_chunk)
 
         write_batches = _chuck_array(chunks, transaction.max_parallel_requests)
         batch_write_responses = []
         for write_batch in write_batches:
-            request = [self._write_single_batch(i, is_write, options) for i in write_batch]
+            request = [
+                self._write_single_batch(i, is_write, options) for i in write_batch
+            ]
             response = await asyncio.gather(*request)
             flatten_list = [
-                item for batch_single_response in response for item in batch_single_response]
+                item
+                for batch_single_response in response
+                for item in batch_single_response
+            ]
             batch_write_responses.extend(flatten_list)
 
         return batch_write_responses
 
-    async def _write_with_transaction(self, body: ClientWriteRequest, options: dict[str, str] = None):
+    async def _write_with_transaction(
+        self, body: ClientWriteRequest, options: dict[str, str] = None
+    ):
         """
         Write or deletes tuples
         """
         kwargs = options_to_kwargs(options)
         writes_tuple_keys = None
         deletes_tuple_keys = None
         if body.writes_tuple_keys:
@@ -419,19 +462,22 @@
                 authorization_model_id=self._get_authorization_model_id(options),
             ),
             **kwargs,
         )
         # any error will result in exception being thrown and not reached below code
         writes_response = None
         if body.writes:
-            writes_response = [construct_write_single_response(i, True, None) for i in body.writes]
+            writes_response = [
+                construct_write_single_response(i, True, None) for i in body.writes
+            ]
         deletes_response = None
         if body.deletes:
-            deletes_response = [construct_write_single_response(
-                i, True, None) for i in body.deletes]
+            deletes_response = [
+                construct_write_single_response(i, True, None) for i in body.deletes
+            ]
         return ClientWriteResponse(writes=writes_response, deletes=deletes_response)
 
     async def write(self, body: ClientWriteRequest, options: dict[str, str] = None):
         """
         Write or deletes tuples
         :param body - the write request
         :param header(options) - Custom headers to send alongside the request
@@ -441,41 +487,51 @@
         """
         options = set_heading_if_not_set(options, CLIENT_METHOD_HEADER, "Writes")
         transaction = options_to_transaction_info(options)
         if not transaction.disabled:
             results = await self._write_with_transaction(body, options)
             return results
 
-        options = set_heading_if_not_set(options, CLIENT_BULK_REQUEST_ID_HEADER, str(uuid.uuid4()))
+        options = set_heading_if_not_set(
+            options, CLIENT_BULK_REQUEST_ID_HEADER, str(uuid.uuid4())
+        )
         # TODO: this should be run in parallel
         await self._check_valid_api_connection(options)
 
         # otherwise, it is not a transaction and it is a batch write requests
         writes_response = None
         if body.writes:
-            writes_response = await self._write_batches(body.writes, transaction, True, options)
+            writes_response = await self._write_batches(
+                body.writes, transaction, True, options
+            )
         deletes_response = None
         if body.deletes:
-            deletes_response = await self._write_batches(body.deletes, transaction, False, options)
+            deletes_response = await self._write_batches(
+                body.deletes, transaction, False, options
+            )
         return ClientWriteResponse(writes=writes_response, deletes=deletes_response)
 
-    async def write_tuples(self, body: List[ClientTuple], options: dict[str, str] = None):
+    async def write_tuples(
+        self, body: list[ClientTuple], options: dict[str, str] = None
+    ):
         """
         Convenient method for writing tuples
         :param body - the list of tuples we want to write
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
         :param retryParams.minWaitInMs(options) - Override the minimum wait before a retry is initiated
         """
         options = set_heading_if_not_set(options, CLIENT_METHOD_HEADER, "WriteTuples")
         result = await self.write(ClientWriteRequest(body, None), options)
         return result
 
-    async def delete_tuples(self, body: List[ClientTuple], options: dict[str, str] = None):
+    async def delete_tuples(
+        self, body: list[ClientTuple], options: dict[str, str] = None
+    ):
         """
         Convenient method for deleteing tuples
         :param body - the list of tuples we want to delete
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
         :param retryParams.minWaitInMs(options) - Override the minimum wait before a retry is initiated
@@ -483,15 +539,15 @@
         options = set_heading_if_not_set(options, CLIENT_METHOD_HEADER, "DeleteTuples")
         result = await self.write(ClientWriteRequest(None, body), options)
         return result
 
     #######################
     # Relationship Queries
     #######################
-    async def check(self, body: ClientCheckRequest, options: dict[str, str] = None):  # noqa: E501
+    async def check(self, body: ClientCheckRequest, options: dict[str, str] = None):
         """
         Check whether a user is authorized to access an object
         :param body - ClientCheckRequest defining check request
         :param authorization_model_id(options) - Overrides the authorization model id in the configuration
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
@@ -510,63 +566,78 @@
             context=body.context,
             authorization_model_id=self._get_authorization_model_id(options),
         )
         if body.contextual_tuples:
             req_body.contextual_tuples = ContextualTupleKeys(
                 tuple_keys=convert_tuple_keys(body.contextual_tuples)
             )
-        api_response = await self._api.check(
-            body=req_body,
-            **kwargs
-        )
+        api_response = await self._api.check(body=req_body, **kwargs)
         return api_response
 
-    async def _single_batch_check(self, body: ClientCheckRequest, semaphore: asyncio.Semaphore, options: dict[str, str] = None):  # noqa: E501
+    async def _single_batch_check(
+        self,
+        body: ClientCheckRequest,
+        semaphore: asyncio.Semaphore,
+        options: dict[str, str] = None,
+    ):
         """
         Run a single batch request and return body in a SingleBatchCheckResponse
         :param body - ClientCheckRequest defining check request
         :param authorization_model_id(options) - Overrides the authorization model id in the configuration
         """
         await semaphore.acquire()
         try:
             api_response = await self.check(body, options)
-            return BatchCheckResponse(allowed=api_response.allowed, request=body, response=api_response, error=None)
+            return BatchCheckResponse(
+                allowed=api_response.allowed,
+                request=body,
+                response=api_response,
+                error=None,
+            )
         except Exception as err:
-            return BatchCheckResponse(allowed=False, request=body, response=None, error=err)
+            return BatchCheckResponse(
+                allowed=False, request=body, response=None, error=err
+            )
         finally:
             semaphore.release()
 
-    async def batch_check(self, body: List[ClientCheckRequest], options: dict[str, str] = None):  # noqa: E501
+    async def batch_check(
+        self, body: list[ClientCheckRequest], options: dict[str, str] = None
+    ):
         """
         Run a set of checks
         :param body - list of ClientCheckRequest defining check request
         :param authorization_model_id(options) - Overrides the authorization model id in the configuration
         :param max_parallel_requests(options) - Max number of requests to issue in parallel. Defaults to 10
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
         :param retryParams.minWaitInMs(options) - Override the minimum wait before a retry is initiated
         """
         options = set_heading_if_not_set(options, CLIENT_METHOD_HEADER, "BatchCheck")
-        options = set_heading_if_not_set(options, CLIENT_BULK_REQUEST_ID_HEADER, str(uuid.uuid4()))
+        options = set_heading_if_not_set(
+            options, CLIENT_BULK_REQUEST_ID_HEADER, str(uuid.uuid4())
+        )
 
         # TODO: this should be run in parallel
         await self._check_valid_api_connection(options)
 
         max_parallel_requests = 10
         if options is not None and "max_parallel_requests" in options:
             max_parallel_requests = options["max_parallel_requests"]
 
         sem = asyncio.Semaphore(max_parallel_requests)
-        batch_check_coros = [self._single_batch_check(request, sem, options) for request in body]
+        batch_check_coros = [
+            self._single_batch_check(request, sem, options) for request in body
+        ]
         batch_check_response = await asyncio.gather(*batch_check_coros)
 
         return batch_check_response
 
-    async def expand(self, body: ClientExpandRequest, options: dict[str, str] = None):  # noqa: E501
+    async def expand(self, body: ClientExpandRequest, options: dict[str, str] = None):
         """
         Run expand request
         :param body - list of ClientExpandRequest defining expand request
         :param authorization_model_id(options) - Overrides the authorization model id in the configuration
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
@@ -578,21 +649,20 @@
         req_body = ExpandRequest(
             tuple_key=ExpandRequestTupleKey(
                 relation=body.relation,
                 object=body.object,
             ),
             authorization_model_id=self._get_authorization_model_id(options),
         )
-        api_response = await self._api.expand(
-            body=req_body,
-            **kwargs
-        )
+        api_response = await self._api.expand(body=req_body, **kwargs)
         return api_response
 
-    async def list_objects(self, body: ClientListObjectsRequest, options: dict[str, str] = None):  # noqa: E501
+    async def list_objects(
+        self, body: ClientListObjectsRequest, options: dict[str, str] = None
+    ):
         """
         Run list object request
         :param body - list object parameters
         :param authorization_model_id(options) - Overrides the authorization model id in the configuration
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
@@ -608,79 +678,99 @@
             type=body.type,
             context=body.context,
         )
         if body.contextual_tuples:
             req_body.contextual_tuples = ContextualTupleKeys(
                 tuple_keys=convert_tuple_keys(body.contextual_tuples)
             )
-        api_response = await self._api.list_objects(
-            body=req_body,
-            **kwargs
-        )
+        api_response = await self._api.list_objects(body=req_body, **kwargs)
         return api_response
 
-    async def list_relations(self, body: ClientListRelationsRequest, options: dict[str, str] = None):  # noqa: E501
+    async def list_relations(
+        self, body: ClientListRelationsRequest, options: dict[str, str] = None
+    ):
         """
         Return all the relations for which user has a relationship with the object
         :param body - list relation request
         :param authorization_model_id(options) - Overrides the authorization model id in the configuration
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
         :param retryParams.minWaitInMs(options) - Override the minimum wait before a retry is initiated
         """
         options = set_heading_if_not_set(options, CLIENT_METHOD_HEADER, "ListRelations")
-        options = set_heading_if_not_set(options, CLIENT_BULK_REQUEST_ID_HEADER, str(uuid.uuid4()))
+        options = set_heading_if_not_set(
+            options, CLIENT_BULK_REQUEST_ID_HEADER, str(uuid.uuid4())
+        )
 
-        request_body = [construct_check_request(user=body.user, relation=i, object=body.object,
-                                                contextual_tuples=body.contextual_tuples, context=body.context) for i in body.relations]
+        request_body = [
+            construct_check_request(
+                user=body.user,
+                relation=i,
+                object=body.object,
+                contextual_tuples=body.contextual_tuples,
+                context=body.context,
+            )
+            for i in body.relations
+        ]
         result = await self.batch_check(request_body, options)
         # need to filter with the allowed response
         result_iterator = filter(_check_allowed, result)
         result_list = list(result_iterator)
         return [i.request.relation for i in result_list]
 
     #######################
     # Assertions
     #######################
-
-    async def read_assertions(self, options: dict[str, str] = None):  # noqa: E501
+    async def read_assertions(self, options: dict[str, str] = None):
         """
         Return the assertions
         :param authorization_model_id(options) - Overrides the authorization model id in the configuration
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
         :param retryParams.minWaitInMs(options) - Override the minimum wait before a retry is initiated
         """
-        options = set_heading_if_not_set(options, CLIENT_METHOD_HEADER, "ReadAssertions")
+        options = set_heading_if_not_set(
+            options, CLIENT_METHOD_HEADER, "ReadAssertions"
+        )
 
         kwargs = options_to_kwargs(options)
         authorization_model_id = self._get_authorization_model_id(options)
         api_response = await self._api.read_assertions(authorization_model_id, **kwargs)
         return api_response
 
-    async def write_assertions(self, body: List[ClientAssertion], options: dict[str, str] = None):  # noqa: E501
+    async def write_assertions(
+        self, body: list[ClientAssertion], options: dict[str, str] = None
+    ):
         """
         Upsert the assertions
         :param body - Write assertion request
         :param authorization_model_id(options) - Overrides the authorization model id in the configuration
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
         :param retryParams.minWaitInMs(options) - Override the minimum wait before a retry is initiated
         """
-        options = set_heading_if_not_set(options, CLIENT_METHOD_HEADER, "WriteAssertions")
+        options = set_heading_if_not_set(
+            options, CLIENT_METHOD_HEADER, "WriteAssertions"
+        )
         kwargs = options_to_kwargs(options)
         authorization_model_id = self._get_authorization_model_id(options)
 
         def map_to_assertion(client_assertion: ClientAssertion):
-            return Assertion(TupleKey(
-                user=client_assertion.user,
-                relation=client_assertion.relation,
-                object=client_assertion.object,
-            ), client_assertion.expectation)
+            return Assertion(
+                TupleKey(
+                    user=client_assertion.user,
+                    relation=client_assertion.relation,
+                    object=client_assertion.object,
+                ),
+                client_assertion.expectation,
+            )
 
         api_request_body = WriteAssertionsRequest(
-            [map_to_assertion(client_assertion) for client_assertion in body])
-        api_response = await self._api.write_assertions(authorization_model_id, api_request_body, **kwargs)
+            [map_to_assertion(client_assertion) for client_assertion in body]
+        )
+        api_response = await self._api.write_assertions(
+            authorization_model_id, api_request_body, **kwargs
+        )
         return api_response
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/client/configuration.py` & `openfga-sdk-0.4.2/openfga_sdk/client/configuration.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,15 +1,14 @@
-# coding: utf-8
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 from openfga_sdk.configuration import Configuration
 from openfga_sdk.exceptions import FgaValidationException
@@ -28,24 +27,37 @@
         store_id=None,
         credentials=None,
         retry_params=None,
         authorization_model_id=None,
         ssl_ca_cert=None,
         api_url=None,  # TODO: restructure when removing api_scheme/api_host
     ):
-        super().__init__(api_scheme, api_host, store_id, credentials,
-                         retry_params, ssl_ca_cert=ssl_ca_cert, api_url=api_url)
+        super().__init__(
+            api_scheme,
+            api_host,
+            store_id,
+            credentials,
+            retry_params,
+            ssl_ca_cert=ssl_ca_cert,
+            api_url=api_url,
+        )
         self._authorization_model_id = authorization_model_id
 
     def is_valid(self):
         super().is_valid()
 
-        if self.authorization_model_id is not None and self.authorization_model_id != "" and is_well_formed_ulid_string(self.authorization_model_id) is False:
+        if (
+            self.authorization_model_id is not None
+            and self.authorization_model_id != ""
+            and is_well_formed_ulid_string(self.authorization_model_id) is False
+        ):
             raise FgaValidationException(
-                "authorization_model_id ('%s') is not in a valid ulid format" % self.authorization_model_id)
+                "authorization_model_id ('%s') is not in a valid ulid format"
+                % self.authorization_model_id
+            )
 
     @property
     def authorization_model_id(self):
         return self._authorization_model_id
 
     @authorization_model_id.setter
     def authorization_model_id(self, value):
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/client/models/__init__.py` & `openfga-sdk-0.4.2/openfga_sdk/client/models/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,14 @@
-# flake8: noqa
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 from openfga_sdk.client.models.assertion import ClientAssertion
 from openfga_sdk.client.models.batch_check_response import BatchCheckResponse
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/client/models/assertion.py` & `openfga-sdk-0.4.2/openfga_sdk/client/models/assertion.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,22 +1,21 @@
-# coding: utf-8
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 
-class ClientAssertion():
+class ClientAssertion:
     """
     ClientAssertion flattens the input necessary for an Assertion
     """
 
     def __init__(self, user: str, relation: str, object: str, expectation: bool):
         self._user = user
         self._relation = relation
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/client/models/batch_check_response.py` & `openfga-sdk-0.4.2/openfga_sdk/client/models/batch_check_response.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,30 +1,35 @@
-# coding: utf-8
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 from openfga_sdk.client.models.check_request import ClientCheckRequest
 from openfga_sdk.models.check_response import CheckResponse
 
 
-class BatchCheckResponse():
+class BatchCheckResponse:
     """
     BatchCheckResponse encapsulates the response for a single batch check
     """
 
-    def __init__(self, allowed: bool, request: ClientCheckRequest, response: CheckResponse, error: Exception = None):
+    def __init__(
+        self,
+        allowed: bool,
+        request: ClientCheckRequest,
+        response: CheckResponse,
+        error: Exception = None,
+    ):
         self._allowed = allowed
         self._request = request
         self._response = response
         self._error = error
 
     @property
     def allowed(self):
@@ -54,8 +59,8 @@
         """
         return self._error
 
     def __str__(self):
         """
         Return the class string
         """
-        return "allowed %s request %s error %s" % (self._allowed, self._request, self._error)
+        return f"allowed {self._allowed} request {self._request} error {self._error}"
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/client/models/check_request.py` & `openfga-sdk-0.4.2/openfga_sdk/client/models/check_request.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,38 +1,48 @@
-# coding: utf-8
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 from openfga_sdk.client.models.tuple import ClientTuple
 
-from typing import List
 
-
-def construct_check_request(user: str, relation: str, object: str, contextual_tuples: List[ClientTuple] = None, context: object = None):
+def construct_check_request(
+    user: str,
+    relation: str,
+    object: str,
+    contextual_tuples: list[ClientTuple] = None,
+    context: object = None,
+):
     """
     helper function to construct the check request body
     """
     return ClientCheckRequest(user, relation, object, contextual_tuples, context)
 
 
-class ClientCheckRequest():
+class ClientCheckRequest:
     """
     ClientCheckRequest encapsulates the parameters for check request
     """
 
-    def __init__(self, user: str, relation: str, object: str, contextual_tuples: List[ClientTuple] = None, context: object = None):
+    def __init__(
+        self,
+        user: str,
+        relation: str,
+        object: str,
+        contextual_tuples: list[ClientTuple] = None,
+        context: object = None,
+    ):
         self._user = user
         self._relation = relation
         self._object = object
         self._contextual_tuples = None
         if contextual_tuples:
             self._contextual_tuples = contextual_tuples
         self._context = context
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/client/models/expand_request.py` & `openfga-sdk-0.4.2/openfga_sdk/client/models/expand_request.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,22 +1,21 @@
-# coding: utf-8
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 
-class ClientExpandRequest():
+class ClientExpandRequest:
     """
     ClientExpandRequest encapsulates the parameters required to expand request
     """
 
     def __init__(self, relation: str, object: str):
         self._relation = relation
         self._object = object
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/client/models/list_objects_request.py` & `openfga-sdk-0.4.2/openfga_sdk/client/models/list_objects_request.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,31 +1,35 @@
-# coding: utf-8
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 from openfga_sdk.client.models.tuple import ClientTuple
 
-from typing import List
 
-
-class ClientListObjectsRequest():
+class ClientListObjectsRequest:
     """
     ClientListObjectsRequest encapsulates the parameters required for list objects
     """
 
-    def __init__(self, user: str, relation: str, type: str, contextual_tuples: List[ClientTuple] = None, context: object = None):
+    def __init__(
+        self,
+        user: str,
+        relation: str,
+        type: str,
+        contextual_tuples: list[ClientTuple] = None,
+        context: object = None,
+    ):
         self._user = user
         self._relation = relation
         self._type = type
         self._contextual_tuples = contextual_tuples
         self._context = context
 
     @property
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/client/models/list_relations_request.py` & `openfga-sdk-0.4.2/openfga_sdk/client/models/list_relations_request.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,31 +1,35 @@
-# coding: utf-8
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 from openfga_sdk.client.models.tuple import ClientTuple
 
-from typing import List
 
-
-class ClientListRelationsRequest():
+class ClientListRelationsRequest:
     """
     ClientListRelationsRequest encapsulates the parameters required for list all relations user have with object
     """
 
-    def __init__(self, user: str, relations: List[str], object: str, contextual_tuples: List[ClientTuple] = None, context: object = None):
+    def __init__(
+        self,
+        user: str,
+        relations: list[str],
+        object: str,
+        contextual_tuples: list[ClientTuple] = None,
+        context: object = None,
+    ):
         self._user = user
         self._relations = relations
         self._object = object
         self._contextual_tuples = contextual_tuples
         self._context = context
 
     @property
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/client/models/read_changes_request.py` & `openfga-sdk-0.4.2/openfga_sdk/client/models/read_changes_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,22 +1,21 @@
-# coding: utf-8
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 
-class ClientReadChangesRequest():
+class ClientReadChangesRequest:
     """
     ClientReadChangesRequest encapsulates the parameters required to read changes
     """
 
     def __init__(self, type: str):
         self._type = type
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/client/models/tuple.py` & `openfga-sdk-0.4.2/openfga_sdk/client/models/tuple.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,39 +1,46 @@
-# coding: utf-8
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 from openfga_sdk.models.relationship_condition import RelationshipCondition
 from openfga_sdk.models.tuple_key import TupleKey
 
-from typing import List
 
-
-class ClientTuple():
+class ClientTuple:
     """
     ClientTuple encapsulates the client tuple
     """
 
-    def __init__(self, user: str, relation: str, object: str, condition: RelationshipCondition = None):
+    def __init__(
+        self,
+        user: str,
+        relation: str,
+        object: str,
+        condition: RelationshipCondition = None,
+    ):
         self._user = user
         self._relation = relation
         self._object = object
         self._condition = condition
 
     def __eq__(self, other):
-        return self.user == other.user and self.relation == other.relation and self.object == other.object
+        return (
+            self.user == other.user
+            and self.relation == other.relation
+            and self.object == other.object
+        )
 
     @property
     def user(self):
         """
         Return user
         """
         return self._user
@@ -92,19 +99,19 @@
         """
         Return the tuple as tuple_key
         """
         return TupleKey(
             object=self.object,
             relation=self.relation,
             user=self.user,
-            condition=self.condition
+            condition=self.condition,
         )
 
 
-def convert_tuple_keys(lists: List[ClientTuple]):
+def convert_tuple_keys(lists: list[ClientTuple]):
     """
     Return the items as tuple_keys
     """
     if lists is None:
         return None
     items = map(lambda item: item.tuple_key, lists)
     return list(items)
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/client/models/write_request.py` & `openfga-sdk-0.4.2/openfga_sdk/client/models/write_request.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,33 +1,32 @@
-# coding: utf-8
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 from openfga_sdk.client.models.tuple import ClientTuple, convert_tuple_keys
-from openfga_sdk.models.write_request_writes import WriteRequestWrites
 from openfga_sdk.models.write_request_deletes import WriteRequestDeletes
-
-from typing import List
+from openfga_sdk.models.write_request_writes import WriteRequestWrites
 
 
-class ClientWriteRequest():
+class ClientWriteRequest:
     """
     ClientWriteRequest encapsulates the parameters required to write
     """
 
-    def __init__(self, writes: List[ClientTuple] = None, deletes: List[ClientTuple] = None):
+    def __init__(
+        self, writes: list[ClientTuple] = None, deletes: list[ClientTuple] = None
+    ):
         self._writes = writes
         self._deletes = deletes
 
     @property
     def writes(self):
         """
         Return writes
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/client/models/write_response.py` & `openfga-sdk-0.4.2/openfga_sdk/client/models/write_response.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,31 +1,32 @@
-# coding: utf-8
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 from openfga_sdk.client.models.write_single_response import ClientWriteSingleResponse
 
-from typing import List
 
-
-class ClientWriteResponse():
+class ClientWriteResponse:
     """
     ClientWriteResponse returns the set of responses and their statuses
     """
 
-    def __init__(self, writes: List[ClientWriteSingleResponse], deletes: List[ClientWriteSingleResponse]):
+    def __init__(
+        self,
+        writes: list[ClientWriteSingleResponse],
+        deletes: list[ClientWriteSingleResponse],
+    ):
         self._writes = writes
         self._deletes = deletes
 
     @property
     def writes(self):
         """
         Return the writes response
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/client/models/write_single_response.py` & `openfga-sdk-0.4.2/openfga_sdk/client/models/write_single_response.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,42 +1,47 @@
-# coding: utf-8
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 from openfga_sdk.client.models.tuple import ClientTuple
 
 
-def construct_write_single_response(tuple_key: ClientTuple, success: bool, error: Exception = None):
+def construct_write_single_response(
+    tuple_key: ClientTuple, success: bool, error: Exception = None
+):
     """
     Helper function to return a single write response
     """
     return ClientWriteSingleResponse(tuple_key, success, error)
 
 
-class ClientWriteSingleResponse():
+class ClientWriteSingleResponse:
     """
     ClientWriteSingleResponse encapsulates the response of a single write
     """
 
     def __init__(self, tuple_key: ClientTuple, success: bool, error: Exception = None):
         self._tuple_key = tuple_key
         self._success = success
         self._error = error
 
     def __eq__(self, other):
-        return self.tuple_key == other.tuple_key and self.success == other.success and self.error == other.error
+        return (
+            self.tuple_key == other.tuple_key
+            and self.success == other.success
+            and self.error == other.error
+        )
 
     @property
     def tuple_key(self):
         """
         Return tuple_key
         """
         return self._tuple_key
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/client/models/write_transaction_opts.py` & `openfga-sdk-0.4.2/openfga_sdk/client/models/write_transaction_opts.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,27 +1,31 @@
-# coding: utf-8
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 
 class WriteTransactionOpts:
     """
     OpenFGA client write transaction info
     """
 
-    def __init__(self, disabled: bool = False, max_per_chunk: int = 1, max_parallel_requests: int = 10):
+    def __init__(
+        self,
+        disabled: bool = False,
+        max_per_chunk: int = 1,
+        max_parallel_requests: int = 10,
+    ):
         self._disabled = disabled
         self._max_per_chunk = max_per_chunk
         self._max_parallel_requests = max_parallel_requests
 
     @property
     def disabled(self):
         """
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/configuration.py` & `openfga-sdk-0.4.2/openfga_sdk/configuration.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,42 +1,45 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 import copy
+import http
 import logging
 import sys
-from urllib.parse import urlparse
+import urllib
 
 import urllib3
-import six
-from six.moves import http_client as httplib
 
-from openfga_sdk.exceptions import FgaValidationException, ApiValueError
+from openfga_sdk.exceptions import ApiValueError, FgaValidationException
 from openfga_sdk.validation import is_well_formed_ulid_string
 
-
 JSON_SCHEMA_VALIDATION_KEYWORDS = {
-    'multipleOf', 'maximum', 'exclusiveMaximum',
-    'minimum', 'exclusiveMinimum', 'maxLength',
-    'minLength', 'pattern', 'maxItems', 'minItems'
+    "multipleOf",
+    "maximum",
+    "exclusiveMaximum",
+    "minimum",
+    "exclusiveMinimum",
+    "maxLength",
+    "minLength",
+    "pattern",
+    "maxItems",
+    "minItems",
 }
 
 
-class RetryParams(object):
+class RetryParams:
     """NOTE: This class is auto generated by OpenAPI Generator
 
     Ref: https://openapi-generator.tech
     Do not edit the class manually.
 
     Retry configuration in case of HTTP too many request
 
@@ -49,39 +52,59 @@
         self._min_wait_in_ms = min_wait_in_ms
 
     @property
     def max_retry(self):
         """
         Return the maximum number of retry
         """
+        if self._max_retry > 15:
+            raise FgaValidationException(
+                "RetryParams.max_retry exceeds maximum allowed limit of 15"
+            )
+
         return self._max_retry
 
     @max_retry.setter
     def max_retry(self, value):
         """
         Update the maximum number of retry
         """
+        if not isinstance(value, int) or value < 0:
+            raise FgaValidationException(
+                "RetryParams.max_retry must be an integer greater than or equal to 0"
+            )
+
+        if value > 15:
+            raise FgaValidationException(
+                "RetryParams.max_retry exceeds maximum allowed limit of 15"
+            )
+
         self._max_retry = value
 
     @property
     def min_wait_in_ms(self):
         """
         Return the minimum wait (in ms) in between retry
         """
         return self._min_wait_in_ms
 
     @min_wait_in_ms.setter
     def min_wait_in_ms(self, value):
         """
         Update the minimum wait (in ms) in between retry
         """
+        if not isinstance(value, int) or value < 0:
+            raise FgaValidationException(
+                "RetryParams.min_wait_in_ms must be an integer greater than or equal to 0"
+            )
+
         self._min_wait_in_ms = value
 
 
-class Configuration(object):
+class Configuration:
     """NOTE: This class is auto generated by OpenAPI Generator
 
     Ref: https://openapi-generator.tech
     Do not edit the class manually.
 
     :param api_scheme: Whether connection is 'https' or 'http'. Default as 'https'
         .. deprecated:: 0.4.1
@@ -137,29 +160,35 @@
     :param ssl_ca_cert: str - the path to a file of concatenated CA certificates
       in PEM format
     :param api_url: str - the URL of the FGA server
     """
 
     _default = None
 
-    def __init__(self, api_scheme="https", api_host=None,
-                 store_id=None,
-                 credentials=None,
-                 retry_params=None,
-                 api_key=None, api_key_prefix=None,
-                 username=None, password=None,
-                 discard_unknown_keys=False,
-                 disabled_client_side_validations="",
-                 server_index=None, server_variables=None,
-                 server_operation_index=None, server_operation_variables=None,
-                 ssl_ca_cert=None,
-                 api_url=None,  # TODO: restructure when removing api_scheme/api_host
-                 ):
-        """Constructor
-        """
+    def __init__(
+        self,
+        api_scheme="https",
+        api_host=None,
+        store_id=None,
+        credentials=None,
+        retry_params=None,
+        api_key=None,
+        api_key_prefix=None,
+        username=None,
+        password=None,
+        discard_unknown_keys=False,
+        disabled_client_side_validations="",
+        server_index=None,
+        server_variables=None,
+        server_operation_index=None,
+        server_operation_variables=None,
+        ssl_ca_cert=None,
+        api_url=None,  # TODO: restructure when removing api_scheme/api_host
+    ):
+        """Constructor"""
         self._url = api_url
         self._scheme = api_scheme
         self._base_path = api_host
         self._store_id = store_id
         self._credentials = credentials
         if retry_params is not None:
             self._retry_params = retry_params
@@ -202,15 +231,15 @@
         self.discard_unknown_keys = discard_unknown_keys
         self.disabled_client_side_validations = disabled_client_side_validations
         self.logger = {}
         """Logging Settings
         """
         self.logger["package_logger"] = logging.getLogger("openfga_sdk")
         self.logger["urllib3_logger"] = logging.getLogger("urllib3")
-        self.logger_format = '%(asctime)s %(levelname)s %(message)s'
+        self.logger_format = "%(asctime)s %(levelname)s %(message)s"
         """Log format
         """
         self.logger_stream_handler = None
         """Log stream handler
         """
         self.logger_file_handler = None
         """Log file handler
@@ -247,15 +276,15 @@
 
         self.proxy = None
         """Proxy URL
         """
         self.proxy_headers = None
         """Proxy headers
         """
-        self.safe_chars_for_path_param = ''
+        self.safe_chars_for_path_param = ""
         """Safe chars for path_param
         """
         self.retries = None
         """Adding retries to override urllib3 default value 3
         """
         # Enable client side validation
         self.client_side_validation = True
@@ -265,33 +294,23 @@
         """
 
     def __deepcopy__(self, memo):
         cls = self.__class__
         result = cls.__new__(cls)
         memo[id(self)] = result
         for k, v in self.__dict__.items():
-            if k not in ('logger', 'logger_file_handler'):
+            if k not in ("logger", "logger_file_handler"):
                 setattr(result, k, copy.deepcopy(v, memo))
         # shallow copy of loggers
         result.logger = copy.copy(self.logger)
         # use setters to configure loggers
         result.logger_file = self.logger_file
         result.debug = self.debug
         return result
 
-    def __setattr__(self, name, value):
-        object.__setattr__(self, name, value)
-        if name == 'disabled_client_side_validations':
-            s = set(filter(None, value.split(',')))
-            for v in s:
-                if v not in JSON_SCHEMA_VALIDATION_KEYWORDS:
-                    raise ApiValueError(
-                        "Invalid keyword: '{0}''".format(v))
-            self._disabled_client_side_validations = s
-
     @classmethod
     def set_default(cls, default):
         """Set default instance of configuration.
 
         It stores default configuration, which can be
         returned by get_default_copy method.
 
@@ -337,15 +356,15 @@
         """
         self.__logger_file = value
         if self.__logger_file:
             # If set logging file,
             # then add file handler and remove stream handler.
             self.logger_file_handler = logging.FileHandler(self.__logger_file)
             self.logger_file_handler.setFormatter(self.logger_formatter)
-            for _, logger in six.iteritems(self.logger):
+            for _, logger in self.logger.items():
                 logger.addHandler(self.logger_file_handler)
 
     @property
     def debug(self):
         """Debug status
 
         :param value: The debug status, True or False.
@@ -359,25 +378,25 @@
 
         :param value: The debug status, True or False.
         :type: bool
         """
         self.__debug = value
         if self.__debug:
             # if debug status is True, turn on debug logging
-            for _, logger in six.iteritems(self.logger):
+            for _, logger in self.logger.items():
                 logger.setLevel(logging.DEBUG)
             # turn on httplib debug
-            httplib.HTTPConnection.debuglevel = 1
+            http.client.HTTPConnection.set_debuglevel(http.client.HTTPConnection, 1)
         else:
             # if debug status is False, turn off debug logging,
             # setting log level to default `logging.WARNING`
-            for _, logger in six.iteritems(self.logger):
+            for _, logger in self.logger.items():
                 logger.setLevel(logging.WARNING)
             # turn off httplib debug
-            httplib.HTTPConnection.debuglevel = 0
+            http.client.HTTPConnection.set_debuglevel(http.client.HTTPConnection, 0)
 
     @property
     def logger_format(self):
         """The logger format.
 
         The logger_formatter will be updated when sets logger_format.
 
@@ -403,66 +422,69 @@
 
         :param identifier: The identifier of apiKey.
         :param alias: The alternative identifier of apiKey.
         :return: The token for api key authentication.
         """
         if self.refresh_api_key_hook is not None:
             self.refresh_api_key_hook(self)
-        key = self.api_key.get(identifier, self.api_key.get(alias) if alias is not None else None)
+        key = self.api_key.get(
+            identifier, self.api_key.get(alias) if alias is not None else None
+        )
         if key:
             prefix = self.api_key_prefix.get(identifier)
             if prefix:
-                return "%s %s" % (prefix, key)
+                return f"{prefix} {key}"
             else:
                 return key
 
     def get_basic_auth_token(self):
         """Gets HTTP basic authentication header (string).
 
         :return: The token for basic HTTP authentication.
         """
         username = ""
         if self.username is not None:
             username = self.username
         password = ""
         if self.password is not None:
             password = self.password
-        return urllib3.util.make_headers(
-            basic_auth=username + ':' + password
-        ).get('authorization')
+        return urllib3.util.make_headers(basic_auth=username + ":" + password).get(
+            "authorization"
+        )
 
     def auth_settings(self):
         """Gets Auth Settings dict for api client.
 
         :return: The Auth Settings information dict.
         """
         auth = {}
         return auth
 
     def to_debug_report(self):
         """Gets the essential information for debugging.
 
         :return: The report for debugging.
         """
-        return "Python SDK Debug Report:\n"\
-               "OS: {env}\n"\
-               "Python Version: {pyversion}\n"\
-               "Version of the API: 0.1\n"\
-               "SDK Package Version: 0.4.1".\
-               format(env=sys.platform, pyversion=sys.version)
+        return (
+            "Python SDK Debug Report:\n"
+            "OS: {env}\n"
+            "Python Version: {pyversion}\n"
+            "Version of the API: 0.1\n"
+            "SDK Package Version: 0.4.2".format(env=sys.platform, pyversion=sys.version)
+        )
 
     def get_host_settings(self):
         """Gets an array of host settings
 
         :return: An array of host settings
         """
         return [
             {
-                'url': "",
-                'description': "No description provided",
+                "url": "",
+                "description": "No description provided",
             }
         ]
 
     def get_host_from_settings(self, index, variables=None, servers=None):
         """Gets host URL based on the index and variables
         :param index: array index of the host settings
         :param variables: hash of variable and the corresponding value
@@ -475,86 +497,103 @@
         variables = {} if variables is None else variables
         servers = self.get_host_settings() if servers is None else servers
 
         try:
             server = servers[index]
         except IndexError:
             raise ValueError(
-                "Invalid index {0} when selecting the host settings. "
-                "Must be less than {1}".format(index, len(servers)))
+                "Invalid index {} when selecting the host settings. "
+                "Must be less than {}".format(index, len(servers))
+            )
 
-        url = server['url']
+        url = server["url"]
 
         # go through variables and replace placeholders
-        for variable_name, variable in server.get('variables', {}).items():
-            used_value = variables.get(
-                variable_name, variable['default_value'])
+        for variable_name, variable in server.get("variables", {}).items():
+            used_value = variables.get(variable_name, variable["default_value"])
 
-            if 'enum_values' in variable \
-                    and used_value not in variable['enum_values']:
+            if "enum_values" in variable and used_value not in variable["enum_values"]:
                 raise ValueError(
-                    "The variable `{0}` in the host URL has invalid value "
-                    "{1}. Must be {2}.".format(
-                        variable_name, variables[variable_name],
-                        variable['enum_values']))
+                    "The variable `{}` in the host URL has invalid value "
+                    "{}. Must be {}.".format(
+                        variable_name, variables[variable_name], variable["enum_values"]
+                    )
+                )
 
             url = url.replace("{" + variable_name + "}", used_value)
 
         return url
 
     def is_valid(self):
         """
         Verify the configuration is valid.
         Note that we are only doing basic validation to ensure input is sane.
         """
         combined_url = self.api_url
         if self.api_url is None:
-            if self.api_host is None or self.api_host == '':
-                raise FgaValidationException('api_host is required but not configured.')
-            if self.api_scheme is None or self.api_scheme == '':
-                raise FgaValidationException('api_scheme is required but not configured.')
-            combined_url = self.api_scheme + '://' + self.api_host
+            if self.api_host is None or self.api_host == "":
+                raise FgaValidationException("api_host is required but not configured.")
+            if self.api_scheme is None or self.api_scheme == "":
+                raise FgaValidationException(
+                    "api_scheme is required but not configured."
+                )
+            combined_url = self.api_scheme + "://" + self.api_host
         parsed_url = None
         try:
-            parsed_url = urlparse(combined_url)
+            parsed_url = urllib.parse.urlparse(combined_url)
         except ValueError:
             if self.api_url is None:
-                raise ApiValueError('Either api_scheme `{}` or api_host `{}` is invalid'.format(
-                    self.api_scheme, self.api_host))
+                raise ApiValueError(
+                    "Either api_scheme `{}` or api_host `{}` is invalid".format(
+                        self.api_scheme, self.api_host
+                    )
+                )
             else:
-                raise ApiValueError('api_url `{}` is invalid'.format(
-                    self.api_url))
+                raise ApiValueError(f"api_url `{self.api_url}` is invalid")
         if self.api_url is None:
-            if (parsed_url.scheme != 'http' and parsed_url.scheme != 'https'):
+            if parsed_url.scheme != "http" and parsed_url.scheme != "https":
                 raise ApiValueError(
-                    'api_scheme `{}` must be either `http` or `https`'.format(self.api_scheme))
-            if (parsed_url.netloc == ''):
-                raise ApiValueError('api_host `{}` is invalid'.format(self.api_host))
-            if (parsed_url.path != ''):
+                    f"api_scheme `{self.api_scheme}` must be either `http` or `https`"
+                )
+            if parsed_url.netloc == "":
+                raise ApiValueError(f"api_host `{self.api_host}` is invalid")
+            if parsed_url.path != "":
                 raise ApiValueError(
-                    'api_host `{}` is not expected to have path specified'.format(self.api_scheme))
-            if (parsed_url.query != ''):
+                    f"api_host `{self.api_scheme}` is not expected to have path specified"
+                )
+            if parsed_url.query != "":
                 raise ApiValueError(
-                    'api_host `{}` is not expected to have query specified'.format(self.api_scheme))
+                    f"api_host `{self.api_scheme}` is not expected to have query specified"
+                )
 
-        if self.store_id is not None and self.store_id != "" and is_well_formed_ulid_string(self.store_id) is False:
+        if (
+            self.store_id is not None
+            and self.store_id != ""
+            and is_well_formed_ulid_string(self.store_id) is False
+        ):
             raise FgaValidationException(
-                "store_id ('%s') is not in a valid ulid format" % self.store_id)
+                "store_id ('%s') is not in a valid ulid format" % self.store_id
+            )
 
         if self._credentials is not None:
             self._credentials.validate_credentials_config()
 
     @property
     def api_scheme(self):
         """Return connection is https or http."""
         return self._scheme
 
     @api_scheme.setter
     def api_scheme(self, value):
         """Update connection scheme (https or http)."""
+        if value is not None and value not in ["https", "http"]:
+            raise FgaValidationException(
+                f"api_scheme `{value}` must be either `http` or `https`"
+            )
+
         self._scheme = value
 
     @property
     def api_host(self):
         """Return api_host."""
         return self._base_path
 
@@ -604,7 +643,24 @@
 
     @retry_params.setter
     def retry_params(self, value):
         """
         Update retry parameters
         """
         self._retry_params = value
+
+    @property
+    def disabled_client_side_validations(self):
+        """Return disable_client_side_validations."""
+        return self._disabled_client_side_validations
+
+    @disabled_client_side_validations.setter
+    def disabled_client_side_validations(self, value):
+        """Update disable_client_side_validations."""
+        self._disabled_client_side_validations = {}
+
+        if isinstance(value, str) and value:
+            s = set(filter(None, value.split(",")))
+            for v in s:
+                if v not in JSON_SCHEMA_VALIDATION_KEYWORDS:
+                    raise FgaValidationException(f"Invalid keyword: '{v}''")
+            self._disabled_client_side_validations = s
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/credentials.py` & `openfga-sdk-0.4.2/openfga_sdk/credentials.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,50 +1,48 @@
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
-from dataclasses import dataclass
-import typing
 from urllib.parse import urlparse
 
 from openfga_sdk.exceptions import ApiValueError
 
 
 def none_or_empty(value):
     """
     Return true if value is either none or empty string
     """
-    return value is None or value == ''
+    return value is None or value == ""
 
 
 class CredentialConfiguration:
     """
     Configuration for SDK credential
     :param client_id: Client ID which will be matched with client_secret
     :param client_secret: Client secret which will be matched with client_id
     :param api_token: Bearer token to be sent for authentication
     :param api_audience: API audience used for OAuth2
     :param api_issuer: API issuer used for OAuth2
     """
 
     def __init__(
         self,
-        client_id: typing.Optional[str] = None,
-        client_secret: typing.Optional[str] = None,
-        api_audience: typing.Optional[str] = None,
-        api_issuer: typing.Optional[str] = None,
-        api_token: typing.Optional[str] = None,
+        client_id: str | None = None,
+        client_secret: str | None = None,
+        api_audience: str | None = None,
+        api_issuer: str | None = None,
+        api_token: str | None = None,
     ):
         self._client_id = client_id
         self._client_secret = client_secret
         self._api_audience = api_audience
         self._api_issuer = api_issuer
         self._api_token = api_token
 
@@ -62,15 +60,15 @@
         """
         self._client_id = value
 
     @property
     def client_secret(self):
         """
         Return the client secret configured
-         """
+        """
         return self._client_secret
 
     @client_secret.setter
     def client_secret(self, value):
         """
         Update the client secret
         """
@@ -124,16 +122,16 @@
     Manage the credential for the API Client
     :param method: Type of authentication. Possible value is 'none', 'api_token' and 'client_credentials'. Default as 'none'.
     :param configuration: Credential configuration of type CredentialConfiguration. Default as None.
     """
 
     def __init__(
         self,
-        method: typing.Optional[str] = 'none',
-        configuration: typing.Optional[CredentialConfiguration] = None,
+        method: str | None = "none",
+        configuration: CredentialConfiguration | None = None,
     ):
         self._method = method
         self._configuration = configuration
 
     @property
     def method(self):
         """
@@ -162,28 +160,45 @@
         """
         self._configuration = value
 
     def validate_credentials_config(self):
         """
         Check whether credentials configuration is valid
         """
-        if self.method != 'none' and self.method != 'api_token' and self.method != 'client_credentials':
+        if (
+            self.method != "none"
+            and self.method != "api_token"
+            and self.method != "client_credentials"
+        ):
             raise ApiValueError(
-                'method `{}` must be either `none`, `api_token` or `client_credentials`'.format(self.method))
-        if self.method == 'api_token' and (self.configuration is None or none_or_empty(self.configuration.api_token)):
+                f"method `{self.method}` must be either `none`, `api_token` or `client_credentials`"
+            )
+        if self.method == "api_token" and (
+            self.configuration is None or none_or_empty(self.configuration.api_token)
+        ):
             raise ApiValueError(
-                'configuration `{}` api_token must be defined and non empty when method is api_token'.format(self.configuration))
-        if self.method == 'client_credentials':
-            if self.configuration is None or none_or_empty(self.configuration.client_id) or none_or_empty(self.configuration.client_secret) or none_or_empty(self.configuration.api_audience) or none_or_empty(self.configuration.api_issuer):
+                f"configuration `{self.configuration}` api_token must be defined and non empty when method is api_token"
+            )
+        if self.method == "client_credentials":
+            if (
+                self.configuration is None
+                or none_or_empty(self.configuration.client_id)
+                or none_or_empty(self.configuration.client_secret)
+                or none_or_empty(self.configuration.api_audience)
+                or none_or_empty(self.configuration.api_issuer)
+            ):
                 raise ApiValueError(
-                    'configuration `{}` requires client_id, client_secret, api_audience and api_issuer defined for client_credentials method.')
+                    "configuration `{}` requires client_id, client_secret, api_audience and api_issuer defined for client_credentials method."
+                )
             # validate token issuer
-            combined_url = 'https://' + self.configuration.api_issuer
+            combined_url = "https://" + self.configuration.api_issuer
             parsed_url = None
             try:
                 parsed_url = urlparse(combined_url)
             except ValueError:
-                raise ApiValueError('api_issuer `{}` is invalid'.format(
-                    self.configuration.api_issuer))
-            if (parsed_url.netloc == ''):
-                raise ApiValueError('api_issuer `{}` is invalid'.format(
-                    self.configuration.api_issuer))
+                raise ApiValueError(
+                    f"api_issuer `{self.configuration.api_issuer}` is invalid"
+                )
+            if parsed_url.netloc == "":
+                raise ApiValueError(
+                    f"api_issuer `{self.configuration.api_issuer}` is invalid"
+                )
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/exceptions.py` & `openfga-sdk-0.4.2/openfga_sdk/exceptions.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
-import six
-
-
 # Specifc FGA header to be parsed
-X_RATELIMIT_LIMIT = 'x-ratelimit-limit'
-X_RATELIMIT_REMAINING = 'x_ratelimit_remaining'
-X_RATELIMIT_RESET = 'x_ratelimit_reset'
-FGA_REQUEST_ID = 'fga-request-id'
-FGA_QUERY_DURATION_MS = 'fga-query-duration-ms'
-OPENFGA_AUTHORIZATION_MODEL_ID = 'openfga_authorization_model_id'
-RESPONSE_HEADERS_TO_KEEP = [X_RATELIMIT_LIMIT, X_RATELIMIT_REMAINING, X_RATELIMIT_RESET,
-                            FGA_REQUEST_ID, FGA_QUERY_DURATION_MS, OPENFGA_AUTHORIZATION_MODEL_ID]
+X_RATELIMIT_LIMIT = "x-ratelimit-limit"
+X_RATELIMIT_REMAINING = "x_ratelimit_remaining"
+X_RATELIMIT_RESET = "x_ratelimit_reset"
+FGA_REQUEST_ID = "fga-request-id"
+FGA_QUERY_DURATION_MS = "fga-query-duration-ms"
+OPENFGA_AUTHORIZATION_MODEL_ID = "openfga_authorization_model_id"
+RESPONSE_HEADERS_TO_KEEP = [
+    X_RATELIMIT_LIMIT,
+    X_RATELIMIT_REMAINING,
+    X_RATELIMIT_RESET,
+    FGA_REQUEST_ID,
+    FGA_QUERY_DURATION_MS,
+    OPENFGA_AUTHORIZATION_MODEL_ID,
+]
 
 
 class OpenApiException(Exception):
     """The base exception class for all OpenAPIExceptions"""
 
 
 class FgaValidationException(OpenApiException, TypeError):
-    def __init__(self, msg, path_to_item=None, valid_classes=None,
-                 key_type=None):
-        """ Raises an exception for TypeErrors
+    def __init__(self, msg, path_to_item=None, valid_classes=None, key_type=None):
+        """Raises an exception for TypeErrors
 
         Args:
             msg (str): the exception message
 
         Keyword Args:
             path_to_item (list): a list of keys an indices to get to the
                                  current_item
@@ -51,16 +51,16 @@
                              None if unset
         """
         self.path_to_item = path_to_item
         self.valid_classes = valid_classes
         self.key_type = key_type
         full_msg = msg
         if path_to_item:
-            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
-        super(FgaValidationException, self).__init__(full_msg)
+            full_msg = f"{msg} at {render_path(path_to_item)}"
+        super().__init__(full_msg)
 
 
 class ApiValueError(OpenApiException, ValueError):
     def __init__(self, msg, path_to_item=None):
         """
         Args:
             msg (str): the exception message
@@ -69,16 +69,16 @@
             path_to_item (list) the path to the exception in the
                 received_data dict. None if unset
         """
 
         self.path_to_item = path_to_item
         full_msg = msg
         if path_to_item:
-            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
-        super(ApiValueError, self).__init__(full_msg)
+            full_msg = f"{msg} at {render_path(path_to_item)}"
+        super().__init__(full_msg)
 
 
 class ApiAttributeError(OpenApiException, AttributeError):
     def __init__(self, msg, path_to_item=None):
         """
         Raised when an attribute reference or assignment fails.
 
@@ -88,16 +88,16 @@
         Keyword Args:
             path_to_item (None/list) the path to the exception in the
                 received_data dict
         """
         self.path_to_item = path_to_item
         full_msg = msg
         if path_to_item:
-            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
-        super(ApiAttributeError, self).__init__(full_msg)
+            full_msg = f"{msg} at {render_path(path_to_item)}"
+        super().__init__(full_msg)
 
 
 class ApiKeyError(OpenApiException, KeyError):
     def __init__(self, msg, path_to_item=None):
         """
         Args:
             msg (str): the exception message
@@ -105,44 +105,48 @@
         Keyword Args:
             path_to_item (None/list) the path to the exception in the
                 received_data dict
         """
         self.path_to_item = path_to_item
         full_msg = msg
         if path_to_item:
-            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
-        super(ApiKeyError, self).__init__(full_msg)
+            full_msg = f"{msg} at {render_path(path_to_item)}"
+        super().__init__(full_msg)
 
 
 class ApiException(OpenApiException):
 
     def __init__(self, status=None, reason=None, http_resp=None):
         if http_resp:
+            try:
+                headers = http_resp.headers.items()
+            except AttributeError:
+                headers = http_resp.getheaders().items()
+
             self.status = http_resp.status
             self.reason = http_resp.reason
             self.body = http_resp.data
             self._parsed_exception = None
-            normalized_headers = dict((k.lower(), v) for k, v in http_resp.getheaders().items())
+            normalized_headers = {k.lower(): v for k, v in headers}
             self.header = dict()
             for key in RESPONSE_HEADERS_TO_KEEP:
                 self.header[key] = normalized_headers.get(key)
         else:
             self.status = status
             self.reason = reason
             self.body = None
             self._parsed_exception = None
             self.header = dict()
 
     def __str__(self):
         """Custom error messages for exception"""
-        error_message = "({0})\n"\
-                        "Reason: {1}\n".format(self.status, self.reason)
+        error_message = "({})\n" "Reason: {}\n".format(self.status, self.reason)
 
         if self.body:
-            error_message += "HTTP response body: {0}\n".format(self.body)
+            error_message += f"HTTP response body: {self.body}\n"
 
         return error_message
 
     @property
     def parsed_exception(self):
         """
         Return the parsed body of the exception
@@ -156,55 +160,55 @@
         """
         self._parsed_exception = content
 
 
 class NotFoundException(ApiException):
 
     def __init__(self, status=None, reason=None, http_resp=None):
-        super(NotFoundException, self).__init__(status, reason, http_resp)
+        super().__init__(status, reason, http_resp)
 
 
 class UnauthorizedException(ApiException):
 
     def __init__(self, status=None, reason=None, http_resp=None):
-        super(UnauthorizedException, self).__init__(status, reason, http_resp)
+        super().__init__(status, reason, http_resp)
 
 
 class ForbiddenException(ApiException):
 
     def __init__(self, status=None, reason=None, http_resp=None):
-        super(ForbiddenException, self).__init__(status, reason, http_resp)
+        super().__init__(status, reason, http_resp)
 
 
 class ServiceException(ApiException):
 
     def __init__(self, status=None, reason=None, http_resp=None):
-        super(ServiceException, self).__init__(status, reason, http_resp)
+        super().__init__(status, reason, http_resp)
 
 
 class ValidationException(ApiException):
 
     def __init__(self, status=None, reason=None, http_resp=None):
-        super(ValidationException, self).__init__(status, reason, http_resp)
+        super().__init__(status, reason, http_resp)
 
 
 class AuthenticationError(ApiException):
 
     def __init__(self, status=None, reason=None, http_resp=None):
-        super(AuthenticationError, self).__init__(status, reason, http_resp)
+        super().__init__(status, reason, http_resp)
 
 
 class RateLimitExceededError(ApiException):
 
     def __init__(self, status=None, reason=None, http_resp=None):
-        super(RateLimitExceededError, self).__init__(status, reason, http_resp)
+        super().__init__(status, reason, http_resp)
 
 
 def render_path(path_to_item):
     """Returns a string representation of a path"""
     result = ""
     for pth in path_to_item:
-        if isinstance(pth, six.integer_types):
-            result += "[{0}]".format(pth)
+        if isinstance(pth, int):
+            result += f"[{pth}]"
         else:
-            result += "['{0}']".format(pth)
+            result += f"['{pth}']"
     return result
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/help.py` & `openfga-sdk-0.4.2/openfga_sdk/help.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,45 +1,37 @@
 import json
 import platform
 import sys
-from typing import Dict
 from collections import OrderedDict
 
 from . import __version__ as openfga_sdk_version
 
 try:
     import urllib3
 
     urllib3_version = urllib3.__version__
 except ModuleNotFoundError:
     urllib3_version = ""
 
 try:
-    import six
-
-    six_version = six.__version__
-except ModuleNotFoundError:
-    six_version = ""
-
-try:
     import dateutil
 
     dateutil_version = dateutil.__version__
 except ModuleNotFoundError:
     dateutil_version = ""
 
 try:
     import aiohttp
 
     aiohttp_version = aiohttp.__version__
 except ModuleNotFoundError:
     aiohttp_version = ""
 
 
-def info() -> Dict[str, Dict[str, str]]:
+def info() -> dict[str, dict[str, str]]:
     """
     Generate information for a bug report.
     Based on the requests package help utility module.
     """
     try:
         platform_info = {
             "system": platform.system(),
@@ -72,15 +64,14 @@
             "implementation": {
                 "name": implementation,
                 "version": implementation_version,
             },
             "openfga_sdk": {"version": openfga_sdk_version},
             "dependencies": {
                 "urllib3": {"version": urllib3_version},
-                "six": {"version": six_version},
                 "python-dateutil": {"version": dateutil_version},
                 "aiohttp": {"version": aiohttp_version},
             },
         }
     )
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/__init__.py` & `openfga-sdk-0.4.2/openfga_sdk/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,66 +1,87 @@
-# coding: utf-8
-
-# flake8: noqa
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
-# import models into model package
+__version__ = "0.4.2"
+
+from openfga_sdk.api.open_fga_api import OpenFgaApi
+from openfga_sdk.api_client import ApiClient
+from openfga_sdk.client.client import OpenFgaClient
+from openfga_sdk.client.configuration import ClientConfiguration
+from openfga_sdk.configuration import Configuration
+from openfga_sdk.exceptions import (
+    ApiAttributeError,
+    ApiException,
+    ApiKeyError,
+    ApiValueError,
+    FgaValidationException,
+    OpenApiException,
+)
 from openfga_sdk.models.aborted_message_response import AbortedMessageResponse
 from openfga_sdk.models.any import Any
 from openfga_sdk.models.assertion import Assertion
 from openfga_sdk.models.assertion_tuple_key import AssertionTupleKey
 from openfga_sdk.models.authorization_model import AuthorizationModel
 from openfga_sdk.models.check_request import CheckRequest
 from openfga_sdk.models.check_request_tuple_key import CheckRequestTupleKey
 from openfga_sdk.models.check_response import CheckResponse
 from openfga_sdk.models.computed import Computed
 from openfga_sdk.models.condition import Condition
+from openfga_sdk.models.condition_metadata import ConditionMetadata
 from openfga_sdk.models.condition_param_type_ref import ConditionParamTypeRef
 from openfga_sdk.models.contextual_tuple_keys import ContextualTupleKeys
 from openfga_sdk.models.create_store_request import CreateStoreRequest
 from openfga_sdk.models.create_store_response import CreateStoreResponse
 from openfga_sdk.models.difference import Difference
 from openfga_sdk.models.error_code import ErrorCode
 from openfga_sdk.models.expand_request import ExpandRequest
 from openfga_sdk.models.expand_request_tuple_key import ExpandRequestTupleKey
 from openfga_sdk.models.expand_response import ExpandResponse
 from openfga_sdk.models.get_store_response import GetStoreResponse
 from openfga_sdk.models.internal_error_code import InternalErrorCode
-from openfga_sdk.models.internal_error_message_response import InternalErrorMessageResponse
+from openfga_sdk.models.internal_error_message_response import (
+    InternalErrorMessageResponse,
+)
 from openfga_sdk.models.leaf import Leaf
 from openfga_sdk.models.list_objects_request import ListObjectsRequest
 from openfga_sdk.models.list_objects_response import ListObjectsResponse
 from openfga_sdk.models.list_stores_response import ListStoresResponse
 from openfga_sdk.models.metadata import Metadata
 from openfga_sdk.models.node import Node
 from openfga_sdk.models.nodes import Nodes
 from openfga_sdk.models.not_found_error_code import NotFoundErrorCode
 from openfga_sdk.models.null_value import NullValue
 from openfga_sdk.models.object_relation import ObjectRelation
-from openfga_sdk.models.path_unknown_error_message_response import PathUnknownErrorMessageResponse
+from openfga_sdk.models.path_unknown_error_message_response import (
+    PathUnknownErrorMessageResponse,
+)
 from openfga_sdk.models.read_assertions_response import ReadAssertionsResponse
-from openfga_sdk.models.read_authorization_model_response import ReadAuthorizationModelResponse
-from openfga_sdk.models.read_authorization_models_response import ReadAuthorizationModelsResponse
+from openfga_sdk.models.read_authorization_model_response import (
+    ReadAuthorizationModelResponse,
+)
+from openfga_sdk.models.read_authorization_models_response import (
+    ReadAuthorizationModelsResponse,
+)
 from openfga_sdk.models.read_changes_response import ReadChangesResponse
 from openfga_sdk.models.read_request import ReadRequest
 from openfga_sdk.models.read_request_tuple_key import ReadRequestTupleKey
 from openfga_sdk.models.read_response import ReadResponse
 from openfga_sdk.models.relation_metadata import RelationMetadata
 from openfga_sdk.models.relation_reference import RelationReference
 from openfga_sdk.models.relationship_condition import RelationshipCondition
+from openfga_sdk.models.source_info import SourceInfo
 from openfga_sdk.models.status import Status
 from openfga_sdk.models.store import Store
 from openfga_sdk.models.tuple import Tuple
 from openfga_sdk.models.tuple_change import TupleChange
 from openfga_sdk.models.tuple_key import TupleKey
 from openfga_sdk.models.tuple_key_without_condition import TupleKeyWithoutCondition
 from openfga_sdk.models.tuple_operation import TupleOperation
@@ -69,14 +90,20 @@
 from openfga_sdk.models.type_name import TypeName
 from openfga_sdk.models.users import Users
 from openfga_sdk.models.userset import Userset
 from openfga_sdk.models.userset_tree import UsersetTree
 from openfga_sdk.models.userset_tree_difference import UsersetTreeDifference
 from openfga_sdk.models.userset_tree_tuple_to_userset import UsersetTreeTupleToUserset
 from openfga_sdk.models.usersets import Usersets
-from openfga_sdk.models.validation_error_message_response import ValidationErrorMessageResponse
+from openfga_sdk.models.validation_error_message_response import (
+    ValidationErrorMessageResponse,
+)
 from openfga_sdk.models.write_assertions_request import WriteAssertionsRequest
-from openfga_sdk.models.write_authorization_model_request import WriteAuthorizationModelRequest
-from openfga_sdk.models.write_authorization_model_response import WriteAuthorizationModelResponse
+from openfga_sdk.models.write_authorization_model_request import (
+    WriteAuthorizationModelRequest,
+)
+from openfga_sdk.models.write_authorization_model_response import (
+    WriteAuthorizationModelResponse,
+)
 from openfga_sdk.models.write_request import WriteRequest
 from openfga_sdk.models.write_request_deletes import WriteRequestDeletes
 from openfga_sdk.models.write_request_writes import WriteRequestWrites
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/aborted_message_response.py` & `openfga-sdk-0.4.2/openfga_sdk/models/validation_error_message_response.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,58 +1,48 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class AbortedMessageResponse(object):
+class ValidationErrorMessageResponse:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'code': 'str',
-        'message': 'str'
-    }
-
-    attribute_map = {
-        'code': 'code',
-        'message': 'message'
-    }
+    openapi_types = {"code": "ErrorCode", "message": "str"}
+
+    attribute_map = {"code": "code", "message": "message"}
 
-    def __init__(self, code=None, message=None, local_vars_configuration=None):  # noqa: E501
-        """AbortedMessageResponse - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, code=None, message=None, local_vars_configuration=None):
+        """ValidationErrorMessageResponse - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._code = None
         self._message = None
         self.discriminator = None
@@ -60,49 +50,49 @@
         if code is not None:
             self.code = code
         if message is not None:
             self.message = message
 
     @property
     def code(self):
-        """Gets the code of this AbortedMessageResponse.  # noqa: E501
+        """Gets the code of this ValidationErrorMessageResponse.
 
 
-        :return: The code of this AbortedMessageResponse.  # noqa: E501
-        :rtype: str
+        :return: The code of this ValidationErrorMessageResponse.
+        :rtype: ErrorCode
         """
         return self._code
 
     @code.setter
     def code(self, code):
-        """Sets the code of this AbortedMessageResponse.
+        """Sets the code of this ValidationErrorMessageResponse.
 
 
-        :param code: The code of this AbortedMessageResponse.  # noqa: E501
-        :type code: str
+        :param code: The code of this ValidationErrorMessageResponse.
+        :type code: ErrorCode
         """
 
         self._code = code
 
     @property
     def message(self):
-        """Gets the message of this AbortedMessageResponse.  # noqa: E501
+        """Gets the message of this ValidationErrorMessageResponse.
 
 
-        :return: The message of this AbortedMessageResponse.  # noqa: E501
+        :return: The message of this ValidationErrorMessageResponse.
         :rtype: str
         """
         return self._message
 
     @message.setter
     def message(self, message):
-        """Sets the message of this AbortedMessageResponse.
+        """Sets the message of this ValidationErrorMessageResponse.
 
 
-        :param message: The message of this AbortedMessageResponse.  # noqa: E501
+        :param message: The message of this ValidationErrorMessageResponse.
         :type message: str
         """
 
         self._message = message
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
@@ -114,27 +104,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -142,18 +128,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, AbortedMessageResponse):
+        if not isinstance(other, ValidationErrorMessageResponse):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, AbortedMessageResponse):
+        if not isinstance(other, ValidationErrorMessageResponse):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/any.py` & `openfga-sdk-0.4.2/openfga_sdk/models/any.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,82 +1,74 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class Any(object):
+class Any:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'type': 'str'
-    }
-
-    attribute_map = {
-        'type': '@type'
-    }
+    openapi_types = {"type": "str"}
+
+    attribute_map = {"type": "@type"}
 
-    def __init__(self, type=None, local_vars_configuration=None):  # noqa: E501
-        """Any - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, type=None, local_vars_configuration=None):
+        """Any - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._type = None
         self.discriminator = None
 
         if type is not None:
             self.type = type
 
     @property
     def type(self):
-        """Gets the type of this Any.  # noqa: E501
+        """Gets the type of this Any.
 
 
-        :return: The type of this Any.  # noqa: E501
+        :return: The type of this Any.
         :rtype: str
         """
         return self._type
 
     @type.setter
     def type(self, type):
         """Sets the type of this Any.
 
 
-        :param type: The type of this Any.  # noqa: E501
+        :param type: The type of this Any.
         :type type: str
         """
 
         self._type = type
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
@@ -88,27 +80,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/assertion.py` & `openfga-sdk-0.4.2/openfga_sdk/models/expand_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,114 +1,111 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class Assertion(object):
+class ExpandRequest:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'tuple_key': 'AssertionTupleKey',
-        'expectation': 'bool'
+        "tuple_key": "ExpandRequestTupleKey",
+        "authorization_model_id": "str",
     }
 
     attribute_map = {
-        'tuple_key': 'tuple_key',
-        'expectation': 'expectation'
+        "tuple_key": "tuple_key",
+        "authorization_model_id": "authorization_model_id",
     }
 
-    def __init__(self, tuple_key=None, expectation=None, local_vars_configuration=None):  # noqa: E501
-        """Assertion - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(
+        self, tuple_key=None, authorization_model_id=None, local_vars_configuration=None
+    ):
+        """ExpandRequest - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._tuple_key = None
-        self._expectation = None
+        self._authorization_model_id = None
         self.discriminator = None
 
         self.tuple_key = tuple_key
-        self.expectation = expectation
+        if authorization_model_id is not None:
+            self.authorization_model_id = authorization_model_id
 
     @property
     def tuple_key(self):
-        """Gets the tuple_key of this Assertion.  # noqa: E501
+        """Gets the tuple_key of this ExpandRequest.
 
 
-        :return: The tuple_key of this Assertion.  # noqa: E501
-        :rtype: AssertionTupleKey
+        :return: The tuple_key of this ExpandRequest.
+        :rtype: ExpandRequestTupleKey
         """
         return self._tuple_key
 
     @tuple_key.setter
     def tuple_key(self, tuple_key):
-        """Sets the tuple_key of this Assertion.
+        """Sets the tuple_key of this ExpandRequest.
 
 
-        :param tuple_key: The tuple_key of this Assertion.  # noqa: E501
-        :type tuple_key: AssertionTupleKey
+        :param tuple_key: The tuple_key of this ExpandRequest.
+        :type tuple_key: ExpandRequestTupleKey
         """
-        if self.local_vars_configuration.client_side_validation and tuple_key is None:  # noqa: E501
-            raise ValueError("Invalid value for `tuple_key`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and tuple_key is None:
+            raise ValueError("Invalid value for `tuple_key`, must not be `None`")
 
         self._tuple_key = tuple_key
 
     @property
-    def expectation(self):
-        """Gets the expectation of this Assertion.  # noqa: E501
+    def authorization_model_id(self):
+        """Gets the authorization_model_id of this ExpandRequest.
 
 
-        :return: The expectation of this Assertion.  # noqa: E501
-        :rtype: bool
+        :return: The authorization_model_id of this ExpandRequest.
+        :rtype: str
         """
-        return self._expectation
+        return self._authorization_model_id
 
-    @expectation.setter
-    def expectation(self, expectation):
-        """Sets the expectation of this Assertion.
+    @authorization_model_id.setter
+    def authorization_model_id(self, authorization_model_id):
+        """Sets the authorization_model_id of this ExpandRequest.
 
 
-        :param expectation: The expectation of this Assertion.  # noqa: E501
-        :type expectation: bool
+        :param authorization_model_id: The authorization_model_id of this ExpandRequest.
+        :type authorization_model_id: str
         """
-        if self.local_vars_configuration.client_side_validation and expectation is None:  # noqa: E501
-            raise ValueError("Invalid value for `expectation`, must not be `None`")  # noqa: E501
 
-        self._expectation = expectation
+        self._authorization_model_id = authorization_model_id
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
         def convert(x):
             if hasattr(x, "to_dict"):
@@ -116,27 +113,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -144,18 +137,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Assertion):
+        if not isinstance(other, ExpandRequest):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, Assertion):
+        if not isinstance(other, ExpandRequest):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/assertion_tuple_key.py` & `openfga-sdk-0.4.2/openfga_sdk/models/tuple_key_without_condition.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,150 +1,155 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class AssertionTupleKey(object):
+class TupleKeyWithoutCondition:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'object': 'str',
-        'relation': 'str',
-        'user': 'str'
-    }
-
-    attribute_map = {
-        'object': 'object',
-        'relation': 'relation',
-        'user': 'user'
-    }
+    openapi_types = {"user": "str", "relation": "str", "object": "str"}
+
+    attribute_map = {"user": "user", "relation": "relation", "object": "object"}
 
-    def __init__(self, object=None, relation=None, user=None, local_vars_configuration=None):  # noqa: E501
-        """AssertionTupleKey - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(
+        self, user=None, relation=None, object=None, local_vars_configuration=None
+    ):
+        """TupleKeyWithoutCondition - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
-        self._object = None
-        self._relation = None
         self._user = None
+        self._relation = None
+        self._object = None
         self.discriminator = None
 
-        self.object = object
-        self.relation = relation
         self.user = user
+        self.relation = relation
+        self.object = object
 
     @property
-    def object(self):
-        """Gets the object of this AssertionTupleKey.  # noqa: E501
+    def user(self):
+        """Gets the user of this TupleKeyWithoutCondition.
 
 
-        :return: The object of this AssertionTupleKey.  # noqa: E501
+        :return: The user of this TupleKeyWithoutCondition.
         :rtype: str
         """
-        return self._object
+        return self._user
 
-    @object.setter
-    def object(self, object):
-        """Sets the object of this AssertionTupleKey.
+    @user.setter
+    def user(self, user):
+        """Sets the user of this TupleKeyWithoutCondition.
 
 
-        :param object: The object of this AssertionTupleKey.  # noqa: E501
-        :type object: str
+        :param user: The user of this TupleKeyWithoutCondition.
+        :type user: str
         """
-        if self.local_vars_configuration.client_side_validation and object is None:  # noqa: E501
-            raise ValueError("Invalid value for `object`, must not be `None`")  # noqa: E501
-        if (self.local_vars_configuration.client_side_validation and
-                object is not None and len(object) > 256):
-            raise ValueError("Invalid value for `object`, length must be less than or equal to `256`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and user is None:
+            raise ValueError("Invalid value for `user`, must not be `None`")
+        if (
+            self.local_vars_configuration.client_side_validation
+            and user is not None
+            and len(user) > 512
+        ):
+            raise ValueError(
+                "Invalid value for `user`, length must be less than or equal to `512`"
+            )
 
-        self._object = object
+        self._user = user
 
     @property
     def relation(self):
-        """Gets the relation of this AssertionTupleKey.  # noqa: E501
+        """Gets the relation of this TupleKeyWithoutCondition.
 
 
-        :return: The relation of this AssertionTupleKey.  # noqa: E501
+        :return: The relation of this TupleKeyWithoutCondition.
         :rtype: str
         """
         return self._relation
 
     @relation.setter
     def relation(self, relation):
-        """Sets the relation of this AssertionTupleKey.
+        """Sets the relation of this TupleKeyWithoutCondition.
 
 
-        :param relation: The relation of this AssertionTupleKey.  # noqa: E501
+        :param relation: The relation of this TupleKeyWithoutCondition.
         :type relation: str
         """
-        if self.local_vars_configuration.client_side_validation and relation is None:  # noqa: E501
-            raise ValueError("Invalid value for `relation`, must not be `None`")  # noqa: E501
-        if (self.local_vars_configuration.client_side_validation and
-                relation is not None and len(relation) > 50):
-            raise ValueError("Invalid value for `relation`, length must be less than or equal to `50`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and relation is None:
+            raise ValueError("Invalid value for `relation`, must not be `None`")
+        if (
+            self.local_vars_configuration.client_side_validation
+            and relation is not None
+            and len(relation) > 50
+        ):
+            raise ValueError(
+                "Invalid value for `relation`, length must be less than or equal to `50`"
+            )
 
         self._relation = relation
 
     @property
-    def user(self):
-        """Gets the user of this AssertionTupleKey.  # noqa: E501
+    def object(self):
+        """Gets the object of this TupleKeyWithoutCondition.
 
 
-        :return: The user of this AssertionTupleKey.  # noqa: E501
+        :return: The object of this TupleKeyWithoutCondition.
         :rtype: str
         """
-        return self._user
+        return self._object
 
-    @user.setter
-    def user(self, user):
-        """Sets the user of this AssertionTupleKey.
+    @object.setter
+    def object(self, object):
+        """Sets the object of this TupleKeyWithoutCondition.
 
 
-        :param user: The user of this AssertionTupleKey.  # noqa: E501
-        :type user: str
+        :param object: The object of this TupleKeyWithoutCondition.
+        :type object: str
         """
-        if self.local_vars_configuration.client_side_validation and user is None:  # noqa: E501
-            raise ValueError("Invalid value for `user`, must not be `None`")  # noqa: E501
-        if (self.local_vars_configuration.client_side_validation and
-                user is not None and len(user) > 512):
-            raise ValueError("Invalid value for `user`, length must be less than or equal to `512`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and object is None:
+            raise ValueError("Invalid value for `object`, must not be `None`")
+        if (
+            self.local_vars_configuration.client_side_validation
+            and object is not None
+            and len(object) > 256
+        ):
+            raise ValueError(
+                "Invalid value for `object`, length must be less than or equal to `256`"
+            )
 
-        self._user = user
+        self._object = object
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
         def convert(x):
             if hasattr(x, "to_dict"):
@@ -152,27 +157,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -180,18 +181,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, AssertionTupleKey):
+        if not isinstance(other, TupleKeyWithoutCondition):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, AssertionTupleKey):
+        if not isinstance(other, TupleKeyWithoutCondition):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/authorization_model.py` & `openfga-sdk-0.4.2/openfga_sdk/models/authorization_model.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,62 +1,65 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class AuthorizationModel(object):
+class AuthorizationModel:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'id': 'str',
-        'schema_version': 'str',
-        'type_definitions': 'list[TypeDefinition]',
-        'conditions': 'dict[str, Condition]'
+        "id": "str",
+        "schema_version": "str",
+        "type_definitions": "list[TypeDefinition]",
+        "conditions": "dict[str, Condition]",
     }
 
     attribute_map = {
-        'id': 'id',
-        'schema_version': 'schema_version',
-        'type_definitions': 'type_definitions',
-        'conditions': 'conditions'
+        "id": "id",
+        "schema_version": "schema_version",
+        "type_definitions": "type_definitions",
+        "conditions": "conditions",
     }
 
-    def __init__(self, id=None, schema_version=None, type_definitions=None, conditions=None, local_vars_configuration=None):  # noqa: E501
-        """AuthorizationModel - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        schema_version=None,
+        type_definitions=None,
+        conditions=None,
+        local_vars_configuration=None,
+    ):
+        """AuthorizationModel - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._id = None
         self._schema_version = None
         self._type_definitions = None
@@ -67,97 +70,103 @@
         self.schema_version = schema_version
         self.type_definitions = type_definitions
         if conditions is not None:
             self.conditions = conditions
 
     @property
     def id(self):
-        """Gets the id of this AuthorizationModel.  # noqa: E501
+        """Gets the id of this AuthorizationModel.
 
 
-        :return: The id of this AuthorizationModel.  # noqa: E501
+        :return: The id of this AuthorizationModel.
         :rtype: str
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this AuthorizationModel.
 
 
-        :param id: The id of this AuthorizationModel.  # noqa: E501
+        :param id: The id of this AuthorizationModel.
         :type id: str
         """
-        if self.local_vars_configuration.client_side_validation and id is None:  # noqa: E501
-            raise ValueError("Invalid value for `id`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and id is None:
+            raise ValueError("Invalid value for `id`, must not be `None`")
 
         self._id = id
 
     @property
     def schema_version(self):
-        """Gets the schema_version of this AuthorizationModel.  # noqa: E501
+        """Gets the schema_version of this AuthorizationModel.
 
 
-        :return: The schema_version of this AuthorizationModel.  # noqa: E501
+        :return: The schema_version of this AuthorizationModel.
         :rtype: str
         """
         return self._schema_version
 
     @schema_version.setter
     def schema_version(self, schema_version):
         """Sets the schema_version of this AuthorizationModel.
 
 
-        :param schema_version: The schema_version of this AuthorizationModel.  # noqa: E501
+        :param schema_version: The schema_version of this AuthorizationModel.
         :type schema_version: str
         """
-        if self.local_vars_configuration.client_side_validation and schema_version is None:  # noqa: E501
-            raise ValueError("Invalid value for `schema_version`, must not be `None`")  # noqa: E501
+        if (
+            self.local_vars_configuration.client_side_validation
+            and schema_version is None
+        ):
+            raise ValueError("Invalid value for `schema_version`, must not be `None`")
 
         self._schema_version = schema_version
 
     @property
     def type_definitions(self):
-        """Gets the type_definitions of this AuthorizationModel.  # noqa: E501
+        """Gets the type_definitions of this AuthorizationModel.
 
 
-        :return: The type_definitions of this AuthorizationModel.  # noqa: E501
+        :return: The type_definitions of this AuthorizationModel.
         :rtype: list[TypeDefinition]
         """
         return self._type_definitions
 
     @type_definitions.setter
     def type_definitions(self, type_definitions):
         """Sets the type_definitions of this AuthorizationModel.
 
 
-        :param type_definitions: The type_definitions of this AuthorizationModel.  # noqa: E501
+        :param type_definitions: The type_definitions of this AuthorizationModel.
         :type type_definitions: list[TypeDefinition]
         """
-        if self.local_vars_configuration.client_side_validation and type_definitions is None:  # noqa: E501
-            raise ValueError("Invalid value for `type_definitions`, must not be `None`")  # noqa: E501
+        if (
+            self.local_vars_configuration.client_side_validation
+            and type_definitions is None
+        ):
+            raise ValueError("Invalid value for `type_definitions`, must not be `None`")
 
         self._type_definitions = type_definitions
 
     @property
     def conditions(self):
-        """Gets the conditions of this AuthorizationModel.  # noqa: E501
+        """Gets the conditions of this AuthorizationModel.
 
 
-        :return: The conditions of this AuthorizationModel.  # noqa: E501
+        :return: The conditions of this AuthorizationModel.
         :rtype: dict[str, Condition]
         """
         return self._conditions
 
     @conditions.setter
     def conditions(self, conditions):
         """Sets the conditions of this AuthorizationModel.
 
 
-        :param conditions: The conditions of this AuthorizationModel.  # noqa: E501
+        :param conditions: The conditions of this AuthorizationModel.
         :type conditions: dict[str, Condition]
         """
 
         self._conditions = conditions
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
@@ -169,27 +178,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/check_request_tuple_key.py` & `openfga-sdk-0.4.2/openfga_sdk/models/check_request_tuple_key.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,60 +1,50 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class CheckRequestTupleKey(object):
+class CheckRequestTupleKey:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'user': 'str',
-        'relation': 'str',
-        'object': 'str'
-    }
-
-    attribute_map = {
-        'user': 'user',
-        'relation': 'relation',
-        'object': 'object'
-    }
+    openapi_types = {"user": "str", "relation": "str", "object": "str"}
+
+    attribute_map = {"user": "user", "relation": "relation", "object": "object"}
 
-    def __init__(self, user=None, relation=None, object=None, local_vars_configuration=None):  # noqa: E501
-        """CheckRequestTupleKey - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(
+        self, user=None, relation=None, object=None, local_vars_configuration=None
+    ):
+        """CheckRequestTupleKey - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._user = None
         self._relation = None
         self._object = None
@@ -62,87 +52,102 @@
 
         self.user = user
         self.relation = relation
         self.object = object
 
     @property
     def user(self):
-        """Gets the user of this CheckRequestTupleKey.  # noqa: E501
+        """Gets the user of this CheckRequestTupleKey.
 
 
-        :return: The user of this CheckRequestTupleKey.  # noqa: E501
+        :return: The user of this CheckRequestTupleKey.
         :rtype: str
         """
         return self._user
 
     @user.setter
     def user(self, user):
         """Sets the user of this CheckRequestTupleKey.
 
 
-        :param user: The user of this CheckRequestTupleKey.  # noqa: E501
+        :param user: The user of this CheckRequestTupleKey.
         :type user: str
         """
-        if self.local_vars_configuration.client_side_validation and user is None:  # noqa: E501
-            raise ValueError("Invalid value for `user`, must not be `None`")  # noqa: E501
-        if (self.local_vars_configuration.client_side_validation and
-                user is not None and len(user) > 512):
-            raise ValueError("Invalid value for `user`, length must be less than or equal to `512`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and user is None:
+            raise ValueError("Invalid value for `user`, must not be `None`")
+        if (
+            self.local_vars_configuration.client_side_validation
+            and user is not None
+            and len(user) > 512
+        ):
+            raise ValueError(
+                "Invalid value for `user`, length must be less than or equal to `512`"
+            )
 
         self._user = user
 
     @property
     def relation(self):
-        """Gets the relation of this CheckRequestTupleKey.  # noqa: E501
+        """Gets the relation of this CheckRequestTupleKey.
 
 
-        :return: The relation of this CheckRequestTupleKey.  # noqa: E501
+        :return: The relation of this CheckRequestTupleKey.
         :rtype: str
         """
         return self._relation
 
     @relation.setter
     def relation(self, relation):
         """Sets the relation of this CheckRequestTupleKey.
 
 
-        :param relation: The relation of this CheckRequestTupleKey.  # noqa: E501
+        :param relation: The relation of this CheckRequestTupleKey.
         :type relation: str
         """
-        if self.local_vars_configuration.client_side_validation and relation is None:  # noqa: E501
-            raise ValueError("Invalid value for `relation`, must not be `None`")  # noqa: E501
-        if (self.local_vars_configuration.client_side_validation and
-                relation is not None and len(relation) > 50):
-            raise ValueError("Invalid value for `relation`, length must be less than or equal to `50`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and relation is None:
+            raise ValueError("Invalid value for `relation`, must not be `None`")
+        if (
+            self.local_vars_configuration.client_side_validation
+            and relation is not None
+            and len(relation) > 50
+        ):
+            raise ValueError(
+                "Invalid value for `relation`, length must be less than or equal to `50`"
+            )
 
         self._relation = relation
 
     @property
     def object(self):
-        """Gets the object of this CheckRequestTupleKey.  # noqa: E501
+        """Gets the object of this CheckRequestTupleKey.
 
 
-        :return: The object of this CheckRequestTupleKey.  # noqa: E501
+        :return: The object of this CheckRequestTupleKey.
         :rtype: str
         """
         return self._object
 
     @object.setter
     def object(self, object):
         """Sets the object of this CheckRequestTupleKey.
 
 
-        :param object: The object of this CheckRequestTupleKey.  # noqa: E501
+        :param object: The object of this CheckRequestTupleKey.
         :type object: str
         """
-        if self.local_vars_configuration.client_side_validation and object is None:  # noqa: E501
-            raise ValueError("Invalid value for `object`, must not be `None`")  # noqa: E501
-        if (self.local_vars_configuration.client_side_validation and
-                object is not None and len(object) > 256):
-            raise ValueError("Invalid value for `object`, length must be less than or equal to `256`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and object is None:
+            raise ValueError("Invalid value for `object`, must not be `None`")
+        if (
+            self.local_vars_configuration.client_side_validation
+            and object is not None
+            and len(object) > 256
+        ):
+            raise ValueError(
+                "Invalid value for `object`, length must be less than or equal to `256`"
+            )
 
         self._object = object
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
@@ -152,27 +157,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/check_response.py` & `openfga-sdk-0.4.2/openfga_sdk/models/check_response.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,58 +1,48 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class CheckResponse(object):
+class CheckResponse:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'allowed': 'bool',
-        'resolution': 'str'
-    }
-
-    attribute_map = {
-        'allowed': 'allowed',
-        'resolution': 'resolution'
-    }
+    openapi_types = {"allowed": "bool", "resolution": "str"}
+
+    attribute_map = {"allowed": "allowed", "resolution": "resolution"}
 
-    def __init__(self, allowed=None, resolution=None, local_vars_configuration=None):  # noqa: E501
-        """CheckResponse - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, allowed=None, resolution=None, local_vars_configuration=None):
+        """CheckResponse - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._allowed = None
         self._resolution = None
         self.discriminator = None
@@ -60,51 +50,51 @@
         if allowed is not None:
             self.allowed = allowed
         if resolution is not None:
             self.resolution = resolution
 
     @property
     def allowed(self):
-        """Gets the allowed of this CheckResponse.  # noqa: E501
+        """Gets the allowed of this CheckResponse.
 
 
-        :return: The allowed of this CheckResponse.  # noqa: E501
+        :return: The allowed of this CheckResponse.
         :rtype: bool
         """
         return self._allowed
 
     @allowed.setter
     def allowed(self, allowed):
         """Sets the allowed of this CheckResponse.
 
 
-        :param allowed: The allowed of this CheckResponse.  # noqa: E501
+        :param allowed: The allowed of this CheckResponse.
         :type allowed: bool
         """
 
         self._allowed = allowed
 
     @property
     def resolution(self):
-        """Gets the resolution of this CheckResponse.  # noqa: E501
+        """Gets the resolution of this CheckResponse.
 
-        For internal use only.  # noqa: E501
+        For internal use only.
 
-        :return: The resolution of this CheckResponse.  # noqa: E501
+        :return: The resolution of this CheckResponse.
         :rtype: str
         """
         return self._resolution
 
     @resolution.setter
     def resolution(self, resolution):
         """Sets the resolution of this CheckResponse.
 
-        For internal use only.  # noqa: E501
+        For internal use only.
 
-        :param resolution: The resolution of this CheckResponse.  # noqa: E501
+        :param resolution: The resolution of this CheckResponse.
         :type resolution: str
         """
 
         self._resolution = resolution
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
@@ -116,27 +106,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/computed.py` & `openfga-sdk-0.4.2/openfga_sdk/models/internal_error_code.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,115 +1,105 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class Computed(object):
+class InternalErrorCode:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
+    allowed enum values
+    """
+    NO_INTERNAL_ERROR = "no_internal_error"
+    INTERNAL_ERROR = "internal_error"
+    CANCELLED = "cancelled"
+    DEADLINE_EXCEEDED = "deadline_exceeded"
+    ALREADY_EXISTS = "already_exists"
+    RESOURCE_EXHAUSTED = "resource_exhausted"
+    FAILED_PRECONDITION = "failed_precondition"
+    ABORTED = "aborted"
+    OUT_OF_RANGE = "out_of_range"
+    UNAVAILABLE = "unavailable"
+    DATA_LOSS = "data_loss"
+
+    allowable_values = [
+        NO_INTERNAL_ERROR,
+        INTERNAL_ERROR,
+        CANCELLED,
+        DEADLINE_EXCEEDED,
+        ALREADY_EXISTS,
+        RESOURCE_EXHAUSTED,
+        FAILED_PRECONDITION,
+        ABORTED,
+        OUT_OF_RANGE,
+        UNAVAILABLE,
+        DATA_LOSS,
+    ]
+
+    """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'userset': 'str'
-    }
-
-    attribute_map = {
-        'userset': 'userset'
-    }
+    openapi_types = {}
 
-    def __init__(self, userset=None, local_vars_configuration=None):  # noqa: E501
-        """Computed - a model defined in OpenAPI"""  # noqa: E501
+    attribute_map = {}
+
+    def __init__(self, local_vars_configuration=None):
+        """InternalErrorCode - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
-
-        self._userset = None
         self.discriminator = None
 
-        self.userset = userset
-
-    @property
-    def userset(self):
-        """Gets the userset of this Computed.  # noqa: E501
-
-
-        :return: The userset of this Computed.  # noqa: E501
-        :rtype: str
-        """
-        return self._userset
-
-    @userset.setter
-    def userset(self, userset):
-        """Sets the userset of this Computed.
-
-
-        :param userset: The userset of this Computed.  # noqa: E501
-        :type userset: str
-        """
-        if self.local_vars_configuration.client_side_validation and userset is None:  # noqa: E501
-            raise ValueError("Invalid value for `userset`, must not be `None`")  # noqa: E501
-
-        self._userset = userset
-
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
         def convert(x):
             if hasattr(x, "to_dict"):
                 args = getfullargspec(x.to_dict).args
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -117,18 +107,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Computed):
+        if not isinstance(other, InternalErrorCode):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, Computed):
+        if not isinstance(other, InternalErrorCode):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/condition.py` & `openfga-sdk-0.4.2/openfga_sdk/models/condition.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,172 +1,197 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class Condition(object):
+class Condition:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'name': 'str',
-        'expression': 'str',
-        'parameters': 'dict[str, ConditionParamTypeRef]'
+        "name": "str",
+        "expression": "str",
+        "parameters": "dict[str, ConditionParamTypeRef]",
+        "metadata": "ConditionMetadata",
     }
 
     attribute_map = {
-        'name': 'name',
-        'expression': 'expression',
-        'parameters': 'parameters'
+        "name": "name",
+        "expression": "expression",
+        "parameters": "parameters",
+        "metadata": "metadata",
     }
 
-    def __init__(self, name=None, expression=None, parameters=None, local_vars_configuration=None):  # noqa: E501
-        """Condition - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(
+        self,
+        name=None,
+        expression=None,
+        parameters=None,
+        metadata=None,
+        local_vars_configuration=None,
+    ):
+        """Condition - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._name = None
         self._expression = None
         self._parameters = None
+        self._metadata = None
         self.discriminator = None
 
         self.name = name
         self.expression = expression
         if parameters is not None:
             self.parameters = parameters
+        if metadata is not None:
+            self.metadata = metadata
 
     @property
     def name(self):
-        """Gets the name of this Condition.  # noqa: E501
+        """Gets the name of this Condition.
 
 
-        :return: The name of this Condition.  # noqa: E501
+        :return: The name of this Condition.
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this Condition.
 
 
-        :param name: The name of this Condition.  # noqa: E501
+        :param name: The name of this Condition.
         :type name: str
         """
-        if self.local_vars_configuration.client_side_validation and name is None:  # noqa: E501
-            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and name is None:
+            raise ValueError("Invalid value for `name`, must not be `None`")
 
         self._name = name
 
     @property
     def expression(self):
-        """Gets the expression of this Condition.  # noqa: E501
+        """Gets the expression of this Condition.
 
-        A Google CEL expression, expressed as a string.  # noqa: E501
+        A Google CEL expression, expressed as a string.
 
-        :return: The expression of this Condition.  # noqa: E501
+        :return: The expression of this Condition.
         :rtype: str
         """
         return self._expression
 
     @expression.setter
     def expression(self, expression):
         """Sets the expression of this Condition.
 
-        A Google CEL expression, expressed as a string.  # noqa: E501
+        A Google CEL expression, expressed as a string.
 
-        :param expression: The expression of this Condition.  # noqa: E501
+        :param expression: The expression of this Condition.
         :type expression: str
         """
-        if self.local_vars_configuration.client_side_validation and expression is None:  # noqa: E501
-            raise ValueError("Invalid value for `expression`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and expression is None:
+            raise ValueError("Invalid value for `expression`, must not be `None`")
 
         self._expression = expression
 
     @property
     def parameters(self):
-        """Gets the parameters of this Condition.  # noqa: E501
+        """Gets the parameters of this Condition.
 
-        A map of parameter names to the parameter's defined type reference.  # noqa: E501
+        A map of parameter names to the parameter's defined type reference.
 
-        :return: The parameters of this Condition.  # noqa: E501
+        :return: The parameters of this Condition.
         :rtype: dict[str, ConditionParamTypeRef]
         """
         return self._parameters
 
     @parameters.setter
     def parameters(self, parameters):
         """Sets the parameters of this Condition.
 
-        A map of parameter names to the parameter's defined type reference.  # noqa: E501
+        A map of parameter names to the parameter's defined type reference.
 
-        :param parameters: The parameters of this Condition.  # noqa: E501
+        :param parameters: The parameters of this Condition.
         :type parameters: dict[str, ConditionParamTypeRef]
         """
 
         self._parameters = parameters
 
+    @property
+    def metadata(self):
+        """Gets the metadata of this Condition.
+
+
+        :return: The metadata of this Condition.
+        :rtype: ConditionMetadata
+        """
+        return self._metadata
+
+    @metadata.setter
+    def metadata(self, metadata):
+        """Sets the metadata of this Condition.
+
+
+        :param metadata: The metadata of this Condition.
+        :type metadata: ConditionMetadata
+        """
+
+        self._metadata = metadata
+
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
         def convert(x):
             if hasattr(x, "to_dict"):
                 args = getfullargspec(x.to_dict).args
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/condition_param_type_ref.py` & `openfga-sdk-0.4.2/openfga_sdk/models/status.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,113 +1,128 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class ConditionParamTypeRef(object):
+class Status:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'type_name': 'TypeName',
-        'generic_types': 'list[ConditionParamTypeRef]'
-    }
-
-    attribute_map = {
-        'type_name': 'type_name',
-        'generic_types': 'generic_types'
-    }
+    openapi_types = {"code": "int", "message": "str", "details": "list[Any]"}
+
+    attribute_map = {"code": "code", "message": "message", "details": "details"}
 
-    def __init__(self, type_name=None, generic_types=None, local_vars_configuration=None):  # noqa: E501
-        """ConditionParamTypeRef - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(
+        self, code=None, message=None, details=None, local_vars_configuration=None
+    ):
+        """Status - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
-        self._type_name = None
-        self._generic_types = None
+        self._code = None
+        self._message = None
+        self._details = None
         self.discriminator = None
 
-        self.type_name = type_name
-        if generic_types is not None:
-            self.generic_types = generic_types
+        if code is not None:
+            self.code = code
+        if message is not None:
+            self.message = message
+        if details is not None:
+            self.details = details
+
+    @property
+    def code(self):
+        """Gets the code of this Status.
+
+
+        :return: The code of this Status.
+        :rtype: int
+        """
+        return self._code
+
+    @code.setter
+    def code(self, code):
+        """Sets the code of this Status.
+
+
+        :param code: The code of this Status.
+        :type code: int
+        """
+
+        self._code = code
 
     @property
-    def type_name(self):
-        """Gets the type_name of this ConditionParamTypeRef.  # noqa: E501
+    def message(self):
+        """Gets the message of this Status.
 
 
-        :return: The type_name of this ConditionParamTypeRef.  # noqa: E501
-        :rtype: TypeName
+        :return: The message of this Status.
+        :rtype: str
         """
-        return self._type_name
+        return self._message
 
-    @type_name.setter
-    def type_name(self, type_name):
-        """Sets the type_name of this ConditionParamTypeRef.
+    @message.setter
+    def message(self, message):
+        """Sets the message of this Status.
 
 
-        :param type_name: The type_name of this ConditionParamTypeRef.  # noqa: E501
-        :type type_name: TypeName
+        :param message: The message of this Status.
+        :type message: str
         """
-        if self.local_vars_configuration.client_side_validation and type_name is None:  # noqa: E501
-            raise ValueError("Invalid value for `type_name`, must not be `None`")  # noqa: E501
 
-        self._type_name = type_name
+        self._message = message
 
     @property
-    def generic_types(self):
-        """Gets the generic_types of this ConditionParamTypeRef.  # noqa: E501
+    def details(self):
+        """Gets the details of this Status.
 
 
-        :return: The generic_types of this ConditionParamTypeRef.  # noqa: E501
-        :rtype: list[ConditionParamTypeRef]
+        :return: The details of this Status.
+        :rtype: list[Any]
         """
-        return self._generic_types
+        return self._details
 
-    @generic_types.setter
-    def generic_types(self, generic_types):
-        """Sets the generic_types of this ConditionParamTypeRef.
+    @details.setter
+    def details(self, details):
+        """Sets the details of this Status.
 
 
-        :param generic_types: The generic_types of this ConditionParamTypeRef.  # noqa: E501
-        :type generic_types: list[ConditionParamTypeRef]
+        :param details: The details of this Status.
+        :type details: list[Any]
         """
 
-        self._generic_types = generic_types
+        self._details = details
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
         def convert(x):
             if hasattr(x, "to_dict"):
@@ -115,27 +130,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -143,18 +154,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ConditionParamTypeRef):
+        if not isinstance(other, Status):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, ConditionParamTypeRef):
+        if not isinstance(other, Status):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/contextual_tuple_keys.py` & `openfga-sdk-0.4.2/openfga_sdk/models/contextual_tuple_keys.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,85 +1,77 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class ContextualTupleKeys(object):
+class ContextualTupleKeys:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'tuple_keys': 'list[TupleKey]'
-    }
-
-    attribute_map = {
-        'tuple_keys': 'tuple_keys'
-    }
+    openapi_types = {"tuple_keys": "list[TupleKey]"}
+
+    attribute_map = {"tuple_keys": "tuple_keys"}
 
-    def __init__(self, tuple_keys=None, local_vars_configuration=None):  # noqa: E501
-        """ContextualTupleKeys - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, tuple_keys=None, local_vars_configuration=None):
+        """ContextualTupleKeys - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._tuple_keys = None
         self.discriminator = None
 
         self.tuple_keys = tuple_keys
 
     @property
     def tuple_keys(self):
-        """Gets the tuple_keys of this ContextualTupleKeys.  # noqa: E501
+        """Gets the tuple_keys of this ContextualTupleKeys.
 
 
-        :return: The tuple_keys of this ContextualTupleKeys.  # noqa: E501
+        :return: The tuple_keys of this ContextualTupleKeys.
         :rtype: list[TupleKey]
         """
         return self._tuple_keys
 
     @tuple_keys.setter
     def tuple_keys(self, tuple_keys):
         """Sets the tuple_keys of this ContextualTupleKeys.
 
 
-        :param tuple_keys: The tuple_keys of this ContextualTupleKeys.  # noqa: E501
+        :param tuple_keys: The tuple_keys of this ContextualTupleKeys.
         :type tuple_keys: list[TupleKey]
         """
-        if self.local_vars_configuration.client_side_validation and tuple_keys is None:  # noqa: E501
-            raise ValueError("Invalid value for `tuple_keys`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and tuple_keys is None:
+            raise ValueError("Invalid value for `tuple_keys`, must not be `None`")
 
         self._tuple_keys = tuple_keys
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
@@ -89,27 +81,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/create_store_request.py` & `openfga-sdk-0.4.2/openfga_sdk/models/create_store_request.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,85 +1,77 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class CreateStoreRequest(object):
+class CreateStoreRequest:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'name': 'str'
-    }
-
-    attribute_map = {
-        'name': 'name'
-    }
+    openapi_types = {"name": "str"}
+
+    attribute_map = {"name": "name"}
 
-    def __init__(self, name=None, local_vars_configuration=None):  # noqa: E501
-        """CreateStoreRequest - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, name=None, local_vars_configuration=None):
+        """CreateStoreRequest - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._name = None
         self.discriminator = None
 
         self.name = name
 
     @property
     def name(self):
-        """Gets the name of this CreateStoreRequest.  # noqa: E501
+        """Gets the name of this CreateStoreRequest.
 
 
-        :return: The name of this CreateStoreRequest.  # noqa: E501
+        :return: The name of this CreateStoreRequest.
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this CreateStoreRequest.
 
 
-        :param name: The name of this CreateStoreRequest.  # noqa: E501
+        :param name: The name of this CreateStoreRequest.
         :type name: str
         """
-        if self.local_vars_configuration.client_side_validation and name is None:  # noqa: E501
-            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and name is None:
+            raise ValueError("Invalid value for `name`, must not be `None`")
 
         self._name = name
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
@@ -89,27 +81,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/create_store_response.py` & `openfga-sdk-0.4.2/openfga_sdk/models/create_store_response.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,62 +1,65 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class CreateStoreResponse(object):
+class CreateStoreResponse:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'id': 'str',
-        'name': 'str',
-        'created_at': 'datetime',
-        'updated_at': 'datetime'
+        "id": "str",
+        "name": "str",
+        "created_at": "datetime",
+        "updated_at": "datetime",
     }
 
     attribute_map = {
-        'id': 'id',
-        'name': 'name',
-        'created_at': 'created_at',
-        'updated_at': 'updated_at'
+        "id": "id",
+        "name": "name",
+        "created_at": "created_at",
+        "updated_at": "updated_at",
     }
 
-    def __init__(self, id=None, name=None, created_at=None, updated_at=None, local_vars_configuration=None):  # noqa: E501
-        """CreateStoreResponse - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        name=None,
+        created_at=None,
+        updated_at=None,
+        local_vars_configuration=None,
+    ):
+        """CreateStoreResponse - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._id = None
         self._name = None
         self._created_at = None
@@ -66,101 +69,101 @@
         self.id = id
         self.name = name
         self.created_at = created_at
         self.updated_at = updated_at
 
     @property
     def id(self):
-        """Gets the id of this CreateStoreResponse.  # noqa: E501
+        """Gets the id of this CreateStoreResponse.
 
 
-        :return: The id of this CreateStoreResponse.  # noqa: E501
+        :return: The id of this CreateStoreResponse.
         :rtype: str
         """
         return self._id
 
     @id.setter
     def id(self, id):
         """Sets the id of this CreateStoreResponse.
 
 
-        :param id: The id of this CreateStoreResponse.  # noqa: E501
+        :param id: The id of this CreateStoreResponse.
         :type id: str
         """
-        if self.local_vars_configuration.client_side_validation and id is None:  # noqa: E501
-            raise ValueError("Invalid value for `id`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and id is None:
+            raise ValueError("Invalid value for `id`, must not be `None`")
 
         self._id = id
 
     @property
     def name(self):
-        """Gets the name of this CreateStoreResponse.  # noqa: E501
+        """Gets the name of this CreateStoreResponse.
 
 
-        :return: The name of this CreateStoreResponse.  # noqa: E501
+        :return: The name of this CreateStoreResponse.
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this CreateStoreResponse.
 
 
-        :param name: The name of this CreateStoreResponse.  # noqa: E501
+        :param name: The name of this CreateStoreResponse.
         :type name: str
         """
-        if self.local_vars_configuration.client_side_validation and name is None:  # noqa: E501
-            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and name is None:
+            raise ValueError("Invalid value for `name`, must not be `None`")
 
         self._name = name
 
     @property
     def created_at(self):
-        """Gets the created_at of this CreateStoreResponse.  # noqa: E501
+        """Gets the created_at of this CreateStoreResponse.
 
 
-        :return: The created_at of this CreateStoreResponse.  # noqa: E501
+        :return: The created_at of this CreateStoreResponse.
         :rtype: datetime
         """
         return self._created_at
 
     @created_at.setter
     def created_at(self, created_at):
         """Sets the created_at of this CreateStoreResponse.
 
 
-        :param created_at: The created_at of this CreateStoreResponse.  # noqa: E501
+        :param created_at: The created_at of this CreateStoreResponse.
         :type created_at: datetime
         """
-        if self.local_vars_configuration.client_side_validation and created_at is None:  # noqa: E501
-            raise ValueError("Invalid value for `created_at`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and created_at is None:
+            raise ValueError("Invalid value for `created_at`, must not be `None`")
 
         self._created_at = created_at
 
     @property
     def updated_at(self):
-        """Gets the updated_at of this CreateStoreResponse.  # noqa: E501
+        """Gets the updated_at of this CreateStoreResponse.
 
 
-        :return: The updated_at of this CreateStoreResponse.  # noqa: E501
+        :return: The updated_at of this CreateStoreResponse.
         :rtype: datetime
         """
         return self._updated_at
 
     @updated_at.setter
     def updated_at(self, updated_at):
         """Sets the updated_at of this CreateStoreResponse.
 
 
-        :param updated_at: The updated_at of this CreateStoreResponse.  # noqa: E501
+        :param updated_at: The updated_at of this CreateStoreResponse.
         :type updated_at: datetime
         """
-        if self.local_vars_configuration.client_side_validation and updated_at is None:  # noqa: E501
-            raise ValueError("Invalid value for `updated_at`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and updated_at is None:
+            raise ValueError("Invalid value for `updated_at`, must not be `None`")
 
         self._updated_at = updated_at
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
@@ -170,27 +173,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/difference.py` & `openfga-sdk-0.4.2/openfga_sdk/models/internal_error_message_response.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,114 +1,102 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class Difference(object):
+class InternalErrorMessageResponse:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'base': 'Userset',
-        'subtract': 'Userset'
-    }
-
-    attribute_map = {
-        'base': 'base',
-        'subtract': 'subtract'
-    }
+    openapi_types = {"code": "InternalErrorCode", "message": "str"}
+
+    attribute_map = {"code": "code", "message": "message"}
 
-    def __init__(self, base=None, subtract=None, local_vars_configuration=None):  # noqa: E501
-        """Difference - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, code=None, message=None, local_vars_configuration=None):
+        """InternalErrorMessageResponse - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
-        self._base = None
-        self._subtract = None
+        self._code = None
+        self._message = None
         self.discriminator = None
 
-        self.base = base
-        self.subtract = subtract
+        if code is not None:
+            self.code = code
+        if message is not None:
+            self.message = message
 
     @property
-    def base(self):
-        """Gets the base of this Difference.  # noqa: E501
+    def code(self):
+        """Gets the code of this InternalErrorMessageResponse.
 
 
-        :return: The base of this Difference.  # noqa: E501
-        :rtype: Userset
+        :return: The code of this InternalErrorMessageResponse.
+        :rtype: InternalErrorCode
         """
-        return self._base
+        return self._code
 
-    @base.setter
-    def base(self, base):
-        """Sets the base of this Difference.
+    @code.setter
+    def code(self, code):
+        """Sets the code of this InternalErrorMessageResponse.
 
 
-        :param base: The base of this Difference.  # noqa: E501
-        :type base: Userset
+        :param code: The code of this InternalErrorMessageResponse.
+        :type code: InternalErrorCode
         """
-        if self.local_vars_configuration.client_side_validation and base is None:  # noqa: E501
-            raise ValueError("Invalid value for `base`, must not be `None`")  # noqa: E501
 
-        self._base = base
+        self._code = code
 
     @property
-    def subtract(self):
-        """Gets the subtract of this Difference.  # noqa: E501
+    def message(self):
+        """Gets the message of this InternalErrorMessageResponse.
 
 
-        :return: The subtract of this Difference.  # noqa: E501
-        :rtype: Userset
+        :return: The message of this InternalErrorMessageResponse.
+        :rtype: str
         """
-        return self._subtract
+        return self._message
 
-    @subtract.setter
-    def subtract(self, subtract):
-        """Sets the subtract of this Difference.
+    @message.setter
+    def message(self, message):
+        """Sets the message of this InternalErrorMessageResponse.
 
 
-        :param subtract: The subtract of this Difference.  # noqa: E501
-        :type subtract: Userset
+        :param message: The message of this InternalErrorMessageResponse.
+        :type message: str
         """
-        if self.local_vars_configuration.client_side_validation and subtract is None:  # noqa: E501
-            raise ValueError("Invalid value for `subtract`, must not be `None`")  # noqa: E501
 
-        self._subtract = subtract
+        self._message = message
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
         def convert(x):
             if hasattr(x, "to_dict"):
@@ -116,27 +104,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -144,18 +128,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Difference):
+        if not isinstance(other, InternalErrorMessageResponse):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, Difference):
+        if not isinstance(other, InternalErrorMessageResponse):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/error_code.py` & `openfga-sdk-0.4.2/openfga_sdk/models/error_code.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,58 +1,64 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class ErrorCode(object):
+class ErrorCode:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     allowed enum values
     """
     NO_ERROR = "no_error"
     VALIDATION_ERROR = "validation_error"
     AUTHORIZATION_MODEL_NOT_FOUND = "authorization_model_not_found"
-    AUTHORIZATION_MODEL_RESOLUTION_TOO_COMPLEX = "authorization_model_resolution_too_complex"
+    AUTHORIZATION_MODEL_RESOLUTION_TOO_COMPLEX = (
+        "authorization_model_resolution_too_complex"
+    )
     INVALID_WRITE_INPUT = "invalid_write_input"
-    CANNOT_ALLOW_DUPLICATE_TUPLES_IN_ONE_REQUEST = "cannot_allow_duplicate_tuples_in_one_request"
-    CANNOT_ALLOW_DUPLICATE_TYPES_IN_ONE_REQUEST = "cannot_allow_duplicate_types_in_one_request"
-    CANNOT_ALLOW_MULTIPLE_REFERENCES_TO_ONE_RELATION = "cannot_allow_multiple_references_to_one_relation"
+    CANNOT_ALLOW_DUPLICATE_TUPLES_IN_ONE_REQUEST = (
+        "cannot_allow_duplicate_tuples_in_one_request"
+    )
+    CANNOT_ALLOW_DUPLICATE_TYPES_IN_ONE_REQUEST = (
+        "cannot_allow_duplicate_types_in_one_request"
+    )
+    CANNOT_ALLOW_MULTIPLE_REFERENCES_TO_ONE_RELATION = (
+        "cannot_allow_multiple_references_to_one_relation"
+    )
     INVALID_CONTINUATION_TOKEN = "invalid_continuation_token"
     INVALID_TUPLE_SET = "invalid_tuple_set"
     INVALID_CHECK_INPUT = "invalid_check_input"
     INVALID_EXPAND_INPUT = "invalid_expand_input"
     UNSUPPORTED_USER_SET = "unsupported_user_set"
     INVALID_OBJECT_FORMAT = "invalid_object_format"
     WRITE_FAILED_DUE_TO_INVALID_INPUT = "write_failed_due_to_invalid_input"
-    AUTHORIZATION_MODEL_ASSERTIONS_NOT_FOUND = "authorization_model_assertions_not_found"
+    AUTHORIZATION_MODEL_ASSERTIONS_NOT_FOUND = (
+        "authorization_model_assertions_not_found"
+    )
     LATEST_AUTHORIZATION_MODEL_NOT_FOUND = "latest_authorization_model_not_found"
     TYPE_NOT_FOUND = "type_not_found"
     RELATION_NOT_FOUND = "relation_not_found"
     EMPTY_RELATION_DEFINITION = "empty_relation_definition"
     INVALID_USER = "invalid_user"
     INVALID_TUPLE = "invalid_tuple"
     UNKNOWN_RELATION = "unknown_relation"
@@ -71,38 +77,87 @@
     TYPE_DEFINITIONS_TOO_FEW_ITEMS = "type_definitions_too_few_items"
     TYPE_INVALID_LENGTH = "type_invalid_length"
     TYPE_INVALID_PATTERN = "type_invalid_pattern"
     RELATIONS_TOO_FEW_ITEMS = "relations_too_few_items"
     RELATIONS_TOO_LONG = "relations_too_long"
     RELATIONS_INVALID_PATTERN = "relations_invalid_pattern"
     OBJECT_INVALID_PATTERN = "object_invalid_pattern"
-    QUERY_STRING_TYPE_CONTINUATION_TOKEN_MISMATCH = "query_string_type_continuation_token_mismatch"
+    QUERY_STRING_TYPE_CONTINUATION_TOKEN_MISMATCH = (
+        "query_string_type_continuation_token_mismatch"
+    )
     EXCEEDED_ENTITY_LIMIT = "exceeded_entity_limit"
     INVALID_CONTEXTUAL_TUPLE = "invalid_contextual_tuple"
     DUPLICATE_CONTEXTUAL_TUPLE = "duplicate_contextual_tuple"
     INVALID_AUTHORIZATION_MODEL = "invalid_authorization_model"
     UNSUPPORTED_SCHEMA_VERSION = "unsupported_schema_version"
 
-    allowable_values = [NO_ERROR, VALIDATION_ERROR, AUTHORIZATION_MODEL_NOT_FOUND, AUTHORIZATION_MODEL_RESOLUTION_TOO_COMPLEX, INVALID_WRITE_INPUT, CANNOT_ALLOW_DUPLICATE_TUPLES_IN_ONE_REQUEST, CANNOT_ALLOW_DUPLICATE_TYPES_IN_ONE_REQUEST, CANNOT_ALLOW_MULTIPLE_REFERENCES_TO_ONE_RELATION, INVALID_CONTINUATION_TOKEN, INVALID_TUPLE_SET, INVALID_CHECK_INPUT, INVALID_EXPAND_INPUT, UNSUPPORTED_USER_SET, INVALID_OBJECT_FORMAT, WRITE_FAILED_DUE_TO_INVALID_INPUT, AUTHORIZATION_MODEL_ASSERTIONS_NOT_FOUND, LATEST_AUTHORIZATION_MODEL_NOT_FOUND, TYPE_NOT_FOUND, RELATION_NOT_FOUND, EMPTY_RELATION_DEFINITION, INVALID_USER, INVALID_TUPLE, UNKNOWN_RELATION, STORE_ID_INVALID_LENGTH, ASSERTIONS_TOO_MANY_ITEMS, ID_TOO_LONG, AUTHORIZATION_MODEL_ID_TOO_LONG, TUPLE_KEY_VALUE_NOT_SPECIFIED, TUPLE_KEYS_TOO_MANY_OR_TOO_FEW_ITEMS, PAGE_SIZE_INVALID, PARAM_MISSING_VALUE, DIFFERENCE_BASE_MISSING_VALUE, SUBTRACT_BASE_MISSING_VALUE, OBJECT_TOO_LONG, RELATION_TOO_LONG, TYPE_DEFINITIONS_TOO_FEW_ITEMS, TYPE_INVALID_LENGTH, TYPE_INVALID_PATTERN, RELATIONS_TOO_FEW_ITEMS, RELATIONS_TOO_LONG, RELATIONS_INVALID_PATTERN, OBJECT_INVALID_PATTERN, QUERY_STRING_TYPE_CONTINUATION_TOKEN_MISMATCH, EXCEEDED_ENTITY_LIMIT, INVALID_CONTEXTUAL_TUPLE, DUPLICATE_CONTEXTUAL_TUPLE, INVALID_AUTHORIZATION_MODEL, UNSUPPORTED_SCHEMA_VERSION]  # noqa: E501
+    allowable_values = [
+        NO_ERROR,
+        VALIDATION_ERROR,
+        AUTHORIZATION_MODEL_NOT_FOUND,
+        AUTHORIZATION_MODEL_RESOLUTION_TOO_COMPLEX,
+        INVALID_WRITE_INPUT,
+        CANNOT_ALLOW_DUPLICATE_TUPLES_IN_ONE_REQUEST,
+        CANNOT_ALLOW_DUPLICATE_TYPES_IN_ONE_REQUEST,
+        CANNOT_ALLOW_MULTIPLE_REFERENCES_TO_ONE_RELATION,
+        INVALID_CONTINUATION_TOKEN,
+        INVALID_TUPLE_SET,
+        INVALID_CHECK_INPUT,
+        INVALID_EXPAND_INPUT,
+        UNSUPPORTED_USER_SET,
+        INVALID_OBJECT_FORMAT,
+        WRITE_FAILED_DUE_TO_INVALID_INPUT,
+        AUTHORIZATION_MODEL_ASSERTIONS_NOT_FOUND,
+        LATEST_AUTHORIZATION_MODEL_NOT_FOUND,
+        TYPE_NOT_FOUND,
+        RELATION_NOT_FOUND,
+        EMPTY_RELATION_DEFINITION,
+        INVALID_USER,
+        INVALID_TUPLE,
+        UNKNOWN_RELATION,
+        STORE_ID_INVALID_LENGTH,
+        ASSERTIONS_TOO_MANY_ITEMS,
+        ID_TOO_LONG,
+        AUTHORIZATION_MODEL_ID_TOO_LONG,
+        TUPLE_KEY_VALUE_NOT_SPECIFIED,
+        TUPLE_KEYS_TOO_MANY_OR_TOO_FEW_ITEMS,
+        PAGE_SIZE_INVALID,
+        PARAM_MISSING_VALUE,
+        DIFFERENCE_BASE_MISSING_VALUE,
+        SUBTRACT_BASE_MISSING_VALUE,
+        OBJECT_TOO_LONG,
+        RELATION_TOO_LONG,
+        TYPE_DEFINITIONS_TOO_FEW_ITEMS,
+        TYPE_INVALID_LENGTH,
+        TYPE_INVALID_PATTERN,
+        RELATIONS_TOO_FEW_ITEMS,
+        RELATIONS_TOO_LONG,
+        RELATIONS_INVALID_PATTERN,
+        OBJECT_INVALID_PATTERN,
+        QUERY_STRING_TYPE_CONTINUATION_TOKEN_MISMATCH,
+        EXCEEDED_ENTITY_LIMIT,
+        INVALID_CONTEXTUAL_TUPLE,
+        DUPLICATE_CONTEXTUAL_TUPLE,
+        INVALID_AUTHORIZATION_MODEL,
+        UNSUPPORTED_SCHEMA_VERSION,
+    ]
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-    }
+    openapi_types = {}
 
-    attribute_map = {
-    }
+    attribute_map = {}
 
-    def __init__(self, local_vars_configuration=None):  # noqa: E501
-        """ErrorCode - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, local_vars_configuration=None):
+        """ErrorCode - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
         self.discriminator = None
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
@@ -114,27 +169,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/expand_request.py` & `openfga-sdk-0.4.2/openfga_sdk/models/path_unknown_error_message_response.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,113 +1,102 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class ExpandRequest(object):
+class PathUnknownErrorMessageResponse:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'tuple_key': 'ExpandRequestTupleKey',
-        'authorization_model_id': 'str'
-    }
-
-    attribute_map = {
-        'tuple_key': 'tuple_key',
-        'authorization_model_id': 'authorization_model_id'
-    }
+    openapi_types = {"code": "NotFoundErrorCode", "message": "str"}
+
+    attribute_map = {"code": "code", "message": "message"}
 
-    def __init__(self, tuple_key=None, authorization_model_id=None, local_vars_configuration=None):  # noqa: E501
-        """ExpandRequest - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, code=None, message=None, local_vars_configuration=None):
+        """PathUnknownErrorMessageResponse - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
-        self._tuple_key = None
-        self._authorization_model_id = None
+        self._code = None
+        self._message = None
         self.discriminator = None
 
-        self.tuple_key = tuple_key
-        if authorization_model_id is not None:
-            self.authorization_model_id = authorization_model_id
+        if code is not None:
+            self.code = code
+        if message is not None:
+            self.message = message
 
     @property
-    def tuple_key(self):
-        """Gets the tuple_key of this ExpandRequest.  # noqa: E501
+    def code(self):
+        """Gets the code of this PathUnknownErrorMessageResponse.
 
 
-        :return: The tuple_key of this ExpandRequest.  # noqa: E501
-        :rtype: ExpandRequestTupleKey
+        :return: The code of this PathUnknownErrorMessageResponse.
+        :rtype: NotFoundErrorCode
         """
-        return self._tuple_key
+        return self._code
 
-    @tuple_key.setter
-    def tuple_key(self, tuple_key):
-        """Sets the tuple_key of this ExpandRequest.
+    @code.setter
+    def code(self, code):
+        """Sets the code of this PathUnknownErrorMessageResponse.
 
 
-        :param tuple_key: The tuple_key of this ExpandRequest.  # noqa: E501
-        :type tuple_key: ExpandRequestTupleKey
+        :param code: The code of this PathUnknownErrorMessageResponse.
+        :type code: NotFoundErrorCode
         """
-        if self.local_vars_configuration.client_side_validation and tuple_key is None:  # noqa: E501
-            raise ValueError("Invalid value for `tuple_key`, must not be `None`")  # noqa: E501
 
-        self._tuple_key = tuple_key
+        self._code = code
 
     @property
-    def authorization_model_id(self):
-        """Gets the authorization_model_id of this ExpandRequest.  # noqa: E501
+    def message(self):
+        """Gets the message of this PathUnknownErrorMessageResponse.
 
 
-        :return: The authorization_model_id of this ExpandRequest.  # noqa: E501
+        :return: The message of this PathUnknownErrorMessageResponse.
         :rtype: str
         """
-        return self._authorization_model_id
+        return self._message
 
-    @authorization_model_id.setter
-    def authorization_model_id(self, authorization_model_id):
-        """Sets the authorization_model_id of this ExpandRequest.
+    @message.setter
+    def message(self, message):
+        """Sets the message of this PathUnknownErrorMessageResponse.
 
 
-        :param authorization_model_id: The authorization_model_id of this ExpandRequest.  # noqa: E501
-        :type authorization_model_id: str
+        :param message: The message of this PathUnknownErrorMessageResponse.
+        :type message: str
         """
 
-        self._authorization_model_id = authorization_model_id
+        self._message = message
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
         def convert(x):
             if hasattr(x, "to_dict"):
@@ -115,27 +104,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -143,18 +128,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ExpandRequest):
+        if not isinstance(other, PathUnknownErrorMessageResponse):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, ExpandRequest):
+        if not isinstance(other, PathUnknownErrorMessageResponse):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/expand_request_tuple_key.py` & `openfga-sdk-0.4.2/openfga_sdk/models/expand_request_tuple_key.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,118 +1,118 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class ExpandRequestTupleKey(object):
+class ExpandRequestTupleKey:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'relation': 'str',
-        'object': 'str'
-    }
-
-    attribute_map = {
-        'relation': 'relation',
-        'object': 'object'
-    }
+    openapi_types = {"relation": "str", "object": "str"}
+
+    attribute_map = {"relation": "relation", "object": "object"}
 
-    def __init__(self, relation=None, object=None, local_vars_configuration=None):  # noqa: E501
-        """ExpandRequestTupleKey - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, relation=None, object=None, local_vars_configuration=None):
+        """ExpandRequestTupleKey - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._relation = None
         self._object = None
         self.discriminator = None
 
         self.relation = relation
         self.object = object
 
     @property
     def relation(self):
-        """Gets the relation of this ExpandRequestTupleKey.  # noqa: E501
+        """Gets the relation of this ExpandRequestTupleKey.
 
 
-        :return: The relation of this ExpandRequestTupleKey.  # noqa: E501
+        :return: The relation of this ExpandRequestTupleKey.
         :rtype: str
         """
         return self._relation
 
     @relation.setter
     def relation(self, relation):
         """Sets the relation of this ExpandRequestTupleKey.
 
 
-        :param relation: The relation of this ExpandRequestTupleKey.  # noqa: E501
+        :param relation: The relation of this ExpandRequestTupleKey.
         :type relation: str
         """
-        if self.local_vars_configuration.client_side_validation and relation is None:  # noqa: E501
-            raise ValueError("Invalid value for `relation`, must not be `None`")  # noqa: E501
-        if (self.local_vars_configuration.client_side_validation and
-                relation is not None and len(relation) > 50):
-            raise ValueError("Invalid value for `relation`, length must be less than or equal to `50`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and relation is None:
+            raise ValueError("Invalid value for `relation`, must not be `None`")
+        if (
+            self.local_vars_configuration.client_side_validation
+            and relation is not None
+            and len(relation) > 50
+        ):
+            raise ValueError(
+                "Invalid value for `relation`, length must be less than or equal to `50`"
+            )
 
         self._relation = relation
 
     @property
     def object(self):
-        """Gets the object of this ExpandRequestTupleKey.  # noqa: E501
+        """Gets the object of this ExpandRequestTupleKey.
 
 
-        :return: The object of this ExpandRequestTupleKey.  # noqa: E501
+        :return: The object of this ExpandRequestTupleKey.
         :rtype: str
         """
         return self._object
 
     @object.setter
     def object(self, object):
         """Sets the object of this ExpandRequestTupleKey.
 
 
-        :param object: The object of this ExpandRequestTupleKey.  # noqa: E501
+        :param object: The object of this ExpandRequestTupleKey.
         :type object: str
         """
-        if self.local_vars_configuration.client_side_validation and object is None:  # noqa: E501
-            raise ValueError("Invalid value for `object`, must not be `None`")  # noqa: E501
-        if (self.local_vars_configuration.client_side_validation and
-                object is not None and len(object) > 256):
-            raise ValueError("Invalid value for `object`, length must be less than or equal to `256`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and object is None:
+            raise ValueError("Invalid value for `object`, must not be `None`")
+        if (
+            self.local_vars_configuration.client_side_validation
+            and object is not None
+            and len(object) > 256
+        ):
+            raise ValueError(
+                "Invalid value for `object`, length must be less than or equal to `256`"
+            )
 
         self._object = object
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
@@ -122,27 +122,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/expand_response.py` & `openfga-sdk-0.4.2/openfga_sdk/models/not_found_error_code.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,114 +1,91 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class ExpandResponse(object):
+class NotFoundErrorCode:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
+    allowed enum values
+    """
+    NO_NOT_FOUND_ERROR = "no_not_found_error"
+    UNDEFINED_ENDPOINT = "undefined_endpoint"
+    STORE_ID_NOT_FOUND = "store_id_not_found"
+    UNIMPLEMENTED = "unimplemented"
+
+    allowable_values = [
+        NO_NOT_FOUND_ERROR,
+        UNDEFINED_ENDPOINT,
+        STORE_ID_NOT_FOUND,
+        UNIMPLEMENTED,
+    ]
+
+    """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'tree': 'UsersetTree'
-    }
-
-    attribute_map = {
-        'tree': 'tree'
-    }
+    openapi_types = {}
 
-    def __init__(self, tree=None, local_vars_configuration=None):  # noqa: E501
-        """ExpandResponse - a model defined in OpenAPI"""  # noqa: E501
+    attribute_map = {}
+
+    def __init__(self, local_vars_configuration=None):
+        """NotFoundErrorCode - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
-
-        self._tree = None
         self.discriminator = None
 
-        if tree is not None:
-            self.tree = tree
-
-    @property
-    def tree(self):
-        """Gets the tree of this ExpandResponse.  # noqa: E501
-
-
-        :return: The tree of this ExpandResponse.  # noqa: E501
-        :rtype: UsersetTree
-        """
-        return self._tree
-
-    @tree.setter
-    def tree(self, tree):
-        """Sets the tree of this ExpandResponse.
-
-
-        :param tree: The tree of this ExpandResponse.  # noqa: E501
-        :type tree: UsersetTree
-        """
-
-        self._tree = tree
-
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
         def convert(x):
             if hasattr(x, "to_dict"):
                 args = getfullargspec(x.to_dict).args
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -116,18 +93,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ExpandResponse):
+        if not isinstance(other, NotFoundErrorCode):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, ExpandResponse):
+        if not isinstance(other, NotFoundErrorCode):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/get_store_response.py` & `openfga-sdk-0.4.2/openfga_sdk/models/store.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,64 +1,68 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class GetStoreResponse(object):
+class Store:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'id': 'str',
-        'name': 'str',
-        'created_at': 'datetime',
-        'updated_at': 'datetime',
-        'deleted_at': 'datetime'
+        "id": "str",
+        "name": "str",
+        "created_at": "datetime",
+        "updated_at": "datetime",
+        "deleted_at": "datetime",
     }
 
     attribute_map = {
-        'id': 'id',
-        'name': 'name',
-        'created_at': 'created_at',
-        'updated_at': 'updated_at',
-        'deleted_at': 'deleted_at'
+        "id": "id",
+        "name": "name",
+        "created_at": "created_at",
+        "updated_at": "updated_at",
+        "deleted_at": "deleted_at",
     }
 
-    def __init__(self, id=None, name=None, created_at=None, updated_at=None, deleted_at=None, local_vars_configuration=None):  # noqa: E501
-        """GetStoreResponse - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        name=None,
+        created_at=None,
+        updated_at=None,
+        deleted_at=None,
+        local_vars_configuration=None,
+    ):
+        """Store - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._id = None
         self._name = None
         self._created_at = None
@@ -71,120 +75,120 @@
         self.created_at = created_at
         self.updated_at = updated_at
         if deleted_at is not None:
             self.deleted_at = deleted_at
 
     @property
     def id(self):
-        """Gets the id of this GetStoreResponse.  # noqa: E501
+        """Gets the id of this Store.
 
 
-        :return: The id of this GetStoreResponse.  # noqa: E501
+        :return: The id of this Store.
         :rtype: str
         """
         return self._id
 
     @id.setter
     def id(self, id):
-        """Sets the id of this GetStoreResponse.
+        """Sets the id of this Store.
 
 
-        :param id: The id of this GetStoreResponse.  # noqa: E501
+        :param id: The id of this Store.
         :type id: str
         """
-        if self.local_vars_configuration.client_side_validation and id is None:  # noqa: E501
-            raise ValueError("Invalid value for `id`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and id is None:
+            raise ValueError("Invalid value for `id`, must not be `None`")
 
         self._id = id
 
     @property
     def name(self):
-        """Gets the name of this GetStoreResponse.  # noqa: E501
+        """Gets the name of this Store.
 
 
-        :return: The name of this GetStoreResponse.  # noqa: E501
+        :return: The name of this Store.
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
-        """Sets the name of this GetStoreResponse.
+        """Sets the name of this Store.
 
 
-        :param name: The name of this GetStoreResponse.  # noqa: E501
+        :param name: The name of this Store.
         :type name: str
         """
-        if self.local_vars_configuration.client_side_validation and name is None:  # noqa: E501
-            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and name is None:
+            raise ValueError("Invalid value for `name`, must not be `None`")
 
         self._name = name
 
     @property
     def created_at(self):
-        """Gets the created_at of this GetStoreResponse.  # noqa: E501
+        """Gets the created_at of this Store.
 
 
-        :return: The created_at of this GetStoreResponse.  # noqa: E501
+        :return: The created_at of this Store.
         :rtype: datetime
         """
         return self._created_at
 
     @created_at.setter
     def created_at(self, created_at):
-        """Sets the created_at of this GetStoreResponse.
+        """Sets the created_at of this Store.
 
 
-        :param created_at: The created_at of this GetStoreResponse.  # noqa: E501
+        :param created_at: The created_at of this Store.
         :type created_at: datetime
         """
-        if self.local_vars_configuration.client_side_validation and created_at is None:  # noqa: E501
-            raise ValueError("Invalid value for `created_at`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and created_at is None:
+            raise ValueError("Invalid value for `created_at`, must not be `None`")
 
         self._created_at = created_at
 
     @property
     def updated_at(self):
-        """Gets the updated_at of this GetStoreResponse.  # noqa: E501
+        """Gets the updated_at of this Store.
 
 
-        :return: The updated_at of this GetStoreResponse.  # noqa: E501
+        :return: The updated_at of this Store.
         :rtype: datetime
         """
         return self._updated_at
 
     @updated_at.setter
     def updated_at(self, updated_at):
-        """Sets the updated_at of this GetStoreResponse.
+        """Sets the updated_at of this Store.
 
 
-        :param updated_at: The updated_at of this GetStoreResponse.  # noqa: E501
+        :param updated_at: The updated_at of this Store.
         :type updated_at: datetime
         """
-        if self.local_vars_configuration.client_side_validation and updated_at is None:  # noqa: E501
-            raise ValueError("Invalid value for `updated_at`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and updated_at is None:
+            raise ValueError("Invalid value for `updated_at`, must not be `None`")
 
         self._updated_at = updated_at
 
     @property
     def deleted_at(self):
-        """Gets the deleted_at of this GetStoreResponse.  # noqa: E501
+        """Gets the deleted_at of this Store.
 
 
-        :return: The deleted_at of this GetStoreResponse.  # noqa: E501
+        :return: The deleted_at of this Store.
         :rtype: datetime
         """
         return self._deleted_at
 
     @deleted_at.setter
     def deleted_at(self, deleted_at):
-        """Sets the deleted_at of this GetStoreResponse.
+        """Sets the deleted_at of this Store.
 
 
-        :param deleted_at: The deleted_at of this GetStoreResponse.  # noqa: E501
+        :param deleted_at: The deleted_at of this Store.
         :type deleted_at: datetime
         """
 
         self._deleted_at = deleted_at
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
@@ -196,27 +200,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -224,18 +224,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, GetStoreResponse):
+        if not isinstance(other, Store):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, GetStoreResponse):
+        if not isinstance(other, Store):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/internal_error_code.py` & `openfga-sdk-0.4.2/openfga_sdk/models/source_info.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,103 +1,102 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class InternalErrorCode(object):
+class SourceInfo:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
-    allowed enum values
-    """
-    NO_INTERNAL_ERROR = "no_internal_error"
-    INTERNAL_ERROR = "internal_error"
-    CANCELLED = "cancelled"
-    DEADLINE_EXCEEDED = "deadline_exceeded"
-    ALREADY_EXISTS = "already_exists"
-    RESOURCE_EXHAUSTED = "resource_exhausted"
-    FAILED_PRECONDITION = "failed_precondition"
-    ABORTED = "aborted"
-    OUT_OF_RANGE = "out_of_range"
-    UNAVAILABLE = "unavailable"
-    DATA_LOSS = "data_loss"
-
-    allowable_values = [NO_INTERNAL_ERROR, INTERNAL_ERROR, CANCELLED, DEADLINE_EXCEEDED, ALREADY_EXISTS, RESOURCE_EXHAUSTED, FAILED_PRECONDITION, ABORTED, OUT_OF_RANGE, UNAVAILABLE, DATA_LOSS]  # noqa: E501
-
-    """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-    }
+    openapi_types = {"file": "str"}
 
-    attribute_map = {
-    }
+    attribute_map = {"file": "file"}
 
-    def __init__(self, local_vars_configuration=None):  # noqa: E501
-        """InternalErrorCode - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, file=None, local_vars_configuration=None):
+        """SourceInfo - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
+
+        self._file = None
         self.discriminator = None
 
+        if file is not None:
+            self.file = file
+
+    @property
+    def file(self):
+        """Gets the file of this SourceInfo.
+
+
+        :return: The file of this SourceInfo.
+        :rtype: str
+        """
+        return self._file
+
+    @file.setter
+    def file(self, file):
+        """Sets the file of this SourceInfo.
+
+
+        :param file: The file of this SourceInfo.
+        :type file: str
+        """
+
+        self._file = file
+
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
         def convert(x):
             if hasattr(x, "to_dict"):
                 args = getfullargspec(x.to_dict).args
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -105,18 +104,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, InternalErrorCode):
+        if not isinstance(other, SourceInfo):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, InternalErrorCode):
+        if not isinstance(other, SourceInfo):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/internal_error_message_response.py` & `openfga-sdk-0.4.2/openfga_sdk/models/assertion.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,112 +1,104 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class InternalErrorMessageResponse(object):
+class Assertion:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'code': 'InternalErrorCode',
-        'message': 'str'
-    }
-
-    attribute_map = {
-        'code': 'code',
-        'message': 'message'
-    }
+    openapi_types = {"tuple_key": "AssertionTupleKey", "expectation": "bool"}
+
+    attribute_map = {"tuple_key": "tuple_key", "expectation": "expectation"}
 
-    def __init__(self, code=None, message=None, local_vars_configuration=None):  # noqa: E501
-        """InternalErrorMessageResponse - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, tuple_key=None, expectation=None, local_vars_configuration=None):
+        """Assertion - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
-        self._code = None
-        self._message = None
+        self._tuple_key = None
+        self._expectation = None
         self.discriminator = None
 
-        if code is not None:
-            self.code = code
-        if message is not None:
-            self.message = message
+        self.tuple_key = tuple_key
+        self.expectation = expectation
 
     @property
-    def code(self):
-        """Gets the code of this InternalErrorMessageResponse.  # noqa: E501
+    def tuple_key(self):
+        """Gets the tuple_key of this Assertion.
 
 
-        :return: The code of this InternalErrorMessageResponse.  # noqa: E501
-        :rtype: InternalErrorCode
+        :return: The tuple_key of this Assertion.
+        :rtype: AssertionTupleKey
         """
-        return self._code
+        return self._tuple_key
 
-    @code.setter
-    def code(self, code):
-        """Sets the code of this InternalErrorMessageResponse.
+    @tuple_key.setter
+    def tuple_key(self, tuple_key):
+        """Sets the tuple_key of this Assertion.
 
 
-        :param code: The code of this InternalErrorMessageResponse.  # noqa: E501
-        :type code: InternalErrorCode
+        :param tuple_key: The tuple_key of this Assertion.
+        :type tuple_key: AssertionTupleKey
         """
+        if self.local_vars_configuration.client_side_validation and tuple_key is None:
+            raise ValueError("Invalid value for `tuple_key`, must not be `None`")
 
-        self._code = code
+        self._tuple_key = tuple_key
 
     @property
-    def message(self):
-        """Gets the message of this InternalErrorMessageResponse.  # noqa: E501
+    def expectation(self):
+        """Gets the expectation of this Assertion.
 
 
-        :return: The message of this InternalErrorMessageResponse.  # noqa: E501
-        :rtype: str
+        :return: The expectation of this Assertion.
+        :rtype: bool
         """
-        return self._message
+        return self._expectation
 
-    @message.setter
-    def message(self, message):
-        """Sets the message of this InternalErrorMessageResponse.
+    @expectation.setter
+    def expectation(self, expectation):
+        """Sets the expectation of this Assertion.
 
 
-        :param message: The message of this InternalErrorMessageResponse.  # noqa: E501
-        :type message: str
+        :param expectation: The expectation of this Assertion.
+        :type expectation: bool
         """
+        if self.local_vars_configuration.client_side_validation and expectation is None:
+            raise ValueError("Invalid value for `expectation`, must not be `None`")
 
-        self._message = message
+        self._expectation = expectation
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
         def convert(x):
             if hasattr(x, "to_dict"):
@@ -114,27 +106,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -142,18 +130,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, InternalErrorMessageResponse):
+        if not isinstance(other, Assertion):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, InternalErrorMessageResponse):
+        if not isinstance(other, Assertion):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/leaf.py` & `openfga-sdk-0.4.2/openfga_sdk/models/leaf.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,60 +1,62 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class Leaf(object):
+class Leaf:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'users': 'Users',
-        'computed': 'Computed',
-        'tuple_to_userset': 'UsersetTreeTupleToUserset'
+        "users": "Users",
+        "computed": "Computed",
+        "tuple_to_userset": "UsersetTreeTupleToUserset",
     }
 
     attribute_map = {
-        'users': 'users',
-        'computed': 'computed',
-        'tuple_to_userset': 'tupleToUserset'
+        "users": "users",
+        "computed": "computed",
+        "tuple_to_userset": "tupleToUserset",
     }
 
-    def __init__(self, users=None, computed=None, tuple_to_userset=None, local_vars_configuration=None):  # noqa: E501
-        """Leaf - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(
+        self,
+        users=None,
+        computed=None,
+        tuple_to_userset=None,
+        local_vars_configuration=None,
+    ):
+        """Leaf - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._users = None
         self._computed = None
         self._tuple_to_userset = None
@@ -65,70 +67,70 @@
         if computed is not None:
             self.computed = computed
         if tuple_to_userset is not None:
             self.tuple_to_userset = tuple_to_userset
 
     @property
     def users(self):
-        """Gets the users of this Leaf.  # noqa: E501
+        """Gets the users of this Leaf.
 
 
-        :return: The users of this Leaf.  # noqa: E501
+        :return: The users of this Leaf.
         :rtype: Users
         """
         return self._users
 
     @users.setter
     def users(self, users):
         """Sets the users of this Leaf.
 
 
-        :param users: The users of this Leaf.  # noqa: E501
+        :param users: The users of this Leaf.
         :type users: Users
         """
 
         self._users = users
 
     @property
     def computed(self):
-        """Gets the computed of this Leaf.  # noqa: E501
+        """Gets the computed of this Leaf.
 
 
-        :return: The computed of this Leaf.  # noqa: E501
+        :return: The computed of this Leaf.
         :rtype: Computed
         """
         return self._computed
 
     @computed.setter
     def computed(self, computed):
         """Sets the computed of this Leaf.
 
 
-        :param computed: The computed of this Leaf.  # noqa: E501
+        :param computed: The computed of this Leaf.
         :type computed: Computed
         """
 
         self._computed = computed
 
     @property
     def tuple_to_userset(self):
-        """Gets the tuple_to_userset of this Leaf.  # noqa: E501
+        """Gets the tuple_to_userset of this Leaf.
 
 
-        :return: The tuple_to_userset of this Leaf.  # noqa: E501
+        :return: The tuple_to_userset of this Leaf.
         :rtype: UsersetTreeTupleToUserset
         """
         return self._tuple_to_userset
 
     @tuple_to_userset.setter
     def tuple_to_userset(self, tuple_to_userset):
         """Sets the tuple_to_userset of this Leaf.
 
 
-        :param tuple_to_userset: The tuple_to_userset of this Leaf.  # noqa: E501
+        :param tuple_to_userset: The tuple_to_userset of this Leaf.
         :type tuple_to_userset: UsersetTreeTupleToUserset
         """
 
         self._tuple_to_userset = tuple_to_userset
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
@@ -140,27 +142,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/list_objects_response.py` & `openfga-sdk-0.4.2/openfga_sdk/models/expand_response.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,87 +1,78 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class ListObjectsResponse(object):
+class ExpandResponse:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'objects': 'list[str]'
-    }
-
-    attribute_map = {
-        'objects': 'objects'
-    }
+    openapi_types = {"tree": "UsersetTree"}
+
+    attribute_map = {"tree": "tree"}
 
-    def __init__(self, objects=None, local_vars_configuration=None):  # noqa: E501
-        """ListObjectsResponse - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, tree=None, local_vars_configuration=None):
+        """ExpandResponse - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
-        self._objects = None
+        self._tree = None
         self.discriminator = None
 
-        self.objects = objects
+        if tree is not None:
+            self.tree = tree
 
     @property
-    def objects(self):
-        """Gets the objects of this ListObjectsResponse.  # noqa: E501
+    def tree(self):
+        """Gets the tree of this ExpandResponse.
 
 
-        :return: The objects of this ListObjectsResponse.  # noqa: E501
-        :rtype: list[str]
+        :return: The tree of this ExpandResponse.
+        :rtype: UsersetTree
         """
-        return self._objects
+        return self._tree
 
-    @objects.setter
-    def objects(self, objects):
-        """Sets the objects of this ListObjectsResponse.
+    @tree.setter
+    def tree(self, tree):
+        """Sets the tree of this ExpandResponse.
 
 
-        :param objects: The objects of this ListObjectsResponse.  # noqa: E501
-        :type objects: list[str]
+        :param tree: The tree of this ExpandResponse.
+        :type tree: UsersetTree
         """
-        if self.local_vars_configuration.client_side_validation and objects is None:  # noqa: E501
-            raise ValueError("Invalid value for `objects`, must not be `None`")  # noqa: E501
 
-        self._objects = objects
+        self._tree = tree
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
         def convert(x):
             if hasattr(x, "to_dict"):
@@ -89,27 +80,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -117,18 +104,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ListObjectsResponse):
+        if not isinstance(other, ExpandResponse):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, ListObjectsResponse):
+        if not isinstance(other, ExpandResponse):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/list_stores_response.py` & `openfga-sdk-0.4.2/openfga_sdk/models/read_response.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,114 +1,111 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class ListStoresResponse(object):
+class ReadResponse:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'stores': 'list[Store]',
-        'continuation_token': 'str'
-    }
-
-    attribute_map = {
-        'stores': 'stores',
-        'continuation_token': 'continuation_token'
-    }
+    openapi_types = {"tuples": "list[Tuple]", "continuation_token": "str"}
+
+    attribute_map = {"tuples": "tuples", "continuation_token": "continuation_token"}
 
-    def __init__(self, stores=None, continuation_token=None, local_vars_configuration=None):  # noqa: E501
-        """ListStoresResponse - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(
+        self, tuples=None, continuation_token=None, local_vars_configuration=None
+    ):
+        """ReadResponse - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
-        self._stores = None
+        self._tuples = None
         self._continuation_token = None
         self.discriminator = None
 
-        self.stores = stores
+        self.tuples = tuples
         self.continuation_token = continuation_token
 
     @property
-    def stores(self):
-        """Gets the stores of this ListStoresResponse.  # noqa: E501
+    def tuples(self):
+        """Gets the tuples of this ReadResponse.
 
 
-        :return: The stores of this ListStoresResponse.  # noqa: E501
-        :rtype: list[Store]
+        :return: The tuples of this ReadResponse.
+        :rtype: list[Tuple]
         """
-        return self._stores
+        return self._tuples
 
-    @stores.setter
-    def stores(self, stores):
-        """Sets the stores of this ListStoresResponse.
+    @tuples.setter
+    def tuples(self, tuples):
+        """Sets the tuples of this ReadResponse.
 
 
-        :param stores: The stores of this ListStoresResponse.  # noqa: E501
-        :type stores: list[Store]
+        :param tuples: The tuples of this ReadResponse.
+        :type tuples: list[Tuple]
         """
-        if self.local_vars_configuration.client_side_validation and stores is None:  # noqa: E501
-            raise ValueError("Invalid value for `stores`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and tuples is None:
+            raise ValueError("Invalid value for `tuples`, must not be `None`")
 
-        self._stores = stores
+        self._tuples = tuples
 
     @property
     def continuation_token(self):
-        """Gets the continuation_token of this ListStoresResponse.  # noqa: E501
+        """Gets the continuation_token of this ReadResponse.
 
-        The continuation token will be empty if there are no more stores.  # noqa: E501
+        The continuation token will be empty if there are no more tuples.
 
-        :return: The continuation_token of this ListStoresResponse.  # noqa: E501
+        :return: The continuation_token of this ReadResponse.
         :rtype: str
         """
         return self._continuation_token
 
     @continuation_token.setter
     def continuation_token(self, continuation_token):
-        """Sets the continuation_token of this ListStoresResponse.
+        """Sets the continuation_token of this ReadResponse.
 
-        The continuation token will be empty if there are no more stores.  # noqa: E501
+        The continuation token will be empty if there are no more tuples.
 
-        :param continuation_token: The continuation_token of this ListStoresResponse.  # noqa: E501
+        :param continuation_token: The continuation_token of this ReadResponse.
         :type continuation_token: str
         """
-        if self.local_vars_configuration.client_side_validation and continuation_token is None:  # noqa: E501
-            raise ValueError("Invalid value for `continuation_token`, must not be `None`")  # noqa: E501
+        if (
+            self.local_vars_configuration.client_side_validation
+            and continuation_token is None
+        ):
+            raise ValueError(
+                "Invalid value for `continuation_token`, must not be `None`"
+            )
 
         self._continuation_token = continuation_token
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
@@ -118,27 +115,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -146,18 +139,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ListStoresResponse):
+        if not isinstance(other, ReadResponse):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, ListStoresResponse):
+        if not isinstance(other, ReadResponse):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/metadata.py` & `openfga-sdk-0.4.2/openfga_sdk/models/users.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,86 +1,79 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class Metadata(object):
+class Users:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'relations': 'dict[str, RelationMetadata]'
-    }
-
-    attribute_map = {
-        'relations': 'relations'
-    }
+    openapi_types = {"users": "list[str]"}
+
+    attribute_map = {"users": "users"}
 
-    def __init__(self, relations=None, local_vars_configuration=None):  # noqa: E501
-        """Metadata - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, users=None, local_vars_configuration=None):
+        """Users - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
-        self._relations = None
+        self._users = None
         self.discriminator = None
 
-        if relations is not None:
-            self.relations = relations
+        self.users = users
 
     @property
-    def relations(self):
-        """Gets the relations of this Metadata.  # noqa: E501
+    def users(self):
+        """Gets the users of this Users.
 
 
-        :return: The relations of this Metadata.  # noqa: E501
-        :rtype: dict[str, RelationMetadata]
+        :return: The users of this Users.
+        :rtype: list[str]
         """
-        return self._relations
+        return self._users
 
-    @relations.setter
-    def relations(self, relations):
-        """Sets the relations of this Metadata.
+    @users.setter
+    def users(self, users):
+        """Sets the users of this Users.
 
 
-        :param relations: The relations of this Metadata.  # noqa: E501
-        :type relations: dict[str, RelationMetadata]
+        :param users: The users of this Users.
+        :type users: list[str]
         """
+        if self.local_vars_configuration.client_side_validation and users is None:
+            raise ValueError("Invalid value for `users`, must not be `None`")
 
-        self._relations = relations
+        self._users = users
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
         def convert(x):
             if hasattr(x, "to_dict"):
@@ -88,27 +81,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -116,18 +105,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Metadata):
+        if not isinstance(other, Users):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, Metadata):
+        if not isinstance(other, Users):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/node.py` & `openfga-sdk-0.4.2/openfga_sdk/models/node.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,64 +1,68 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class Node(object):
+class Node:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'name': 'str',
-        'leaf': 'Leaf',
-        'difference': 'UsersetTreeDifference',
-        'union': 'Nodes',
-        'intersection': 'Nodes'
+        "name": "str",
+        "leaf": "Leaf",
+        "difference": "UsersetTreeDifference",
+        "union": "Nodes",
+        "intersection": "Nodes",
     }
 
     attribute_map = {
-        'name': 'name',
-        'leaf': 'leaf',
-        'difference': 'difference',
-        'union': 'union',
-        'intersection': 'intersection'
+        "name": "name",
+        "leaf": "leaf",
+        "difference": "difference",
+        "union": "union",
+        "intersection": "intersection",
     }
 
-    def __init__(self, name=None, leaf=None, difference=None, union=None, intersection=None, local_vars_configuration=None):  # noqa: E501
-        """Node - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(
+        self,
+        name=None,
+        leaf=None,
+        difference=None,
+        union=None,
+        intersection=None,
+        local_vars_configuration=None,
+    ):
+        """Node - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._name = None
         self._leaf = None
         self._difference = None
@@ -74,114 +78,114 @@
         if union is not None:
             self.union = union
         if intersection is not None:
             self.intersection = intersection
 
     @property
     def name(self):
-        """Gets the name of this Node.  # noqa: E501
+        """Gets the name of this Node.
 
 
-        :return: The name of this Node.  # noqa: E501
+        :return: The name of this Node.
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this Node.
 
 
-        :param name: The name of this Node.  # noqa: E501
+        :param name: The name of this Node.
         :type name: str
         """
-        if self.local_vars_configuration.client_side_validation and name is None:  # noqa: E501
-            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and name is None:
+            raise ValueError("Invalid value for `name`, must not be `None`")
 
         self._name = name
 
     @property
     def leaf(self):
-        """Gets the leaf of this Node.  # noqa: E501
+        """Gets the leaf of this Node.
 
 
-        :return: The leaf of this Node.  # noqa: E501
+        :return: The leaf of this Node.
         :rtype: Leaf
         """
         return self._leaf
 
     @leaf.setter
     def leaf(self, leaf):
         """Sets the leaf of this Node.
 
 
-        :param leaf: The leaf of this Node.  # noqa: E501
+        :param leaf: The leaf of this Node.
         :type leaf: Leaf
         """
 
         self._leaf = leaf
 
     @property
     def difference(self):
-        """Gets the difference of this Node.  # noqa: E501
+        """Gets the difference of this Node.
 
 
-        :return: The difference of this Node.  # noqa: E501
+        :return: The difference of this Node.
         :rtype: UsersetTreeDifference
         """
         return self._difference
 
     @difference.setter
     def difference(self, difference):
         """Sets the difference of this Node.
 
 
-        :param difference: The difference of this Node.  # noqa: E501
+        :param difference: The difference of this Node.
         :type difference: UsersetTreeDifference
         """
 
         self._difference = difference
 
     @property
     def union(self):
-        """Gets the union of this Node.  # noqa: E501
+        """Gets the union of this Node.
 
 
-        :return: The union of this Node.  # noqa: E501
+        :return: The union of this Node.
         :rtype: Nodes
         """
         return self._union
 
     @union.setter
     def union(self, union):
         """Sets the union of this Node.
 
 
-        :param union: The union of this Node.  # noqa: E501
+        :param union: The union of this Node.
         :type union: Nodes
         """
 
         self._union = union
 
     @property
     def intersection(self):
-        """Gets the intersection of this Node.  # noqa: E501
+        """Gets the intersection of this Node.
 
 
-        :return: The intersection of this Node.  # noqa: E501
+        :return: The intersection of this Node.
         :rtype: Nodes
         """
         return self._intersection
 
     @intersection.setter
     def intersection(self, intersection):
         """Sets the intersection of this Node.
 
 
-        :param intersection: The intersection of this Node.  # noqa: E501
+        :param intersection: The intersection of this Node.
         :type intersection: Nodes
         """
 
         self._intersection = intersection
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
@@ -193,27 +197,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/nodes.py` & `openfga-sdk-0.4.2/openfga_sdk/models/write_request_deletes.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,87 +1,79 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class Nodes(object):
+class WriteRequestDeletes:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'nodes': 'list[Node]'
-    }
-
-    attribute_map = {
-        'nodes': 'nodes'
-    }
+    openapi_types = {"tuple_keys": "list[TupleKeyWithoutCondition]"}
+
+    attribute_map = {"tuple_keys": "tuple_keys"}
 
-    def __init__(self, nodes=None, local_vars_configuration=None):  # noqa: E501
-        """Nodes - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, tuple_keys=None, local_vars_configuration=None):
+        """WriteRequestDeletes - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
-        self._nodes = None
+        self._tuple_keys = None
         self.discriminator = None
 
-        self.nodes = nodes
+        self.tuple_keys = tuple_keys
 
     @property
-    def nodes(self):
-        """Gets the nodes of this Nodes.  # noqa: E501
+    def tuple_keys(self):
+        """Gets the tuple_keys of this WriteRequestDeletes.
 
 
-        :return: The nodes of this Nodes.  # noqa: E501
-        :rtype: list[Node]
+        :return: The tuple_keys of this WriteRequestDeletes.
+        :rtype: list[TupleKeyWithoutCondition]
         """
-        return self._nodes
+        return self._tuple_keys
 
-    @nodes.setter
-    def nodes(self, nodes):
-        """Sets the nodes of this Nodes.
+    @tuple_keys.setter
+    def tuple_keys(self, tuple_keys):
+        """Sets the tuple_keys of this WriteRequestDeletes.
 
 
-        :param nodes: The nodes of this Nodes.  # noqa: E501
-        :type nodes: list[Node]
+        :param tuple_keys: The tuple_keys of this WriteRequestDeletes.
+        :type tuple_keys: list[TupleKeyWithoutCondition]
         """
-        if self.local_vars_configuration.client_side_validation and nodes is None:  # noqa: E501
-            raise ValueError("Invalid value for `nodes`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and tuple_keys is None:
+            raise ValueError("Invalid value for `tuple_keys`, must not be `None`")
 
-        self._nodes = nodes
+        self._tuple_keys = tuple_keys
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
         def convert(x):
             if hasattr(x, "to_dict"):
@@ -89,27 +81,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -117,18 +105,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Nodes):
+        if not isinstance(other, WriteRequestDeletes):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, Nodes):
+        if not isinstance(other, WriteRequestDeletes):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/not_found_error_code.py` & `openfga-sdk-0.4.2/openfga_sdk/models/type_name.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,64 +1,79 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class NotFoundErrorCode(object):
+class TypeName:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     allowed enum values
     """
-    NO_NOT_FOUND_ERROR = "no_not_found_error"
-    UNDEFINED_ENDPOINT = "undefined_endpoint"
-    STORE_ID_NOT_FOUND = "store_id_not_found"
-    UNIMPLEMENTED = "unimplemented"
-
-    allowable_values = [NO_NOT_FOUND_ERROR, UNDEFINED_ENDPOINT, STORE_ID_NOT_FOUND, UNIMPLEMENTED]  # noqa: E501
+    UNSPECIFIED = "TYPE_NAME_UNSPECIFIED"
+    ANY = "TYPE_NAME_ANY"
+    BOOL = "TYPE_NAME_BOOL"
+    STRING = "TYPE_NAME_STRING"
+    INT = "TYPE_NAME_INT"
+    UINT = "TYPE_NAME_UINT"
+    DOUBLE = "TYPE_NAME_DOUBLE"
+    DURATION = "TYPE_NAME_DURATION"
+    TIMESTAMP = "TYPE_NAME_TIMESTAMP"
+    MAP = "TYPE_NAME_MAP"
+    LIST = "TYPE_NAME_LIST"
+    IPADDRESS = "TYPE_NAME_IPADDRESS"
+
+    allowable_values = [
+        UNSPECIFIED,
+        ANY,
+        BOOL,
+        STRING,
+        INT,
+        UINT,
+        DOUBLE,
+        DURATION,
+        TIMESTAMP,
+        MAP,
+        LIST,
+        IPADDRESS,
+    ]
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-    }
+    openapi_types = {}
 
-    attribute_map = {
-    }
+    attribute_map = {}
 
-    def __init__(self, local_vars_configuration=None):  # noqa: E501
-        """NotFoundErrorCode - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, local_vars_configuration=None):
+        """TypeName - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
         self.discriminator = None
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
@@ -70,27 +85,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -98,18 +109,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, NotFoundErrorCode):
+        if not isinstance(other, TypeName):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, NotFoundErrorCode):
+        if not isinstance(other, TypeName):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/null_value.py` & `openfga-sdk-0.4.2/openfga_sdk/models/null_value.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,61 +1,55 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class NullValue(object):
+class NullValue:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     allowed enum values
     """
     NULL_VALUE = "NULL_VALUE"
 
-    allowable_values = [NULL_VALUE]  # noqa: E501
+    allowable_values = [NULL_VALUE]
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-    }
+    openapi_types = {}
 
-    attribute_map = {
-    }
+    attribute_map = {}
 
-    def __init__(self, local_vars_configuration=None):  # noqa: E501
-        """NullValue - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, local_vars_configuration=None):
+        """NullValue - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
         self.discriminator = None
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
@@ -67,27 +61,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/object_relation.py` & `openfga-sdk-0.4.2/openfga_sdk/models/object_relation.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,58 +1,48 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class ObjectRelation(object):
+class ObjectRelation:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'object': 'str',
-        'relation': 'str'
-    }
-
-    attribute_map = {
-        'object': 'object',
-        'relation': 'relation'
-    }
+    openapi_types = {"object": "str", "relation": "str"}
+
+    attribute_map = {"object": "object", "relation": "relation"}
 
-    def __init__(self, object=None, relation=None, local_vars_configuration=None):  # noqa: E501
-        """ObjectRelation - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, object=None, relation=None, local_vars_configuration=None):
+        """ObjectRelation - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._object = None
         self._relation = None
         self.discriminator = None
@@ -60,49 +50,49 @@
         if object is not None:
             self.object = object
         if relation is not None:
             self.relation = relation
 
     @property
     def object(self):
-        """Gets the object of this ObjectRelation.  # noqa: E501
+        """Gets the object of this ObjectRelation.
 
 
-        :return: The object of this ObjectRelation.  # noqa: E501
+        :return: The object of this ObjectRelation.
         :rtype: str
         """
         return self._object
 
     @object.setter
     def object(self, object):
         """Sets the object of this ObjectRelation.
 
 
-        :param object: The object of this ObjectRelation.  # noqa: E501
+        :param object: The object of this ObjectRelation.
         :type object: str
         """
 
         self._object = object
 
     @property
     def relation(self):
-        """Gets the relation of this ObjectRelation.  # noqa: E501
+        """Gets the relation of this ObjectRelation.
 
 
-        :return: The relation of this ObjectRelation.  # noqa: E501
+        :return: The relation of this ObjectRelation.
         :rtype: str
         """
         return self._relation
 
     @relation.setter
     def relation(self, relation):
         """Sets the relation of this ObjectRelation.
 
 
-        :param relation: The relation of this ObjectRelation.  # noqa: E501
+        :param relation: The relation of this ObjectRelation.
         :type relation: str
         """
 
         self._relation = relation
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
@@ -114,27 +104,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/read_assertions_response.py` & `openfga-sdk-0.4.2/openfga_sdk/models/read_assertions_response.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,109 +1,112 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class ReadAssertionsResponse(object):
+class ReadAssertionsResponse:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'authorization_model_id': 'str',
-        'assertions': 'list[Assertion]'
-    }
+    openapi_types = {"authorization_model_id": "str", "assertions": "list[Assertion]"}
 
     attribute_map = {
-        'authorization_model_id': 'authorization_model_id',
-        'assertions': 'assertions'
+        "authorization_model_id": "authorization_model_id",
+        "assertions": "assertions",
     }
 
-    def __init__(self, authorization_model_id=None, assertions=None, local_vars_configuration=None):  # noqa: E501
-        """ReadAssertionsResponse - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(
+        self,
+        authorization_model_id=None,
+        assertions=None,
+        local_vars_configuration=None,
+    ):
+        """ReadAssertionsResponse - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._authorization_model_id = None
         self._assertions = None
         self.discriminator = None
 
         self.authorization_model_id = authorization_model_id
         if assertions is not None:
             self.assertions = assertions
 
     @property
     def authorization_model_id(self):
-        """Gets the authorization_model_id of this ReadAssertionsResponse.  # noqa: E501
+        """Gets the authorization_model_id of this ReadAssertionsResponse.
 
 
-        :return: The authorization_model_id of this ReadAssertionsResponse.  # noqa: E501
+        :return: The authorization_model_id of this ReadAssertionsResponse.
         :rtype: str
         """
         return self._authorization_model_id
 
     @authorization_model_id.setter
     def authorization_model_id(self, authorization_model_id):
         """Sets the authorization_model_id of this ReadAssertionsResponse.
 
 
-        :param authorization_model_id: The authorization_model_id of this ReadAssertionsResponse.  # noqa: E501
+        :param authorization_model_id: The authorization_model_id of this ReadAssertionsResponse.
         :type authorization_model_id: str
         """
-        if self.local_vars_configuration.client_side_validation and authorization_model_id is None:  # noqa: E501
-            raise ValueError("Invalid value for `authorization_model_id`, must not be `None`")  # noqa: E501
+        if (
+            self.local_vars_configuration.client_side_validation
+            and authorization_model_id is None
+        ):
+            raise ValueError(
+                "Invalid value for `authorization_model_id`, must not be `None`"
+            )
 
         self._authorization_model_id = authorization_model_id
 
     @property
     def assertions(self):
-        """Gets the assertions of this ReadAssertionsResponse.  # noqa: E501
+        """Gets the assertions of this ReadAssertionsResponse.
 
 
-        :return: The assertions of this ReadAssertionsResponse.  # noqa: E501
+        :return: The assertions of this ReadAssertionsResponse.
         :rtype: list[Assertion]
         """
         return self._assertions
 
     @assertions.setter
     def assertions(self, assertions):
         """Sets the assertions of this ReadAssertionsResponse.
 
 
-        :param assertions: The assertions of this ReadAssertionsResponse.  # noqa: E501
+        :param assertions: The assertions of this ReadAssertionsResponse.
         :type assertions: list[Assertion]
         """
 
         self._assertions = assertions
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
@@ -115,27 +118,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/read_authorization_model_response.py` & `openfga-sdk-0.4.2/openfga_sdk/models/read_authorization_model_response.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,82 +1,74 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class ReadAuthorizationModelResponse(object):
+class ReadAuthorizationModelResponse:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'authorization_model': 'AuthorizationModel'
-    }
-
-    attribute_map = {
-        'authorization_model': 'authorization_model'
-    }
+    openapi_types = {"authorization_model": "AuthorizationModel"}
+
+    attribute_map = {"authorization_model": "authorization_model"}
 
-    def __init__(self, authorization_model=None, local_vars_configuration=None):  # noqa: E501
-        """ReadAuthorizationModelResponse - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, authorization_model=None, local_vars_configuration=None):
+        """ReadAuthorizationModelResponse - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._authorization_model = None
         self.discriminator = None
 
         if authorization_model is not None:
             self.authorization_model = authorization_model
 
     @property
     def authorization_model(self):
-        """Gets the authorization_model of this ReadAuthorizationModelResponse.  # noqa: E501
+        """Gets the authorization_model of this ReadAuthorizationModelResponse.
 
 
-        :return: The authorization_model of this ReadAuthorizationModelResponse.  # noqa: E501
+        :return: The authorization_model of this ReadAuthorizationModelResponse.
         :rtype: AuthorizationModel
         """
         return self._authorization_model
 
     @authorization_model.setter
     def authorization_model(self, authorization_model):
         """Sets the authorization_model of this ReadAuthorizationModelResponse.
 
 
-        :param authorization_model: The authorization_model of this ReadAuthorizationModelResponse.  # noqa: E501
+        :param authorization_model: The authorization_model of this ReadAuthorizationModelResponse.
         :type authorization_model: AuthorizationModel
         """
 
         self._authorization_model = authorization_model
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
@@ -88,27 +80,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/read_authorization_models_response.py` & `openfga-sdk-0.4.2/openfga_sdk/models/read_authorization_models_response.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,111 +1,117 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class ReadAuthorizationModelsResponse(object):
+class ReadAuthorizationModelsResponse:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'authorization_models': 'list[AuthorizationModel]',
-        'continuation_token': 'str'
+        "authorization_models": "list[AuthorizationModel]",
+        "continuation_token": "str",
     }
 
     attribute_map = {
-        'authorization_models': 'authorization_models',
-        'continuation_token': 'continuation_token'
+        "authorization_models": "authorization_models",
+        "continuation_token": "continuation_token",
     }
 
-    def __init__(self, authorization_models=None, continuation_token=None, local_vars_configuration=None):  # noqa: E501
-        """ReadAuthorizationModelsResponse - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(
+        self,
+        authorization_models=None,
+        continuation_token=None,
+        local_vars_configuration=None,
+    ):
+        """ReadAuthorizationModelsResponse - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._authorization_models = None
         self._continuation_token = None
         self.discriminator = None
 
         self.authorization_models = authorization_models
         if continuation_token is not None:
             self.continuation_token = continuation_token
 
     @property
     def authorization_models(self):
-        """Gets the authorization_models of this ReadAuthorizationModelsResponse.  # noqa: E501
+        """Gets the authorization_models of this ReadAuthorizationModelsResponse.
 
 
-        :return: The authorization_models of this ReadAuthorizationModelsResponse.  # noqa: E501
+        :return: The authorization_models of this ReadAuthorizationModelsResponse.
         :rtype: list[AuthorizationModel]
         """
         return self._authorization_models
 
     @authorization_models.setter
     def authorization_models(self, authorization_models):
         """Sets the authorization_models of this ReadAuthorizationModelsResponse.
 
 
-        :param authorization_models: The authorization_models of this ReadAuthorizationModelsResponse.  # noqa: E501
+        :param authorization_models: The authorization_models of this ReadAuthorizationModelsResponse.
         :type authorization_models: list[AuthorizationModel]
         """
-        if self.local_vars_configuration.client_side_validation and authorization_models is None:  # noqa: E501
-            raise ValueError("Invalid value for `authorization_models`, must not be `None`")  # noqa: E501
+        if (
+            self.local_vars_configuration.client_side_validation
+            and authorization_models is None
+        ):
+            raise ValueError(
+                "Invalid value for `authorization_models`, must not be `None`"
+            )
 
         self._authorization_models = authorization_models
 
     @property
     def continuation_token(self):
-        """Gets the continuation_token of this ReadAuthorizationModelsResponse.  # noqa: E501
+        """Gets the continuation_token of this ReadAuthorizationModelsResponse.
 
-        The continuation token will be empty if there are no more models.  # noqa: E501
+        The continuation token will be empty if there are no more models.
 
-        :return: The continuation_token of this ReadAuthorizationModelsResponse.  # noqa: E501
+        :return: The continuation_token of this ReadAuthorizationModelsResponse.
         :rtype: str
         """
         return self._continuation_token
 
     @continuation_token.setter
     def continuation_token(self, continuation_token):
         """Sets the continuation_token of this ReadAuthorizationModelsResponse.
 
-        The continuation token will be empty if there are no more models.  # noqa: E501
+        The continuation token will be empty if there are no more models.
 
-        :param continuation_token: The continuation_token of this ReadAuthorizationModelsResponse.  # noqa: E501
+        :param continuation_token: The continuation_token of this ReadAuthorizationModelsResponse.
         :type continuation_token: str
         """
 
         self._continuation_token = continuation_token
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
@@ -117,27 +123,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/read_changes_response.py` & `openfga-sdk-0.4.2/openfga_sdk/models/read_changes_response.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,111 +1,103 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class ReadChangesResponse(object):
+class ReadChangesResponse:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'changes': 'list[TupleChange]',
-        'continuation_token': 'str'
-    }
-
-    attribute_map = {
-        'changes': 'changes',
-        'continuation_token': 'continuation_token'
-    }
+    openapi_types = {"changes": "list[TupleChange]", "continuation_token": "str"}
+
+    attribute_map = {"changes": "changes", "continuation_token": "continuation_token"}
 
-    def __init__(self, changes=None, continuation_token=None, local_vars_configuration=None):  # noqa: E501
-        """ReadChangesResponse - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(
+        self, changes=None, continuation_token=None, local_vars_configuration=None
+    ):
+        """ReadChangesResponse - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._changes = None
         self._continuation_token = None
         self.discriminator = None
 
         self.changes = changes
         if continuation_token is not None:
             self.continuation_token = continuation_token
 
     @property
     def changes(self):
-        """Gets the changes of this ReadChangesResponse.  # noqa: E501
+        """Gets the changes of this ReadChangesResponse.
 
 
-        :return: The changes of this ReadChangesResponse.  # noqa: E501
+        :return: The changes of this ReadChangesResponse.
         :rtype: list[TupleChange]
         """
         return self._changes
 
     @changes.setter
     def changes(self, changes):
         """Sets the changes of this ReadChangesResponse.
 
 
-        :param changes: The changes of this ReadChangesResponse.  # noqa: E501
+        :param changes: The changes of this ReadChangesResponse.
         :type changes: list[TupleChange]
         """
-        if self.local_vars_configuration.client_side_validation and changes is None:  # noqa: E501
-            raise ValueError("Invalid value for `changes`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and changes is None:
+            raise ValueError("Invalid value for `changes`, must not be `None`")
 
         self._changes = changes
 
     @property
     def continuation_token(self):
-        """Gets the continuation_token of this ReadChangesResponse.  # noqa: E501
+        """Gets the continuation_token of this ReadChangesResponse.
 
-        The continuation token will be identical if there are no new changes.  # noqa: E501
+        The continuation token will be identical if there are no new changes.
 
-        :return: The continuation_token of this ReadChangesResponse.  # noqa: E501
+        :return: The continuation_token of this ReadChangesResponse.
         :rtype: str
         """
         return self._continuation_token
 
     @continuation_token.setter
     def continuation_token(self, continuation_token):
         """Sets the continuation_token of this ReadChangesResponse.
 
-        The continuation token will be identical if there are no new changes.  # noqa: E501
+        The continuation token will be identical if there are no new changes.
 
-        :param continuation_token: The continuation_token of this ReadChangesResponse.  # noqa: E501
+        :param continuation_token: The continuation_token of this ReadChangesResponse.
         :type continuation_token: str
         """
 
         self._continuation_token = continuation_token
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
@@ -117,27 +109,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/read_request.py` & `openfga-sdk-0.4.2/openfga_sdk/models/read_request_tuple_key.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,138 +1,152 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class ReadRequest(object):
+class ReadRequestTupleKey:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'tuple_key': 'ReadRequestTupleKey',
-        'page_size': 'int',
-        'continuation_token': 'str'
-    }
-
-    attribute_map = {
-        'tuple_key': 'tuple_key',
-        'page_size': 'page_size',
-        'continuation_token': 'continuation_token'
-    }
+    openapi_types = {"user": "str", "relation": "str", "object": "str"}
+
+    attribute_map = {"user": "user", "relation": "relation", "object": "object"}
 
-    def __init__(self, tuple_key=None, page_size=None, continuation_token=None, local_vars_configuration=None):  # noqa: E501
-        """ReadRequest - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(
+        self, user=None, relation=None, object=None, local_vars_configuration=None
+    ):
+        """ReadRequestTupleKey - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
-        self._tuple_key = None
-        self._page_size = None
-        self._continuation_token = None
+        self._user = None
+        self._relation = None
+        self._object = None
         self.discriminator = None
 
-        if tuple_key is not None:
-            self.tuple_key = tuple_key
-        if page_size is not None:
-            self.page_size = page_size
-        if continuation_token is not None:
-            self.continuation_token = continuation_token
+        if user is not None:
+            self.user = user
+        if relation is not None:
+            self.relation = relation
+        if object is not None:
+            self.object = object
 
     @property
-    def tuple_key(self):
-        """Gets the tuple_key of this ReadRequest.  # noqa: E501
+    def user(self):
+        """Gets the user of this ReadRequestTupleKey.
 
 
-        :return: The tuple_key of this ReadRequest.  # noqa: E501
-        :rtype: ReadRequestTupleKey
+        :return: The user of this ReadRequestTupleKey.
+        :rtype: str
         """
-        return self._tuple_key
+        return self._user
 
-    @tuple_key.setter
-    def tuple_key(self, tuple_key):
-        """Sets the tuple_key of this ReadRequest.
+    @user.setter
+    def user(self, user):
+        """Sets the user of this ReadRequestTupleKey.
+
+
+        :param user: The user of this ReadRequestTupleKey.
+        :type user: str
+        """
+        if (
+            self.local_vars_configuration.client_side_validation
+            and user is not None
+            and len(user) > 512
+        ):
+            raise ValueError(
+                "Invalid value for `user`, length must be less than or equal to `512`"
+            )
 
-
-        :param tuple_key: The tuple_key of this ReadRequest.  # noqa: E501
-        :type tuple_key: ReadRequestTupleKey
-        """
-
-        self._tuple_key = tuple_key
+        self._user = user
 
     @property
-    def page_size(self):
-        """Gets the page_size of this ReadRequest.  # noqa: E501
+    def relation(self):
+        """Gets the relation of this ReadRequestTupleKey.
 
 
-        :return: The page_size of this ReadRequest.  # noqa: E501
-        :rtype: int
+        :return: The relation of this ReadRequestTupleKey.
+        :rtype: str
         """
-        return self._page_size
+        return self._relation
 
-    @page_size.setter
-    def page_size(self, page_size):
-        """Sets the page_size of this ReadRequest.
+    @relation.setter
+    def relation(self, relation):
+        """Sets the relation of this ReadRequestTupleKey.
+
+
+        :param relation: The relation of this ReadRequestTupleKey.
+        :type relation: str
+        """
+        if (
+            self.local_vars_configuration.client_side_validation
+            and relation is not None
+            and len(relation) > 50
+        ):
+            raise ValueError(
+                "Invalid value for `relation`, length must be less than or equal to `50`"
+            )
 
-
-        :param page_size: The page_size of this ReadRequest.  # noqa: E501
-        :type page_size: int
-        """
-
-        self._page_size = page_size
+        self._relation = relation
 
     @property
-    def continuation_token(self):
-        """Gets the continuation_token of this ReadRequest.  # noqa: E501
+    def object(self):
+        """Gets the object of this ReadRequestTupleKey.
 
 
-        :return: The continuation_token of this ReadRequest.  # noqa: E501
+        :return: The object of this ReadRequestTupleKey.
         :rtype: str
         """
-        return self._continuation_token
+        return self._object
 
-    @continuation_token.setter
-    def continuation_token(self, continuation_token):
-        """Sets the continuation_token of this ReadRequest.
-
-
-        :param continuation_token: The continuation_token of this ReadRequest.  # noqa: E501
-        :type continuation_token: str
-        """
+    @object.setter
+    def object(self, object):
+        """Sets the object of this ReadRequestTupleKey.
+
+
+        :param object: The object of this ReadRequestTupleKey.
+        :type object: str
+        """
+        if (
+            self.local_vars_configuration.client_side_validation
+            and object is not None
+            and len(object) > 256
+        ):
+            raise ValueError(
+                "Invalid value for `object`, length must be less than or equal to `256`"
+            )
 
-        self._continuation_token = continuation_token
+        self._object = object
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
         def convert(x):
             if hasattr(x, "to_dict"):
@@ -140,27 +154,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -168,18 +178,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ReadRequest):
+        if not isinstance(other, ReadRequestTupleKey):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, ReadRequest):
+        if not isinstance(other, ReadRequestTupleKey):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/read_request_tuple_key.py` & `openfga-sdk-0.4.2/openfga_sdk/models/tuple_key.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,175 +1,218 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class ReadRequestTupleKey(object):
+class TupleKey:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'user': 'str',
-        'relation': 'str',
-        'object': 'str'
+        "user": "str",
+        "relation": "str",
+        "object": "str",
+        "condition": "RelationshipCondition",
     }
 
     attribute_map = {
-        'user': 'user',
-        'relation': 'relation',
-        'object': 'object'
+        "user": "user",
+        "relation": "relation",
+        "object": "object",
+        "condition": "condition",
     }
 
-    def __init__(self, user=None, relation=None, object=None, local_vars_configuration=None):  # noqa: E501
-        """ReadRequestTupleKey - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(
+        self,
+        user=None,
+        relation=None,
+        object=None,
+        condition=None,
+        local_vars_configuration=None,
+    ):
+        """TupleKey - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._user = None
         self._relation = None
         self._object = None
+        self._condition = None
         self.discriminator = None
 
-        if user is not None:
-            self.user = user
-        if relation is not None:
-            self.relation = relation
-        if object is not None:
-            self.object = object
+        self.user = user
+        self.relation = relation
+        self.object = object
+        if condition is not None:
+            self.condition = condition
 
     @property
     def user(self):
-        """Gets the user of this ReadRequestTupleKey.  # noqa: E501
+        """Gets the user of this TupleKey.
 
 
-        :return: The user of this ReadRequestTupleKey.  # noqa: E501
+        :return: The user of this TupleKey.
         :rtype: str
         """
         return self._user
 
     @user.setter
     def user(self, user):
-        """Sets the user of this ReadRequestTupleKey.
+        """Sets the user of this TupleKey.
 
 
-        :param user: The user of this ReadRequestTupleKey.  # noqa: E501
+        :param user: The user of this TupleKey.
         :type user: str
         """
-        if (self.local_vars_configuration.client_side_validation and
-                user is not None and len(user) > 512):
-            raise ValueError("Invalid value for `user`, length must be less than or equal to `512`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and user is None:
+            raise ValueError("Invalid value for `user`, must not be `None`")
+        if (
+            self.local_vars_configuration.client_side_validation
+            and user is not None
+            and len(user) > 512
+        ):
+            raise ValueError(
+                "Invalid value for `user`, length must be less than or equal to `512`"
+            )
 
         self._user = user
 
     @property
     def relation(self):
-        """Gets the relation of this ReadRequestTupleKey.  # noqa: E501
+        """Gets the relation of this TupleKey.
 
 
-        :return: The relation of this ReadRequestTupleKey.  # noqa: E501
+        :return: The relation of this TupleKey.
         :rtype: str
         """
         return self._relation
 
     @relation.setter
     def relation(self, relation):
-        """Sets the relation of this ReadRequestTupleKey.
+        """Sets the relation of this TupleKey.
 
 
-        :param relation: The relation of this ReadRequestTupleKey.  # noqa: E501
+        :param relation: The relation of this TupleKey.
         :type relation: str
         """
-        if (self.local_vars_configuration.client_side_validation and
-                relation is not None and len(relation) > 50):
-            raise ValueError("Invalid value for `relation`, length must be less than or equal to `50`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and relation is None:
+            raise ValueError("Invalid value for `relation`, must not be `None`")
+        if (
+            self.local_vars_configuration.client_side_validation
+            and relation is not None
+            and len(relation) > 50
+        ):
+            raise ValueError(
+                "Invalid value for `relation`, length must be less than or equal to `50`"
+            )
 
         self._relation = relation
 
     @property
     def object(self):
-        """Gets the object of this ReadRequestTupleKey.  # noqa: E501
+        """Gets the object of this TupleKey.
 
 
-        :return: The object of this ReadRequestTupleKey.  # noqa: E501
+        :return: The object of this TupleKey.
         :rtype: str
         """
         return self._object
 
     @object.setter
     def object(self, object):
-        """Sets the object of this ReadRequestTupleKey.
+        """Sets the object of this TupleKey.
 
 
-        :param object: The object of this ReadRequestTupleKey.  # noqa: E501
+        :param object: The object of this TupleKey.
         :type object: str
         """
-        if (self.local_vars_configuration.client_side_validation and
-                object is not None and len(object) > 256):
-            raise ValueError("Invalid value for `object`, length must be less than or equal to `256`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and object is None:
+            raise ValueError("Invalid value for `object`, must not be `None`")
+        if (
+            self.local_vars_configuration.client_side_validation
+            and object is not None
+            and len(object) > 256
+        ):
+            raise ValueError(
+                "Invalid value for `object`, length must be less than or equal to `256`"
+            )
 
         self._object = object
 
+    @property
+    def condition(self):
+        """Gets the condition of this TupleKey.
+
+
+        :return: The condition of this TupleKey.
+        :rtype: RelationshipCondition
+        """
+        return self._condition
+
+    @condition.setter
+    def condition(self, condition):
+        """Sets the condition of this TupleKey.
+
+
+        :param condition: The condition of this TupleKey.
+        :type condition: RelationshipCondition
+        """
+
+        self._condition = condition
+
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
         def convert(x):
             if hasattr(x, "to_dict"):
                 args = getfullargspec(x.to_dict).args
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -177,18 +220,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ReadRequestTupleKey):
+        if not isinstance(other, TupleKey):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, ReadRequestTupleKey):
+        if not isinstance(other, TupleKey):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/relation_metadata.py` & `openfga-sdk-0.4.2/openfga_sdk/models/relation_metadata.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,114 +1,164 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class RelationMetadata(object):
+class RelationMetadata:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'directly_related_user_types': 'list[RelationReference]'
+        "directly_related_user_types": "list[RelationReference]",
+        "module": "str",
+        "source_info": "SourceInfo",
     }
 
     attribute_map = {
-        'directly_related_user_types': 'directly_related_user_types'
+        "directly_related_user_types": "directly_related_user_types",
+        "module": "module",
+        "source_info": "source_info",
     }
 
-    def __init__(self, directly_related_user_types=None, local_vars_configuration=None):  # noqa: E501
-        """RelationMetadata - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(
+        self,
+        directly_related_user_types=None,
+        module=None,
+        source_info=None,
+        local_vars_configuration=None,
+    ):
+        """RelationMetadata - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._directly_related_user_types = None
+        self._module = None
+        self._source_info = None
         self.discriminator = None
 
         if directly_related_user_types is not None:
             self.directly_related_user_types = directly_related_user_types
+        if module is not None:
+            self.module = module
+        if source_info is not None:
+            self.source_info = source_info
 
     @property
     def directly_related_user_types(self):
-        """Gets the directly_related_user_types of this RelationMetadata.  # noqa: E501
+        """Gets the directly_related_user_types of this RelationMetadata.
 
 
-        :return: The directly_related_user_types of this RelationMetadata.  # noqa: E501
+        :return: The directly_related_user_types of this RelationMetadata.
         :rtype: list[RelationReference]
         """
         return self._directly_related_user_types
 
     @directly_related_user_types.setter
     def directly_related_user_types(self, directly_related_user_types):
         """Sets the directly_related_user_types of this RelationMetadata.
 
 
-        :param directly_related_user_types: The directly_related_user_types of this RelationMetadata.  # noqa: E501
+        :param directly_related_user_types: The directly_related_user_types of this RelationMetadata.
         :type directly_related_user_types: list[RelationReference]
         """
 
         self._directly_related_user_types = directly_related_user_types
 
+    @property
+    def module(self):
+        """Gets the module of this RelationMetadata.
+
+
+        :return: The module of this RelationMetadata.
+        :rtype: str
+        """
+        return self._module
+
+    @module.setter
+    def module(self, module):
+        """Sets the module of this RelationMetadata.
+
+
+        :param module: The module of this RelationMetadata.
+        :type module: str
+        """
+
+        self._module = module
+
+    @property
+    def source_info(self):
+        """Gets the source_info of this RelationMetadata.
+
+
+        :return: The source_info of this RelationMetadata.
+        :rtype: SourceInfo
+        """
+        return self._source_info
+
+    @source_info.setter
+    def source_info(self, source_info):
+        """Sets the source_info of this RelationMetadata.
+
+
+        :param source_info: The source_info of this RelationMetadata.
+        :type source_info: SourceInfo
+        """
+
+        self._source_info = source_info
+
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
         def convert(x):
             if hasattr(x, "to_dict"):
                 args = getfullargspec(x.to_dict).args
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/relation_reference.py` & `openfga-sdk-0.4.2/openfga_sdk/models/relation_reference.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,62 +1,65 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class RelationReference(object):
+class RelationReference:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'type': 'str',
-        'relation': 'str',
-        'wildcard': 'object',
-        'condition': 'str'
+        "type": "str",
+        "relation": "str",
+        "wildcard": "object",
+        "condition": "str",
     }
 
     attribute_map = {
-        'type': 'type',
-        'relation': 'relation',
-        'wildcard': 'wildcard',
-        'condition': 'condition'
+        "type": "type",
+        "relation": "relation",
+        "wildcard": "wildcard",
+        "condition": "condition",
     }
 
-    def __init__(self, type=None, relation=None, wildcard=None, condition=None, local_vars_configuration=None):  # noqa: E501
-        """RelationReference - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(
+        self,
+        type=None,
+        relation=None,
+        wildcard=None,
+        condition=None,
+        local_vars_configuration=None,
+    ):
+        """RelationReference - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._type = None
         self._relation = None
         self._wildcard = None
@@ -69,95 +72,95 @@
         if wildcard is not None:
             self.wildcard = wildcard
         if condition is not None:
             self.condition = condition
 
     @property
     def type(self):
-        """Gets the type of this RelationReference.  # noqa: E501
+        """Gets the type of this RelationReference.
 
 
-        :return: The type of this RelationReference.  # noqa: E501
+        :return: The type of this RelationReference.
         :rtype: str
         """
         return self._type
 
     @type.setter
     def type(self, type):
         """Sets the type of this RelationReference.
 
 
-        :param type: The type of this RelationReference.  # noqa: E501
+        :param type: The type of this RelationReference.
         :type type: str
         """
-        if self.local_vars_configuration.client_side_validation and type is None:  # noqa: E501
-            raise ValueError("Invalid value for `type`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and type is None:
+            raise ValueError("Invalid value for `type`, must not be `None`")
 
         self._type = type
 
     @property
     def relation(self):
-        """Gets the relation of this RelationReference.  # noqa: E501
+        """Gets the relation of this RelationReference.
 
 
-        :return: The relation of this RelationReference.  # noqa: E501
+        :return: The relation of this RelationReference.
         :rtype: str
         """
         return self._relation
 
     @relation.setter
     def relation(self, relation):
         """Sets the relation of this RelationReference.
 
 
-        :param relation: The relation of this RelationReference.  # noqa: E501
+        :param relation: The relation of this RelationReference.
         :type relation: str
         """
 
         self._relation = relation
 
     @property
     def wildcard(self):
-        """Gets the wildcard of this RelationReference.  # noqa: E501
+        """Gets the wildcard of this RelationReference.
 
 
-        :return: The wildcard of this RelationReference.  # noqa: E501
+        :return: The wildcard of this RelationReference.
         :rtype: object
         """
         return self._wildcard
 
     @wildcard.setter
     def wildcard(self, wildcard):
         """Sets the wildcard of this RelationReference.
 
 
-        :param wildcard: The wildcard of this RelationReference.  # noqa: E501
+        :param wildcard: The wildcard of this RelationReference.
         :type wildcard: object
         """
 
         self._wildcard = wildcard
 
     @property
     def condition(self):
-        """Gets the condition of this RelationReference.  # noqa: E501
+        """Gets the condition of this RelationReference.
 
-        The name of a condition that is enforced over the allowed relation.  # noqa: E501
+        The name of a condition that is enforced over the allowed relation.
 
-        :return: The condition of this RelationReference.  # noqa: E501
+        :return: The condition of this RelationReference.
         :rtype: str
         """
         return self._condition
 
     @condition.setter
     def condition(self, condition):
         """Sets the condition of this RelationReference.
 
-        The name of a condition that is enforced over the allowed relation.  # noqa: E501
+        The name of a condition that is enforced over the allowed relation.
 
-        :param condition: The condition of this RelationReference.  # noqa: E501
+        :param condition: The condition of this RelationReference.
         :type condition: str
         """
 
         self._condition = condition
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
@@ -169,27 +172,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/relationship_condition.py` & `openfga-sdk-0.4.2/openfga_sdk/models/relationship_condition.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,116 +1,111 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class RelationshipCondition(object):
+class RelationshipCondition:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'name': 'str',
-        'context': 'object'
-    }
-
-    attribute_map = {
-        'name': 'name',
-        'context': 'context'
-    }
+    openapi_types = {"name": "str", "context": "object"}
+
+    attribute_map = {"name": "name", "context": "context"}
 
-    def __init__(self, name=None, context=None, local_vars_configuration=None):  # noqa: E501
-        """RelationshipCondition - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, name=None, context=None, local_vars_configuration=None):
+        """RelationshipCondition - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._name = None
         self._context = None
         self.discriminator = None
 
         self.name = name
         if context is not None:
             self.context = context
 
     @property
     def name(self):
-        """Gets the name of this RelationshipCondition.  # noqa: E501
+        """Gets the name of this RelationshipCondition.
 
-        A reference (by name) of the relationship condition defined in the authorization model.  # noqa: E501
+        A reference (by name) of the relationship condition defined in the authorization model.
 
-        :return: The name of this RelationshipCondition.  # noqa: E501
+        :return: The name of this RelationshipCondition.
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this RelationshipCondition.
 
-        A reference (by name) of the relationship condition defined in the authorization model.  # noqa: E501
+        A reference (by name) of the relationship condition defined in the authorization model.
 
-        :param name: The name of this RelationshipCondition.  # noqa: E501
+        :param name: The name of this RelationshipCondition.
         :type name: str
         """
-        if self.local_vars_configuration.client_side_validation and name is None:  # noqa: E501
-            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
-        if (self.local_vars_configuration.client_side_validation and
-                name is not None and len(name) > 256):
-            raise ValueError("Invalid value for `name`, length must be less than or equal to `256`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and name is None:
+            raise ValueError("Invalid value for `name`, must not be `None`")
+        if (
+            self.local_vars_configuration.client_side_validation
+            and name is not None
+            and len(name) > 256
+        ):
+            raise ValueError(
+                "Invalid value for `name`, length must be less than or equal to `256`"
+            )
 
         self._name = name
 
     @property
     def context(self):
-        """Gets the context of this RelationshipCondition.  # noqa: E501
+        """Gets the context of this RelationshipCondition.
 
-        Additional context/data to persist along with the condition. The keys must match the parameters defined by the condition, and the value types must match the parameter type definitions.  # noqa: E501
+        Additional context/data to persist along with the condition. The keys must match the parameters defined by the condition, and the value types must match the parameter type definitions.
 
-        :return: The context of this RelationshipCondition.  # noqa: E501
+        :return: The context of this RelationshipCondition.
         :rtype: object
         """
         return self._context
 
     @context.setter
     def context(self, context):
         """Sets the context of this RelationshipCondition.
 
-        Additional context/data to persist along with the condition. The keys must match the parameters defined by the condition, and the value types must match the parameter type definitions.  # noqa: E501
+        Additional context/data to persist along with the condition. The keys must match the parameters defined by the condition, and the value types must match the parameter type definitions.
 
-        :param context: The context of this RelationshipCondition.  # noqa: E501
+        :param context: The context of this RelationshipCondition.
         :type context: object
         """
 
         self._context = context
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
@@ -122,27 +117,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/store.py` & `openfga-sdk-0.4.2/openfga_sdk/models/get_store_response.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,64 +1,68 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class Store(object):
+class GetStoreResponse:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'id': 'str',
-        'name': 'str',
-        'created_at': 'datetime',
-        'updated_at': 'datetime',
-        'deleted_at': 'datetime'
+        "id": "str",
+        "name": "str",
+        "created_at": "datetime",
+        "updated_at": "datetime",
+        "deleted_at": "datetime",
     }
 
     attribute_map = {
-        'id': 'id',
-        'name': 'name',
-        'created_at': 'created_at',
-        'updated_at': 'updated_at',
-        'deleted_at': 'deleted_at'
+        "id": "id",
+        "name": "name",
+        "created_at": "created_at",
+        "updated_at": "updated_at",
+        "deleted_at": "deleted_at",
     }
 
-    def __init__(self, id=None, name=None, created_at=None, updated_at=None, deleted_at=None, local_vars_configuration=None):  # noqa: E501
-        """Store - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(
+        self,
+        id=None,
+        name=None,
+        created_at=None,
+        updated_at=None,
+        deleted_at=None,
+        local_vars_configuration=None,
+    ):
+        """GetStoreResponse - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._id = None
         self._name = None
         self._created_at = None
@@ -71,120 +75,120 @@
         self.created_at = created_at
         self.updated_at = updated_at
         if deleted_at is not None:
             self.deleted_at = deleted_at
 
     @property
     def id(self):
-        """Gets the id of this Store.  # noqa: E501
+        """Gets the id of this GetStoreResponse.
 
 
-        :return: The id of this Store.  # noqa: E501
+        :return: The id of this GetStoreResponse.
         :rtype: str
         """
         return self._id
 
     @id.setter
     def id(self, id):
-        """Sets the id of this Store.
+        """Sets the id of this GetStoreResponse.
 
 
-        :param id: The id of this Store.  # noqa: E501
+        :param id: The id of this GetStoreResponse.
         :type id: str
         """
-        if self.local_vars_configuration.client_side_validation and id is None:  # noqa: E501
-            raise ValueError("Invalid value for `id`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and id is None:
+            raise ValueError("Invalid value for `id`, must not be `None`")
 
         self._id = id
 
     @property
     def name(self):
-        """Gets the name of this Store.  # noqa: E501
+        """Gets the name of this GetStoreResponse.
 
 
-        :return: The name of this Store.  # noqa: E501
+        :return: The name of this GetStoreResponse.
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
-        """Sets the name of this Store.
+        """Sets the name of this GetStoreResponse.
 
 
-        :param name: The name of this Store.  # noqa: E501
+        :param name: The name of this GetStoreResponse.
         :type name: str
         """
-        if self.local_vars_configuration.client_side_validation and name is None:  # noqa: E501
-            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and name is None:
+            raise ValueError("Invalid value for `name`, must not be `None`")
 
         self._name = name
 
     @property
     def created_at(self):
-        """Gets the created_at of this Store.  # noqa: E501
+        """Gets the created_at of this GetStoreResponse.
 
 
-        :return: The created_at of this Store.  # noqa: E501
+        :return: The created_at of this GetStoreResponse.
         :rtype: datetime
         """
         return self._created_at
 
     @created_at.setter
     def created_at(self, created_at):
-        """Sets the created_at of this Store.
+        """Sets the created_at of this GetStoreResponse.
 
 
-        :param created_at: The created_at of this Store.  # noqa: E501
+        :param created_at: The created_at of this GetStoreResponse.
         :type created_at: datetime
         """
-        if self.local_vars_configuration.client_side_validation and created_at is None:  # noqa: E501
-            raise ValueError("Invalid value for `created_at`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and created_at is None:
+            raise ValueError("Invalid value for `created_at`, must not be `None`")
 
         self._created_at = created_at
 
     @property
     def updated_at(self):
-        """Gets the updated_at of this Store.  # noqa: E501
+        """Gets the updated_at of this GetStoreResponse.
 
 
-        :return: The updated_at of this Store.  # noqa: E501
+        :return: The updated_at of this GetStoreResponse.
         :rtype: datetime
         """
         return self._updated_at
 
     @updated_at.setter
     def updated_at(self, updated_at):
-        """Sets the updated_at of this Store.
+        """Sets the updated_at of this GetStoreResponse.
 
 
-        :param updated_at: The updated_at of this Store.  # noqa: E501
+        :param updated_at: The updated_at of this GetStoreResponse.
         :type updated_at: datetime
         """
-        if self.local_vars_configuration.client_side_validation and updated_at is None:  # noqa: E501
-            raise ValueError("Invalid value for `updated_at`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and updated_at is None:
+            raise ValueError("Invalid value for `updated_at`, must not be `None`")
 
         self._updated_at = updated_at
 
     @property
     def deleted_at(self):
-        """Gets the deleted_at of this Store.  # noqa: E501
+        """Gets the deleted_at of this GetStoreResponse.
 
 
-        :return: The deleted_at of this Store.  # noqa: E501
+        :return: The deleted_at of this GetStoreResponse.
         :rtype: datetime
         """
         return self._deleted_at
 
     @deleted_at.setter
     def deleted_at(self, deleted_at):
-        """Sets the deleted_at of this Store.
+        """Sets the deleted_at of this GetStoreResponse.
 
 
-        :param deleted_at: The deleted_at of this Store.  # noqa: E501
+        :param deleted_at: The deleted_at of this GetStoreResponse.
         :type deleted_at: datetime
         """
 
         self._deleted_at = deleted_at
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
@@ -196,27 +200,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -224,18 +224,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Store):
+        if not isinstance(other, GetStoreResponse):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, Store):
+        if not isinstance(other, GetStoreResponse):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/tuple.py` & `openfga-sdk-0.4.2/openfga_sdk/models/tuple.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,112 +1,102 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class Tuple(object):
+class Tuple:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'key': 'TupleKey',
-        'timestamp': 'datetime'
-    }
-
-    attribute_map = {
-        'key': 'key',
-        'timestamp': 'timestamp'
-    }
+    openapi_types = {"key": "TupleKey", "timestamp": "datetime"}
+
+    attribute_map = {"key": "key", "timestamp": "timestamp"}
 
-    def __init__(self, key=None, timestamp=None, local_vars_configuration=None):  # noqa: E501
-        """Tuple - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, key=None, timestamp=None, local_vars_configuration=None):
+        """Tuple - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._key = None
         self._timestamp = None
         self.discriminator = None
 
         self.key = key
         self.timestamp = timestamp
 
     @property
     def key(self):
-        """Gets the key of this Tuple.  # noqa: E501
+        """Gets the key of this Tuple.
 
 
-        :return: The key of this Tuple.  # noqa: E501
+        :return: The key of this Tuple.
         :rtype: TupleKey
         """
         return self._key
 
     @key.setter
     def key(self, key):
         """Sets the key of this Tuple.
 
 
-        :param key: The key of this Tuple.  # noqa: E501
+        :param key: The key of this Tuple.
         :type key: TupleKey
         """
-        if self.local_vars_configuration.client_side_validation and key is None:  # noqa: E501
-            raise ValueError("Invalid value for `key`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and key is None:
+            raise ValueError("Invalid value for `key`, must not be `None`")
 
         self._key = key
 
     @property
     def timestamp(self):
-        """Gets the timestamp of this Tuple.  # noqa: E501
+        """Gets the timestamp of this Tuple.
 
 
-        :return: The timestamp of this Tuple.  # noqa: E501
+        :return: The timestamp of this Tuple.
         :rtype: datetime
         """
         return self._timestamp
 
     @timestamp.setter
     def timestamp(self, timestamp):
         """Sets the timestamp of this Tuple.
 
 
-        :param timestamp: The timestamp of this Tuple.  # noqa: E501
+        :param timestamp: The timestamp of this Tuple.
         :type timestamp: datetime
         """
-        if self.local_vars_configuration.client_side_validation and timestamp is None:  # noqa: E501
-            raise ValueError("Invalid value for `timestamp`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and timestamp is None:
+            raise ValueError("Invalid value for `timestamp`, must not be `None`")
 
         self._timestamp = timestamp
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
@@ -116,27 +106,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/tuple_change.py` & `openfga-sdk-0.4.2/openfga_sdk/models/tuple_change.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,60 +1,62 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class TupleChange(object):
+class TupleChange:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'tuple_key': 'TupleKey',
-        'operation': 'TupleOperation',
-        'timestamp': 'datetime'
+        "tuple_key": "TupleKey",
+        "operation": "TupleOperation",
+        "timestamp": "datetime",
     }
 
     attribute_map = {
-        'tuple_key': 'tuple_key',
-        'operation': 'operation',
-        'timestamp': 'timestamp'
+        "tuple_key": "tuple_key",
+        "operation": "operation",
+        "timestamp": "timestamp",
     }
 
-    def __init__(self, tuple_key=None, operation=None, timestamp=None, local_vars_configuration=None):  # noqa: E501
-        """TupleChange - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(
+        self,
+        tuple_key=None,
+        operation=None,
+        timestamp=None,
+        local_vars_configuration=None,
+    ):
+        """TupleChange - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._tuple_key = None
         self._operation = None
         self._timestamp = None
@@ -62,78 +64,78 @@
 
         self.tuple_key = tuple_key
         self.operation = operation
         self.timestamp = timestamp
 
     @property
     def tuple_key(self):
-        """Gets the tuple_key of this TupleChange.  # noqa: E501
+        """Gets the tuple_key of this TupleChange.
 
 
-        :return: The tuple_key of this TupleChange.  # noqa: E501
+        :return: The tuple_key of this TupleChange.
         :rtype: TupleKey
         """
         return self._tuple_key
 
     @tuple_key.setter
     def tuple_key(self, tuple_key):
         """Sets the tuple_key of this TupleChange.
 
 
-        :param tuple_key: The tuple_key of this TupleChange.  # noqa: E501
+        :param tuple_key: The tuple_key of this TupleChange.
         :type tuple_key: TupleKey
         """
-        if self.local_vars_configuration.client_side_validation and tuple_key is None:  # noqa: E501
-            raise ValueError("Invalid value for `tuple_key`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and tuple_key is None:
+            raise ValueError("Invalid value for `tuple_key`, must not be `None`")
 
         self._tuple_key = tuple_key
 
     @property
     def operation(self):
-        """Gets the operation of this TupleChange.  # noqa: E501
+        """Gets the operation of this TupleChange.
 
 
-        :return: The operation of this TupleChange.  # noqa: E501
+        :return: The operation of this TupleChange.
         :rtype: TupleOperation
         """
         return self._operation
 
     @operation.setter
     def operation(self, operation):
         """Sets the operation of this TupleChange.
 
 
-        :param operation: The operation of this TupleChange.  # noqa: E501
+        :param operation: The operation of this TupleChange.
         :type operation: TupleOperation
         """
-        if self.local_vars_configuration.client_side_validation and operation is None:  # noqa: E501
-            raise ValueError("Invalid value for `operation`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and operation is None:
+            raise ValueError("Invalid value for `operation`, must not be `None`")
 
         self._operation = operation
 
     @property
     def timestamp(self):
-        """Gets the timestamp of this TupleChange.  # noqa: E501
+        """Gets the timestamp of this TupleChange.
 
 
-        :return: The timestamp of this TupleChange.  # noqa: E501
+        :return: The timestamp of this TupleChange.
         :rtype: datetime
         """
         return self._timestamp
 
     @timestamp.setter
     def timestamp(self, timestamp):
         """Sets the timestamp of this TupleChange.
 
 
-        :param timestamp: The timestamp of this TupleChange.  # noqa: E501
+        :param timestamp: The timestamp of this TupleChange.
         :type timestamp: datetime
         """
-        if self.local_vars_configuration.client_side_validation and timestamp is None:  # noqa: E501
-            raise ValueError("Invalid value for `timestamp`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and timestamp is None:
+            raise ValueError("Invalid value for `timestamp`, must not be `None`")
 
         self._timestamp = timestamp
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
@@ -143,27 +145,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/tuple_operation.py` & `openfga-sdk-0.4.2/openfga_sdk/models/tuple_operation.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,62 +1,56 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class TupleOperation(object):
+class TupleOperation:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     allowed enum values
     """
     WRITE = "TUPLE_OPERATION_WRITE"
     DELETE = "TUPLE_OPERATION_DELETE"
 
-    allowable_values = [WRITE, DELETE]  # noqa: E501
+    allowable_values = [WRITE, DELETE]
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-    }
+    openapi_types = {}
 
-    attribute_map = {
-    }
+    attribute_map = {}
 
-    def __init__(self, local_vars_configuration=None):  # noqa: E501
-        """TupleOperation - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, local_vars_configuration=None):
+        """TupleOperation - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
         self.discriminator = None
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
@@ -68,27 +62,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/tuple_to_userset.py` & `openfga-sdk-0.4.2/openfga_sdk/models/userset_tree_tuple_to_userset.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,114 +1,104 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class TupleToUserset(object):
+class UsersetTreeTupleToUserset:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'tupleset': 'ObjectRelation',
-        'computed_userset': 'ObjectRelation'
-    }
-
-    attribute_map = {
-        'tupleset': 'tupleset',
-        'computed_userset': 'computedUserset'
-    }
+    openapi_types = {"tupleset": "str", "computed": "list[Computed]"}
+
+    attribute_map = {"tupleset": "tupleset", "computed": "computed"}
 
-    def __init__(self, tupleset=None, computed_userset=None, local_vars_configuration=None):  # noqa: E501
-        """TupleToUserset - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, tupleset=None, computed=None, local_vars_configuration=None):
+        """UsersetTreeTupleToUserset - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._tupleset = None
-        self._computed_userset = None
+        self._computed = None
         self.discriminator = None
 
         self.tupleset = tupleset
-        self.computed_userset = computed_userset
+        self.computed = computed
 
     @property
     def tupleset(self):
-        """Gets the tupleset of this TupleToUserset.  # noqa: E501
+        """Gets the tupleset of this UsersetTreeTupleToUserset.
 
 
-        :return: The tupleset of this TupleToUserset.  # noqa: E501
-        :rtype: ObjectRelation
+        :return: The tupleset of this UsersetTreeTupleToUserset.
+        :rtype: str
         """
         return self._tupleset
 
     @tupleset.setter
     def tupleset(self, tupleset):
-        """Sets the tupleset of this TupleToUserset.
+        """Sets the tupleset of this UsersetTreeTupleToUserset.
 
 
-        :param tupleset: The tupleset of this TupleToUserset.  # noqa: E501
-        :type tupleset: ObjectRelation
+        :param tupleset: The tupleset of this UsersetTreeTupleToUserset.
+        :type tupleset: str
         """
-        if self.local_vars_configuration.client_side_validation and tupleset is None:  # noqa: E501
-            raise ValueError("Invalid value for `tupleset`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and tupleset is None:
+            raise ValueError("Invalid value for `tupleset`, must not be `None`")
 
         self._tupleset = tupleset
 
     @property
-    def computed_userset(self):
-        """Gets the computed_userset of this TupleToUserset.  # noqa: E501
+    def computed(self):
+        """Gets the computed of this UsersetTreeTupleToUserset.
 
 
-        :return: The computed_userset of this TupleToUserset.  # noqa: E501
-        :rtype: ObjectRelation
+        :return: The computed of this UsersetTreeTupleToUserset.
+        :rtype: list[Computed]
         """
-        return self._computed_userset
+        return self._computed
 
-    @computed_userset.setter
-    def computed_userset(self, computed_userset):
-        """Sets the computed_userset of this TupleToUserset.
+    @computed.setter
+    def computed(self, computed):
+        """Sets the computed of this UsersetTreeTupleToUserset.
 
 
-        :param computed_userset: The computed_userset of this TupleToUserset.  # noqa: E501
-        :type computed_userset: ObjectRelation
+        :param computed: The computed of this UsersetTreeTupleToUserset.
+        :type computed: list[Computed]
         """
-        if self.local_vars_configuration.client_side_validation and computed_userset is None:  # noqa: E501
-            raise ValueError("Invalid value for `computed_userset`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and computed is None:
+            raise ValueError("Invalid value for `computed`, must not be `None`")
 
-        self._computed_userset = computed_userset
+        self._computed = computed
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
         def convert(x):
             if hasattr(x, "to_dict"):
@@ -116,27 +106,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -144,18 +130,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, TupleToUserset):
+        if not isinstance(other, UsersetTreeTupleToUserset):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, TupleToUserset):
+        if not isinstance(other, UsersetTreeTupleToUserset):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/type_definition.py` & `openfga-sdk-0.4.2/openfga_sdk/models/assertion_tuple_key.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,139 +1,155 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class TypeDefinition(object):
+class AssertionTupleKey:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'type': 'str',
-        'relations': 'dict[str, Userset]',
-        'metadata': 'Metadata'
-    }
-
-    attribute_map = {
-        'type': 'type',
-        'relations': 'relations',
-        'metadata': 'metadata'
-    }
+    openapi_types = {"object": "str", "relation": "str", "user": "str"}
+
+    attribute_map = {"object": "object", "relation": "relation", "user": "user"}
 
-    def __init__(self, type=None, relations=None, metadata=None, local_vars_configuration=None):  # noqa: E501
-        """TypeDefinition - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(
+        self, object=None, relation=None, user=None, local_vars_configuration=None
+    ):
+        """AssertionTupleKey - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
-        self._type = None
-        self._relations = None
-        self._metadata = None
+        self._object = None
+        self._relation = None
+        self._user = None
         self.discriminator = None
 
-        self.type = type
-        if relations is not None:
-            self.relations = relations
-        if metadata is not None:
-            self.metadata = metadata
+        self.object = object
+        self.relation = relation
+        self.user = user
 
     @property
-    def type(self):
-        """Gets the type of this TypeDefinition.  # noqa: E501
+    def object(self):
+        """Gets the object of this AssertionTupleKey.
 
 
-        :return: The type of this TypeDefinition.  # noqa: E501
+        :return: The object of this AssertionTupleKey.
         :rtype: str
         """
-        return self._type
+        return self._object
 
-    @type.setter
-    def type(self, type):
-        """Sets the type of this TypeDefinition.
+    @object.setter
+    def object(self, object):
+        """Sets the object of this AssertionTupleKey.
+
+
+        :param object: The object of this AssertionTupleKey.
+        :type object: str
+        """
+        if self.local_vars_configuration.client_side_validation and object is None:
+            raise ValueError("Invalid value for `object`, must not be `None`")
+        if (
+            self.local_vars_configuration.client_side_validation
+            and object is not None
+            and len(object) > 256
+        ):
+            raise ValueError(
+                "Invalid value for `object`, length must be less than or equal to `256`"
+            )
 
-
-        :param type: The type of this TypeDefinition.  # noqa: E501
-        :type type: str
-        """
-        if self.local_vars_configuration.client_side_validation and type is None:  # noqa: E501
-            raise ValueError("Invalid value for `type`, must not be `None`")  # noqa: E501
-
-        self._type = type
+        self._object = object
 
     @property
-    def relations(self):
-        """Gets the relations of this TypeDefinition.  # noqa: E501
+    def relation(self):
+        """Gets the relation of this AssertionTupleKey.
 
 
-        :return: The relations of this TypeDefinition.  # noqa: E501
-        :rtype: dict[str, Userset]
+        :return: The relation of this AssertionTupleKey.
+        :rtype: str
         """
-        return self._relations
+        return self._relation
 
-    @relations.setter
-    def relations(self, relations):
-        """Sets the relations of this TypeDefinition.
+    @relation.setter
+    def relation(self, relation):
+        """Sets the relation of this AssertionTupleKey.
+
+
+        :param relation: The relation of this AssertionTupleKey.
+        :type relation: str
+        """
+        if self.local_vars_configuration.client_side_validation and relation is None:
+            raise ValueError("Invalid value for `relation`, must not be `None`")
+        if (
+            self.local_vars_configuration.client_side_validation
+            and relation is not None
+            and len(relation) > 50
+        ):
+            raise ValueError(
+                "Invalid value for `relation`, length must be less than or equal to `50`"
+            )
 
-
-        :param relations: The relations of this TypeDefinition.  # noqa: E501
-        :type relations: dict[str, Userset]
-        """
-
-        self._relations = relations
+        self._relation = relation
 
     @property
-    def metadata(self):
-        """Gets the metadata of this TypeDefinition.  # noqa: E501
+    def user(self):
+        """Gets the user of this AssertionTupleKey.
 
 
-        :return: The metadata of this TypeDefinition.  # noqa: E501
-        :rtype: Metadata
+        :return: The user of this AssertionTupleKey.
+        :rtype: str
         """
-        return self._metadata
+        return self._user
 
-    @metadata.setter
-    def metadata(self, metadata):
-        """Sets the metadata of this TypeDefinition.
-
-
-        :param metadata: The metadata of this TypeDefinition.  # noqa: E501
-        :type metadata: Metadata
-        """
+    @user.setter
+    def user(self, user):
+        """Sets the user of this AssertionTupleKey.
+
+
+        :param user: The user of this AssertionTupleKey.
+        :type user: str
+        """
+        if self.local_vars_configuration.client_side_validation and user is None:
+            raise ValueError("Invalid value for `user`, must not be `None`")
+        if (
+            self.local_vars_configuration.client_side_validation
+            and user is not None
+            and len(user) > 512
+        ):
+            raise ValueError(
+                "Invalid value for `user`, length must be less than or equal to `512`"
+            )
 
-        self._metadata = metadata
+        self._user = user
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
         def convert(x):
             if hasattr(x, "to_dict"):
@@ -141,27 +157,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -169,18 +181,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, TypeDefinition):
+        if not isinstance(other, AssertionTupleKey):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, TypeDefinition):
+        if not isinstance(other, AssertionTupleKey):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/type_name.py` & `openfga-sdk-0.4.2/openfga_sdk/models/nodes.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,104 +1,103 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class TypeName(object):
+class Nodes:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
-    allowed enum values
-    """
-    UNSPECIFIED = "TYPE_NAME_UNSPECIFIED"
-    ANY = "TYPE_NAME_ANY"
-    BOOL = "TYPE_NAME_BOOL"
-    STRING = "TYPE_NAME_STRING"
-    INT = "TYPE_NAME_INT"
-    UINT = "TYPE_NAME_UINT"
-    DOUBLE = "TYPE_NAME_DOUBLE"
-    DURATION = "TYPE_NAME_DURATION"
-    TIMESTAMP = "TYPE_NAME_TIMESTAMP"
-    MAP = "TYPE_NAME_MAP"
-    LIST = "TYPE_NAME_LIST"
-    IPADDRESS = "TYPE_NAME_IPADDRESS"
-
-    allowable_values = [UNSPECIFIED, ANY, BOOL, STRING, INT, UINT, DOUBLE, DURATION, TIMESTAMP, MAP, LIST, IPADDRESS]  # noqa: E501
-
-    """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-    }
+    openapi_types = {"nodes": "list[Node]"}
 
-    attribute_map = {
-    }
+    attribute_map = {"nodes": "nodes"}
 
-    def __init__(self, local_vars_configuration=None):  # noqa: E501
-        """TypeName - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, nodes=None, local_vars_configuration=None):
+        """Nodes - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
+
+        self._nodes = None
         self.discriminator = None
 
+        self.nodes = nodes
+
+    @property
+    def nodes(self):
+        """Gets the nodes of this Nodes.
+
+
+        :return: The nodes of this Nodes.
+        :rtype: list[Node]
+        """
+        return self._nodes
+
+    @nodes.setter
+    def nodes(self, nodes):
+        """Sets the nodes of this Nodes.
+
+
+        :param nodes: The nodes of this Nodes.
+        :type nodes: list[Node]
+        """
+        if self.local_vars_configuration.client_side_validation and nodes is None:
+            raise ValueError("Invalid value for `nodes`, must not be `None`")
+
+        self._nodes = nodes
+
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
         def convert(x):
             if hasattr(x, "to_dict"):
                 args = getfullargspec(x.to_dict).args
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -106,18 +105,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, TypeName):
+        if not isinstance(other, Nodes):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, TypeName):
+        if not isinstance(other, Nodes):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/users.py` & `openfga-sdk-0.4.2/openfga_sdk/models/usersets.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,87 +1,79 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class Users(object):
+class Usersets:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'users': 'list[str]'
-    }
-
-    attribute_map = {
-        'users': 'users'
-    }
+    openapi_types = {"child": "list[Userset]"}
+
+    attribute_map = {"child": "child"}
 
-    def __init__(self, users=None, local_vars_configuration=None):  # noqa: E501
-        """Users - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, child=None, local_vars_configuration=None):
+        """Usersets - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
-        self._users = None
+        self._child = None
         self.discriminator = None
 
-        self.users = users
+        self.child = child
 
     @property
-    def users(self):
-        """Gets the users of this Users.  # noqa: E501
+    def child(self):
+        """Gets the child of this Usersets.
 
 
-        :return: The users of this Users.  # noqa: E501
-        :rtype: list[str]
+        :return: The child of this Usersets.
+        :rtype: list[Userset]
         """
-        return self._users
+        return self._child
 
-    @users.setter
-    def users(self, users):
-        """Sets the users of this Users.
+    @child.setter
+    def child(self, child):
+        """Sets the child of this Usersets.
 
 
-        :param users: The users of this Users.  # noqa: E501
-        :type users: list[str]
+        :param child: The child of this Usersets.
+        :type child: list[Userset]
         """
-        if self.local_vars_configuration.client_side_validation and users is None:  # noqa: E501
-            raise ValueError("Invalid value for `users`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and child is None:
+            raise ValueError("Invalid value for `child`, must not be `None`")
 
-        self._users = users
+        self._child = child
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
         def convert(x):
             if hasattr(x, "to_dict"):
@@ -89,27 +81,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -117,18 +105,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Users):
+        if not isinstance(other, Usersets):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, Users):
+        if not isinstance(other, Usersets):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/userset.py` & `openfga-sdk-0.4.2/openfga_sdk/models/userset.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,66 +1,71 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class Userset(object):
+class Userset:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'this': 'object',
-        'computed_userset': 'ObjectRelation',
-        'tuple_to_userset': 'TupleToUserset',
-        'union': 'Usersets',
-        'intersection': 'Usersets',
-        'difference': 'Difference'
+        "this": "object",
+        "computed_userset": "ObjectRelation",
+        "tuple_to_userset": "TupleToUserset",
+        "union": "Usersets",
+        "intersection": "Usersets",
+        "difference": "Difference",
     }
 
     attribute_map = {
-        'this': 'this',
-        'computed_userset': 'computedUserset',
-        'tuple_to_userset': 'tupleToUserset',
-        'union': 'union',
-        'intersection': 'intersection',
-        'difference': 'difference'
+        "this": "this",
+        "computed_userset": "computedUserset",
+        "tuple_to_userset": "tupleToUserset",
+        "union": "union",
+        "intersection": "intersection",
+        "difference": "difference",
     }
 
-    def __init__(self, this=None, computed_userset=None, tuple_to_userset=None, union=None, intersection=None, difference=None, local_vars_configuration=None):  # noqa: E501
-        """Userset - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(
+        self,
+        this=None,
+        computed_userset=None,
+        tuple_to_userset=None,
+        union=None,
+        intersection=None,
+        difference=None,
+        local_vars_configuration=None,
+    ):
+        """Userset - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._this = None
         self._computed_userset = None
         self._tuple_to_userset = None
@@ -80,135 +85,135 @@
         if intersection is not None:
             self.intersection = intersection
         if difference is not None:
             self.difference = difference
 
     @property
     def this(self):
-        """Gets the this of this Userset.  # noqa: E501
+        """Gets the this of this Userset.
 
-        A DirectUserset is a sentinel message for referencing the direct members specified by an object/relation mapping.  # noqa: E501
+        A DirectUserset is a sentinel message for referencing the direct members specified by an object/relation mapping.
 
-        :return: The this of this Userset.  # noqa: E501
+        :return: The this of this Userset.
         :rtype: object
         """
         return self._this
 
     @this.setter
     def this(self, this):
         """Sets the this of this Userset.
 
-        A DirectUserset is a sentinel message for referencing the direct members specified by an object/relation mapping.  # noqa: E501
+        A DirectUserset is a sentinel message for referencing the direct members specified by an object/relation mapping.
 
-        :param this: The this of this Userset.  # noqa: E501
+        :param this: The this of this Userset.
         :type this: object
         """
 
         self._this = this
 
     @property
     def computed_userset(self):
-        """Gets the computed_userset of this Userset.  # noqa: E501
+        """Gets the computed_userset of this Userset.
 
 
-        :return: The computed_userset of this Userset.  # noqa: E501
+        :return: The computed_userset of this Userset.
         :rtype: ObjectRelation
         """
         return self._computed_userset
 
     @computed_userset.setter
     def computed_userset(self, computed_userset):
         """Sets the computed_userset of this Userset.
 
 
-        :param computed_userset: The computed_userset of this Userset.  # noqa: E501
+        :param computed_userset: The computed_userset of this Userset.
         :type computed_userset: ObjectRelation
         """
 
         self._computed_userset = computed_userset
 
     @property
     def tuple_to_userset(self):
-        """Gets the tuple_to_userset of this Userset.  # noqa: E501
+        """Gets the tuple_to_userset of this Userset.
 
 
-        :return: The tuple_to_userset of this Userset.  # noqa: E501
+        :return: The tuple_to_userset of this Userset.
         :rtype: TupleToUserset
         """
         return self._tuple_to_userset
 
     @tuple_to_userset.setter
     def tuple_to_userset(self, tuple_to_userset):
         """Sets the tuple_to_userset of this Userset.
 
 
-        :param tuple_to_userset: The tuple_to_userset of this Userset.  # noqa: E501
+        :param tuple_to_userset: The tuple_to_userset of this Userset.
         :type tuple_to_userset: TupleToUserset
         """
 
         self._tuple_to_userset = tuple_to_userset
 
     @property
     def union(self):
-        """Gets the union of this Userset.  # noqa: E501
+        """Gets the union of this Userset.
 
 
-        :return: The union of this Userset.  # noqa: E501
+        :return: The union of this Userset.
         :rtype: Usersets
         """
         return self._union
 
     @union.setter
     def union(self, union):
         """Sets the union of this Userset.
 
 
-        :param union: The union of this Userset.  # noqa: E501
+        :param union: The union of this Userset.
         :type union: Usersets
         """
 
         self._union = union
 
     @property
     def intersection(self):
-        """Gets the intersection of this Userset.  # noqa: E501
+        """Gets the intersection of this Userset.
 
 
-        :return: The intersection of this Userset.  # noqa: E501
+        :return: The intersection of this Userset.
         :rtype: Usersets
         """
         return self._intersection
 
     @intersection.setter
     def intersection(self, intersection):
         """Sets the intersection of this Userset.
 
 
-        :param intersection: The intersection of this Userset.  # noqa: E501
+        :param intersection: The intersection of this Userset.
         :type intersection: Usersets
         """
 
         self._intersection = intersection
 
     @property
     def difference(self):
-        """Gets the difference of this Userset.  # noqa: E501
+        """Gets the difference of this Userset.
 
 
-        :return: The difference of this Userset.  # noqa: E501
+        :return: The difference of this Userset.
         :rtype: Difference
         """
         return self._difference
 
     @difference.setter
     def difference(self, difference):
         """Sets the difference of this Userset.
 
 
-        :param difference: The difference of this Userset.  # noqa: E501
+        :param difference: The difference of this Userset.
         :type difference: Difference
         """
 
         self._difference = difference
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
@@ -220,27 +225,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/userset_tree.py` & `openfga-sdk-0.4.2/openfga_sdk/models/userset_tree.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,82 +1,74 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class UsersetTree(object):
+class UsersetTree:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'root': 'Node'
-    }
-
-    attribute_map = {
-        'root': 'root'
-    }
+    openapi_types = {"root": "Node"}
+
+    attribute_map = {"root": "root"}
 
-    def __init__(self, root=None, local_vars_configuration=None):  # noqa: E501
-        """UsersetTree - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, root=None, local_vars_configuration=None):
+        """UsersetTree - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._root = None
         self.discriminator = None
 
         if root is not None:
             self.root = root
 
     @property
     def root(self):
-        """Gets the root of this UsersetTree.  # noqa: E501
+        """Gets the root of this UsersetTree.
 
 
-        :return: The root of this UsersetTree.  # noqa: E501
+        :return: The root of this UsersetTree.
         :rtype: Node
         """
         return self._root
 
     @root.setter
     def root(self, root):
         """Sets the root of this UsersetTree.
 
 
-        :param root: The root of this UsersetTree.  # noqa: E501
+        :param root: The root of this UsersetTree.
         :type root: Node
         """
 
         self._root = root
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
@@ -88,27 +80,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/userset_tree_difference.py` & `openfga-sdk-0.4.2/openfga_sdk/models/metadata.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,114 +1,140 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class UsersetTreeDifference(object):
+class Metadata:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'base': 'Node',
-        'subtract': 'Node'
+        "relations": "dict[str, RelationMetadata]",
+        "module": "str",
+        "source_info": "SourceInfo",
     }
 
     attribute_map = {
-        'base': 'base',
-        'subtract': 'subtract'
+        "relations": "relations",
+        "module": "module",
+        "source_info": "source_info",
     }
 
-    def __init__(self, base=None, subtract=None, local_vars_configuration=None):  # noqa: E501
-        """UsersetTreeDifference - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(
+        self,
+        relations=None,
+        module=None,
+        source_info=None,
+        local_vars_configuration=None,
+    ):
+        """Metadata - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
-        self._base = None
-        self._subtract = None
+        self._relations = None
+        self._module = None
+        self._source_info = None
         self.discriminator = None
 
-        self.base = base
-        self.subtract = subtract
+        if relations is not None:
+            self.relations = relations
+        if module is not None:
+            self.module = module
+        if source_info is not None:
+            self.source_info = source_info
+
+    @property
+    def relations(self):
+        """Gets the relations of this Metadata.
+
+
+        :return: The relations of this Metadata.
+        :rtype: dict[str, RelationMetadata]
+        """
+        return self._relations
+
+    @relations.setter
+    def relations(self, relations):
+        """Sets the relations of this Metadata.
+
+
+        :param relations: The relations of this Metadata.
+        :type relations: dict[str, RelationMetadata]
+        """
+
+        self._relations = relations
 
     @property
-    def base(self):
-        """Gets the base of this UsersetTreeDifference.  # noqa: E501
+    def module(self):
+        """Gets the module of this Metadata.
 
 
-        :return: The base of this UsersetTreeDifference.  # noqa: E501
-        :rtype: Node
+        :return: The module of this Metadata.
+        :rtype: str
         """
-        return self._base
+        return self._module
 
-    @base.setter
-    def base(self, base):
-        """Sets the base of this UsersetTreeDifference.
+    @module.setter
+    def module(self, module):
+        """Sets the module of this Metadata.
 
 
-        :param base: The base of this UsersetTreeDifference.  # noqa: E501
-        :type base: Node
+        :param module: The module of this Metadata.
+        :type module: str
         """
-        if self.local_vars_configuration.client_side_validation and base is None:  # noqa: E501
-            raise ValueError("Invalid value for `base`, must not be `None`")  # noqa: E501
 
-        self._base = base
+        self._module = module
 
     @property
-    def subtract(self):
-        """Gets the subtract of this UsersetTreeDifference.  # noqa: E501
+    def source_info(self):
+        """Gets the source_info of this Metadata.
 
 
-        :return: The subtract of this UsersetTreeDifference.  # noqa: E501
-        :rtype: Node
+        :return: The source_info of this Metadata.
+        :rtype: SourceInfo
         """
-        return self._subtract
+        return self._source_info
 
-    @subtract.setter
-    def subtract(self, subtract):
-        """Sets the subtract of this UsersetTreeDifference.
+    @source_info.setter
+    def source_info(self, source_info):
+        """Sets the source_info of this Metadata.
 
 
-        :param subtract: The subtract of this UsersetTreeDifference.  # noqa: E501
-        :type subtract: Node
+        :param source_info: The source_info of this Metadata.
+        :type source_info: SourceInfo
         """
-        if self.local_vars_configuration.client_side_validation and subtract is None:  # noqa: E501
-            raise ValueError("Invalid value for `subtract`, must not be `None`")  # noqa: E501
 
-        self._subtract = subtract
+        self._source_info = source_info
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
         def convert(x):
             if hasattr(x, "to_dict"):
@@ -116,27 +142,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -144,18 +166,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, UsersetTreeDifference):
+        if not isinstance(other, Metadata):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, UsersetTreeDifference):
+        if not isinstance(other, Metadata):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/usersets.py` & `openfga-sdk-0.4.2/openfga_sdk/models/write_request_writes.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,87 +1,79 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class Usersets(object):
+class WriteRequestWrites:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'child': 'list[Userset]'
-    }
-
-    attribute_map = {
-        'child': 'child'
-    }
+    openapi_types = {"tuple_keys": "list[TupleKey]"}
+
+    attribute_map = {"tuple_keys": "tuple_keys"}
 
-    def __init__(self, child=None, local_vars_configuration=None):  # noqa: E501
-        """Usersets - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, tuple_keys=None, local_vars_configuration=None):
+        """WriteRequestWrites - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
-        self._child = None
+        self._tuple_keys = None
         self.discriminator = None
 
-        self.child = child
+        self.tuple_keys = tuple_keys
 
     @property
-    def child(self):
-        """Gets the child of this Usersets.  # noqa: E501
+    def tuple_keys(self):
+        """Gets the tuple_keys of this WriteRequestWrites.
 
 
-        :return: The child of this Usersets.  # noqa: E501
-        :rtype: list[Userset]
+        :return: The tuple_keys of this WriteRequestWrites.
+        :rtype: list[TupleKey]
         """
-        return self._child
+        return self._tuple_keys
 
-    @child.setter
-    def child(self, child):
-        """Sets the child of this Usersets.
+    @tuple_keys.setter
+    def tuple_keys(self, tuple_keys):
+        """Sets the tuple_keys of this WriteRequestWrites.
 
 
-        :param child: The child of this Usersets.  # noqa: E501
-        :type child: list[Userset]
+        :param tuple_keys: The tuple_keys of this WriteRequestWrites.
+        :type tuple_keys: list[TupleKey]
         """
-        if self.local_vars_configuration.client_side_validation and child is None:  # noqa: E501
-            raise ValueError("Invalid value for `child`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and tuple_keys is None:
+            raise ValueError("Invalid value for `tuple_keys`, must not be `None`")
 
-        self._child = child
+        self._tuple_keys = tuple_keys
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
         def convert(x):
             if hasattr(x, "to_dict"):
@@ -89,27 +81,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -117,18 +105,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, Usersets):
+        if not isinstance(other, WriteRequestWrites):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, Usersets):
+        if not isinstance(other, WriteRequestWrites):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/validation_error_message_response.py` & `openfga-sdk-0.4.2/openfga_sdk/models/aborted_message_response.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,58 +1,48 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class ValidationErrorMessageResponse(object):
+class AbortedMessageResponse:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'code': 'ErrorCode',
-        'message': 'str'
-    }
-
-    attribute_map = {
-        'code': 'code',
-        'message': 'message'
-    }
+    openapi_types = {"code": "str", "message": "str"}
+
+    attribute_map = {"code": "code", "message": "message"}
 
-    def __init__(self, code=None, message=None, local_vars_configuration=None):  # noqa: E501
-        """ValidationErrorMessageResponse - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, code=None, message=None, local_vars_configuration=None):
+        """AbortedMessageResponse - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._code = None
         self._message = None
         self.discriminator = None
@@ -60,49 +50,49 @@
         if code is not None:
             self.code = code
         if message is not None:
             self.message = message
 
     @property
     def code(self):
-        """Gets the code of this ValidationErrorMessageResponse.  # noqa: E501
+        """Gets the code of this AbortedMessageResponse.
 
 
-        :return: The code of this ValidationErrorMessageResponse.  # noqa: E501
-        :rtype: ErrorCode
+        :return: The code of this AbortedMessageResponse.
+        :rtype: str
         """
         return self._code
 
     @code.setter
     def code(self, code):
-        """Sets the code of this ValidationErrorMessageResponse.
+        """Sets the code of this AbortedMessageResponse.
 
 
-        :param code: The code of this ValidationErrorMessageResponse.  # noqa: E501
-        :type code: ErrorCode
+        :param code: The code of this AbortedMessageResponse.
+        :type code: str
         """
 
         self._code = code
 
     @property
     def message(self):
-        """Gets the message of this ValidationErrorMessageResponse.  # noqa: E501
+        """Gets the message of this AbortedMessageResponse.
 
 
-        :return: The message of this ValidationErrorMessageResponse.  # noqa: E501
+        :return: The message of this AbortedMessageResponse.
         :rtype: str
         """
         return self._message
 
     @message.setter
     def message(self, message):
-        """Sets the message of this ValidationErrorMessageResponse.
+        """Sets the message of this AbortedMessageResponse.
 
 
-        :param message: The message of this ValidationErrorMessageResponse.  # noqa: E501
+        :param message: The message of this AbortedMessageResponse.
         :type message: str
         """
 
         self._message = message
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
@@ -114,27 +104,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
@@ -142,18 +128,18 @@
 
     def __repr__(self):
         """For `print` and `pprint`"""
         return self.to_str()
 
     def __eq__(self, other):
         """Returns true if both objects are equal"""
-        if not isinstance(other, ValidationErrorMessageResponse):
+        if not isinstance(other, AbortedMessageResponse):
             return False
 
         return self.to_dict() == other.to_dict()
 
     def __ne__(self, other):
         """Returns true if both objects are not equal"""
-        if not isinstance(other, ValidationErrorMessageResponse):
+        if not isinstance(other, AbortedMessageResponse):
             return True
 
         return self.to_dict() != other.to_dict()
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/write_assertions_request.py` & `openfga-sdk-0.4.2/openfga_sdk/models/write_assertions_request.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,85 +1,77 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class WriteAssertionsRequest(object):
+class WriteAssertionsRequest:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'assertions': 'list[Assertion]'
-    }
-
-    attribute_map = {
-        'assertions': 'assertions'
-    }
+    openapi_types = {"assertions": "list[Assertion]"}
+
+    attribute_map = {"assertions": "assertions"}
 
-    def __init__(self, assertions=None, local_vars_configuration=None):  # noqa: E501
-        """WriteAssertionsRequest - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, assertions=None, local_vars_configuration=None):
+        """WriteAssertionsRequest - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._assertions = None
         self.discriminator = None
 
         self.assertions = assertions
 
     @property
     def assertions(self):
-        """Gets the assertions of this WriteAssertionsRequest.  # noqa: E501
+        """Gets the assertions of this WriteAssertionsRequest.
 
 
-        :return: The assertions of this WriteAssertionsRequest.  # noqa: E501
+        :return: The assertions of this WriteAssertionsRequest.
         :rtype: list[Assertion]
         """
         return self._assertions
 
     @assertions.setter
     def assertions(self, assertions):
         """Sets the assertions of this WriteAssertionsRequest.
 
 
-        :param assertions: The assertions of this WriteAssertionsRequest.  # noqa: E501
+        :param assertions: The assertions of this WriteAssertionsRequest.
         :type assertions: list[Assertion]
         """
-        if self.local_vars_configuration.client_side_validation and assertions is None:  # noqa: E501
-            raise ValueError("Invalid value for `assertions`, must not be `None`")  # noqa: E501
+        if self.local_vars_configuration.client_side_validation and assertions is None:
+            raise ValueError("Invalid value for `assertions`, must not be `None`")
 
         self._assertions = assertions
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
@@ -89,27 +81,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/write_authorization_model_request.py` & `openfga-sdk-0.4.2/openfga_sdk/models/write_authorization_model_request.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,60 +1,62 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class WriteAuthorizationModelRequest(object):
+class WriteAuthorizationModelRequest:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'type_definitions': 'list[TypeDefinition]',
-        'schema_version': 'str',
-        'conditions': 'dict[str, Condition]'
+        "type_definitions": "list[TypeDefinition]",
+        "schema_version": "str",
+        "conditions": "dict[str, Condition]",
     }
 
     attribute_map = {
-        'type_definitions': 'type_definitions',
-        'schema_version': 'schema_version',
-        'conditions': 'conditions'
+        "type_definitions": "type_definitions",
+        "schema_version": "schema_version",
+        "conditions": "conditions",
     }
 
-    def __init__(self, type_definitions=None, schema_version=None, conditions=None, local_vars_configuration=None):  # noqa: E501
-        """WriteAuthorizationModelRequest - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(
+        self,
+        type_definitions=None,
+        schema_version=None,
+        conditions=None,
+        local_vars_configuration=None,
+    ):
+        """WriteAuthorizationModelRequest - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._type_definitions = None
         self._schema_version = None
         self._conditions = None
@@ -63,74 +65,80 @@
         self.type_definitions = type_definitions
         self.schema_version = schema_version
         if conditions is not None:
             self.conditions = conditions
 
     @property
     def type_definitions(self):
-        """Gets the type_definitions of this WriteAuthorizationModelRequest.  # noqa: E501
+        """Gets the type_definitions of this WriteAuthorizationModelRequest.
 
 
-        :return: The type_definitions of this WriteAuthorizationModelRequest.  # noqa: E501
+        :return: The type_definitions of this WriteAuthorizationModelRequest.
         :rtype: list[TypeDefinition]
         """
         return self._type_definitions
 
     @type_definitions.setter
     def type_definitions(self, type_definitions):
         """Sets the type_definitions of this WriteAuthorizationModelRequest.
 
 
-        :param type_definitions: The type_definitions of this WriteAuthorizationModelRequest.  # noqa: E501
+        :param type_definitions: The type_definitions of this WriteAuthorizationModelRequest.
         :type type_definitions: list[TypeDefinition]
         """
-        if self.local_vars_configuration.client_side_validation and type_definitions is None:  # noqa: E501
-            raise ValueError("Invalid value for `type_definitions`, must not be `None`")  # noqa: E501
+        if (
+            self.local_vars_configuration.client_side_validation
+            and type_definitions is None
+        ):
+            raise ValueError("Invalid value for `type_definitions`, must not be `None`")
 
         self._type_definitions = type_definitions
 
     @property
     def schema_version(self):
-        """Gets the schema_version of this WriteAuthorizationModelRequest.  # noqa: E501
+        """Gets the schema_version of this WriteAuthorizationModelRequest.
 
 
-        :return: The schema_version of this WriteAuthorizationModelRequest.  # noqa: E501
+        :return: The schema_version of this WriteAuthorizationModelRequest.
         :rtype: str
         """
         return self._schema_version
 
     @schema_version.setter
     def schema_version(self, schema_version):
         """Sets the schema_version of this WriteAuthorizationModelRequest.
 
 
-        :param schema_version: The schema_version of this WriteAuthorizationModelRequest.  # noqa: E501
+        :param schema_version: The schema_version of this WriteAuthorizationModelRequest.
         :type schema_version: str
         """
-        if self.local_vars_configuration.client_side_validation and schema_version is None:  # noqa: E501
-            raise ValueError("Invalid value for `schema_version`, must not be `None`")  # noqa: E501
+        if (
+            self.local_vars_configuration.client_side_validation
+            and schema_version is None
+        ):
+            raise ValueError("Invalid value for `schema_version`, must not be `None`")
 
         self._schema_version = schema_version
 
     @property
     def conditions(self):
-        """Gets the conditions of this WriteAuthorizationModelRequest.  # noqa: E501
+        """Gets the conditions of this WriteAuthorizationModelRequest.
 
 
-        :return: The conditions of this WriteAuthorizationModelRequest.  # noqa: E501
+        :return: The conditions of this WriteAuthorizationModelRequest.
         :rtype: dict[str, Condition]
         """
         return self._conditions
 
     @conditions.setter
     def conditions(self, conditions):
         """Sets the conditions of this WriteAuthorizationModelRequest.
 
 
-        :param conditions: The conditions of this WriteAuthorizationModelRequest.  # noqa: E501
+        :param conditions: The conditions of this WriteAuthorizationModelRequest.
         :type conditions: dict[str, Condition]
         """
 
         self._conditions = conditions
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
@@ -142,27 +150,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/write_authorization_model_response.py` & `openfga-sdk-0.4.2/openfga_sdk/models/write_authorization_model_response.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,85 +1,82 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class WriteAuthorizationModelResponse(object):
+class WriteAuthorizationModelResponse:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
-    openapi_types = {
-        'authorization_model_id': 'str'
-    }
-
-    attribute_map = {
-        'authorization_model_id': 'authorization_model_id'
-    }
+    openapi_types = {"authorization_model_id": "str"}
+
+    attribute_map = {"authorization_model_id": "authorization_model_id"}
 
-    def __init__(self, authorization_model_id=None, local_vars_configuration=None):  # noqa: E501
-        """WriteAuthorizationModelResponse - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(self, authorization_model_id=None, local_vars_configuration=None):
+        """WriteAuthorizationModelResponse - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._authorization_model_id = None
         self.discriminator = None
 
         self.authorization_model_id = authorization_model_id
 
     @property
     def authorization_model_id(self):
-        """Gets the authorization_model_id of this WriteAuthorizationModelResponse.  # noqa: E501
+        """Gets the authorization_model_id of this WriteAuthorizationModelResponse.
 
 
-        :return: The authorization_model_id of this WriteAuthorizationModelResponse.  # noqa: E501
+        :return: The authorization_model_id of this WriteAuthorizationModelResponse.
         :rtype: str
         """
         return self._authorization_model_id
 
     @authorization_model_id.setter
     def authorization_model_id(self, authorization_model_id):
         """Sets the authorization_model_id of this WriteAuthorizationModelResponse.
 
 
-        :param authorization_model_id: The authorization_model_id of this WriteAuthorizationModelResponse.  # noqa: E501
+        :param authorization_model_id: The authorization_model_id of this WriteAuthorizationModelResponse.
         :type authorization_model_id: str
         """
-        if self.local_vars_configuration.client_side_validation and authorization_model_id is None:  # noqa: E501
-            raise ValueError("Invalid value for `authorization_model_id`, must not be `None`")  # noqa: E501
+        if (
+            self.local_vars_configuration.client_side_validation
+            and authorization_model_id is None
+        ):
+            raise ValueError(
+                "Invalid value for `authorization_model_id`, must not be `None`"
+            )
 
         self._authorization_model_id = authorization_model_id
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
         result = {}
 
@@ -89,27 +86,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/models/write_request.py` & `openfga-sdk-0.4.2/openfga_sdk/models/write_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,60 +1,62 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 try:
     from inspect import getfullargspec
 except ImportError:
     from inspect import getargspec as getfullargspec
 import pprint
-import re  # noqa: F401
-import six
 
 from openfga_sdk.configuration import Configuration
 
 
-class WriteRequest(object):
+class WriteRequest:
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     """
     Attributes:
       openapi_types (dict): The key is attribute name
                             and the value is attribute type.
       attribute_map (dict): The key is attribute name
                             and the value is json key in definition.
     """
     openapi_types = {
-        'writes': 'WriteRequestWrites',
-        'deletes': 'WriteRequestDeletes',
-        'authorization_model_id': 'str'
+        "writes": "WriteRequestWrites",
+        "deletes": "WriteRequestDeletes",
+        "authorization_model_id": "str",
     }
 
     attribute_map = {
-        'writes': 'writes',
-        'deletes': 'deletes',
-        'authorization_model_id': 'authorization_model_id'
+        "writes": "writes",
+        "deletes": "deletes",
+        "authorization_model_id": "authorization_model_id",
     }
 
-    def __init__(self, writes=None, deletes=None, authorization_model_id=None, local_vars_configuration=None):  # noqa: E501
-        """WriteRequest - a model defined in OpenAPI"""  # noqa: E501
+    def __init__(
+        self,
+        writes=None,
+        deletes=None,
+        authorization_model_id=None,
+        local_vars_configuration=None,
+    ):
+        """WriteRequest - a model defined in OpenAPI"""
         if local_vars_configuration is None:
             local_vars_configuration = Configuration.get_default_copy()
         self.local_vars_configuration = local_vars_configuration
 
         self._writes = None
         self._deletes = None
         self._authorization_model_id = None
@@ -65,70 +67,70 @@
         if deletes is not None:
             self.deletes = deletes
         if authorization_model_id is not None:
             self.authorization_model_id = authorization_model_id
 
     @property
     def writes(self):
-        """Gets the writes of this WriteRequest.  # noqa: E501
+        """Gets the writes of this WriteRequest.
 
 
-        :return: The writes of this WriteRequest.  # noqa: E501
+        :return: The writes of this WriteRequest.
         :rtype: WriteRequestWrites
         """
         return self._writes
 
     @writes.setter
     def writes(self, writes):
         """Sets the writes of this WriteRequest.
 
 
-        :param writes: The writes of this WriteRequest.  # noqa: E501
+        :param writes: The writes of this WriteRequest.
         :type writes: WriteRequestWrites
         """
 
         self._writes = writes
 
     @property
     def deletes(self):
-        """Gets the deletes of this WriteRequest.  # noqa: E501
+        """Gets the deletes of this WriteRequest.
 
 
-        :return: The deletes of this WriteRequest.  # noqa: E501
+        :return: The deletes of this WriteRequest.
         :rtype: WriteRequestDeletes
         """
         return self._deletes
 
     @deletes.setter
     def deletes(self, deletes):
         """Sets the deletes of this WriteRequest.
 
 
-        :param deletes: The deletes of this WriteRequest.  # noqa: E501
+        :param deletes: The deletes of this WriteRequest.
         :type deletes: WriteRequestDeletes
         """
 
         self._deletes = deletes
 
     @property
     def authorization_model_id(self):
-        """Gets the authorization_model_id of this WriteRequest.  # noqa: E501
+        """Gets the authorization_model_id of this WriteRequest.
 
 
-        :return: The authorization_model_id of this WriteRequest.  # noqa: E501
+        :return: The authorization_model_id of this WriteRequest.
         :rtype: str
         """
         return self._authorization_model_id
 
     @authorization_model_id.setter
     def authorization_model_id(self, authorization_model_id):
         """Sets the authorization_model_id of this WriteRequest.
 
 
-        :param authorization_model_id: The authorization_model_id of this WriteRequest.  # noqa: E501
+        :param authorization_model_id: The authorization_model_id of this WriteRequest.
         :type authorization_model_id: str
         """
 
         self._authorization_model_id = authorization_model_id
 
     def to_dict(self, serialize=False):
         """Returns the model properties as a dict"""
@@ -140,27 +142,23 @@
                 if len(args) == 1:
                     return x.to_dict()
                 else:
                     return x.to_dict(serialize)
             else:
                 return x
 
-        for attr, _ in six.iteritems(self.openapi_types):
+        for attr, _ in self.openapi_types.items():
             value = getattr(self, attr)
             attr = self.attribute_map.get(attr, attr) if serialize else attr
             if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: convert(x),
-                    value
-                ))
+                result[attr] = list(map(lambda x: convert(x), value))
             elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], convert(item[1])),
-                    value.items()
-                ))
+                result[attr] = dict(
+                    map(lambda item: (item[0], convert(item[1])), value.items())
+                )
             else:
                 result[attr] = convert(value)
 
         return result
 
     def to_str(self):
         """Returns the string representation of the model"""
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/rest.py` & `openfga-sdk-0.4.2/openfga_sdk/rest.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,32 +1,37 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 import io
 import json
 import logging
 import re
 import ssl
+import urllib
 
 import aiohttp
-# python 2 and python 3 compatibility library
-from six.moves.urllib.parse import urlencode
 
-from openfga_sdk.exceptions import ApiException, UnauthorizedException, ForbiddenException, NotFoundException, RateLimitExceededError, ServiceException, ValidationException, ApiValueError
+from openfga_sdk.exceptions import (
+    ApiException,
+    ApiValueError,
+    ForbiddenException,
+    NotFoundException,
+    RateLimitExceededError,
+    ServiceException,
+    UnauthorizedException,
+)
 
 logger = logging.getLogger(__name__)
 
 
 class RESTResponse(io.IOBase):
 
     def __init__(self, resp, data):
@@ -40,15 +45,15 @@
         return self.aiohttp_response.headers
 
     def getheader(self, name, default=None):
         """Returns a given response header."""
         return self.aiohttp_response.headers.get(name, default)
 
 
-class RESTClientObject(object):
+class RESTClientObject:
 
     def __init__(self, configuration, pools_size=4, maxsize=None):
 
         # maxsize is number of requests to host that are allowed in parallel
         if maxsize is None:
             maxsize = configuration.connection_pool_maxsize
 
@@ -58,34 +63,36 @@
                 configuration.cert_file, keyfile=configuration.key_file
             )
 
         if not configuration.verify_ssl:
             ssl_context.check_hostname = False
             ssl_context.verify_mode = ssl.CERT_NONE
 
-        connector = aiohttp.TCPConnector(
-            limit=maxsize,
-            ssl=ssl_context
-        )
+        connector = aiohttp.TCPConnector(limit=maxsize, ssl=ssl_context)
 
         self.proxy = configuration.proxy
         self.proxy_headers = configuration.proxy_headers
 
         # https pool manager
-        self.pool_manager = aiohttp.ClientSession(
-            connector=connector,
-            trust_env=True
-        )
+        self.pool_manager = aiohttp.ClientSession(connector=connector, trust_env=True)
 
     async def close(self):
         await self.pool_manager.close()
 
-    async def request(self, method, url, query_params=None, headers=None,
-                      body=None, post_params=None, _preload_content=True,
-                      _request_timeout=None):
+    async def request(
+        self,
+        method,
+        url,
+        query_params=None,
+        headers=None,
+        body=None,
+        post_params=None,
+        _preload_content=True,
+        _request_timeout=None,
+    ):
         """Execute request
 
         :param method: http request method
         :param url: http request url
         :param query_params: query parameters in the url
         :param headers: http request headers
         :param body: request json body, for `application/json`
@@ -96,64 +103,55 @@
                                  the AiohttpClient.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         """
         method = method.upper()
-        assert method in ['GET', 'HEAD', 'DELETE', 'POST', 'PUT',
-                          'PATCH', 'OPTIONS']
+        assert method in ["GET", "HEAD", "DELETE", "POST", "PUT", "PATCH", "OPTIONS"]
 
         if post_params and body:
             raise ApiValueError(
                 "body parameter cannot be used with post_params parameter."
             )
 
         post_params = post_params or {}
         headers = headers or {}
         timeout = _request_timeout or 5 * 60
 
-        if 'Content-Type' not in headers:
-            headers['Content-Type'] = 'application/json'
+        if "Content-Type" not in headers:
+            headers["Content-Type"] = "application/json"
 
-        args = {
-            "method": method,
-            "url": url,
-            "timeout": timeout,
-            "headers": headers
-        }
+        args = {"method": method, "url": url, "timeout": timeout, "headers": headers}
 
         if self.proxy:
             args["proxy"] = self.proxy
         if self.proxy_headers:
             args["proxy_headers"] = self.proxy_headers
 
         if query_params:
-            args["url"] += '?' + urlencode(query_params)
+            args["url"] += "?" + urllib.parse.urlencode(query_params)
 
         # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`
-        if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:
-            if re.search('json', headers['Content-Type'], re.IGNORECASE):
+        if method in ["POST", "PUT", "PATCH", "OPTIONS", "DELETE"]:
+            if re.search("json", headers["Content-Type"], re.IGNORECASE):
                 if body is not None:
                     body = json.dumps(body)
                 args["data"] = body
-            elif headers['Content-Type'] == 'application/x-www-form-urlencoded':  # noqa: E501
+            elif headers["Content-Type"] == "application/x-www-form-urlencoded":
                 args["data"] = aiohttp.FormData(post_params)
-            elif headers['Content-Type'] == 'multipart/form-data':
+            elif headers["Content-Type"] == "multipart/form-data":
                 # must del headers['Content-Type'], or the correct
                 # Content-Type which generated by aiohttp
-                del headers['Content-Type']
+                del headers["Content-Type"]
                 data = aiohttp.FormData()
                 for param in post_params:
                     k, v = param
                     if isinstance(v, tuple) and len(v) == 3:
-                        data.add_field(k,
-                                       value=v[1],
-                                       filename=v[0],
-                                       content_type=v[2])
+                        data.add_field(k, value=v[1], filename=v[0], content_type=v[2])
                     else:
                         data.add_field(k, v)
                 args["data"] = data
 
             # Pass a `bytes` parameter directly in the body to support
             # other content types than Json when `body` argument is provided
             # in serialized form
@@ -191,74 +189,143 @@
                 if 500 <= r.status <= 599:
                     raise ServiceException(http_resp=r)
 
                 raise ApiException(http_resp=r)
 
         return r
 
-    async def GET(self, url, headers=None, query_params=None,
-                  _preload_content=True, _request_timeout=None):
-        return (await self.request("GET", url,
-                                   headers=headers,
-                                   _preload_content=_preload_content,
-                                   _request_timeout=_request_timeout,
-                                   query_params=query_params))
-
-    async def HEAD(self, url, headers=None, query_params=None,
-                   _preload_content=True, _request_timeout=None):
-        return (await self.request("HEAD", url,
-                                   headers=headers,
-                                   _preload_content=_preload_content,
-                                   _request_timeout=_request_timeout,
-                                   query_params=query_params))
-
-    async def OPTIONS(self, url, headers=None, query_params=None,
-                      post_params=None, body=None, _preload_content=True,
-                      _request_timeout=None):
-        return (await self.request("OPTIONS", url,
-                                   headers=headers,
-                                   query_params=query_params,
-                                   post_params=post_params,
-                                   _preload_content=_preload_content,
-                                   _request_timeout=_request_timeout,
-                                   body=body))
-
-    async def DELETE(self, url, headers=None, query_params=None, body=None,
-                     _preload_content=True, _request_timeout=None):
-        return (await self.request("DELETE", url,
-                                   headers=headers,
-                                   query_params=query_params,
-                                   _preload_content=_preload_content,
-                                   _request_timeout=_request_timeout,
-                                   body=body))
-
-    async def POST(self, url, headers=None, query_params=None,
-                   post_params=None, body=None, _preload_content=True,
-                   _request_timeout=None):
-        return (await self.request("POST", url,
-                                   headers=headers,
-                                   query_params=query_params,
-                                   post_params=post_params,
-                                   _preload_content=_preload_content,
-                                   _request_timeout=_request_timeout,
-                                   body=body))
-
-    async def PUT(self, url, headers=None, query_params=None, post_params=None,
-                  body=None, _preload_content=True, _request_timeout=None):
-        return (await self.request("PUT", url,
-                                   headers=headers,
-                                   query_params=query_params,
-                                   post_params=post_params,
-                                   _preload_content=_preload_content,
-                                   _request_timeout=_request_timeout,
-                                   body=body))
-
-    async def PATCH(self, url, headers=None, query_params=None,
-                    post_params=None, body=None, _preload_content=True,
-                    _request_timeout=None):
-        return (await self.request("PATCH", url,
-                                   headers=headers,
-                                   query_params=query_params,
-                                   post_params=post_params,
-                                   _preload_content=_preload_content,
-                                   _request_timeout=_request_timeout,
-                                   body=body))
+    async def GET(
+        self,
+        url,
+        headers=None,
+        query_params=None,
+        _preload_content=True,
+        _request_timeout=None,
+    ):
+        return await self.request(
+            "GET",
+            url,
+            headers=headers,
+            _preload_content=_preload_content,
+            _request_timeout=_request_timeout,
+            query_params=query_params,
+        )
+
+    async def HEAD(
+        self,
+        url,
+        headers=None,
+        query_params=None,
+        _preload_content=True,
+        _request_timeout=None,
+    ):
+        return await self.request(
+            "HEAD",
+            url,
+            headers=headers,
+            _preload_content=_preload_content,
+            _request_timeout=_request_timeout,
+            query_params=query_params,
+        )
+
+    async def OPTIONS(
+        self,
+        url,
+        headers=None,
+        query_params=None,
+        post_params=None,
+        body=None,
+        _preload_content=True,
+        _request_timeout=None,
+    ):
+        return await self.request(
+            "OPTIONS",
+            url,
+            headers=headers,
+            query_params=query_params,
+            post_params=post_params,
+            _preload_content=_preload_content,
+            _request_timeout=_request_timeout,
+            body=body,
+        )
+
+    async def DELETE(
+        self,
+        url,
+        headers=None,
+        query_params=None,
+        body=None,
+        _preload_content=True,
+        _request_timeout=None,
+    ):
+        return await self.request(
+            "DELETE",
+            url,
+            headers=headers,
+            query_params=query_params,
+            _preload_content=_preload_content,
+            _request_timeout=_request_timeout,
+            body=body,
+        )
+
+    async def POST(
+        self,
+        url,
+        headers=None,
+        query_params=None,
+        post_params=None,
+        body=None,
+        _preload_content=True,
+        _request_timeout=None,
+    ):
+        return await self.request(
+            "POST",
+            url,
+            headers=headers,
+            query_params=query_params,
+            post_params=post_params,
+            _preload_content=_preload_content,
+            _request_timeout=_request_timeout,
+            body=body,
+        )
+
+    async def PUT(
+        self,
+        url,
+        headers=None,
+        query_params=None,
+        post_params=None,
+        body=None,
+        _preload_content=True,
+        _request_timeout=None,
+    ):
+        return await self.request(
+            "PUT",
+            url,
+            headers=headers,
+            query_params=query_params,
+            post_params=post_params,
+            _preload_content=_preload_content,
+            _request_timeout=_request_timeout,
+            body=body,
+        )
+
+    async def PATCH(
+        self,
+        url,
+        headers=None,
+        query_params=None,
+        post_params=None,
+        body=None,
+        _preload_content=True,
+        _request_timeout=None,
+    ):
+        return await self.request(
+            "PATCH",
+            url,
+            headers=headers,
+            query_params=query_params,
+            post_params=post_params,
+            _preload_content=_preload_content,
+            _request_timeout=_request_timeout,
+            body=body,
+        )
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/sync/api_client.py` & `openfga-sdk-0.4.2/openfga_sdk/api_client.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,56 +1,55 @@
-# coding: utf-8
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
-import time
+import asyncio
 import atexit
 import datetime
-from dateutil.parser import parse
 import json
 import math
-import mimetypes
-from multiprocessing.pool import ThreadPool
-import os
 import random
 import re
-import tempfile
+import urllib
+from multiprocessing.pool import ThreadPool
 
-# python 2 and python 3 compatibility library
-import six
-from six.moves.urllib.parse import quote
+from dateutil.parser import parse
 
-from openfga_sdk.configuration import Configuration
 import openfga_sdk.models
-from openfga_sdk.sync import rest, oauth2
-from openfga_sdk.exceptions import ApiValueError, ApiException, FgaValidationException, RateLimitExceededError
-
+from openfga_sdk import oauth2, rest
+from openfga_sdk.configuration import Configuration
+from openfga_sdk.exceptions import (
+    ApiException,
+    ApiValueError,
+    FgaValidationException,
+    RateLimitExceededError,
+    ServiceException,
+)
 
-DEFAULT_USER_AGENT = 'openfga-sdk python/0.4.1'
+DEFAULT_USER_AGENT = "openfga-sdk python/0.4.2"
 
 
 def random_time(loop_count, min_wait_in_ms):
     """
     Helper function to return the time (in s) to wait before retry
     """
-    minimum = math.ceil(2 ** loop_count * min_wait_in_ms)
+    minimum = math.ceil(2**loop_count * min_wait_in_ms)
     maximum = math.ceil(2 ** (loop_count + 1) * min_wait_in_ms)
     return random.randrange(minimum, maximum) / 1000
 
 
-class ApiClient(object):
+class ApiClient:
     """Generic API client for OpenAPI client library builds.
 
     OpenAPI generic API client. This client handles the client-
     server communication, and is invariant across implementations. Specifics of
     the methods and models for each application are generated from the OpenAPI
     templates.
 
@@ -64,209 +63,257 @@
         the API.
     :param cookie: a cookie to include in the header when making calls
         to the API
     :param pool_threads: The number of threads to use for async requests
         to the API. More threads means more concurrent API requests.
     """
 
-    PRIMITIVE_TYPES = (float, bool, bytes, six.text_type) + six.integer_types
+    PRIMITIVE_TYPES = (float, bool, bytes, str, int)
     NATIVE_TYPES_MAPPING = {
-        'int': int,
-        'long': int if six.PY3 else long,  # noqa: F821
-        'float': float,
-        'str': str,
-        'bool': bool,
-        'date': datetime.date,
-        'datetime': datetime.datetime,
-        'object': object,
+        "int": int,
+        "long": int,
+        "float": float,
+        "str": str,
+        "bool": bool,
+        "date": datetime.date,
+        "datetime": datetime.datetime,
+        "object": object,
     }
     _pool = None
 
-    def __init__(self, configuration=None, header_name=None, header_value=None,
-                 cookie=None, pool_threads=1):
+    def __init__(
+        self,
+        configuration=None,
+        header_name=None,
+        header_value=None,
+        cookie=None,
+        pool_threads=1,
+    ):
         if configuration is None:
             configuration = Configuration.get_default_copy()
         self.configuration = configuration
         self.pool_threads = pool_threads
 
         self.rest_client = rest.RESTClientObject(configuration)
         self.default_headers = {}
         if header_name is not None:
             self.default_headers[header_name] = header_value
         self.cookie = cookie
         # Set default User-Agent.
         self.user_agent = DEFAULT_USER_AGENT
         self.client_side_validation = configuration.client_side_validation
 
-    def __enter__(self):
+    async def __aenter__(self):
         return self
 
-    def __exit__(self, exc_type, exc_value, traceback):
-        self.close()
+    async def __aexit__(self, exc_type, exc_value, traceback):
+        await self.close()
 
-    def close(self):
+    async def close(self):
+        await self.rest_client.close()
         if self._pool:
             self._pool.close()
             self._pool.join()
             self._pool = None
-            if hasattr(atexit, 'unregister'):
+            if hasattr(atexit, "unregister"):
                 atexit.unregister(self.close)
 
     @property
     def pool(self):
         """Create thread pool on first request
-         avoids instantiating unused threadpool for blocking clients.
+        avoids instantiating unused threadpool for blocking clients.
         """
         if self._pool is None:
             atexit.register(self.close)
             self._pool = ThreadPool(self.pool_threads)
         return self._pool
 
     @property
     def user_agent(self):
         """User agent for this API client"""
-        return self.default_headers['User-Agent']
+        return self.default_headers["User-Agent"]
 
     @user_agent.setter
     def user_agent(self, value):
-        self.default_headers['User-Agent'] = value
+        self.default_headers["User-Agent"] = value
 
     def set_default_header(self, header_name, header_value):
         self.default_headers[header_name] = header_value
 
-    def __call_api(
-            self, resource_path, method, path_params=None,
-            query_params=None, header_params=None, body=None, post_params=None,
-            response_types_map=None, auth_settings=None,
-            _return_http_data_only=None, collection_formats=None,
-            _preload_content=True, _request_timeout=None, _host=None,
-            _request_auth=None, _retry_params=None, _oauth2_client=None):
+    async def __call_api(
+        self,
+        resource_path,
+        method,
+        path_params=None,
+        query_params=None,
+        header_params=None,
+        body=None,
+        post_params=None,
+        response_types_map=None,
+        auth_settings=None,
+        _return_http_data_only=None,
+        collection_formats=None,
+        _preload_content=True,
+        _request_timeout=None,
+        _host=None,
+        _request_auth=None,
+        _retry_params=None,
+        _oauth2_client=None,
+    ):
 
         self.configuration.is_valid()
         config = self.configuration
 
         # header parameters
         header_params = header_params or {}
         header_params.update(self.default_headers)
         if self.cookie:
-            header_params['Cookie'] = self.cookie
+            header_params["Cookie"] = self.cookie
         if header_params:
             header_params = self.sanitize_for_serialization(header_params)
-            header_params = dict(self.parameters_to_tuples(header_params,
-                                                           collection_formats))
+            header_params = dict(
+                self.parameters_to_tuples(header_params, collection_formats)
+            )
 
         # path parameters
         if path_params:
             path_params = self.sanitize_for_serialization(path_params)
-            path_params = self.parameters_to_tuples(path_params,
-                                                    collection_formats)
+            path_params = self.parameters_to_tuples(path_params, collection_formats)
             for k, v in path_params:
                 # specified safe chars, encode everything
                 resource_path = resource_path.replace(
-                    '{%s}' % k,
-                    quote(str(v), safe=config.safe_chars_for_path_param)
+                    "{%s}" % k,
+                    urllib.parse.quote(str(v), safe=config.safe_chars_for_path_param),
                 )
 
         # query parameters
         if query_params:
             query_params = self.sanitize_for_serialization(query_params)
-            query_params = self.parameters_to_tuples(query_params,
-                                                     collection_formats)
+            query_params = self.parameters_to_tuples(query_params, collection_formats)
 
         # post parameters
         if post_params:
             post_params = post_params if post_params else []
             post_params = self.sanitize_for_serialization(post_params)
-            post_params = self.parameters_to_tuples(post_params,
-                                                    collection_formats)
+            post_params = self.parameters_to_tuples(post_params, collection_formats)
 
         # auth setting
-        self.update_params_for_auth(
-            header_params, query_params, auth_settings,
-            request_auth=_request_auth, oauth2_client=_oauth2_client)
+        await self.update_params_for_auth(
+            header_params,
+            query_params,
+            auth_settings,
+            request_auth=_request_auth,
+            oauth2_client=_oauth2_client,
+        )
 
         # body
         if body:
             body = self.sanitize_for_serialization(body)
 
         # request url
         if _host is None:
             if self.configuration.api_url is not None:
                 url = self.configuration.api_url + resource_path
             else:
-                url = self.configuration.api_scheme + '://' + self.configuration.api_host + resource_path
+                url = (
+                    self.configuration.api_scheme
+                    + "://"
+                    + self.configuration.api_host
+                    + resource_path
+                )
         else:
             # use server/host defined in path or operation instead
-            url = self.configuration.api_scheme + '://' + _host + resource_path
+            url = self.configuration.api_scheme + "://" + _host + resource_path
 
-        max_retry = self.configuration.retry_params.max_retry if (
-            self.configuration.retry_params is not None and self.configuration.retry_params.max_retry is not None) else 0
-        min_wait_in_ms = self.configuration.retry_params.min_wait_in_ms if (
-            self.configuration.retry_params is not None and self.configuration.retry_params.min_wait_in_ms is not None) else 0
+        max_retry = (
+            self.configuration.retry_params.max_retry
+            if (
+                self.configuration.retry_params is not None
+                and self.configuration.retry_params.max_retry is not None
+            )
+            else 0
+        )
+        min_wait_in_ms = (
+            self.configuration.retry_params.min_wait_in_ms
+            if (
+                self.configuration.retry_params is not None
+                and self.configuration.retry_params.min_wait_in_ms is not None
+            )
+            else 0
+        )
         if _retry_params is not None:
             if _retry_params.max_retry is not None:
                 max_retry = _retry_params.max_retry
             if _retry_params.min_wait_in_ms is not None:
                 max_retry = _retry_params.min_wait_in_ms
         for x in range(max_retry + 1):
             try:
                 # perform request and return response
-                response_data = self.request(
-                    method, url, query_params=query_params, headers=header_params,
-                    post_params=post_params, body=body,
+                response_data = await self.request(
+                    method,
+                    url,
+                    query_params=query_params,
+                    headers=header_params,
+                    post_params=post_params,
+                    body=body,
                     _preload_content=_preload_content,
-                    _request_timeout=_request_timeout)
-            except RateLimitExceededError as e:
-                if x < max_retry:
-                    time.sleep(random_time(x, min_wait_in_ms))
+                    _request_timeout=_request_timeout,
+                )
+            except (RateLimitExceededError, ServiceException) as e:
+                if x < max_retry and e.status != 501:
+                    await asyncio.sleep(random_time(x, min_wait_in_ms))
+
                     continue
-                e.body = e.body.decode('utf-8') if six.PY3 else e.body
+                e.body = e.body.decode("utf-8")
                 response_type = response_types_map.get(e.status, None)
                 if response_type is not None:
-                    e.parsed_exception = self.__deserialize(json.loads(e.body), response_type)
+                    e.parsed_exception = self.__deserialize(
+                        json.loads(e.body), response_type
+                    )
                     e.body = None
                 raise e
             except ApiException as e:
-                e.body = e.body.decode('utf-8') if six.PY3 else e.body
+                e.body = e.body.decode("utf-8")
                 response_type = response_types_map.get(e.status, None)
                 if response_type is not None:
-                    e.parsed_exception = self.__deserialize(json.loads(e.body), response_type)
+                    e.parsed_exception = self.__deserialize(
+                        json.loads(e.body), response_type
+                    )
                     e.body = None
                 raise e
 
             self.last_response = response_data
 
             return_data = response_data
 
             if not _preload_content:
                 return return_data
 
             response_type = response_types_map.get(response_data.status, None)
 
-            if six.PY3 and response_type not in ["file", "bytes"]:
+            if response_type not in ["file", "bytes"]:
                 match = None
-                content_type = response_data.getheader('content-type')
+                content_type = response_data.getheader("content-type")
                 if content_type is not None:
                     match = re.search(r"charset=([a-zA-Z\-\d]+)[\s\;]?", content_type)
                 encoding = match.group(1) if match else "utf-8"
                 if response_data.data is not None:
                     response_data.data = response_data.data.decode(encoding)
 
             # deserialize response data
 
             if response_type:
                 return_data = self.deserialize(response_data, response_type)
             else:
                 return_data = None
 
             if _return_http_data_only:
-                return (return_data)
+                return return_data
             else:
-                return (return_data, response_data.status,
-                        response_data.getheaders())
+                return (return_data, response_data.status, response_data.headers)
 
     def sanitize_for_serialization(self, obj):
         """Builds a JSON POST object.
 
         If obj is None, return None.
         If obj is str, int, long, float, bool, return directly.
         If obj is datetime.datetime, datetime.date
@@ -279,36 +326,37 @@
         :return: The serialized form of data.
         """
         if obj is None:
             return None
         elif isinstance(obj, self.PRIMITIVE_TYPES):
             return obj
         elif isinstance(obj, list):
-            return [self.sanitize_for_serialization(sub_obj)
-                    for sub_obj in obj]
+            return [self.sanitize_for_serialization(sub_obj) for sub_obj in obj]
         elif isinstance(obj, tuple):
-            return tuple(self.sanitize_for_serialization(sub_obj)
-                         for sub_obj in obj)
+            return tuple(self.sanitize_for_serialization(sub_obj) for sub_obj in obj)
         elif isinstance(obj, (datetime.datetime, datetime.date)):
             return obj.isoformat()
 
         if isinstance(obj, dict):
             obj_dict = obj
         else:
             # Convert model obj to dict except
             # attributes `openapi_types`, `attribute_map`
             # and attributes which value is not None.
             # Convert attribute name to json key in
             # model definition for request.
-            obj_dict = {obj.attribute_map[attr]: getattr(obj, attr)
-                        for attr, _ in six.iteritems(obj.openapi_types)
-                        if getattr(obj, attr) is not None}
-
-        return {key: self.sanitize_for_serialization(val)
-                for key, val in six.iteritems(obj_dict)}
+            obj_dict = {
+                obj.attribute_map[attr]: getattr(obj, attr)
+                for attr, _ in obj.openapi_types.items()
+                if getattr(obj, attr) is not None
+            }
+
+        return {
+            key: self.sanitize_for_serialization(val) for key, val in obj_dict.items()
+        }
 
     def deserialize(self, response, response_type):
         """Deserializes response into an object.
 
         :param response: RESTResponse object to be deserialized.
         :param response_type: class literal for
             deserialized object, or string of class name.
@@ -332,23 +380,21 @@
 
         :return: object.
         """
         if data is None:
             return None
 
         if type(klass) is str:
-            if klass.startswith('list['):
-                sub_kls = re.match(r'list\[(.*)\]', klass).group(1)
-                return [self.__deserialize(sub_data, sub_kls)
-                        for sub_data in data]
-
-            if klass.startswith('dict['):
-                sub_kls = re.match(r'dict\[([^,]*), (.*)\]', klass).group(2)
-                return {k: self.__deserialize(v, sub_kls)
-                        for k, v in six.iteritems(data)}
+            if klass.startswith("list["):
+                sub_kls = re.match(r"list\[(.*)\]", klass).group(1)
+                return [self.__deserialize(sub_data, sub_kls) for sub_data in data]
+
+            if klass.startswith("dict["):
+                sub_kls = re.match(r"dict\[([^,]*), (.*)\]", klass).group(2)
+                return {k: self.__deserialize(v, sub_kls) for k, v in data.items()}
 
             # convert str to class
             if klass in self.NATIVE_TYPES_MAPPING:
                 klass = self.NATIVE_TYPES_MAPPING[klass]
             else:
                 klass = getattr(openfga_sdk.models, klass)
 
@@ -359,22 +405,36 @@
         elif klass == datetime.date:
             return self.__deserialize_date(data)
         elif klass == datetime.datetime:
             return self.__deserialize_datetime(data)
         else:
             return self.__deserialize_model(data, klass)
 
-    def call_api(self, resource_path, method,
-                 path_params=None, query_params=None, header_params=None,
-                 body=None, post_params=None, files=None,
-                 response_types_map=None, auth_settings=None,
-                 async_req=None, _return_http_data_only=None,
-                 collection_formats=None, _preload_content=True,
-                 _request_timeout=None, _host=None, _request_auth=None,
-                 _retry_params=None, _oauth2_client=None):
+    async def call_api(
+        self,
+        resource_path,
+        method,
+        path_params=None,
+        query_params=None,
+        header_params=None,
+        body=None,
+        post_params=None,
+        files=None,
+        response_types_map=None,
+        auth_settings=None,
+        async_req=None,
+        _return_http_data_only=None,
+        collection_formats=None,
+        _preload_content=True,
+        _request_timeout=None,
+        _host=None,
+        _request_auth=None,
+        _retry_params=None,
+        _oauth2_client=None,
+    ):
         """Makes the HTTP request (synchronous) and returns deserialized data.
 
         To make an async_req request, set the async_req parameter.
 
         :param resource_path: Path to method endpoint.
         :param method: Method to call.
         :param path_params: Path parameters in the url.
@@ -408,90 +468,132 @@
             If async_req parameter is True,
             the request will be called asynchronously.
             The method will return the request thread.
             If parameter async_req is False or missing,
             then the method will return the response directly.
         """
         if not async_req:
-            return self.__call_api(resource_path, method,
-                                   path_params, query_params, header_params,
-                                   body, post_params,
-                                   response_types_map, auth_settings,
-                                   _return_http_data_only, collection_formats,
-                                   _preload_content, _request_timeout, _host,
-                                   _request_auth, _retry_params, _oauth2_client)
-
-        return self.pool.apply_async(self.__call_api, (resource_path,
-                                                       method, path_params,
-                                                       query_params,
-                                                       header_params, body,
-                                                       post_params,
-                                                       response_types_map,
-                                                       auth_settings,
-                                                       _return_http_data_only,
-                                                       collection_formats,
-                                                       _preload_content,
-                                                       _request_timeout,
-                                                       _host, _request_auth,
-                                                       _retry_params,
-                                                       _oauth2_client))
-
-    def request(self, method, url, query_params=None, headers=None,
-                post_params=None, body=None, _preload_content=True,
-                _request_timeout=None):
+            return await self.__call_api(
+                resource_path,
+                method,
+                path_params,
+                query_params,
+                header_params,
+                body,
+                post_params,
+                response_types_map,
+                auth_settings,
+                _return_http_data_only,
+                collection_formats,
+                _preload_content,
+                _request_timeout,
+                _host,
+                _request_auth,
+                _retry_params,
+                _oauth2_client,
+            )
+
+        return self.pool.apply_async(
+            self.__call_api,
+            (
+                resource_path,
+                method,
+                path_params,
+                query_params,
+                header_params,
+                body,
+                post_params,
+                response_types_map,
+                auth_settings,
+                _return_http_data_only,
+                collection_formats,
+                _preload_content,
+                _request_timeout,
+                _host,
+                _request_auth,
+                _retry_params,
+                _oauth2_client,
+            ),
+        )
+
+    async def request(
+        self,
+        method,
+        url,
+        query_params=None,
+        headers=None,
+        post_params=None,
+        body=None,
+        _preload_content=True,
+        _request_timeout=None,
+    ):
         """Makes the HTTP request using RESTClient."""
         if method == "GET":
-            return self.rest_client.GET(url,
-                                        query_params=query_params,
-                                        _preload_content=_preload_content,
-                                        _request_timeout=_request_timeout,
-                                        headers=headers)
+            return await self.rest_client.GET(
+                url,
+                query_params=query_params,
+                _preload_content=_preload_content,
+                _request_timeout=_request_timeout,
+                headers=headers,
+            )
         elif method == "HEAD":
-            return self.rest_client.HEAD(url,
-                                         query_params=query_params,
-                                         _preload_content=_preload_content,
-                                         _request_timeout=_request_timeout,
-                                         headers=headers)
+            return await self.rest_client.HEAD(
+                url,
+                query_params=query_params,
+                _preload_content=_preload_content,
+                _request_timeout=_request_timeout,
+                headers=headers,
+            )
         elif method == "OPTIONS":
-            return self.rest_client.OPTIONS(url,
-                                            query_params=query_params,
-                                            headers=headers,
-                                            _preload_content=_preload_content,
-                                            _request_timeout=_request_timeout)
+            return await self.rest_client.OPTIONS(
+                url,
+                query_params=query_params,
+                headers=headers,
+                _preload_content=_preload_content,
+                _request_timeout=_request_timeout,
+            )
         elif method == "POST":
-            return self.rest_client.POST(url,
-                                         query_params=query_params,
-                                         headers=headers,
-                                         post_params=post_params,
-                                         _preload_content=_preload_content,
-                                         _request_timeout=_request_timeout,
-                                         body=body)
+            return await self.rest_client.POST(
+                url,
+                query_params=query_params,
+                headers=headers,
+                post_params=post_params,
+                _preload_content=_preload_content,
+                _request_timeout=_request_timeout,
+                body=body,
+            )
         elif method == "PUT":
-            return self.rest_client.PUT(url,
-                                        query_params=query_params,
-                                        headers=headers,
-                                        post_params=post_params,
-                                        _preload_content=_preload_content,
-                                        _request_timeout=_request_timeout,
-                                        body=body)
+            return await self.rest_client.PUT(
+                url,
+                query_params=query_params,
+                headers=headers,
+                post_params=post_params,
+                _preload_content=_preload_content,
+                _request_timeout=_request_timeout,
+                body=body,
+            )
         elif method == "PATCH":
-            return self.rest_client.PATCH(url,
-                                          query_params=query_params,
-                                          headers=headers,
-                                          post_params=post_params,
-                                          _preload_content=_preload_content,
-                                          _request_timeout=_request_timeout,
-                                          body=body)
+            return await self.rest_client.PATCH(
+                url,
+                query_params=query_params,
+                headers=headers,
+                post_params=post_params,
+                _preload_content=_preload_content,
+                _request_timeout=_request_timeout,
+                body=body,
+            )
         elif method == "DELETE":
-            return self.rest_client.DELETE(url,
-                                           query_params=query_params,
-                                           headers=headers,
-                                           _preload_content=_preload_content,
-                                           _request_timeout=_request_timeout,
-                                           body=body)
+            return await self.rest_client.DELETE(
+                url,
+                query_params=query_params,
+                headers=headers,
+                _preload_content=_preload_content,
+                _request_timeout=_request_timeout,
+                body=body,
+            )
         else:
             raise ApiValueError(
                 "http method must be `GET`, `HEAD`, `OPTIONS`,"
                 " `POST`, `PATCH`, `PUT` or `DELETE`."
             )
 
     def parameters_to_tuples(self, params, collection_formats):
@@ -500,30 +602,29 @@
         :param params: Parameters as dict or list of two-tuples
         :param dict collection_formats: Parameter collection formats
         :return: Parameters as list of tuples, collections formatted
         """
         new_params = []
         if collection_formats is None:
             collection_formats = {}
-        for k, v in six.iteritems(params) if isinstance(params, dict) else params:  # noqa: E501
+        for k, v in params.items() if isinstance(params, dict) else params:
             if k in collection_formats:
                 collection_format = collection_formats[k]
-                if collection_format == 'multi':
+                if collection_format == "multi":
                     new_params.extend((k, value) for value in v)
                 else:
-                    if collection_format == 'ssv':
-                        delimiter = ' '
-                    elif collection_format == 'tsv':
-                        delimiter = '\t'
-                    elif collection_format == 'pipes':
-                        delimiter = '|'
+                    if collection_format == "ssv":
+                        delimiter = " "
+                    elif collection_format == "tsv":
+                        delimiter = "\t"
+                    elif collection_format == "pipes":
+                        delimiter = "|"
                     else:  # csv is the default
-                        delimiter = ','
-                    new_params.append(
-                        (k, delimiter.join(str(value) for value in v)))
+                        delimiter = ","
+                    new_params.append((k, delimiter.join(str(value) for value in v)))
             else:
                 new_params.append((k, v))
         return new_params
 
     def select_header_accept(self, accepts):
         """Returns `Accept` based on an array of accepts provided.
 
@@ -531,63 +632,70 @@
         :return: Accept (e.g. application/json).
         """
         if not accepts:
             return
 
         accepts = [x.lower() for x in accepts]
 
-        if 'application/json' in accepts:
-            return 'application/json'
+        if "application/json" in accepts:
+            return "application/json"
         else:
-            return ', '.join(accepts)
+            return ", ".join(accepts)
 
     def select_header_content_type(self, content_types, method=None, body=None):
         """Returns `Content-Type` based on an array of content_types provided.
 
         :param content_types: List of content-types.
         :param method: http method (e.g. POST, PATCH).
         :param body: http body to send.
         :return: Content-Type (e.g. application/json).
         """
         if not content_types:
             return None
 
         content_types = [x.lower() for x in content_types]
 
-        if (method == 'PATCH' and
-                'application/json-patch+json' in content_types and
-                isinstance(body, list)):
-            return 'application/json-patch+json'
+        if (
+            method == "PATCH"
+            and "application/json-patch+json" in content_types
+            and isinstance(body, list)
+        ):
+            return "application/json-patch+json"
 
-        if 'application/json' in content_types or '*/*' in content_types:
-            return 'application/json'
+        if "application/json" in content_types or "*/*" in content_types:
+            return "application/json"
         else:
             return content_types[0]
 
-    def update_params_for_auth(self, headers, queries, auth_settings,
-                               request_auth=None, oauth2_client=None):
+    async def update_params_for_auth(
+        self, headers, queries, auth_settings, request_auth=None, oauth2_client=None
+    ):
         """Updates header and query params based on authentication setting.
 
         :param headers: Header parameters dict to be updated.
         :param queries: Query parameters tuple list to be updated.
         :param auth_settings: Authentication setting identifiers list.
         :param request_auth: if set, the provided settings will
                              override the token in the configuration.
         :param oauth2_client: if set, will be used for credential exchange.
         """
         credentials = self.configuration.credentials
         if credentials is not None:
-            if credentials.method == 'none':
+            if credentials.method == "none":
                 pass
-            if credentials.method == 'api_token':
-                headers['Authorization'] = 'Bearer {}'.format(credentials.configuration.api_token)
-            if credentials.method == 'client_credentials':
+            if credentials.method == "api_token":
+                headers["Authorization"] = (
+                    f"Bearer {credentials.configuration.api_token}"
+                )
+            if credentials.method == "client_credentials":
                 if oauth2_client is None:
                     oauth2_client = oauth2.OAuth2Client(credentials)
-                oauth2_headers = oauth2_client.get_authentication_header(self.rest_client)
+                oauth2_headers = await oauth2_client.get_authentication_header(
+                    self.rest_client
+                )
                 for key, value in oauth2_headers.items():
                     headers[key] = value
 
         if not auth_settings:
             return
 
         if request_auth:
@@ -602,37 +710,35 @@
     def _apply_auth_params(self, headers, queries, auth_setting):
         """Updates the request parameters based on a single auth_setting
 
         :param headers: Header parameters dict to be updated.
         :param queries: Query parameters tuple list to be updated.
         :param auth_setting: auth settings for the endpoint
         """
-        if auth_setting['in'] == 'cookie':
-            headers['Cookie'] = auth_setting['value']
-        elif auth_setting['in'] == 'header':
-            headers[auth_setting['key']] = auth_setting['value']
-        elif auth_setting['in'] == 'query':
-            queries.append((auth_setting['key'], auth_setting['value']))
+        if auth_setting["in"] == "cookie":
+            headers["Cookie"] = auth_setting["value"]
+        elif auth_setting["in"] == "header":
+            headers[auth_setting["key"]] = auth_setting["value"]
+        elif auth_setting["in"] == "query":
+            queries.append((auth_setting["key"], auth_setting["value"]))
         else:
-            raise ApiValueError(
-                'Authentication token must be in `query` or `header`'
-            )
+            raise ApiValueError("Authentication token must be in `query` or `header`")
 
     def __deserialize_primitive(self, data, klass):
         """Deserializes string to primitive type.
 
         :param data: str.
         :param klass: class literal.
 
         :return: int, long, float, str, bool.
         """
         try:
             return klass(data)
         except UnicodeEncodeError:
-            return six.text_type(data)
+            return str(data)
         except TypeError:
             return data
 
     def __deserialize_object(self, value):
         """Return an original value.
 
         :return: object.
@@ -647,16 +753,15 @@
         """
         try:
             return parse(string).date()
         except ImportError:
             return string
         except ValueError:
             raise rest.ApiException(
-                status=0,
-                reason="Failed to parse `{0}` as date object".format(string)
+                status=0, reason=f"Failed to parse `{string}` as date object"
             )
 
     def __deserialize_datetime(self, string):
         """Deserializes string to datetime.
 
         The string should be in iso8601 datetime format.
 
@@ -666,39 +771,41 @@
         try:
             return parse(string)
         except ImportError:
             return string
         except ValueError:
             raise rest.ApiException(
                 status=0,
-                reason=(
-                    "Failed to parse `{0}` as datetime object"
-                    .format(string)
-                )
+                reason=(f"Failed to parse `{string}` as datetime object"),
             )
 
     def __deserialize_model(self, data, klass):
         """Deserializes list or dict to model.
 
         :param data: dict, list.
         :param klass: class literal.
         :return: model object.
         """
         has_discriminator = False
-        if (hasattr(klass, 'get_real_child_model') and klass.discriminator_value_class_map):
+        if (
+            hasattr(klass, "get_real_child_model")
+            and klass.discriminator_value_class_map
+        ):
             has_discriminator = True
 
         if not klass.openapi_types and has_discriminator is False:
             return data
 
         kwargs = {}
-        if (data is not None and
-                klass.openapi_types is not None and
-                isinstance(data, (list, dict))):
-            for attr, attr_type in six.iteritems(klass.openapi_types):
+        if (
+            data is not None
+            and klass.openapi_types is not None
+            and isinstance(data, (list, dict))
+        ):
+            for attr, attr_type in klass.openapi_types.items():
                 if klass.attribute_map[attr] in data:
                     value = data[klass.attribute_map[attr]]
                     kwargs[attr] = self.__deserialize(value, attr_type)
 
         kwargs["local_vars_configuration"] = self.configuration
         instance = klass(**kwargs)
 
@@ -711,18 +818,16 @@
     def _get_store_id(self):
         """
         Verify that the store id has been configured and not empty string.
         It will return the store ID.
         Otherwise, raise FgaValidationException
         """
         configuration = self.configuration
-        if configuration.store_id is None or configuration.store_id == '':
-            raise FgaValidationException(
-                'store_id is required but not configured'
-            )
+        if configuration.store_id is None or configuration.store_id == "":
+            raise FgaValidationException("store_id is required but not configured")
         return configuration.store_id
 
     def set_store_id(self, value):
         """
         Update the store ID in the configuration
         """
         self.configuration.store_id = value
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/sync/client/client.py` & `openfga-sdk-0.4.2/openfga_sdk/sync/client/client.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,65 +1,75 @@
-# coding: utf-8
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
-from openfga_sdk.sync.api_client import ApiClient
-from openfga_sdk.sync.open_fga_api import OpenFgaApi
+import uuid
+from concurrent.futures import ThreadPoolExecutor
+
 from openfga_sdk.client.configuration import ClientConfiguration
 from openfga_sdk.client.models.assertion import ClientAssertion
-from openfga_sdk.client.models.check_request import ClientCheckRequest, construct_check_request
 from openfga_sdk.client.models.batch_check_response import BatchCheckResponse
-from openfga_sdk.client.models.tuple import ClientTuple, convert_tuple_keys
-from openfga_sdk.client.models.write_request import ClientWriteRequest
-from openfga_sdk.client.models.write_response import ClientWriteResponse
+from openfga_sdk.client.models.check_request import (
+    ClientCheckRequest,
+    construct_check_request,
+)
 from openfga_sdk.client.models.expand_request import ClientExpandRequest
 from openfga_sdk.client.models.list_objects_request import ClientListObjectsRequest
 from openfga_sdk.client.models.list_relations_request import ClientListRelationsRequest
-from openfga_sdk.client.models.write_single_response import construct_write_single_response
-from openfga_sdk.client.models.write_transaction_opts import WriteTransactionOpts
 from openfga_sdk.client.models.read_changes_request import ClientReadChangesRequest
+from openfga_sdk.client.models.tuple import ClientTuple, convert_tuple_keys
+from openfga_sdk.client.models.write_request import ClientWriteRequest
+from openfga_sdk.client.models.write_response import ClientWriteResponse
+from openfga_sdk.client.models.write_single_response import (
+    construct_write_single_response,
+)
+from openfga_sdk.client.models.write_transaction_opts import WriteTransactionOpts
 from openfga_sdk.exceptions import FgaValidationException
 from openfga_sdk.models.assertion import Assertion
 from openfga_sdk.models.check_request import CheckRequest
 from openfga_sdk.models.contextual_tuple_keys import ContextualTupleKeys
 from openfga_sdk.models.create_store_request import CreateStoreRequest
 from openfga_sdk.models.expand_request import ExpandRequest
 from openfga_sdk.models.expand_request_tuple_key import ExpandRequestTupleKey
 from openfga_sdk.models.list_objects_request import ListObjectsRequest
-from openfga_sdk.models.read_authorization_model_response import ReadAuthorizationModelResponse
+from openfga_sdk.models.read_authorization_model_response import (
+    ReadAuthorizationModelResponse,
+)
 from openfga_sdk.models.read_request import ReadRequest
 from openfga_sdk.models.read_request_tuple_key import ReadRequestTupleKey
 from openfga_sdk.models.tuple_key import TupleKey
 from openfga_sdk.models.write_assertions_request import WriteAssertionsRequest
-from openfga_sdk.models.write_authorization_model_request import WriteAuthorizationModelRequest
+from openfga_sdk.models.write_authorization_model_request import (
+    WriteAuthorizationModelRequest,
+)
 from openfga_sdk.models.write_request import WriteRequest
+from openfga_sdk.sync.api_client import ApiClient
+from openfga_sdk.sync.open_fga_api import OpenFgaApi
 from openfga_sdk.validation import is_well_formed_ulid_string
 
-import uuid
-from typing import List
-from concurrent.futures import ThreadPoolExecutor
-
 CLIENT_METHOD_HEADER = "X-OpenFGA-Client-Method"
 CLIENT_BULK_REQUEST_ID_HEADER = "X-OpenFGA-Client-Bulk-Request-Id"
 
 
 def _chuck_array(array, max_size):
     """
     Helper function to chuck array into arrays of max_size
     """
-    return [array[i * max_size:(i + 1) * max_size] for i in range((len(array) + max_size - 1) // max_size)]
+    return [
+        array[i * max_size : (i + 1) * max_size]
+        for i in range((len(array) + max_size - 1) // max_size)
+    ]
 
 
 def set_heading_if_not_set(options: dict[str, int | str], name: str, value: str):
     """
     Set heading to the value if it is not set
     """
     if options is None:
@@ -102,15 +112,15 @@
 def _check_allowed(response: BatchCheckResponse):
     """
     Helper function to return whether the response is check is allowed
     """
     return response.allowed
 
 
-class OpenFgaClient():
+class OpenFgaClient:
     """
     OpenFgaClient is the entry point for invoking calls against the OpenFGA API.
     """
 
     def __init__(self, configuration: ClientConfiguration):
         self._client_configuration = configuration
         self._api_client = ApiClient(configuration)
@@ -133,15 +143,17 @@
         authorization_model_id = self._client_configuration.authorization_model_id
         if options is not None and "authorization_model_id" in options:
             authorization_model_id = options["authorization_model_id"]
         if authorization_model_id is None or authorization_model_id == "":
             return None
         if is_well_formed_ulid_string(authorization_model_id) is False:
             raise FgaValidationException(
-                "authorization_model_id ('%s') is not in a valid ulid format" % authorization_model_id)
+                "authorization_model_id ('%s') is not in a valid ulid format"
+                % authorization_model_id
+            )
         return authorization_model_id
 
     def set_store_id(self, value):
         """
         Update the store ID in the configuration
         """
         self._api_client.set_store_id(value)
@@ -192,28 +204,27 @@
         options = set_heading_if_not_set(options, CLIENT_METHOD_HEADER, "ListStores")
         kwargs = options_to_kwargs(options)
         api_response = self._api.list_stores(
             **kwargs,
         )
         return api_response
 
-    def create_store(self, body: CreateStoreRequest, options: dict[str, int | str] = None):
+    def create_store(
+        self, body: CreateStoreRequest, options: dict[str, int | str] = None
+    ):
         """
         Create the stores in the system
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
         :param retryParams.minWaitInMs(options) - Override the minimum wait before a retry is initiated
         """
         options = set_heading_if_not_set(options, CLIENT_METHOD_HEADER, "CreateStore")
         kwargs = options_to_kwargs(options)
-        api_response = self._api.create_store(
-            body,
-            **kwargs
-        )
+        api_response = self._api.create_store(body, **kwargs)
         return api_response
 
     def get_store(self, options: dict[str, int | str] = None):
         """
         Get the store info in the system. Store id is from the configuration.
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
@@ -250,31 +261,37 @@
         """
         Return all the authorization models for a particular store.
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
         :param retryParams.minWaitInMs(options) - Override the minimum wait before a retry is initiated
         """
-        options = set_heading_if_not_set(options, CLIENT_METHOD_HEADER, "ReadAuthorizationModels")
+        options = set_heading_if_not_set(
+            options, CLIENT_METHOD_HEADER, "ReadAuthorizationModels"
+        )
         kwargs = options_to_kwargs(options)
         api_response = self._api.read_authorization_models(
             **kwargs,
         )
         return api_response
 
-    def write_authorization_model(self, body: WriteAuthorizationModelRequest, options: dict[str, int | str] = None):
+    def write_authorization_model(
+        self, body: WriteAuthorizationModelRequest, options: dict[str, int | str] = None
+    ):
         """
         Write authorization model.
         :param body - WriteAuthorizationModelRequest
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
         :param retryParams.minWaitInMs(options) - Override the minimum wait before a retry is initiated
         """
-        options = set_heading_if_not_set(options, CLIENT_METHOD_HEADER, "WriteAuthorizationModel")
+        options = set_heading_if_not_set(
+            options, CLIENT_METHOD_HEADER, "WriteAuthorizationModel"
+        )
         kwargs = options_to_kwargs(options)
         api_response = self._api.write_authorization_model(
             body,
             **kwargs,
         )
         return api_response
 
@@ -282,15 +299,17 @@
         """
         Read an authorization model.
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
         :param retryParams.minWaitInMs(options) - Override the minimum wait before a retry is initiated
         """
-        options = set_heading_if_not_set(options, CLIENT_METHOD_HEADER, "ReadAuthorizationModel")
+        options = set_heading_if_not_set(
+            options, CLIENT_METHOD_HEADER, "ReadAuthorizationModel"
+        )
         kwargs = options_to_kwargs(options)
         authorization_model_id = self._get_authorization_model_id(options)
         api_response = self._api.read_authorization_model(
             authorization_model_id,
             **kwargs,
         )
         return api_response
@@ -300,24 +319,27 @@
         Convenient method of reading the latest authorization model
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
         :param retryParams.minWaitInMs(options) - Override the minimum wait before a retry is initiated
         """
         options = set_heading_if_not_set(
-            options, CLIENT_METHOD_HEADER, "ReadLatestAuthoriationModel")
+            options, CLIENT_METHOD_HEADER, "ReadLatestAuthoriationModel"
+        )
         options["page_size"] = 1
         api_response = self.read_authorization_models(options)
         return ReadAuthorizationModelResponse(api_response.authorization_models[0])
 
     #######################
     # Relationship Tuples
     #######################
 
-    def read_changes(self, body: ClientReadChangesRequest, options: dict[str, str] = None):
+    def read_changes(
+        self, body: ClientReadChangesRequest, options: dict[str, str] = None
+    ):
         """
         Read changes for specified type
         :param body - the type we want to look for change
         :param page_size(options) - Number of items returned per request
         :param continuation_token(options) - No continuation_token by default
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
@@ -351,60 +373,78 @@
                 page_size = options.get("page_size")
                 options.pop("page_size")
             if options.get("continuation_token"):
                 continuation_token = options.get("continuation_token")
                 options.pop("continuation_token")
         kwargs = options_to_kwargs(options)
 
-        if body is None or (body.object is None and body.relation is None and body.user is None):
+        if body is None or (
+            body.object is None and body.relation is None and body.user is None
+        ):
             tuple_key = None
         else:
             tuple_key = body
 
         api_response = self._api.read(
             ReadRequest(
                 tuple_key=tuple_key,
                 page_size=page_size,
                 continuation_token=continuation_token,
             ),
             **kwargs,
         )
         return api_response
 
-    def _write_single_batch(self, batch: List[ClientTuple], is_write: bool, options: dict[str, str] = None):
+    def _write_single_batch(
+        self, batch: list[ClientTuple], is_write: bool, options: dict[str, str] = None
+    ):
         try:
             write_batch = None
             delete_batch = None
             if is_write:
                 write_batch = batch
             else:
                 delete_batch = batch
-            self._write_with_transaction(ClientWriteRequest(
-                writes=write_batch, deletes=delete_batch), options)
+            self._write_with_transaction(
+                ClientWriteRequest(writes=write_batch, deletes=delete_batch), options
+            )
             return [construct_write_single_response(i, True, None) for i in batch]
         except Exception as err:
             return [construct_write_single_response(i, False, err) for i in batch]
 
-    def _write_batches(self, tuple_keys: List[ClientTuple], transaction: WriteTransactionOpts, is_write: bool, options: dict[str, str] = None):
+    def _write_batches(
+        self,
+        tuple_keys: list[ClientTuple],
+        transaction: WriteTransactionOpts,
+        is_write: bool,
+        options: dict[str, str] = None,
+    ):
         """
         Internal function for write/delete batches
         """
         chunks = _chuck_array(tuple_keys, transaction.max_per_chunk)
 
         write_batches = _chuck_array(chunks, transaction.max_parallel_requests)
         batch_write_responses = []
         for write_batch in write_batches:
-            response = [self._write_single_batch(i, is_write, options) for i in write_batch]
+            response = [
+                self._write_single_batch(i, is_write, options) for i in write_batch
+            ]
             flatten_list = [
-                item for batch_single_response in response for item in batch_single_response]
+                item
+                for batch_single_response in response
+                for item in batch_single_response
+            ]
             batch_write_responses.extend(flatten_list)
 
         return batch_write_responses
 
-    def _write_with_transaction(self, body: ClientWriteRequest, options: dict[str, str] = None):
+    def _write_with_transaction(
+        self, body: ClientWriteRequest, options: dict[str, str] = None
+    ):
         """
         Write or deletes tuples
         """
         kwargs = options_to_kwargs(options)
         writes_tuple_keys = None
         deletes_tuple_keys = None
         if body.writes_tuple_keys:
@@ -419,19 +459,22 @@
                 authorization_model_id=self._get_authorization_model_id(options),
             ),
             **kwargs,
         )
         # any error will result in exception being thrown and not reached below code
         writes_response = None
         if body.writes:
-            writes_response = [construct_write_single_response(i, True, None) for i in body.writes]
+            writes_response = [
+                construct_write_single_response(i, True, None) for i in body.writes
+            ]
         deletes_response = None
         if body.deletes:
-            deletes_response = [construct_write_single_response(
-                i, True, None) for i in body.deletes]
+            deletes_response = [
+                construct_write_single_response(i, True, None) for i in body.deletes
+            ]
         return ClientWriteResponse(writes=writes_response, deletes=deletes_response)
 
     def write(self, body: ClientWriteRequest, options: dict[str, str] = None):
         """
         Write or deletes tuples
         :param body - the write request
         :param header(options) - Custom headers to send alongside the request
@@ -441,41 +484,47 @@
         """
         options = set_heading_if_not_set(options, CLIENT_METHOD_HEADER, "Writes")
         transaction = options_to_transaction_info(options)
         if not transaction.disabled:
             results = self._write_with_transaction(body, options)
             return results
 
-        options = set_heading_if_not_set(options, CLIENT_BULK_REQUEST_ID_HEADER, str(uuid.uuid4()))
+        options = set_heading_if_not_set(
+            options, CLIENT_BULK_REQUEST_ID_HEADER, str(uuid.uuid4())
+        )
         # TODO: this should be run in parallel
         self._check_valid_api_connection(options)
 
         # otherwise, it is not a transaction and it is a batch write requests
         writes_response = None
         if body.writes:
-            writes_response = self._write_batches(body.writes, transaction, True, options)
+            writes_response = self._write_batches(
+                body.writes, transaction, True, options
+            )
         deletes_response = None
         if body.deletes:
-            deletes_response = self._write_batches(body.deletes, transaction, False, options)
+            deletes_response = self._write_batches(
+                body.deletes, transaction, False, options
+            )
         return ClientWriteResponse(writes=writes_response, deletes=deletes_response)
 
-    def write_tuples(self, body: List[ClientTuple], options: dict[str, str] = None):
+    def write_tuples(self, body: list[ClientTuple], options: dict[str, str] = None):
         """
         Convenient method for writing tuples
         :param body - the list of tuples we want to write
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
         :param retryParams.minWaitInMs(options) - Override the minimum wait before a retry is initiated
         """
         options = set_heading_if_not_set(options, CLIENT_METHOD_HEADER, "WriteTuples")
         result = self.write(ClientWriteRequest(body, None), options)
         return result
 
-    def delete_tuples(self, body: List[ClientTuple], options: dict[str, str] = None):
+    def delete_tuples(self, body: list[ClientTuple], options: dict[str, str] = None):
         """
         Convenient method for deleteing tuples
         :param body - the list of tuples we want to delete
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
         :param retryParams.minWaitInMs(options) - Override the minimum wait before a retry is initiated
@@ -483,15 +532,15 @@
         options = set_heading_if_not_set(options, CLIENT_METHOD_HEADER, "DeleteTuples")
         result = self.write(ClientWriteRequest(None, body), options)
         return result
 
     #######################
     # Relationship Queries
     #######################
-    def check(self, body: ClientCheckRequest, options: dict[str, str] = None):  # noqa: E501
+    def check(self, body: ClientCheckRequest, options: dict[str, str] = None):
         """
         Check whether a user is authorized to access an object
         :param body - ClientCheckRequest defining check request
         :param authorization_model_id(options) - Overrides the authorization model id in the configuration
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
@@ -510,45 +559,55 @@
             context=body.context,
             authorization_model_id=self._get_authorization_model_id(options),
         )
         if body.contextual_tuples:
             req_body.contextual_tuples = ContextualTupleKeys(
                 tuple_keys=convert_tuple_keys(body.contextual_tuples)
             )
-        api_response = self._api.check(
-            body=req_body,
-            **kwargs
-        )
+        api_response = self._api.check(body=req_body, **kwargs)
         return api_response
 
-    def _single_batch_check(self, body: ClientCheckRequest, options: dict[str, str] = None):  # noqa: E501
+    def _single_batch_check(
+        self, body: ClientCheckRequest, options: dict[str, str] = None
+    ):
         """
         Run a single batch request and return body in a SingleBatchCheckResponse
         :param body - ClientCheckRequest defining check request
         :param authorization_model_id(options) - Overrides the authorization model id in the configuration
         """
         try:
             api_response = self.check(body, options)
-            return BatchCheckResponse(allowed=api_response.allowed, request=body, response=api_response, error=None)
+            return BatchCheckResponse(
+                allowed=api_response.allowed,
+                request=body,
+                response=api_response,
+                error=None,
+            )
         except Exception as err:
-            return BatchCheckResponse(allowed=False, request=body, response=None, error=err)
+            return BatchCheckResponse(
+                allowed=False, request=body, response=None, error=err
+            )
 
-    def batch_check(self, body: List[ClientCheckRequest], options: dict[str, str] = None):  # noqa: E501
+    def batch_check(
+        self, body: list[ClientCheckRequest], options: dict[str, str] = None
+    ):
         """
         Run a set of checks
         :param body - list of ClientCheckRequest defining check request
         :param authorization_model_id(options) - Overrides the authorization model id in the configuration
         :param max_parallel_requests(options) - Max number of requests to issue in parallel. Defaults to 10
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
         :param retryParams.minWaitInMs(options) - Override the minimum wait before a retry is initiated
         """
         options = set_heading_if_not_set(options, CLIENT_METHOD_HEADER, "BatchCheck")
-        options = set_heading_if_not_set(options, CLIENT_BULK_REQUEST_ID_HEADER, str(uuid.uuid4()))
+        options = set_heading_if_not_set(
+            options, CLIENT_BULK_REQUEST_ID_HEADER, str(uuid.uuid4())
+        )
 
         # TODO: this should be run in parallel
         self._check_valid_api_connection(options)
 
         max_parallel_requests = 10
         if options is not None and "max_parallel_requests" in options:
             max_parallel_requests = options["max_parallel_requests"]
@@ -560,15 +619,15 @@
 
         with ThreadPoolExecutor(max_workers=max_parallel_requests) as executor:
             for response in executor.map(single_batch_check, body):
                 batch_check_response.append(response)
 
         return batch_check_response
 
-    def expand(self, body: ClientExpandRequest, options: dict[str, str] = None):  # noqa: E501
+    def expand(self, body: ClientExpandRequest, options: dict[str, str] = None):
         """
         Run expand request
         :param body - list of ClientExpandRequest defining expand request
         :param authorization_model_id(options) - Overrides the authorization model id in the configuration
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
@@ -580,21 +639,20 @@
         req_body = ExpandRequest(
             tuple_key=ExpandRequestTupleKey(
                 relation=body.relation,
                 object=body.object,
             ),
             authorization_model_id=self._get_authorization_model_id(options),
         )
-        api_response = self._api.expand(
-            body=req_body,
-            **kwargs
-        )
+        api_response = self._api.expand(body=req_body, **kwargs)
         return api_response
 
-    def list_objects(self, body: ClientListObjectsRequest, options: dict[str, str] = None):  # noqa: E501
+    def list_objects(
+        self, body: ClientListObjectsRequest, options: dict[str, str] = None
+    ):
         """
         Run list object request
         :param body - list object parameters
         :param authorization_model_id(options) - Overrides the authorization model id in the configuration
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
@@ -610,80 +668,99 @@
             type=body.type,
             context=body.context,
         )
         if body.contextual_tuples:
             req_body.contextual_tuples = ContextualTupleKeys(
                 tuple_keys=convert_tuple_keys(body.contextual_tuples)
             )
-        api_response = self._api.list_objects(
-            body=req_body,
-            **kwargs
-        )
+        api_response = self._api.list_objects(body=req_body, **kwargs)
         return api_response
 
-    def list_relations(self, body: ClientListRelationsRequest, options: dict[str, str] = None):  # noqa: E501
+    def list_relations(
+        self, body: ClientListRelationsRequest, options: dict[str, str] = None
+    ):
         """
         Return all the relations for which user has a relationship with the object
         :param body - list relation request
         :param authorization_model_id(options) - Overrides the authorization model id in the configuration
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
         :param retryParams.minWaitInMs(options) - Override the minimum wait before a retry is initiated
         """
         options = set_heading_if_not_set(options, CLIENT_METHOD_HEADER, "ListRelations")
-        options = set_heading_if_not_set(options, CLIENT_BULK_REQUEST_ID_HEADER, str(uuid.uuid4()))
+        options = set_heading_if_not_set(
+            options, CLIENT_BULK_REQUEST_ID_HEADER, str(uuid.uuid4())
+        )
 
-        request_body = [construct_check_request(user=body.user, relation=i, object=body.object,
-                                                contextual_tuples=body.contextual_tuples, context=body.context) for i in body.relations]
+        request_body = [
+            construct_check_request(
+                user=body.user,
+                relation=i,
+                object=body.object,
+                contextual_tuples=body.contextual_tuples,
+                context=body.context,
+            )
+            for i in body.relations
+        ]
         result = self.batch_check(request_body, options)
         # need to filter with the allowed response
         result_iterator = filter(_check_allowed, result)
         result_list = list(result_iterator)
         return [i.request.relation for i in result_list]
 
     #######################
     # Assertions
     #######################
-
-    def read_assertions(self, options: dict[str, str] = None):  # noqa: E501
+    def read_assertions(self, options: dict[str, str] = None):
         """
         Return the assertions
         :param authorization_model_id(options) - Overrides the authorization model id in the configuration
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
         :param retryParams.minWaitInMs(options) - Override the minimum wait before a retry is initiated
         """
-        options = set_heading_if_not_set(options, CLIENT_METHOD_HEADER, "ReadAssertions")
+        options = set_heading_if_not_set(
+            options, CLIENT_METHOD_HEADER, "ReadAssertions"
+        )
 
         kwargs = options_to_kwargs(options)
         authorization_model_id = self._get_authorization_model_id(options)
         api_response = self._api.read_assertions(authorization_model_id, **kwargs)
         return api_response
 
-    def write_assertions(self, body: List[ClientAssertion], options: dict[str, str] = None):  # noqa: E501
+    def write_assertions(
+        self, body: list[ClientAssertion], options: dict[str, str] = None
+    ):
         """
         Upsert the assertions
         :param body - Write assertion request
         :param authorization_model_id(options) - Overrides the authorization model id in the configuration
         :param header(options) - Custom headers to send alongside the request
         :param retryParams(options) - Override the retry parameters for this request
         :param retryParams.maxRetry(options) - Override the max number of retries on each API request
         :param retryParams.minWaitInMs(options) - Override the minimum wait before a retry is initiated
         """
-        options = set_heading_if_not_set(options, CLIENT_METHOD_HEADER, "WriteAssertions")
+        options = set_heading_if_not_set(
+            options, CLIENT_METHOD_HEADER, "WriteAssertions"
+        )
         kwargs = options_to_kwargs(options)
         authorization_model_id = self._get_authorization_model_id(options)
 
         def map_to_assertion(client_assertion: ClientAssertion):
-            return Assertion(TupleKey(
-                user=client_assertion.user,
-                relation=client_assertion.relation,
-                object=client_assertion.object,
-            ), client_assertion.expectation)
+            return Assertion(
+                TupleKey(
+                    user=client_assertion.user,
+                    relation=client_assertion.relation,
+                    object=client_assertion.object,
+                ),
+                client_assertion.expectation,
+            )
 
         api_request_body = WriteAssertionsRequest(
-            [map_to_assertion(client_assertion) for client_assertion in body])
+            [map_to_assertion(client_assertion) for client_assertion in body]
+        )
         api_response = self._api.write_assertions(
-            authorization_model_id, api_request_body, **kwargs)
+            authorization_model_id, api_request_body, **kwargs
+        )
         return api_response
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/sync/open_fga_api.py` & `openfga-sdk-0.4.2/openfga_sdk/api/open_fga_api.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,68 +1,57 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
+from openfga_sdk.api_client import ApiClient
+from openfga_sdk.exceptions import ApiValueError, FgaValidationException
+from openfga_sdk.oauth2 import OAuth2Client
 
-import re  # noqa: F401
-
-# python 2 and python 3 compatibility library
-import six
-
-from openfga_sdk.sync.api_client import ApiClient
-from openfga_sdk.sync.oauth2 import OAuth2Client
-from openfga_sdk.exceptions import (  # noqa: F401
-    FgaValidationException,
-    ApiValueError
-)
 
-
-class OpenFgaApi(object):
+class OpenFgaApi:
     """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
         self._oauth2_client = None
         if api_client.configuration is not None:
             credentials = api_client.configuration.credentials
-            if credentials is not None and credentials.method == 'client_credentials':
+            if credentials is not None and credentials.method == "client_credentials":
                 self._oauth2_client = OAuth2Client(credentials)
 
-    def __enter__(self):
+    async def __aenter__(self):
         return self
 
-    def __exit__(self):
-        self.close()
+    async def __aexit__(self, exc_type, exc_value, traceback):
+        await self.close()
 
-    def close(self):
-        self.api_client.close()
+    async def close(self):
+        await self.api_client.close()
 
-    def check(self, body, **kwargs):  # noqa: E501
-        """Check whether a user is authorized to access an object  # noqa: E501
+    async def check(self, body, **kwargs):
+        """Check whether a user is authorized to access an object
 
-        The Check API queries to check if the user has a certain relationship with an object in a certain store. A `contextual_tuples` object may also be included in the body of the request. This object contains one field `tuple_keys`, which is an array of tuple keys. Each of these tuples may have an associated `condition`. You may also provide an `authorization_model_id` in the body. This will be used to assert that the input `tuple_key` is valid for the model specified. If not specified, the assertion will be made against the latest authorization model ID. It is strongly recommended to specify authorization model id for better performance. You may also provide a `context` object that will be used to evaluate the conditioned tuples in the system. It is strongly recommended to provide a value for all the input parameters of all the conditions, to ensure that all tuples be evaluated correctly. The response will return whether the relationship exists in the field `allowed`.  ## Example In order to check if user `user:anne` of type `user` has a `reader` relationship with object `document:2021-budget` given the following contextual tuple ```json {   \"user\": \"user:anne\",   \"relation\": \"member\",   \"object\": \"time_slot:office_hours\" } ``` the Check API can be used with the following request body: ```json {   \"tuple_key\": {     \"user\": \"user:anne\",     \"relation\": \"reader\",     \"object\": \"document:2021-budget\"   },   \"contextual_tuples\": {     \"tuple_keys\": [       {         \"user\": \"user:anne\",         \"relation\": \"member\",         \"object\": \"time_slot:office_hours\"       }     ]   },   \"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\" } ``` OpenFGA's response will include `{ \"allowed\": true }` if there is a relationship and `{ \"allowed\": false }` if there isn't.  # noqa: E501
+        The Check API queries to check if the user has a certain relationship with an object in a certain store. A `contextual_tuples` object may also be included in the body of the request. This object contains one field `tuple_keys`, which is an array of tuple keys. Each of these tuples may have an associated `condition`. You may also provide an `authorization_model_id` in the body. This will be used to assert that the input `tuple_key` is valid for the model specified. If not specified, the assertion will be made against the latest authorization model ID. It is strongly recommended to specify authorization model id for better performance. You may also provide a `context` object that will be used to evaluate the conditioned tuples in the system. It is strongly recommended to provide a value for all the input parameters of all the conditions, to ensure that all tuples be evaluated correctly. The response will return whether the relationship exists in the field `allowed`.  ## Example In order to check if user `user:anne` of type `user` has a `reader` relationship with object `document:2021-budget` given the following contextual tuple ```json {   \"user\": \"user:anne\",   \"relation\": \"member\",   \"object\": \"time_slot:office_hours\" } ``` the Check API can be used with the following request body: ```json {   \"tuple_key\": {     \"user\": \"user:anne\",     \"relation\": \"reader\",     \"object\": \"document:2021-budget\"   },   \"contextual_tuples\": {     \"tuple_keys\": [       {         \"user\": \"user:anne\",         \"relation\": \"member\",         \"object\": \"time_slot:office_hours\"       }     ]   },   \"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\" } ``` OpenFGA's response will include `{ \"allowed\": true }` if there is a relationship and `{ \"allowed\": false }` if there isn't.
 
-        >>> thread = api.check(body)
+        >>> thread = await api.check(body)
 
         :param body: (required)
         :type body: CheckRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
@@ -73,21 +62,21 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: CheckResponse
         """
-        kwargs['_return_http_data_only'] = True
-        return self.check_with_http_info(body, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return await self.check_with_http_info(body, **kwargs)
 
-    def check_with_http_info(self, body, **kwargs):  # noqa: E501
-        """Check whether a user is authorized to access an object  # noqa: E501
+    async def check_with_http_info(self, body, **kwargs):
+        """Check whether a user is authorized to access an object
 
-        The Check API queries to check if the user has a certain relationship with an object in a certain store. A `contextual_tuples` object may also be included in the body of the request. This object contains one field `tuple_keys`, which is an array of tuple keys. Each of these tuples may have an associated `condition`. You may also provide an `authorization_model_id` in the body. This will be used to assert that the input `tuple_key` is valid for the model specified. If not specified, the assertion will be made against the latest authorization model ID. It is strongly recommended to specify authorization model id for better performance. You may also provide a `context` object that will be used to evaluate the conditioned tuples in the system. It is strongly recommended to provide a value for all the input parameters of all the conditions, to ensure that all tuples be evaluated correctly. The response will return whether the relationship exists in the field `allowed`.  ## Example In order to check if user `user:anne` of type `user` has a `reader` relationship with object `document:2021-budget` given the following contextual tuple ```json {   \"user\": \"user:anne\",   \"relation\": \"member\",   \"object\": \"time_slot:office_hours\" } ``` the Check API can be used with the following request body: ```json {   \"tuple_key\": {     \"user\": \"user:anne\",     \"relation\": \"reader\",     \"object\": \"document:2021-budget\"   },   \"contextual_tuples\": {     \"tuple_keys\": [       {         \"user\": \"user:anne\",         \"relation\": \"member\",         \"object\": \"time_slot:office_hours\"       }     ]   },   \"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\" } ``` OpenFGA's response will include `{ \"allowed\": true }` if there is a relationship and `{ \"allowed\": false }` if there isn't.  # noqa: E501
+        The Check API queries to check if the user has a certain relationship with an object in a certain store. A `contextual_tuples` object may also be included in the body of the request. This object contains one field `tuple_keys`, which is an array of tuple keys. Each of these tuples may have an associated `condition`. You may also provide an `authorization_model_id` in the body. This will be used to assert that the input `tuple_key` is valid for the model specified. If not specified, the assertion will be made against the latest authorization model ID. It is strongly recommended to specify authorization model id for better performance. You may also provide a `context` object that will be used to evaluate the conditioned tuples in the system. It is strongly recommended to provide a value for all the input parameters of all the conditions, to ensure that all tuples be evaluated correctly. The response will return whether the relationship exists in the field `allowed`.  ## Example In order to check if user `user:anne` of type `user` has a `reader` relationship with object `document:2021-budget` given the following contextual tuple ```json {   \"user\": \"user:anne\",   \"relation\": \"member\",   \"object\": \"time_slot:office_hours\" } ``` the Check API can be used with the following request body: ```json {   \"tuple_key\": {     \"user\": \"user:anne\",     \"relation\": \"reader\",     \"object\": \"document:2021-budget\"   },   \"contextual_tuples\": {     \"tuple_keys\": [       {         \"user\": \"user:anne\",         \"relation\": \"member\",         \"object\": \"time_slot:office_hours\"       }     ]   },   \"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\" } ``` OpenFGA's response will include `{ \"allowed\": true }` if there is a relationship and `{ \"allowed\": false }` if there isn't.
 
         >>> thread = api.check_with_http_info(body)
 
         :param body: (required)
         :type body: CheckRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
@@ -112,107 +101,117 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: tuple(CheckResponse, status_code(int), headers(HTTPHeaderDict))
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-            'body'
-
-        ]
+        all_params = ["body"]
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method check" % key
+                    "Got an unexpected keyword argument '%s'" " to method check" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
         # verify the required parameter 'body' is set
-        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
-            raise ApiValueError("Missing the required parameter `body` when calling `check`")  # noqa: E501
+        if (
+            self.api_client.client_side_validation
+            and local_var_params.get("body") is None
+        ):
+            raise ApiValueError(
+                "Missing the required parameter `body` when calling `check`"
+            )
 
         collection_formats = {}
 
         path_params = {}
 
         if self.api_client._get_store_id() is None:
-            raise ApiValueError("Store ID expected in api_client's configuration when calling `check`")  # noqa: E501
+            raise ApiValueError(
+                "Store ID expected in api_client's configuration when calling `check`"
+            )
         store_id = self.api_client._get_store_id()
 
         query_params = []
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in local_var_params:
-            body_params = local_var_params['body']
+        if "body" in local_var_params:
+            body_params = local_var_params["body"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # HTTP header `Content-Type`
-        content_types_list = local_var_params.get('_content_type', self.api_client.select_header_content_type(['application/json'], 'POST', body_params))  # noqa: E501
+        content_types_list = local_var_params.get(
+            "_content_type",
+            self.api_client.select_header_content_type(
+                ["application/json"], "POST", body_params
+            ),
+        )
         if content_types_list:
-            header_params['Content-Type'] = content_types_list
+            header_params["Content-Type"] = content_types_list
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {
             200: "CheckResponse",
             400: "ValidationErrorMessageResponse",
             404: "PathUnknownErrorMessageResponse",
             409: "AbortedMessageResponse",
             500: "InternalErrorMessageResponse",
         }
 
-        return self.api_client.call_api(
-            '/stores/{store_id}/check'.replace('{store_id}', store_id), 'POST',
+        return await self.api_client.call_api(
+            "/stores/{store_id}/check".replace("{store_id}", store_id),
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client)
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    def create_store(self, body, **kwargs):  # noqa: E501
-        """Create a store  # noqa: E501
+    async def create_store(self, body, **kwargs):
+        """Create a store
 
-        Create a unique OpenFGA store which will be used to store authorization models and relationship tuples.  # noqa: E501
+        Create a unique OpenFGA store which will be used to store authorization models and relationship tuples.
 
-        >>> thread = api.create_store(body)
+        >>> thread = await api.create_store(body)
 
         :param body: (required)
         :type body: CreateStoreRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
@@ -223,21 +222,21 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: CreateStoreResponse
         """
-        kwargs['_return_http_data_only'] = True
-        return self.create_store_with_http_info(body, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return await self.create_store_with_http_info(body, **kwargs)
 
-    def create_store_with_http_info(self, body, **kwargs):  # noqa: E501
-        """Create a store  # noqa: E501
+    async def create_store_with_http_info(self, body, **kwargs):
+        """Create a store
 
-        Create a unique OpenFGA store which will be used to store authorization models and relationship tuples.  # noqa: E501
+        Create a unique OpenFGA store which will be used to store authorization models and relationship tuples.
 
         >>> thread = api.create_store_with_http_info(body)
 
         :param body: (required)
         :type body: CreateStoreRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
@@ -262,100 +261,104 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: tuple(CreateStoreResponse, status_code(int), headers(HTTPHeaderDict))
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-            'body'
-
-        ]
+        all_params = ["body"]
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_store" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in local_var_params:
-            body_params = local_var_params['body']
+        if "body" in local_var_params:
+            body_params = local_var_params["body"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # HTTP header `Content-Type`
-        content_types_list = local_var_params.get('_content_type', self.api_client.select_header_content_type(['application/json'], 'POST', body_params))  # noqa: E501
+        content_types_list = local_var_params.get(
+            "_content_type",
+            self.api_client.select_header_content_type(
+                ["application/json"], "POST", body_params
+            ),
+        )
         if content_types_list:
-            header_params['Content-Type'] = content_types_list
+            header_params["Content-Type"] = content_types_list
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {
             201: "CreateStoreResponse",
             400: "ValidationErrorMessageResponse",
             404: "PathUnknownErrorMessageResponse",
             409: "AbortedMessageResponse",
             500: "InternalErrorMessageResponse",
         }
 
-        return self.api_client.call_api(
-            '/stores', 'POST',
+        return await self.api_client.call_api(
+            "/stores",
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client)
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    def delete_store(self, **kwargs):  # noqa: E501
-        """Delete a store  # noqa: E501
+    async def delete_store(self, **kwargs):
+        """Delete a store
 
-        Delete an OpenFGA store. This does not delete the data associated with the store, like tuples or authorization models.  # noqa: E501
+        Delete an OpenFGA store. This does not delete the data associated with the store, like tuples or authorization models.
 
-        >>> thread = api.delete_store()
+        >>> thread = await api.delete_store()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :type _preload_content: bool, optional
@@ -364,21 +367,21 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
-        kwargs['_return_http_data_only'] = True
-        return self.delete_store_with_http_info(**kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return await self.delete_store_with_http_info(**kwargs)
 
-    def delete_store_with_http_info(self, **kwargs):  # noqa: E501
-        """Delete a store  # noqa: E501
+    async def delete_store_with_http_info(self, **kwargs):
+        """Delete a store
 
-        Delete an OpenFGA store. This does not delete the data associated with the store, like tuples or authorization models.  # noqa: E501
+        Delete an OpenFGA store. This does not delete the data associated with the store, like tuples or authorization models.
 
         >>> thread = api.delete_store_with_http_info()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
         :param _return_http_data_only: response data without head status code
                                        and headers
@@ -401,89 +404,92 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-        ]
+        all_params = []
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete_store" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
 
         collection_formats = {}
 
         path_params = {}
 
         if self.api_client._get_store_id() is None:
-            raise ApiValueError("Store ID expected in api_client's configuration when calling `delete_store`")  # noqa: E501
+            raise ApiValueError(
+                "Store ID expected in api_client's configuration when calling `delete_store`"
+            )
         store_id = self.api_client._get_store_id()
 
         query_params = []
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {}
 
-        return self.api_client.call_api(
-            '/stores/{store_id}'.replace('{store_id}', store_id), 'DELETE',
+        return await self.api_client.call_api(
+            "/stores/{store_id}".replace("{store_id}", store_id),
+            "DELETE",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client)
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    def expand(self, body, **kwargs):  # noqa: E501
-        """Expand all relationships in userset tree format, and following userset rewrite rules.  Useful to reason about and debug a certain relationship  # noqa: E501
+    async def expand(self, body, **kwargs):
+        """Expand all relationships in userset tree format, and following userset rewrite rules.  Useful to reason about and debug a certain relationship
 
-        The Expand API will return all users and usersets that have certain relationship with an object in a certain store. This is different from the `/stores/{store_id}/read` API in that both users and computed usersets are returned. Body parameters `tuple_key.object` and `tuple_key.relation` are all required. The response will return a tree whose leaves are the specific users and usersets. Union, intersection and difference operator are located in the intermediate nodes.  ## Example To expand all users that have the `reader` relationship with object `document:2021-budget`, use the Expand API with the following request body ```json {   \"tuple_key\": {     \"object\": \"document:2021-budget\",     \"relation\": \"reader\"   },   \"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\" } ``` OpenFGA's response will be a userset tree of the users and usersets that have read access to the document. ```json {   \"tree\":{     \"root\":{       \"type\":\"document:2021-budget#reader\",       \"union\":{         \"nodes\":[           {             \"type\":\"document:2021-budget#reader\",             \"leaf\":{               \"users\":{                 \"users\":[                   \"user:bob\"                 ]               }             }           },           {             \"type\":\"document:2021-budget#reader\",             \"leaf\":{               \"computed\":{                 \"userset\":\"document:2021-budget#writer\"               }             }           }         ]       }     }   } } ``` The caller can then call expand API for the `writer` relationship for the `document:2021-budget`.  # noqa: E501
+        The Expand API will return all users and usersets that have certain relationship with an object in a certain store. This is different from the `/stores/{store_id}/read` API in that both users and computed usersets are returned. Body parameters `tuple_key.object` and `tuple_key.relation` are all required. The response will return a tree whose leaves are the specific users and usersets. Union, intersection and difference operator are located in the intermediate nodes.  ## Example To expand all users that have the `reader` relationship with object `document:2021-budget`, use the Expand API with the following request body ```json {   \"tuple_key\": {     \"object\": \"document:2021-budget\",     \"relation\": \"reader\"   },   \"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\" } ``` OpenFGA's response will be a userset tree of the users and usersets that have read access to the document. ```json {   \"tree\":{     \"root\":{       \"type\":\"document:2021-budget#reader\",       \"union\":{         \"nodes\":[           {             \"type\":\"document:2021-budget#reader\",             \"leaf\":{               \"users\":{                 \"users\":[                   \"user:bob\"                 ]               }             }           },           {             \"type\":\"document:2021-budget#reader\",             \"leaf\":{               \"computed\":{                 \"userset\":\"document:2021-budget#writer\"               }             }           }         ]       }     }   } } ``` The caller can then call expand API for the `writer` relationship for the `document:2021-budget`.
 
-        >>> thread = api.expand(body)
+        >>> thread = await api.expand(body)
 
         :param body: (required)
         :type body: ExpandRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
@@ -494,21 +500,21 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ExpandResponse
         """
-        kwargs['_return_http_data_only'] = True
-        return self.expand_with_http_info(body, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return await self.expand_with_http_info(body, **kwargs)
 
-    def expand_with_http_info(self, body, **kwargs):  # noqa: E501
-        """Expand all relationships in userset tree format, and following userset rewrite rules.  Useful to reason about and debug a certain relationship  # noqa: E501
+    async def expand_with_http_info(self, body, **kwargs):
+        """Expand all relationships in userset tree format, and following userset rewrite rules.  Useful to reason about and debug a certain relationship
 
-        The Expand API will return all users and usersets that have certain relationship with an object in a certain store. This is different from the `/stores/{store_id}/read` API in that both users and computed usersets are returned. Body parameters `tuple_key.object` and `tuple_key.relation` are all required. The response will return a tree whose leaves are the specific users and usersets. Union, intersection and difference operator are located in the intermediate nodes.  ## Example To expand all users that have the `reader` relationship with object `document:2021-budget`, use the Expand API with the following request body ```json {   \"tuple_key\": {     \"object\": \"document:2021-budget\",     \"relation\": \"reader\"   },   \"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\" } ``` OpenFGA's response will be a userset tree of the users and usersets that have read access to the document. ```json {   \"tree\":{     \"root\":{       \"type\":\"document:2021-budget#reader\",       \"union\":{         \"nodes\":[           {             \"type\":\"document:2021-budget#reader\",             \"leaf\":{               \"users\":{                 \"users\":[                   \"user:bob\"                 ]               }             }           },           {             \"type\":\"document:2021-budget#reader\",             \"leaf\":{               \"computed\":{                 \"userset\":\"document:2021-budget#writer\"               }             }           }         ]       }     }   } } ``` The caller can then call expand API for the `writer` relationship for the `document:2021-budget`.  # noqa: E501
+        The Expand API will return all users and usersets that have certain relationship with an object in a certain store. This is different from the `/stores/{store_id}/read` API in that both users and computed usersets are returned. Body parameters `tuple_key.object` and `tuple_key.relation` are all required. The response will return a tree whose leaves are the specific users and usersets. Union, intersection and difference operator are located in the intermediate nodes.  ## Example To expand all users that have the `reader` relationship with object `document:2021-budget`, use the Expand API with the following request body ```json {   \"tuple_key\": {     \"object\": \"document:2021-budget\",     \"relation\": \"reader\"   },   \"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\" } ``` OpenFGA's response will be a userset tree of the users and usersets that have read access to the document. ```json {   \"tree\":{     \"root\":{       \"type\":\"document:2021-budget#reader\",       \"union\":{         \"nodes\":[           {             \"type\":\"document:2021-budget#reader\",             \"leaf\":{               \"users\":{                 \"users\":[                   \"user:bob\"                 ]               }             }           },           {             \"type\":\"document:2021-budget#reader\",             \"leaf\":{               \"computed\":{                 \"userset\":\"document:2021-budget#writer\"               }             }           }         ]       }     }   } } ``` The caller can then call expand API for the `writer` relationship for the `document:2021-budget`.
 
         >>> thread = api.expand_with_http_info(body)
 
         :param body: (required)
         :type body: ExpandRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
@@ -533,107 +539,117 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: tuple(ExpandResponse, status_code(int), headers(HTTPHeaderDict))
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-            'body'
-
-        ]
+        all_params = ["body"]
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method expand" % key
+                    "Got an unexpected keyword argument '%s'" " to method expand" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
         # verify the required parameter 'body' is set
-        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
-            raise ApiValueError("Missing the required parameter `body` when calling `expand`")  # noqa: E501
+        if (
+            self.api_client.client_side_validation
+            and local_var_params.get("body") is None
+        ):
+            raise ApiValueError(
+                "Missing the required parameter `body` when calling `expand`"
+            )
 
         collection_formats = {}
 
         path_params = {}
 
         if self.api_client._get_store_id() is None:
-            raise ApiValueError("Store ID expected in api_client's configuration when calling `expand`")  # noqa: E501
+            raise ApiValueError(
+                "Store ID expected in api_client's configuration when calling `expand`"
+            )
         store_id = self.api_client._get_store_id()
 
         query_params = []
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in local_var_params:
-            body_params = local_var_params['body']
+        if "body" in local_var_params:
+            body_params = local_var_params["body"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # HTTP header `Content-Type`
-        content_types_list = local_var_params.get('_content_type', self.api_client.select_header_content_type(['application/json'], 'POST', body_params))  # noqa: E501
+        content_types_list = local_var_params.get(
+            "_content_type",
+            self.api_client.select_header_content_type(
+                ["application/json"], "POST", body_params
+            ),
+        )
         if content_types_list:
-            header_params['Content-Type'] = content_types_list
+            header_params["Content-Type"] = content_types_list
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {
             200: "ExpandResponse",
             400: "ValidationErrorMessageResponse",
             404: "PathUnknownErrorMessageResponse",
             409: "AbortedMessageResponse",
             500: "InternalErrorMessageResponse",
         }
 
-        return self.api_client.call_api(
-            '/stores/{store_id}/expand'.replace('{store_id}', store_id), 'POST',
+        return await self.api_client.call_api(
+            "/stores/{store_id}/expand".replace("{store_id}", store_id),
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client)
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    def get_store(self, **kwargs):  # noqa: E501
-        """Get a store  # noqa: E501
+    async def get_store(self, **kwargs):
+        """Get a store
 
-        Returns an OpenFGA store by its identifier  # noqa: E501
+        Returns an OpenFGA store by its identifier
 
-        >>> thread = api.get_store()
+        >>> thread = await api.get_store()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :type _preload_content: bool, optional
@@ -642,21 +658,21 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GetStoreResponse
         """
-        kwargs['_return_http_data_only'] = True
-        return self.get_store_with_http_info(**kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return await self.get_store_with_http_info(**kwargs)
 
-    def get_store_with_http_info(self, **kwargs):  # noqa: E501
-        """Get a store  # noqa: E501
+    async def get_store_with_http_info(self, **kwargs):
+        """Get a store
 
-        Returns an OpenFGA store by its identifier  # noqa: E501
+        Returns an OpenFGA store by its identifier
 
         >>> thread = api.get_store_with_http_info()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
         :param _return_http_data_only: response data without head status code
                                        and headers
@@ -679,95 +695,98 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: tuple(GetStoreResponse, status_code(int), headers(HTTPHeaderDict))
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-        ]
+        all_params = []
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_store" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
 
         collection_formats = {}
 
         path_params = {}
 
         if self.api_client._get_store_id() is None:
-            raise ApiValueError("Store ID expected in api_client's configuration when calling `get_store`")  # noqa: E501
+            raise ApiValueError(
+                "Store ID expected in api_client's configuration when calling `get_store`"
+            )
         store_id = self.api_client._get_store_id()
 
         query_params = []
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {
             200: "GetStoreResponse",
             400: "ValidationErrorMessageResponse",
             404: "PathUnknownErrorMessageResponse",
             409: "AbortedMessageResponse",
             500: "InternalErrorMessageResponse",
         }
 
-        return self.api_client.call_api(
-            '/stores/{store_id}'.replace('{store_id}', store_id), 'GET',
+        return await self.api_client.call_api(
+            "/stores/{store_id}".replace("{store_id}", store_id),
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client)
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    def list_objects(self, body, **kwargs):  # noqa: E501
-        """List all objects of the given type that the user has a relation with  # noqa: E501
+    async def list_objects(self, body, **kwargs):
+        """List all objects of the given type that the user has a relation with
 
-        The ListObjects API returns a list of all the objects of the given type that the user has a relation with. To achieve this, both the store tuples and the authorization model are used. An `authorization_model_id` may be specified in the body. If it is not specified, the latest authorization model ID will be used. It is strongly recommended to specify authorization model id for better performance. You may also specify `contextual_tuples` that will be treated as regular tuples. Each of these tuples may have an associated `condition`. You may also provide a `context` object that will be used to evaluate the conditioned tuples in the system. It is strongly recommended to provide a value for all the input parameters of all the conditions, to ensure that all tuples be evaluated correctly. The response will contain the related objects in an array in the \"objects\" field of the response and they will be strings in the object format `<type>:<id>` (e.g. \"document:roadmap\"). The number of objects in the response array will be limited by the execution timeout specified in the flag OPENFGA_LIST_OBJECTS_DEADLINE and by the upper bound specified in the flag OPENFGA_LIST_OBJECTS_MAX_RESULTS, whichever is hit first. The objects given will not be sorted, and therefore two identical calls can give a given different set of objects.  # noqa: E501
+        The ListObjects API returns a list of all the objects of the given type that the user has a relation with. To achieve this, both the store tuples and the authorization model are used. An `authorization_model_id` may be specified in the body. If it is not specified, the latest authorization model ID will be used. It is strongly recommended to specify authorization model id for better performance. You may also specify `contextual_tuples` that will be treated as regular tuples. Each of these tuples may have an associated `condition`. You may also provide a `context` object that will be used to evaluate the conditioned tuples in the system. It is strongly recommended to provide a value for all the input parameters of all the conditions, to ensure that all tuples be evaluated correctly. The response will contain the related objects in an array in the \"objects\" field of the response and they will be strings in the object format `<type>:<id>` (e.g. \"document:roadmap\"). The number of objects in the response array will be limited by the execution timeout specified in the flag OPENFGA_LIST_OBJECTS_DEADLINE and by the upper bound specified in the flag OPENFGA_LIST_OBJECTS_MAX_RESULTS, whichever is hit first. The objects given will not be sorted, and therefore two identical calls can give a given different set of objects.
 
-        >>> thread = api.list_objects(body)
+        >>> thread = await api.list_objects(body)
 
         :param body: (required)
         :type body: ListObjectsRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
@@ -778,21 +797,21 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ListObjectsResponse
         """
-        kwargs['_return_http_data_only'] = True
-        return self.list_objects_with_http_info(body, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return await self.list_objects_with_http_info(body, **kwargs)
 
-    def list_objects_with_http_info(self, body, **kwargs):  # noqa: E501
-        """List all objects of the given type that the user has a relation with  # noqa: E501
+    async def list_objects_with_http_info(self, body, **kwargs):
+        """List all objects of the given type that the user has a relation with
 
-        The ListObjects API returns a list of all the objects of the given type that the user has a relation with. To achieve this, both the store tuples and the authorization model are used. An `authorization_model_id` may be specified in the body. If it is not specified, the latest authorization model ID will be used. It is strongly recommended to specify authorization model id for better performance. You may also specify `contextual_tuples` that will be treated as regular tuples. Each of these tuples may have an associated `condition`. You may also provide a `context` object that will be used to evaluate the conditioned tuples in the system. It is strongly recommended to provide a value for all the input parameters of all the conditions, to ensure that all tuples be evaluated correctly. The response will contain the related objects in an array in the \"objects\" field of the response and they will be strings in the object format `<type>:<id>` (e.g. \"document:roadmap\"). The number of objects in the response array will be limited by the execution timeout specified in the flag OPENFGA_LIST_OBJECTS_DEADLINE and by the upper bound specified in the flag OPENFGA_LIST_OBJECTS_MAX_RESULTS, whichever is hit first. The objects given will not be sorted, and therefore two identical calls can give a given different set of objects.  # noqa: E501
+        The ListObjects API returns a list of all the objects of the given type that the user has a relation with. To achieve this, both the store tuples and the authorization model are used. An `authorization_model_id` may be specified in the body. If it is not specified, the latest authorization model ID will be used. It is strongly recommended to specify authorization model id for better performance. You may also specify `contextual_tuples` that will be treated as regular tuples. Each of these tuples may have an associated `condition`. You may also provide a `context` object that will be used to evaluate the conditioned tuples in the system. It is strongly recommended to provide a value for all the input parameters of all the conditions, to ensure that all tuples be evaluated correctly. The response will contain the related objects in an array in the \"objects\" field of the response and they will be strings in the object format `<type>:<id>` (e.g. \"document:roadmap\"). The number of objects in the response array will be limited by the execution timeout specified in the flag OPENFGA_LIST_OBJECTS_DEADLINE and by the upper bound specified in the flag OPENFGA_LIST_OBJECTS_MAX_RESULTS, whichever is hit first. The objects given will not be sorted, and therefore two identical calls can give a given different set of objects.
 
         >>> thread = api.list_objects_with_http_info(body)
 
         :param body: (required)
         :type body: ListObjectsRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
@@ -817,107 +836,118 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: tuple(ListObjectsResponse, status_code(int), headers(HTTPHeaderDict))
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-            'body'
-
-        ]
+        all_params = ["body"]
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
                     "Got an unexpected keyword argument '%s'"
                     " to method list_objects" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
         # verify the required parameter 'body' is set
-        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
-            raise ApiValueError("Missing the required parameter `body` when calling `list_objects`")  # noqa: E501
+        if (
+            self.api_client.client_side_validation
+            and local_var_params.get("body") is None
+        ):
+            raise ApiValueError(
+                "Missing the required parameter `body` when calling `list_objects`"
+            )
 
         collection_formats = {}
 
         path_params = {}
 
         if self.api_client._get_store_id() is None:
-            raise ApiValueError("Store ID expected in api_client's configuration when calling `list_objects`")  # noqa: E501
+            raise ApiValueError(
+                "Store ID expected in api_client's configuration when calling `list_objects`"
+            )
         store_id = self.api_client._get_store_id()
 
         query_params = []
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in local_var_params:
-            body_params = local_var_params['body']
+        if "body" in local_var_params:
+            body_params = local_var_params["body"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # HTTP header `Content-Type`
-        content_types_list = local_var_params.get('_content_type', self.api_client.select_header_content_type(['application/json'], 'POST', body_params))  # noqa: E501
+        content_types_list = local_var_params.get(
+            "_content_type",
+            self.api_client.select_header_content_type(
+                ["application/json"], "POST", body_params
+            ),
+        )
         if content_types_list:
-            header_params['Content-Type'] = content_types_list
+            header_params["Content-Type"] = content_types_list
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {
             200: "ListObjectsResponse",
             400: "ValidationErrorMessageResponse",
             404: "PathUnknownErrorMessageResponse",
             409: "AbortedMessageResponse",
             500: "InternalErrorMessageResponse",
         }
 
-        return self.api_client.call_api(
-            '/stores/{store_id}/list-objects'.replace('{store_id}', store_id), 'POST',
+        return await self.api_client.call_api(
+            "/stores/{store_id}/list-objects".replace("{store_id}", store_id),
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client)
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    def list_stores(self, **kwargs):  # noqa: E501
-        """List all stores  # noqa: E501
+    async def list_stores(self, **kwargs):
+        """List all stores
 
-        Returns a paginated list of OpenFGA stores and a continuation token to get additional stores. The continuation token will be empty if there are no more stores.   # noqa: E501
+        Returns a paginated list of OpenFGA stores and a continuation token to get additional stores. The continuation token will be empty if there are no more stores.
 
-        >>> thread = api.list_stores()
+        >>> thread = await api.list_stores()
 
         :param page_size:(optional)
         :type page_size: int, optional
         :param continuation_token:(optional)
         :type continuation_token: str, optional
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
@@ -930,21 +960,21 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ListStoresResponse
         """
-        kwargs['_return_http_data_only'] = True
-        return self.list_stores_with_http_info(**kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return await self.list_stores_with_http_info(**kwargs)
 
-    def list_stores_with_http_info(self, **kwargs):  # noqa: E501
-        """List all stores  # noqa: E501
+    async def list_stores_with_http_info(self, **kwargs):
+        """List all stores
 
-        Returns a paginated list of OpenFGA stores and a continuation token to get additional stores. The continuation token will be empty if there are no more stores.   # noqa: E501
+        Returns a paginated list of OpenFGA stores and a continuation token to get additional stores. The continuation token will be empty if there are no more stores.
 
         >>> thread = api.list_stores_with_http_info()
 
         :param page_size:(optional)
         :type page_size: int, optional
         :param continuation_token:(optional)
         :type continuation_token: str, optional
@@ -971,97 +1001,98 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: tuple(ListStoresResponse, status_code(int), headers(HTTPHeaderDict))
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-            'page_size',
-            'continuation_token'
-        ]
+        all_params = ["page_size", "continuation_token"]
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
                     "Got an unexpected keyword argument '%s'"
                     " to method list_stores" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
-        if local_var_params.get('page_size') is not None:  # noqa: E501
-            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501
-        if local_var_params.get('continuation_token') is not None:  # noqa: E501
-            query_params.append(('continuation_token', local_var_params['continuation_token']))  # noqa: E501
+        if local_var_params.get("page_size") is not None:
+            query_params.append(("page_size", local_var_params["page_size"]))
+        if local_var_params.get("continuation_token") is not None:
+            query_params.append(
+                ("continuation_token", local_var_params["continuation_token"])
+            )
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {
             200: "ListStoresResponse",
             400: "ValidationErrorMessageResponse",
             404: "PathUnknownErrorMessageResponse",
             409: "AbortedMessageResponse",
             500: "InternalErrorMessageResponse",
         }
 
-        return self.api_client.call_api(
-            '/stores', 'GET',
+        return await self.api_client.call_api(
+            "/stores",
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client)
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    def read(self, body, **kwargs):  # noqa: E501
-        """Get tuples from the store that matches a query, without following userset rewrite rules  # noqa: E501
+    async def read(self, body, **kwargs):
+        """Get tuples from the store that matches a query, without following userset rewrite rules
 
-        The Read API will return the tuples for a certain store that match a query filter specified in the body of the request.  The API doesn't guarantee order by any field.  It is different from the `/stores/{store_id}/expand` API in that it only returns relationship tuples that are stored in the system and satisfy the query.  In the body: 1. `tuple_key` is optional. If not specified, it will return all tuples in the store. 2. `tuple_key.object` is mandatory if `tuple_key` is specified. It can be a full object (e.g., `type:object_id`) or type only (e.g., `type:`). 3. `tuple_key.user` is mandatory if tuple_key is specified in the case the `tuple_key.object` is a type only. ## Examples ### Query for all objects in a type definition To query for all objects that `user:bob` has `reader` relationship in the `document` type definition, call read API with body of ```json {  \"tuple_key\": {      \"user\": \"user:bob\",      \"relation\": \"reader\",      \"object\": \"document:\"   } } ``` The API will return tuples and a continuation token, something like ```json {   \"tuples\": [     {       \"key\": {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-06T15:32:11.128Z\"     }   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` This means that `user:bob` has a `reader` relationship with 1 document `document:2021-budget`. Note that this API, unlike the List Objects API, does not evaluate the tuples in the store. The continuation token will be empty if there are no more tuples to query. ### Query for all stored relationship tuples that have a particular relation and object To query for all users that have `reader` relationship with `document:2021-budget`, call read API with body of  ```json {   \"tuple_key\": {      \"object\": \"document:2021-budget\",      \"relation\": \"reader\"    } } ``` The API will return something like  ```json {   \"tuples\": [     {       \"key\": {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-06T15:32:11.128Z\"     }   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` This means that `document:2021-budget` has 1 `reader` (`user:bob`).  Note that, even if the model said that all `writers` are also `readers`, the API will not return writers such as `user:anne` because it only returns tuples and does not evaluate them. ### Query for all users with all relationships for a particular document To query for all users that have any relationship with `document:2021-budget`, call read API with body of  ```json {   \"tuple_key\": {       \"object\": \"document:2021-budget\"    } } ``` The API will return something like  ```json {   \"tuples\": [     {       \"key\": {         \"user\": \"user:anne\",         \"relation\": \"writer\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-05T13:42:12.356Z\"     },     {       \"key\": {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-06T15:32:11.128Z\"     }   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` This means that `document:2021-budget` has 1 `reader` (`user:bob`) and 1 `writer` (`user:anne`).   # noqa: E501
+        The Read API will return the tuples for a certain store that match a query filter specified in the body of the request.  The API doesn't guarantee order by any field.  It is different from the `/stores/{store_id}/expand` API in that it only returns relationship tuples that are stored in the system and satisfy the query.  In the body: 1. `tuple_key` is optional. If not specified, it will return all tuples in the store. 2. `tuple_key.object` is mandatory if `tuple_key` is specified. It can be a full object (e.g., `type:object_id`) or type only (e.g., `type:`). 3. `tuple_key.user` is mandatory if tuple_key is specified in the case the `tuple_key.object` is a type only. ## Examples ### Query for all objects in a type definition To query for all objects that `user:bob` has `reader` relationship in the `document` type definition, call read API with body of ```json {  \"tuple_key\": {      \"user\": \"user:bob\",      \"relation\": \"reader\",      \"object\": \"document:\"   } } ``` The API will return tuples and a continuation token, something like ```json {   \"tuples\": [     {       \"key\": {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-06T15:32:11.128Z\"     }   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` This means that `user:bob` has a `reader` relationship with 1 document `document:2021-budget`. Note that this API, unlike the List Objects API, does not evaluate the tuples in the store. The continuation token will be empty if there are no more tuples to query. ### Query for all stored relationship tuples that have a particular relation and object To query for all users that have `reader` relationship with `document:2021-budget`, call read API with body of  ```json {   \"tuple_key\": {      \"object\": \"document:2021-budget\",      \"relation\": \"reader\"    } } ``` The API will return something like  ```json {   \"tuples\": [     {       \"key\": {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-06T15:32:11.128Z\"     }   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` This means that `document:2021-budget` has 1 `reader` (`user:bob`).  Note that, even if the model said that all `writers` are also `readers`, the API will not return writers such as `user:anne` because it only returns tuples and does not evaluate them. ### Query for all users with all relationships for a particular document To query for all users that have any relationship with `document:2021-budget`, call read API with body of  ```json {   \"tuple_key\": {       \"object\": \"document:2021-budget\"    } } ``` The API will return something like  ```json {   \"tuples\": [     {       \"key\": {         \"user\": \"user:anne\",         \"relation\": \"writer\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-05T13:42:12.356Z\"     },     {       \"key\": {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-06T15:32:11.128Z\"     }   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` This means that `document:2021-budget` has 1 `reader` (`user:bob`) and 1 `writer` (`user:anne`).
 
-        >>> thread = api.read(body)
+        >>> thread = await api.read(body)
 
         :param body: (required)
         :type body: ReadRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
@@ -1072,21 +1103,21 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ReadResponse
         """
-        kwargs['_return_http_data_only'] = True
-        return self.read_with_http_info(body, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return await self.read_with_http_info(body, **kwargs)
 
-    def read_with_http_info(self, body, **kwargs):  # noqa: E501
-        """Get tuples from the store that matches a query, without following userset rewrite rules  # noqa: E501
+    async def read_with_http_info(self, body, **kwargs):
+        """Get tuples from the store that matches a query, without following userset rewrite rules
 
-        The Read API will return the tuples for a certain store that match a query filter specified in the body of the request.  The API doesn't guarantee order by any field.  It is different from the `/stores/{store_id}/expand` API in that it only returns relationship tuples that are stored in the system and satisfy the query.  In the body: 1. `tuple_key` is optional. If not specified, it will return all tuples in the store. 2. `tuple_key.object` is mandatory if `tuple_key` is specified. It can be a full object (e.g., `type:object_id`) or type only (e.g., `type:`). 3. `tuple_key.user` is mandatory if tuple_key is specified in the case the `tuple_key.object` is a type only. ## Examples ### Query for all objects in a type definition To query for all objects that `user:bob` has `reader` relationship in the `document` type definition, call read API with body of ```json {  \"tuple_key\": {      \"user\": \"user:bob\",      \"relation\": \"reader\",      \"object\": \"document:\"   } } ``` The API will return tuples and a continuation token, something like ```json {   \"tuples\": [     {       \"key\": {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-06T15:32:11.128Z\"     }   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` This means that `user:bob` has a `reader` relationship with 1 document `document:2021-budget`. Note that this API, unlike the List Objects API, does not evaluate the tuples in the store. The continuation token will be empty if there are no more tuples to query. ### Query for all stored relationship tuples that have a particular relation and object To query for all users that have `reader` relationship with `document:2021-budget`, call read API with body of  ```json {   \"tuple_key\": {      \"object\": \"document:2021-budget\",      \"relation\": \"reader\"    } } ``` The API will return something like  ```json {   \"tuples\": [     {       \"key\": {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-06T15:32:11.128Z\"     }   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` This means that `document:2021-budget` has 1 `reader` (`user:bob`).  Note that, even if the model said that all `writers` are also `readers`, the API will not return writers such as `user:anne` because it only returns tuples and does not evaluate them. ### Query for all users with all relationships for a particular document To query for all users that have any relationship with `document:2021-budget`, call read API with body of  ```json {   \"tuple_key\": {       \"object\": \"document:2021-budget\"    } } ``` The API will return something like  ```json {   \"tuples\": [     {       \"key\": {         \"user\": \"user:anne\",         \"relation\": \"writer\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-05T13:42:12.356Z\"     },     {       \"key\": {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-06T15:32:11.128Z\"     }   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` This means that `document:2021-budget` has 1 `reader` (`user:bob`) and 1 `writer` (`user:anne`).   # noqa: E501
+        The Read API will return the tuples for a certain store that match a query filter specified in the body of the request.  The API doesn't guarantee order by any field.  It is different from the `/stores/{store_id}/expand` API in that it only returns relationship tuples that are stored in the system and satisfy the query.  In the body: 1. `tuple_key` is optional. If not specified, it will return all tuples in the store. 2. `tuple_key.object` is mandatory if `tuple_key` is specified. It can be a full object (e.g., `type:object_id`) or type only (e.g., `type:`). 3. `tuple_key.user` is mandatory if tuple_key is specified in the case the `tuple_key.object` is a type only. ## Examples ### Query for all objects in a type definition To query for all objects that `user:bob` has `reader` relationship in the `document` type definition, call read API with body of ```json {  \"tuple_key\": {      \"user\": \"user:bob\",      \"relation\": \"reader\",      \"object\": \"document:\"   } } ``` The API will return tuples and a continuation token, something like ```json {   \"tuples\": [     {       \"key\": {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-06T15:32:11.128Z\"     }   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` This means that `user:bob` has a `reader` relationship with 1 document `document:2021-budget`. Note that this API, unlike the List Objects API, does not evaluate the tuples in the store. The continuation token will be empty if there are no more tuples to query. ### Query for all stored relationship tuples that have a particular relation and object To query for all users that have `reader` relationship with `document:2021-budget`, call read API with body of  ```json {   \"tuple_key\": {      \"object\": \"document:2021-budget\",      \"relation\": \"reader\"    } } ``` The API will return something like  ```json {   \"tuples\": [     {       \"key\": {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-06T15:32:11.128Z\"     }   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` This means that `document:2021-budget` has 1 `reader` (`user:bob`).  Note that, even if the model said that all `writers` are also `readers`, the API will not return writers such as `user:anne` because it only returns tuples and does not evaluate them. ### Query for all users with all relationships for a particular document To query for all users that have any relationship with `document:2021-budget`, call read API with body of  ```json {   \"tuple_key\": {       \"object\": \"document:2021-budget\"    } } ``` The API will return something like  ```json {   \"tuples\": [     {       \"key\": {         \"user\": \"user:anne\",         \"relation\": \"writer\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-05T13:42:12.356Z\"     },     {       \"key\": {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       },       \"timestamp\": \"2021-10-06T15:32:11.128Z\"     }   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` This means that `document:2021-budget` has 1 `reader` (`user:bob`) and 1 `writer` (`user:anne`).
 
         >>> thread = api.read_with_http_info(body)
 
         :param body: (required)
         :type body: ReadRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
@@ -1111,107 +1142,117 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: tuple(ReadResponse, status_code(int), headers(HTTPHeaderDict))
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-            'body'
-
-        ]
+        all_params = ["body"]
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method read" % key
+                    "Got an unexpected keyword argument '%s'" " to method read" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
         # verify the required parameter 'body' is set
-        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
-            raise ApiValueError("Missing the required parameter `body` when calling `read`")  # noqa: E501
+        if (
+            self.api_client.client_side_validation
+            and local_var_params.get("body") is None
+        ):
+            raise ApiValueError(
+                "Missing the required parameter `body` when calling `read`"
+            )
 
         collection_formats = {}
 
         path_params = {}
 
         if self.api_client._get_store_id() is None:
-            raise ApiValueError("Store ID expected in api_client's configuration when calling `read`")  # noqa: E501
+            raise ApiValueError(
+                "Store ID expected in api_client's configuration when calling `read`"
+            )
         store_id = self.api_client._get_store_id()
 
         query_params = []
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in local_var_params:
-            body_params = local_var_params['body']
+        if "body" in local_var_params:
+            body_params = local_var_params["body"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # HTTP header `Content-Type`
-        content_types_list = local_var_params.get('_content_type', self.api_client.select_header_content_type(['application/json'], 'POST', body_params))  # noqa: E501
+        content_types_list = local_var_params.get(
+            "_content_type",
+            self.api_client.select_header_content_type(
+                ["application/json"], "POST", body_params
+            ),
+        )
         if content_types_list:
-            header_params['Content-Type'] = content_types_list
+            header_params["Content-Type"] = content_types_list
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {
             200: "ReadResponse",
             400: "ValidationErrorMessageResponse",
             404: "PathUnknownErrorMessageResponse",
             409: "AbortedMessageResponse",
             500: "InternalErrorMessageResponse",
         }
 
-        return self.api_client.call_api(
-            '/stores/{store_id}/read'.replace('{store_id}', store_id), 'POST',
+        return await self.api_client.call_api(
+            "/stores/{store_id}/read".replace("{store_id}", store_id),
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client)
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    def read_assertions(self, authorization_model_id, **kwargs):  # noqa: E501
-        """Read assertions for an authorization model ID  # noqa: E501
+    async def read_assertions(self, authorization_model_id, **kwargs):
+        """Read assertions for an authorization model ID
 
-        The ReadAssertions API will return, for a given authorization model id, all the assertions stored for it. An assertion is an object that contains a tuple key, and the expectation of whether a call to the Check API of that tuple key will return true or false.   # noqa: E501
+        The ReadAssertions API will return, for a given authorization model id, all the assertions stored for it. An assertion is an object that contains a tuple key, and the expectation of whether a call to the Check API of that tuple key will return true or false.
 
-        >>> thread = api.read_assertions(authorization_model_id)
+        >>> thread = await api.read_assertions(authorization_model_id)
 
         :param authorization_model_id: (required)
         :type authorization_model_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
@@ -1222,21 +1263,23 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ReadAssertionsResponse
         """
-        kwargs['_return_http_data_only'] = True
-        return self.read_assertions_with_http_info(authorization_model_id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return await self.read_assertions_with_http_info(
+            authorization_model_id, **kwargs
+        )
 
-    def read_assertions_with_http_info(self, authorization_model_id, **kwargs):  # noqa: E501
-        """Read assertions for an authorization model ID  # noqa: E501
+    async def read_assertions_with_http_info(self, authorization_model_id, **kwargs):
+        """Read assertions for an authorization model ID
 
-        The ReadAssertions API will return, for a given authorization model id, all the assertions stored for it. An assertion is an object that contains a tuple key, and the expectation of whether a call to the Check API of that tuple key will return true or false.   # noqa: E501
+        The ReadAssertions API will return, for a given authorization model id, all the assertions stored for it. An assertion is an object that contains a tuple key, and the expectation of whether a call to the Check API of that tuple key will return true or false.
 
         >>> thread = api.read_assertions_with_http_info(authorization_model_id)
 
         :param authorization_model_id: (required)
         :type authorization_model_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
@@ -1261,104 +1304,113 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: tuple(ReadAssertionsResponse, status_code(int), headers(HTTPHeaderDict))
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-            'authorization_model_id'
-
-        ]
+        all_params = ["authorization_model_id"]
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
                     "Got an unexpected keyword argument '%s'"
                     " to method read_assertions" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
         # verify the required parameter 'authorization_model_id' is set
-        if self.api_client.client_side_validation and local_var_params.get('authorization_model_id') is None:  # noqa: E501
-            raise ApiValueError("Missing the required parameter `authorization_model_id` when calling `read_assertions`")  # noqa: E501
+        if (
+            self.api_client.client_side_validation
+            and local_var_params.get("authorization_model_id") is None
+        ):
+            raise ApiValueError(
+                "Missing the required parameter `authorization_model_id` when calling `read_assertions`"
+            )
 
         collection_formats = {}
 
         path_params = {}
 
         if self.api_client._get_store_id() is None:
-            raise ApiValueError("Store ID expected in api_client's configuration when calling `read_assertions`")  # noqa: E501
+            raise ApiValueError(
+                "Store ID expected in api_client's configuration when calling `read_assertions`"
+            )
         store_id = self.api_client._get_store_id()
 
-        if 'authorization_model_id' in local_var_params:
-            path_params['authorization_model_id'] = local_var_params['authorization_model_id']  # noqa: E501
+        if "authorization_model_id" in local_var_params:
+            path_params["authorization_model_id"] = local_var_params[
+                "authorization_model_id"
+            ]
 
         query_params = []
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {
             200: "ReadAssertionsResponse",
             400: "ValidationErrorMessageResponse",
             404: "PathUnknownErrorMessageResponse",
             409: "AbortedMessageResponse",
             500: "InternalErrorMessageResponse",
         }
 
-        return self.api_client.call_api(
-            '/stores/{store_id}/assertions/{authorization_model_id}'.replace(
-                '{store_id}', store_id), 'GET',
+        return await self.api_client.call_api(
+            "/stores/{store_id}/assertions/{authorization_model_id}".replace(
+                "{store_id}", store_id
+            ),
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client)
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    def read_authorization_model(self, id, **kwargs):  # noqa: E501
-        """Return a particular version of an authorization model  # noqa: E501
+    async def read_authorization_model(self, id, **kwargs):
+        """Return a particular version of an authorization model
 
-        The ReadAuthorizationModel API returns an authorization model by its identifier. The response will return the authorization model for the particular version.  ## Example To retrieve the authorization model with ID `01G5JAVJ41T49E9TT3SKVS7X1J` for the store, call the GET authorization-models by ID API with `01G5JAVJ41T49E9TT3SKVS7X1J` as the `id` path parameter.  The API will return: ```json {   \"authorization_model\":{     \"id\":\"01G5JAVJ41T49E9TT3SKVS7X1J\",     \"type_definitions\":[       {         \"type\":\"user\"       },       {         \"type\":\"document\",         \"relations\":{           \"reader\":{             \"union\":{               \"child\":[                 {                   \"this\":{}                 },                 {                   \"computedUserset\":{                     \"object\":\"\",                     \"relation\":\"writer\"                   }                 }               ]             }           },           \"writer\":{             \"this\":{}           }         }       }     ]   } } ``` In the above example, there are 2 types (`user` and `document`). The `document` type has 2 relations (`writer` and `reader`).  # noqa: E501
+        The ReadAuthorizationModel API returns an authorization model by its identifier. The response will return the authorization model for the particular version.  ## Example To retrieve the authorization model with ID `01G5JAVJ41T49E9TT3SKVS7X1J` for the store, call the GET authorization-models by ID API with `01G5JAVJ41T49E9TT3SKVS7X1J` as the `id` path parameter.  The API will return: ```json {   \"authorization_model\":{     \"id\":\"01G5JAVJ41T49E9TT3SKVS7X1J\",     \"type_definitions\":[       {         \"type\":\"user\"       },       {         \"type\":\"document\",         \"relations\":{           \"reader\":{             \"union\":{               \"child\":[                 {                   \"this\":{}                 },                 {                   \"computedUserset\":{                     \"object\":\"\",                     \"relation\":\"writer\"                   }                 }               ]             }           },           \"writer\":{             \"this\":{}           }         }       }     ]   } } ``` In the above example, there are 2 types (`user` and `document`). The `document` type has 2 relations (`writer` and `reader`).
 
-        >>> thread = api.read_authorization_model(id)
+        >>> thread = await api.read_authorization_model(id)
 
         :param id: (required)
         :type id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
@@ -1369,21 +1421,21 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ReadAuthorizationModelResponse
         """
-        kwargs['_return_http_data_only'] = True
-        return self.read_authorization_model_with_http_info(id, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return await self.read_authorization_model_with_http_info(id, **kwargs)
 
-    def read_authorization_model_with_http_info(self, id, **kwargs):  # noqa: E501
-        """Return a particular version of an authorization model  # noqa: E501
+    async def read_authorization_model_with_http_info(self, id, **kwargs):
+        """Return a particular version of an authorization model
 
-        The ReadAuthorizationModel API returns an authorization model by its identifier. The response will return the authorization model for the particular version.  ## Example To retrieve the authorization model with ID `01G5JAVJ41T49E9TT3SKVS7X1J` for the store, call the GET authorization-models by ID API with `01G5JAVJ41T49E9TT3SKVS7X1J` as the `id` path parameter.  The API will return: ```json {   \"authorization_model\":{     \"id\":\"01G5JAVJ41T49E9TT3SKVS7X1J\",     \"type_definitions\":[       {         \"type\":\"user\"       },       {         \"type\":\"document\",         \"relations\":{           \"reader\":{             \"union\":{               \"child\":[                 {                   \"this\":{}                 },                 {                   \"computedUserset\":{                     \"object\":\"\",                     \"relation\":\"writer\"                   }                 }               ]             }           },           \"writer\":{             \"this\":{}           }         }       }     ]   } } ``` In the above example, there are 2 types (`user` and `document`). The `document` type has 2 relations (`writer` and `reader`).  # noqa: E501
+        The ReadAuthorizationModel API returns an authorization model by its identifier. The response will return the authorization model for the particular version.  ## Example To retrieve the authorization model with ID `01G5JAVJ41T49E9TT3SKVS7X1J` for the store, call the GET authorization-models by ID API with `01G5JAVJ41T49E9TT3SKVS7X1J` as the `id` path parameter.  The API will return: ```json {   \"authorization_model\":{     \"id\":\"01G5JAVJ41T49E9TT3SKVS7X1J\",     \"type_definitions\":[       {         \"type\":\"user\"       },       {         \"type\":\"document\",         \"relations\":{           \"reader\":{             \"union\":{               \"child\":[                 {                   \"this\":{}                 },                 {                   \"computedUserset\":{                     \"object\":\"\",                     \"relation\":\"writer\"                   }                 }               ]             }           },           \"writer\":{             \"this\":{}           }         }       }     ]   } } ``` In the above example, there are 2 types (`user` and `document`). The `document` type has 2 relations (`writer` and `reader`).
 
         >>> thread = api.read_authorization_model_with_http_info(id)
 
         :param id: (required)
         :type id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
@@ -1408,103 +1460,111 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: tuple(ReadAuthorizationModelResponse, status_code(int), headers(HTTPHeaderDict))
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-            'id'
-
-        ]
+        all_params = ["id"]
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
                     "Got an unexpected keyword argument '%s'"
                     " to method read_authorization_model" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
         # verify the required parameter 'id' is set
-        if self.api_client.client_side_validation and local_var_params.get('id') is None:  # noqa: E501
-            raise ApiValueError("Missing the required parameter `id` when calling `read_authorization_model`")  # noqa: E501
+        if (
+            self.api_client.client_side_validation
+            and local_var_params.get("id") is None
+        ):
+            raise ApiValueError(
+                "Missing the required parameter `id` when calling `read_authorization_model`"
+            )
 
         collection_formats = {}
 
         path_params = {}
 
         if self.api_client._get_store_id() is None:
-            raise ApiValueError("Store ID expected in api_client's configuration when calling `read_authorization_model`")  # noqa: E501
+            raise ApiValueError(
+                "Store ID expected in api_client's configuration when calling `read_authorization_model`"
+            )
         store_id = self.api_client._get_store_id()
 
-        if 'id' in local_var_params:
-            path_params['id'] = local_var_params['id']  # noqa: E501
+        if "id" in local_var_params:
+            path_params["id"] = local_var_params["id"]
 
         query_params = []
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {
             200: "ReadAuthorizationModelResponse",
             400: "ValidationErrorMessageResponse",
             404: "PathUnknownErrorMessageResponse",
             409: "AbortedMessageResponse",
             500: "InternalErrorMessageResponse",
         }
 
-        return self.api_client.call_api(
-            '/stores/{store_id}/authorization-models/{id}'.replace('{store_id}', store_id), 'GET',
+        return await self.api_client.call_api(
+            "/stores/{store_id}/authorization-models/{id}".replace(
+                "{store_id}", store_id
+            ),
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client)
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    def read_authorization_models(self, **kwargs):  # noqa: E501
-        """Return all the authorization models for a particular store  # noqa: E501
+    async def read_authorization_models(self, **kwargs):
+        """Return all the authorization models for a particular store
 
-        The ReadAuthorizationModels API will return all the authorization models for a certain store. OpenFGA's response will contain an array of all authorization models, sorted in descending order of creation.  ## Example Assume that a store's authorization model has been configured twice. To get all the authorization models that have been created in this store, call GET authorization-models. The API will return a response that looks like: ```json {   \"authorization_models\": [     {       \"id\": \"01G50QVV17PECNVAHX1GG4Y5NC\",       \"type_definitions\": [...]     },     {       \"id\": \"01G4ZW8F4A07AKQ8RHSVG9RW04\",       \"type_definitions\": [...]     },   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` If there are no more authorization models available, the `continuation_token` field will be empty ```json {   \"authorization_models\": [     {       \"id\": \"01G50QVV17PECNVAHX1GG4Y5NC\",       \"type_definitions\": [...]     },     {       \"id\": \"01G4ZW8F4A07AKQ8RHSVG9RW04\",       \"type_definitions\": [...]     },   ],   \"continuation_token\": \"\" } ```   # noqa: E501
+        The ReadAuthorizationModels API will return all the authorization models for a certain store. OpenFGA's response will contain an array of all authorization models, sorted in descending order of creation.  ## Example Assume that a store's authorization model has been configured twice. To get all the authorization models that have been created in this store, call GET authorization-models. The API will return a response that looks like: ```json {   \"authorization_models\": [     {       \"id\": \"01G50QVV17PECNVAHX1GG4Y5NC\",       \"type_definitions\": [...]     },     {       \"id\": \"01G4ZW8F4A07AKQ8RHSVG9RW04\",       \"type_definitions\": [...]     },   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` If there are no more authorization models available, the `continuation_token` field will be empty ```json {   \"authorization_models\": [     {       \"id\": \"01G50QVV17PECNVAHX1GG4Y5NC\",       \"type_definitions\": [...]     },     {       \"id\": \"01G4ZW8F4A07AKQ8RHSVG9RW04\",       \"type_definitions\": [...]     },   ],   \"continuation_token\": \"\" } ```
 
-        >>> thread = api.read_authorization_models()
+        >>> thread = await api.read_authorization_models()
 
         :param page_size:(optional)
         :type page_size: int, optional
         :param continuation_token:(optional)
         :type continuation_token: str, optional
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
@@ -1517,21 +1577,21 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ReadAuthorizationModelsResponse
         """
-        kwargs['_return_http_data_only'] = True
-        return self.read_authorization_models_with_http_info(**kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return await self.read_authorization_models_with_http_info(**kwargs)
 
-    def read_authorization_models_with_http_info(self, **kwargs):  # noqa: E501
-        """Return all the authorization models for a particular store  # noqa: E501
+    async def read_authorization_models_with_http_info(self, **kwargs):
+        """Return all the authorization models for a particular store
 
-        The ReadAuthorizationModels API will return all the authorization models for a certain store. OpenFGA's response will contain an array of all authorization models, sorted in descending order of creation.  ## Example Assume that a store's authorization model has been configured twice. To get all the authorization models that have been created in this store, call GET authorization-models. The API will return a response that looks like: ```json {   \"authorization_models\": [     {       \"id\": \"01G50QVV17PECNVAHX1GG4Y5NC\",       \"type_definitions\": [...]     },     {       \"id\": \"01G4ZW8F4A07AKQ8RHSVG9RW04\",       \"type_definitions\": [...]     },   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` If there are no more authorization models available, the `continuation_token` field will be empty ```json {   \"authorization_models\": [     {       \"id\": \"01G50QVV17PECNVAHX1GG4Y5NC\",       \"type_definitions\": [...]     },     {       \"id\": \"01G4ZW8F4A07AKQ8RHSVG9RW04\",       \"type_definitions\": [...]     },   ],   \"continuation_token\": \"\" } ```   # noqa: E501
+        The ReadAuthorizationModels API will return all the authorization models for a certain store. OpenFGA's response will contain an array of all authorization models, sorted in descending order of creation.  ## Example Assume that a store's authorization model has been configured twice. To get all the authorization models that have been created in this store, call GET authorization-models. The API will return a response that looks like: ```json {   \"authorization_models\": [     {       \"id\": \"01G50QVV17PECNVAHX1GG4Y5NC\",       \"type_definitions\": [...]     },     {       \"id\": \"01G4ZW8F4A07AKQ8RHSVG9RW04\",       \"type_definitions\": [...]     },   ],   \"continuation_token\": \"eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==\" } ``` If there are no more authorization models available, the `continuation_token` field will be empty ```json {   \"authorization_models\": [     {       \"id\": \"01G50QVV17PECNVAHX1GG4Y5NC\",       \"type_definitions\": [...]     },     {       \"id\": \"01G4ZW8F4A07AKQ8RHSVG9RW04\",       \"type_definitions\": [...]     },   ],   \"continuation_token\": \"\" } ```
 
         >>> thread = api.read_authorization_models_with_http_info()
 
         :param page_size:(optional)
         :type page_size: int, optional
         :param continuation_token:(optional)
         :type continuation_token: str, optional
@@ -1558,101 +1618,104 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: tuple(ReadAuthorizationModelsResponse, status_code(int), headers(HTTPHeaderDict))
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-            'page_size',
-            'continuation_token'
-        ]
+        all_params = ["page_size", "continuation_token"]
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
                     "Got an unexpected keyword argument '%s'"
                     " to method read_authorization_models" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
 
         collection_formats = {}
 
         path_params = {}
 
         if self.api_client._get_store_id() is None:
-            raise ApiValueError("Store ID expected in api_client's configuration when calling `read_authorization_models`")  # noqa: E501
+            raise ApiValueError(
+                "Store ID expected in api_client's configuration when calling `read_authorization_models`"
+            )
         store_id = self.api_client._get_store_id()
 
         query_params = []
-        if local_var_params.get('page_size') is not None:  # noqa: E501
-            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501
-        if local_var_params.get('continuation_token') is not None:  # noqa: E501
-            query_params.append(('continuation_token', local_var_params['continuation_token']))  # noqa: E501
+        if local_var_params.get("page_size") is not None:
+            query_params.append(("page_size", local_var_params["page_size"]))
+        if local_var_params.get("continuation_token") is not None:
+            query_params.append(
+                ("continuation_token", local_var_params["continuation_token"])
+            )
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {
             200: "ReadAuthorizationModelsResponse",
             400: "ValidationErrorMessageResponse",
             404: "PathUnknownErrorMessageResponse",
             409: "AbortedMessageResponse",
             500: "InternalErrorMessageResponse",
         }
 
-        return self.api_client.call_api(
-            '/stores/{store_id}/authorization-models'.replace('{store_id}', store_id), 'GET',
+        return await self.api_client.call_api(
+            "/stores/{store_id}/authorization-models".replace("{store_id}", store_id),
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client)
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    def read_changes(self, **kwargs):  # noqa: E501
-        """Return a list of all the tuple changes  # noqa: E501
+    async def read_changes(self, **kwargs):
+        """Return a list of all the tuple changes
 
-        The ReadChanges API will return a paginated list of tuple changes (additions and deletions) that occurred in a given store, sorted by ascending time. The response will include a continuation token that is used to get the next set of changes. If there are no changes after the provided continuation token, the same token will be returned in order for it to be used when new changes are recorded. If the store never had any tuples added or removed, this token will be empty. You can use the `type` parameter to only get the list of tuple changes that affect objects of that type. When reading a write tuple change, if it was conditioned, the condition will be returned. When reading a delete tuple change, the condition will NOT be returned regardless of whether it was originally conditioned or not.   # noqa: E501
+        The ReadChanges API will return a paginated list of tuple changes (additions and deletions) that occurred in a given store, sorted by ascending time. The response will include a continuation token that is used to get the next set of changes. If there are no changes after the provided continuation token, the same token will be returned in order for it to be used when new changes are recorded. If the store never had any tuples added or removed, this token will be empty. You can use the `type` parameter to only get the list of tuple changes that affect objects of that type. When reading a write tuple change, if it was conditioned, the condition will be returned. When reading a delete tuple change, the condition will NOT be returned regardless of whether it was originally conditioned or not.
 
-        >>> thread = api.read_changes()
+        >>> thread = await api.read_changes()
 
         :param type:(optional)
         :type type: str, optional
         :param page_size:(optional)
         :type page_size: int, optional
         :param continuation_token:(optional)
         :type continuation_token: str, optional
@@ -1667,21 +1730,21 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ReadChangesResponse
         """
-        kwargs['_return_http_data_only'] = True
-        return self.read_changes_with_http_info(**kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return await self.read_changes_with_http_info(**kwargs)
 
-    def read_changes_with_http_info(self, **kwargs):  # noqa: E501
-        """Return a list of all the tuple changes  # noqa: E501
+    async def read_changes_with_http_info(self, **kwargs):
+        """Return a list of all the tuple changes
 
-        The ReadChanges API will return a paginated list of tuple changes (additions and deletions) that occurred in a given store, sorted by ascending time. The response will include a continuation token that is used to get the next set of changes. If there are no changes after the provided continuation token, the same token will be returned in order for it to be used when new changes are recorded. If the store never had any tuples added or removed, this token will be empty. You can use the `type` parameter to only get the list of tuple changes that affect objects of that type. When reading a write tuple change, if it was conditioned, the condition will be returned. When reading a delete tuple change, the condition will NOT be returned regardless of whether it was originally conditioned or not.   # noqa: E501
+        The ReadChanges API will return a paginated list of tuple changes (additions and deletions) that occurred in a given store, sorted by ascending time. The response will include a continuation token that is used to get the next set of changes. If there are no changes after the provided continuation token, the same token will be returned in order for it to be used when new changes are recorded. If the store never had any tuples added or removed, this token will be empty. You can use the `type` parameter to only get the list of tuple changes that affect objects of that type. When reading a write tuple change, if it was conditioned, the condition will be returned. When reading a delete tuple change, the condition will NOT be returned regardless of whether it was originally conditioned or not.
 
         >>> thread = api.read_changes_with_http_info()
 
         :param type:(optional)
         :type type: str, optional
         :param page_size:(optional)
         :type page_size: int, optional
@@ -1710,104 +1773,106 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: tuple(ReadChangesResponse, status_code(int), headers(HTTPHeaderDict))
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-            'type',
-            'page_size',
-            'continuation_token'
-        ]
+        all_params = ["type", "page_size", "continuation_token"]
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
                     "Got an unexpected keyword argument '%s'"
                     " to method read_changes" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
 
         collection_formats = {}
 
         path_params = {}
 
         if self.api_client._get_store_id() is None:
-            raise ApiValueError("Store ID expected in api_client's configuration when calling `read_changes`")  # noqa: E501
+            raise ApiValueError(
+                "Store ID expected in api_client's configuration when calling `read_changes`"
+            )
         store_id = self.api_client._get_store_id()
 
         query_params = []
-        if local_var_params.get('type') is not None:  # noqa: E501
-            query_params.append(('type', local_var_params['type']))  # noqa: E501
-        if local_var_params.get('page_size') is not None:  # noqa: E501
-            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501
-        if local_var_params.get('continuation_token') is not None:  # noqa: E501
-            query_params.append(('continuation_token', local_var_params['continuation_token']))  # noqa: E501
+        if local_var_params.get("type") is not None:
+            query_params.append(("type", local_var_params["type"]))
+        if local_var_params.get("page_size") is not None:
+            query_params.append(("page_size", local_var_params["page_size"]))
+        if local_var_params.get("continuation_token") is not None:
+            query_params.append(
+                ("continuation_token", local_var_params["continuation_token"])
+            )
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {
             200: "ReadChangesResponse",
             400: "ValidationErrorMessageResponse",
             404: "PathUnknownErrorMessageResponse",
             409: "AbortedMessageResponse",
             500: "InternalErrorMessageResponse",
         }
 
-        return self.api_client.call_api(
-            '/stores/{store_id}/changes'.replace('{store_id}', store_id), 'GET',
+        return await self.api_client.call_api(
+            "/stores/{store_id}/changes".replace("{store_id}", store_id),
+            "GET",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client)
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    def write(self, body, **kwargs):  # noqa: E501
-        """Add or delete tuples from the store  # noqa: E501
+    async def write(self, body, **kwargs):
+        """Add or delete tuples from the store
 
-        The Write API will update the tuples for a certain store. Tuples and type definitions allow OpenFGA to determine whether a relationship exists between an object and an user. In the body, `writes` adds new tuples and `deletes` removes existing tuples. When deleting a tuple, any `condition` specified with it is ignored. The API is not idempotent: if, later on, you try to add the same tuple key (even if the `condition` is different), or if you try to delete a non-existing tuple, it will throw an error. An `authorization_model_id` may be specified in the body. If it is, it will be used to assert that each written tuple (not deleted) is valid for the model specified. If it is not specified, the latest authorization model ID will be used. ## Example ### Adding relationships To add `user:anne` as a `writer` for `document:2021-budget`, call write API with the following  ```json {   \"writes\": {     \"tuple_keys\": [       {         \"user\": \"user:anne\",         \"relation\": \"writer\",         \"object\": \"document:2021-budget\"       }     ]   },   \"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\" } ``` ### Removing relationships To remove `user:bob` as a `reader` for `document:2021-budget`, call write API with the following  ```json {   \"deletes\": {     \"tuple_keys\": [       {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       }     ]   } } ```   # noqa: E501
+        The Write API will update the tuples for a certain store. Tuples and type definitions allow OpenFGA to determine whether a relationship exists between an object and an user. In the body, `writes` adds new tuples and `deletes` removes existing tuples. When deleting a tuple, any `condition` specified with it is ignored. The API is not idempotent: if, later on, you try to add the same tuple key (even if the `condition` is different), or if you try to delete a non-existing tuple, it will throw an error. An `authorization_model_id` may be specified in the body. If it is, it will be used to assert that each written tuple (not deleted) is valid for the model specified. If it is not specified, the latest authorization model ID will be used. ## Example ### Adding relationships To add `user:anne` as a `writer` for `document:2021-budget`, call write API with the following  ```json {   \"writes\": {     \"tuple_keys\": [       {         \"user\": \"user:anne\",         \"relation\": \"writer\",         \"object\": \"document:2021-budget\"       }     ]   },   \"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\" } ``` ### Removing relationships To remove `user:bob` as a `reader` for `document:2021-budget`, call write API with the following  ```json {   \"deletes\": {     \"tuple_keys\": [       {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       }     ]   } } ```
 
-        >>> thread = api.write(body)
+        >>> thread = await api.write(body)
 
         :param body: (required)
         :type body: WriteRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
@@ -1818,21 +1883,21 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: object
         """
-        kwargs['_return_http_data_only'] = True
-        return self.write_with_http_info(body, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return await self.write_with_http_info(body, **kwargs)
 
-    def write_with_http_info(self, body, **kwargs):  # noqa: E501
-        """Add or delete tuples from the store  # noqa: E501
+    async def write_with_http_info(self, body, **kwargs):
+        """Add or delete tuples from the store
 
-        The Write API will update the tuples for a certain store. Tuples and type definitions allow OpenFGA to determine whether a relationship exists between an object and an user. In the body, `writes` adds new tuples and `deletes` removes existing tuples. When deleting a tuple, any `condition` specified with it is ignored. The API is not idempotent: if, later on, you try to add the same tuple key (even if the `condition` is different), or if you try to delete a non-existing tuple, it will throw an error. An `authorization_model_id` may be specified in the body. If it is, it will be used to assert that each written tuple (not deleted) is valid for the model specified. If it is not specified, the latest authorization model ID will be used. ## Example ### Adding relationships To add `user:anne` as a `writer` for `document:2021-budget`, call write API with the following  ```json {   \"writes\": {     \"tuple_keys\": [       {         \"user\": \"user:anne\",         \"relation\": \"writer\",         \"object\": \"document:2021-budget\"       }     ]   },   \"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\" } ``` ### Removing relationships To remove `user:bob` as a `reader` for `document:2021-budget`, call write API with the following  ```json {   \"deletes\": {     \"tuple_keys\": [       {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       }     ]   } } ```   # noqa: E501
+        The Write API will update the tuples for a certain store. Tuples and type definitions allow OpenFGA to determine whether a relationship exists between an object and an user. In the body, `writes` adds new tuples and `deletes` removes existing tuples. When deleting a tuple, any `condition` specified with it is ignored. The API is not idempotent: if, later on, you try to add the same tuple key (even if the `condition` is different), or if you try to delete a non-existing tuple, it will throw an error. An `authorization_model_id` may be specified in the body. If it is, it will be used to assert that each written tuple (not deleted) is valid for the model specified. If it is not specified, the latest authorization model ID will be used. ## Example ### Adding relationships To add `user:anne` as a `writer` for `document:2021-budget`, call write API with the following  ```json {   \"writes\": {     \"tuple_keys\": [       {         \"user\": \"user:anne\",         \"relation\": \"writer\",         \"object\": \"document:2021-budget\"       }     ]   },   \"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\" } ``` ### Removing relationships To remove `user:bob` as a `reader` for `document:2021-budget`, call write API with the following  ```json {   \"deletes\": {     \"tuple_keys\": [       {         \"user\": \"user:bob\",         \"relation\": \"reader\",         \"object\": \"document:2021-budget\"       }     ]   } } ```
 
         >>> thread = api.write_with_http_info(body)
 
         :param body: (required)
         :type body: WriteRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
@@ -1857,107 +1922,117 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-            'body'
-
-        ]
+        all_params = ["body"]
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method write" % key
+                    "Got an unexpected keyword argument '%s'" " to method write" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
         # verify the required parameter 'body' is set
-        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
-            raise ApiValueError("Missing the required parameter `body` when calling `write`")  # noqa: E501
+        if (
+            self.api_client.client_side_validation
+            and local_var_params.get("body") is None
+        ):
+            raise ApiValueError(
+                "Missing the required parameter `body` when calling `write`"
+            )
 
         collection_formats = {}
 
         path_params = {}
 
         if self.api_client._get_store_id() is None:
-            raise ApiValueError("Store ID expected in api_client's configuration when calling `write`")  # noqa: E501
+            raise ApiValueError(
+                "Store ID expected in api_client's configuration when calling `write`"
+            )
         store_id = self.api_client._get_store_id()
 
         query_params = []
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in local_var_params:
-            body_params = local_var_params['body']
+        if "body" in local_var_params:
+            body_params = local_var_params["body"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # HTTP header `Content-Type`
-        content_types_list = local_var_params.get('_content_type', self.api_client.select_header_content_type(['application/json'], 'POST', body_params))  # noqa: E501
+        content_types_list = local_var_params.get(
+            "_content_type",
+            self.api_client.select_header_content_type(
+                ["application/json"], "POST", body_params
+            ),
+        )
         if content_types_list:
-            header_params['Content-Type'] = content_types_list
+            header_params["Content-Type"] = content_types_list
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {
             200: "object",
             400: "ValidationErrorMessageResponse",
             404: "PathUnknownErrorMessageResponse",
             409: "AbortedMessageResponse",
             500: "InternalErrorMessageResponse",
         }
 
-        return self.api_client.call_api(
-            '/stores/{store_id}/write'.replace('{store_id}', store_id), 'POST',
+        return await self.api_client.call_api(
+            "/stores/{store_id}/write".replace("{store_id}", store_id),
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client)
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    def write_assertions(self, authorization_model_id, body, **kwargs):  # noqa: E501
-        """Upsert assertions for an authorization model ID  # noqa: E501
+    async def write_assertions(self, authorization_model_id, body, **kwargs):
+        """Upsert assertions for an authorization model ID
 
-        The WriteAssertions API will upsert new assertions for an authorization model id, or overwrite the existing ones. An assertion is an object that contains a tuple key, and the expectation of whether a call to the Check API of that tuple key will return true or false.   # noqa: E501
+        The WriteAssertions API will upsert new assertions for an authorization model id, or overwrite the existing ones. An assertion is an object that contains a tuple key, and the expectation of whether a call to the Check API of that tuple key will return true or false.
 
-        >>> thread = api.write_assertions(authorization_model_id, body)
+        >>> thread = await api.write_assertions(authorization_model_id, body)
 
         :param authorization_model_id: (required)
         :type authorization_model_id: str
         :param body: (required)
         :type body: WriteAssertionsRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
@@ -1970,21 +2045,25 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
-        kwargs['_return_http_data_only'] = True
-        return self.write_assertions_with_http_info(authorization_model_id, body, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return await self.write_assertions_with_http_info(
+            authorization_model_id, body, **kwargs
+        )
 
-    def write_assertions_with_http_info(self, authorization_model_id, body, **kwargs):  # noqa: E501
-        """Upsert assertions for an authorization model ID  # noqa: E501
+    async def write_assertions_with_http_info(
+        self, authorization_model_id, body, **kwargs
+    ):
+        """Upsert assertions for an authorization model ID
 
-        The WriteAssertions API will upsert new assertions for an authorization model id, or overwrite the existing ones. An assertion is an object that contains a tuple key, and the expectation of whether a call to the Check API of that tuple key will return true or false.   # noqa: E501
+        The WriteAssertions API will upsert new assertions for an authorization model id, or overwrite the existing ones. An assertion is an object that contains a tuple key, and the expectation of whether a call to the Check API of that tuple key will return true or false.
 
         >>> thread = api.write_assertions_with_http_info(authorization_model_id, body)
 
         :param authorization_model_id: (required)
         :type authorization_model_id: str
         :param body: (required)
         :type body: WriteAssertionsRequest
@@ -2011,110 +2090,127 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-            'authorization_model_id',
-
-            'body'
-
-        ]
+        all_params = ["authorization_model_id", "body"]
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
                     "Got an unexpected keyword argument '%s'"
                     " to method write_assertions" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
         # verify the required parameter 'authorization_model_id' is set
-        if self.api_client.client_side_validation and local_var_params.get('authorization_model_id') is None:  # noqa: E501
-            raise ApiValueError("Missing the required parameter `authorization_model_id` when calling `write_assertions`")  # noqa: E501
+        if (
+            self.api_client.client_side_validation
+            and local_var_params.get("authorization_model_id") is None
+        ):
+            raise ApiValueError(
+                "Missing the required parameter `authorization_model_id` when calling `write_assertions`"
+            )
         # verify the required parameter 'body' is set
-        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
-            raise ApiValueError("Missing the required parameter `body` when calling `write_assertions`")  # noqa: E501
+        if (
+            self.api_client.client_side_validation
+            and local_var_params.get("body") is None
+        ):
+            raise ApiValueError(
+                "Missing the required parameter `body` when calling `write_assertions`"
+            )
 
         collection_formats = {}
 
         path_params = {}
 
         if self.api_client._get_store_id() is None:
-            raise ApiValueError("Store ID expected in api_client's configuration when calling `write_assertions`")  # noqa: E501
+            raise ApiValueError(
+                "Store ID expected in api_client's configuration when calling `write_assertions`"
+            )
         store_id = self.api_client._get_store_id()
 
-        if 'authorization_model_id' in local_var_params:
-            path_params['authorization_model_id'] = local_var_params['authorization_model_id']  # noqa: E501
+        if "authorization_model_id" in local_var_params:
+            path_params["authorization_model_id"] = local_var_params[
+                "authorization_model_id"
+            ]
 
         query_params = []
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in local_var_params:
-            body_params = local_var_params['body']
+        if "body" in local_var_params:
+            body_params = local_var_params["body"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # HTTP header `Content-Type`
-        content_types_list = local_var_params.get('_content_type', self.api_client.select_header_content_type(['application/json'], 'PUT', body_params))  # noqa: E501
+        content_types_list = local_var_params.get(
+            "_content_type",
+            self.api_client.select_header_content_type(
+                ["application/json"], "PUT", body_params
+            ),
+        )
         if content_types_list:
-            header_params['Content-Type'] = content_types_list
+            header_params["Content-Type"] = content_types_list
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {}
 
-        return self.api_client.call_api(
-            '/stores/{store_id}/assertions/{authorization_model_id}'.replace(
-                '{store_id}', store_id), 'PUT',
+        return await self.api_client.call_api(
+            "/stores/{store_id}/assertions/{authorization_model_id}".replace(
+                "{store_id}", store_id
+            ),
+            "PUT",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client)
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
 
-    def write_authorization_model(self, body, **kwargs):  # noqa: E501
-        """Create a new authorization model  # noqa: E501
+    async def write_authorization_model(self, body, **kwargs):
+        """Create a new authorization model
 
-        The WriteAuthorizationModel API will add a new authorization model to a store. Each item in the `type_definitions` array is a type definition as specified in the field `type_definition`. The response will return the authorization model's ID in the `id` field.  ## Example To add an authorization model with `user` and `document` type definitions, call POST authorization-models API with the body:  ```json {   \"type_definitions\":[     {       \"type\":\"user\"     },     {       \"type\":\"document\",       \"relations\":{         \"reader\":{           \"union\":{             \"child\":[               {                 \"this\":{}               },               {                 \"computedUserset\":{                   \"object\":\"\",                   \"relation\":\"writer\"                 }               }             ]           }         },         \"writer\":{           \"this\":{}         }       }     }   ] } ``` OpenFGA's response will include the version id for this authorization model, which will look like  ``` {\"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\"} ```   # noqa: E501
+        The WriteAuthorizationModel API will add a new authorization model to a store. Each item in the `type_definitions` array is a type definition as specified in the field `type_definition`. The response will return the authorization model's ID in the `id` field.  ## Example To add an authorization model with `user` and `document` type definitions, call POST authorization-models API with the body:  ```json {   \"type_definitions\":[     {       \"type\":\"user\"     },     {       \"type\":\"document\",       \"relations\":{         \"reader\":{           \"union\":{             \"child\":[               {                 \"this\":{}               },               {                 \"computedUserset\":{                   \"object\":\"\",                   \"relation\":\"writer\"                 }               }             ]           }         },         \"writer\":{           \"this\":{}         }       }     }   ] } ``` OpenFGA's response will include the version id for this authorization model, which will look like  ``` {\"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\"} ```
 
-        >>> thread = api.write_authorization_model(body)
+        >>> thread = await api.write_authorization_model(body)
 
         :param body: (required)
         :type body: WriteAuthorizationModelRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
@@ -2125,21 +2221,21 @@
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: WriteAuthorizationModelResponse
         """
-        kwargs['_return_http_data_only'] = True
-        return self.write_authorization_model_with_http_info(body, **kwargs)  # noqa: E501
+        kwargs["_return_http_data_only"] = True
+        return await self.write_authorization_model_with_http_info(body, **kwargs)
 
-    def write_authorization_model_with_http_info(self, body, **kwargs):  # noqa: E501
-        """Create a new authorization model  # noqa: E501
+    async def write_authorization_model_with_http_info(self, body, **kwargs):
+        """Create a new authorization model
 
-        The WriteAuthorizationModel API will add a new authorization model to a store. Each item in the `type_definitions` array is a type definition as specified in the field `type_definition`. The response will return the authorization model's ID in the `id` field.  ## Example To add an authorization model with `user` and `document` type definitions, call POST authorization-models API with the body:  ```json {   \"type_definitions\":[     {       \"type\":\"user\"     },     {       \"type\":\"document\",       \"relations\":{         \"reader\":{           \"union\":{             \"child\":[               {                 \"this\":{}               },               {                 \"computedUserset\":{                   \"object\":\"\",                   \"relation\":\"writer\"                 }               }             ]           }         },         \"writer\":{           \"this\":{}         }       }     }   ] } ``` OpenFGA's response will include the version id for this authorization model, which will look like  ``` {\"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\"} ```   # noqa: E501
+        The WriteAuthorizationModel API will add a new authorization model to a store. Each item in the `type_definitions` array is a type definition as specified in the field `type_definition`. The response will return the authorization model's ID in the `id` field.  ## Example To add an authorization model with `user` and `document` type definitions, call POST authorization-models API with the body:  ```json {   \"type_definitions\":[     {       \"type\":\"user\"     },     {       \"type\":\"document\",       \"relations\":{         \"reader\":{           \"union\":{             \"child\":[               {                 \"this\":{}               },               {                 \"computedUserset\":{                   \"object\":\"\",                   \"relation\":\"writer\"                 }               }             ]           }         },         \"writer\":{           \"this\":{}         }       }     }   ] } ``` OpenFGA's response will include the version id for this authorization model, which will look like  ``` {\"authorization_model_id\": \"01G50QVV17PECNVAHX1GG4Y5NC\"} ```
 
         >>> thread = api.write_authorization_model_with_http_info(body)
 
         :param body: (required)
         :type body: WriteAuthorizationModelRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
@@ -2164,93 +2260,104 @@
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: tuple(WriteAuthorizationModelResponse, status_code(int), headers(HTTPHeaderDict))
         """
 
         local_var_params = locals()
 
-        all_params = [
-
-            'body'
-
-        ]
+        all_params = ["body"]
         all_params.extend(
             [
-                'async_req',
-                '_return_http_data_only',
-                '_preload_content',
-                '_request_timeout',
-                '_request_auth',
-                '_content_type',
-                '_headers',
-                '_retry_parms'
+                "async_req",
+                "_return_http_data_only",
+                "_preload_content",
+                "_request_timeout",
+                "_request_auth",
+                "_content_type",
+                "_headers",
+                "_retry_parms",
             ]
         )
 
-        for key, val in six.iteritems(local_var_params['kwargs']):
+        for key, val in local_var_params["kwargs"].items():
             if key not in all_params:
                 raise FgaValidationException(
                     "Got an unexpected keyword argument '%s'"
                     " to method write_authorization_model" % key
                 )
             local_var_params[key] = val
-        del local_var_params['kwargs']
+        del local_var_params["kwargs"]
         # verify the required parameter 'body' is set
-        if self.api_client.client_side_validation and local_var_params.get('body') is None:  # noqa: E501
-            raise ApiValueError("Missing the required parameter `body` when calling `write_authorization_model`")  # noqa: E501
+        if (
+            self.api_client.client_side_validation
+            and local_var_params.get("body") is None
+        ):
+            raise ApiValueError(
+                "Missing the required parameter `body` when calling `write_authorization_model`"
+            )
 
         collection_formats = {}
 
         path_params = {}
 
         if self.api_client._get_store_id() is None:
-            raise ApiValueError("Store ID expected in api_client's configuration when calling `write_authorization_model`")  # noqa: E501
+            raise ApiValueError(
+                "Store ID expected in api_client's configuration when calling `write_authorization_model`"
+            )
         store_id = self.api_client._get_store_id()
 
         query_params = []
 
-        header_params = dict(local_var_params.get('_headers', {}))
+        header_params = dict(local_var_params.get("_headers", {}))
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in local_var_params:
-            body_params = local_var_params['body']
+        if "body" in local_var_params:
+            body_params = local_var_params["body"]
         # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json'])  # noqa: E501
+        header_params["Accept"] = self.api_client.select_header_accept(
+            ["application/json"]
+        )
 
         # HTTP header `Content-Type`
-        content_types_list = local_var_params.get('_content_type', self.api_client.select_header_content_type(['application/json'], 'POST', body_params))  # noqa: E501
+        content_types_list = local_var_params.get(
+            "_content_type",
+            self.api_client.select_header_content_type(
+                ["application/json"], "POST", body_params
+            ),
+        )
         if content_types_list:
-            header_params['Content-Type'] = content_types_list
+            header_params["Content-Type"] = content_types_list
 
         # Authentication setting
-        auth_settings = []  # noqa: E501
+        auth_settings = []
 
         response_types_map = {
             201: "WriteAuthorizationModelResponse",
             400: "ValidationErrorMessageResponse",
             404: "PathUnknownErrorMessageResponse",
             409: "AbortedMessageResponse",
             500: "InternalErrorMessageResponse",
         }
 
-        return self.api_client.call_api(
-            '/stores/{store_id}/authorization-models'.replace('{store_id}', store_id), 'POST',
+        return await self.api_client.call_api(
+            "/stores/{store_id}/authorization-models".replace("{store_id}", store_id),
+            "POST",
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
             response_types_map=response_types_map,
             auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            _retry_params=local_var_params.get('_retry_params'),
+            async_req=local_var_params.get("async_req"),
+            _return_http_data_only=local_var_params.get("_return_http_data_only"),
+            _preload_content=local_var_params.get("_preload_content", True),
+            _request_timeout=local_var_params.get("_request_timeout"),
+            _retry_params=local_var_params.get("_retry_params"),
             collection_formats=collection_formats,
-            _request_auth=local_var_params.get('_request_auth'),
-            _oauth2_client=self._oauth2_client)
+            _request_auth=local_var_params.get("_request_auth"),
+            _oauth2_client=self._oauth2_client,
+        )
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/sync/rest.py` & `openfga-sdk-0.4.2/openfga_sdk/sync/rest.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,34 +1,37 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 import io
 import json
 import logging
 import re
 import ssl
+import urllib
 
-# python 2 and python 3 compatibility library
-import six
-from six.moves.urllib.parse import urlencode
 import urllib3
 
-from openfga_sdk.exceptions import ApiException, UnauthorizedException, ForbiddenException, NotFoundException, ServiceException, ApiValueError, ValidationException
-
+from openfga_sdk.exceptions import (
+    ApiException,
+    ApiValueError,
+    ForbiddenException,
+    NotFoundException,
+    ServiceException,
+    UnauthorizedException,
+    ValidationException,
+)
 
 logger = logging.getLogger(__name__)
 
 
 class RESTResponse(io.IOBase):
 
     def __init__(self, resp, data):
@@ -39,41 +42,41 @@
 
     def getheaders(self):
         """Returns a dictionary of the response headers."""
         return self.urllib3_response.headers
 
     def getheader(self, name, default=None):
         """Returns a given response header."""
-        return self.urllib3_response.getheader(name, default)
+        return self.urllib3_response.headers.get(name, default)
 
 
-class RESTClientObject(object):
+class RESTClientObject:
 
     def __init__(self, configuration, pools_size=4, maxsize=None):
         # urllib3.PoolManager will pass all kw parameters to connectionpool
-        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  # noqa: E501
-        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  # noqa: E501
-        # maxsize is the number of requests to host that are allowed in parallel  # noqa: E501
-        # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  # noqa: E501
+        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75
+        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680
+        # maxsize is the number of requests to host that are allowed in parallel
+        # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html
 
         # cert_reqs
         if configuration.verify_ssl:
             cert_reqs = ssl.CERT_REQUIRED
         else:
             cert_reqs = ssl.CERT_NONE
 
         addition_pool_args = {}
         if configuration.assert_hostname is not None:
-            addition_pool_args['assert_hostname'] = configuration.assert_hostname  # noqa: E501
+            addition_pool_args["assert_hostname"] = configuration.assert_hostname
 
         if configuration.retries is not None:
-            addition_pool_args['retries'] = configuration.retries
+            addition_pool_args["retries"] = configuration.retries
 
         if configuration.socket_options is not None:
-            addition_pool_args['socket_options'] = configuration.socket_options
+            addition_pool_args["socket_options"] = configuration.socket_options
 
         if maxsize is None:
             if configuration.connection_pool_maxsize is not None:
                 maxsize = configuration.connection_pool_maxsize
             else:
                 maxsize = 4
 
@@ -84,33 +87,41 @@
                 maxsize=maxsize,
                 cert_reqs=cert_reqs,
                 ca_certs=configuration.ssl_ca_cert,
                 cert_file=configuration.cert_file,
                 key_file=configuration.key_file,
                 proxy_url=configuration.proxy,
                 proxy_headers=configuration.proxy_headers,
-                **addition_pool_args
+                **addition_pool_args,
             )
         else:
             self.pool_manager = urllib3.PoolManager(
                 num_pools=pools_size,
                 maxsize=maxsize,
                 cert_reqs=cert_reqs,
                 ca_certs=configuration.ssl_ca_cert,
                 cert_file=configuration.cert_file,
                 key_file=configuration.key_file,
-                **addition_pool_args
+                **addition_pool_args,
             )
 
     def close(self):
         self.pool_manager.clear()
 
-    def request(self, method, url, query_params=None, headers=None,
-                body=None, post_params=None, _preload_content=True,
-                _request_timeout=None):
+    def request(
+        self,
+        method,
+        url,
+        query_params=None,
+        headers=None,
+        body=None,
+        post_params=None,
+        _preload_content=True,
+        _request_timeout=None,
+    ):
         """Perform requests.
 
         :param method: http request method
         :param url: http request url
         :param query_params: query parameters in the url
         :param headers: http request headers
         :param body: request json body, for `application/json`
@@ -122,98 +133,108 @@
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         """
         method = method.upper()
-        assert method in ['GET', 'HEAD', 'DELETE', 'POST', 'PUT',
-                          'PATCH', 'OPTIONS']
+        assert method in ["GET", "HEAD", "DELETE", "POST", "PUT", "PATCH", "OPTIONS"]
 
         if post_params and body:
             raise ApiValueError(
                 "body parameter cannot be used with post_params parameter."
             )
 
         post_params = post_params or {}
         headers = headers or {}
 
         timeout = None
         if _request_timeout:
-            if isinstance(_request_timeout, six.integer_types + (float, )):  # noqa: E501,F821
+            if isinstance(_request_timeout, (float, int)):
                 timeout = urllib3.Timeout(total=_request_timeout)
-            elif (isinstance(_request_timeout, tuple) and
-                  len(_request_timeout) == 2):
+            elif isinstance(_request_timeout, tuple) and len(_request_timeout) == 2:
                 timeout = urllib3.Timeout(
-                    connect=_request_timeout[0], read=_request_timeout[1])
+                    connect=_request_timeout[0], read=_request_timeout[1]
+                )
 
-        if 'Content-Type' not in headers:
-            headers['Content-Type'] = 'application/json'
+        if "Content-Type" not in headers:
+            headers["Content-Type"] = "application/json"
 
         try:
             # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`
-            if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:
+            if method in ["POST", "PUT", "PATCH", "OPTIONS", "DELETE"]:
                 if query_params:
-                    url += '?' + urlencode(query_params)
-                if re.search('json', headers['Content-Type'], re.IGNORECASE):
+                    url += "?" + urllib.parse.urlencode(query_params)
+                if re.search("json", headers["Content-Type"], re.IGNORECASE):
                     request_body = None
                     if body is not None:
                         request_body = json.dumps(body)
                     r = self.pool_manager.request(
-                        method, url,
+                        method,
+                        url,
                         body=request_body,
                         preload_content=_preload_content,
                         timeout=timeout,
-                        headers=headers)
-                elif headers['Content-Type'] == 'application/x-www-form-urlencoded':  # noqa: E501
+                        headers=headers,
+                    )
+                elif headers["Content-Type"] == "application/x-www-form-urlencoded":
                     r = self.pool_manager.request(
-                        method, url,
+                        method,
+                        url,
                         fields=post_params,
                         encode_multipart=False,
                         preload_content=_preload_content,
                         timeout=timeout,
-                        headers=headers)
-                elif headers['Content-Type'] == 'multipart/form-data':
+                        headers=headers,
+                    )
+                elif headers["Content-Type"] == "multipart/form-data":
                     # must del headers['Content-Type'], or the correct
                     # Content-Type which generated by urllib3 will be
                     # overwritten.
-                    del headers['Content-Type']
+                    del headers["Content-Type"]
                     r = self.pool_manager.request(
-                        method, url,
+                        method,
+                        url,
                         fields=post_params,
                         encode_multipart=True,
                         preload_content=_preload_content,
                         timeout=timeout,
-                        headers=headers)
+                        headers=headers,
+                    )
                 # Pass a `string` parameter directly in the body to support
                 # other content types than Json when `body` argument is
                 # provided in serialized form
                 elif isinstance(body, str) or isinstance(body, bytes):
                     request_body = body
                     r = self.pool_manager.request(
-                        method, url,
+                        method,
+                        url,
                         body=request_body,
                         preload_content=_preload_content,
                         timeout=timeout,
-                        headers=headers)
+                        headers=headers,
+                    )
                 else:
                     # Cannot generate the request from given parameters
                     msg = """Cannot prepare a request message for provided
                              arguments. Please check that your arguments match
                              declared content type."""
                     raise ApiException(status=0, reason=msg)
             # For `GET`, `HEAD`
             else:
-                r = self.pool_manager.request(method, url,
-                                              fields=query_params,
-                                              preload_content=_preload_content,
-                                              timeout=timeout,
-                                              headers=headers)
+                r = self.pool_manager.request(
+                    method,
+                    url,
+                    fields=query_params,
+                    preload_content=_preload_content,
+                    timeout=timeout,
+                    headers=headers,
+                )
         except urllib3.exceptions.SSLError as e:
-            msg = "{0}\n{1}".format(type(e).__name__, str(e))
+            msg = f"{type(e).__name__}\n{str(e)}"
             raise ApiException(status=0, reason=msg)
 
         if _preload_content:
             r = RESTResponse(r, r.data)
 
             # log response body
             logger.debug("response body: %s", r.data)
@@ -234,71 +255,143 @@
             if 500 <= r.status <= 599:
                 raise ServiceException(http_resp=r)
 
             raise ApiException(http_resp=r)
 
         return r
 
-    def GET(self, url, headers=None, query_params=None, _preload_content=True,
-            _request_timeout=None):
-        return self.request("GET", url,
-                            headers=headers,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
-                            query_params=query_params)
-
-    def HEAD(self, url, headers=None, query_params=None, _preload_content=True,
-             _request_timeout=None):
-        return self.request("HEAD", url,
-                            headers=headers,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
-                            query_params=query_params)
-
-    def OPTIONS(self, url, headers=None, query_params=None, post_params=None,
-                body=None, _preload_content=True, _request_timeout=None):
-        return self.request("OPTIONS", url,
-                            headers=headers,
-                            query_params=query_params,
-                            post_params=post_params,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
-                            body=body)
-
-    def DELETE(self, url, headers=None, query_params=None, body=None,
-               _preload_content=True, _request_timeout=None):
-        return self.request("DELETE", url,
-                            headers=headers,
-                            query_params=query_params,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
-                            body=body)
-
-    def POST(self, url, headers=None, query_params=None, post_params=None,
-             body=None, _preload_content=True, _request_timeout=None):
-        return self.request("POST", url,
-                            headers=headers,
-                            query_params=query_params,
-                            post_params=post_params,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
-                            body=body)
-
-    def PUT(self, url, headers=None, query_params=None, post_params=None,
-            body=None, _preload_content=True, _request_timeout=None):
-        return self.request("PUT", url,
-                            headers=headers,
-                            query_params=query_params,
-                            post_params=post_params,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
-                            body=body)
-
-    def PATCH(self, url, headers=None, query_params=None, post_params=None,
-              body=None, _preload_content=True, _request_timeout=None):
-        return self.request("PATCH", url,
-                            headers=headers,
-                            query_params=query_params,
-                            post_params=post_params,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
-                            body=body)
+    def GET(
+        self,
+        url,
+        headers=None,
+        query_params=None,
+        _preload_content=True,
+        _request_timeout=None,
+    ):
+        return self.request(
+            "GET",
+            url,
+            headers=headers,
+            _preload_content=_preload_content,
+            _request_timeout=_request_timeout,
+            query_params=query_params,
+        )
+
+    def HEAD(
+        self,
+        url,
+        headers=None,
+        query_params=None,
+        _preload_content=True,
+        _request_timeout=None,
+    ):
+        return self.request(
+            "HEAD",
+            url,
+            headers=headers,
+            _preload_content=_preload_content,
+            _request_timeout=_request_timeout,
+            query_params=query_params,
+        )
+
+    def OPTIONS(
+        self,
+        url,
+        headers=None,
+        query_params=None,
+        post_params=None,
+        body=None,
+        _preload_content=True,
+        _request_timeout=None,
+    ):
+        return self.request(
+            "OPTIONS",
+            url,
+            headers=headers,
+            query_params=query_params,
+            post_params=post_params,
+            _preload_content=_preload_content,
+            _request_timeout=_request_timeout,
+            body=body,
+        )
+
+    def DELETE(
+        self,
+        url,
+        headers=None,
+        query_params=None,
+        body=None,
+        _preload_content=True,
+        _request_timeout=None,
+    ):
+        return self.request(
+            "DELETE",
+            url,
+            headers=headers,
+            query_params=query_params,
+            _preload_content=_preload_content,
+            _request_timeout=_request_timeout,
+            body=body,
+        )
+
+    def POST(
+        self,
+        url,
+        headers=None,
+        query_params=None,
+        post_params=None,
+        body=None,
+        _preload_content=True,
+        _request_timeout=None,
+    ):
+        return self.request(
+            "POST",
+            url,
+            headers=headers,
+            query_params=query_params,
+            post_params=post_params,
+            _preload_content=_preload_content,
+            _request_timeout=_request_timeout,
+            body=body,
+        )
+
+    def PUT(
+        self,
+        url,
+        headers=None,
+        query_params=None,
+        post_params=None,
+        body=None,
+        _preload_content=True,
+        _request_timeout=None,
+    ):
+        return self.request(
+            "PUT",
+            url,
+            headers=headers,
+            query_params=query_params,
+            post_params=post_params,
+            _preload_content=_preload_content,
+            _request_timeout=_request_timeout,
+            body=body,
+        )
+
+    def PATCH(
+        self,
+        url,
+        headers=None,
+        query_params=None,
+        post_params=None,
+        body=None,
+        _preload_content=True,
+        _request_timeout=None,
+    ):
+        return self.request(
+            "PATCH",
+            url,
+            headers=headers,
+            query_params=query_params,
+            post_params=post_params,
+            _preload_content=_preload_content,
+            _request_timeout=_request_timeout,
+            body=body,
+        )
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk/validation.py` & `openfga-sdk-0.4.2/openfga_sdk/validation.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,16 +1,14 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 import re
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk.egg-info/PKG-INFO` & `openfga-sdk-0.4.2/openfga_sdk.egg-info/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: openfga-sdk
-Version: 0.4.1
+Version: 0.4.2
 Summary: A high performance and flexible authorization/permission engine built for developers and inspired by Google Zanzibar.
 Home-page: https://github.com/openfga/python-sdk
 Author: OpenFGA (https://openfga.dev)
 Author-email: community@openfga.dev
 License: Apache-2.0
 Keywords: openfga,authorization,fga,fine-grained-authorization,rebac,zanzibar
 Classifier: Development Status :: 5 - Production/Stable
@@ -13,22 +13,26 @@
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
 Classifier: Programming Language :: Python :: 3.12
 Requires-Python: >=3.10
 Description-Content-Type: text/markdown
 License-File: LICENSE
 License-File: NOTICE.txt
+Requires-Dist: aiohttp<4,>=3.9.3
+Requires-Dist: python-dateutil<3,>=2.9.0
+Requires-Dist: setuptools>=69.1.1
+Requires-Dist: urllib3<3,>=1.25.11
 
 # Python SDK for OpenFGA
 
 [![pypi](https://img.shields.io/pypi/v/openfga_sdk.svg?style=flat)](https://pypi.org/project/openfga_sdk)
 [![Release](https://img.shields.io/github/v/release/openfga/python-sdk?sort=semver&color=green)](https://github.com/openfga/python-sdk/releases)
 [![License](https://img.shields.io/badge/License-Apache_2.0-blue.svg)](./LICENSE)
 [![FOSSA Status](https://app.fossa.com/api/projects/git%2Bgithub.com%2Fopenfga%2Fpython-sdk.svg?type=shield)](https://app.fossa.com/projects/git%2Bgithub.com%2Fopenfga%2Fpython-sdk?ref=badge_shield)
-[![Discord Server](https://img.shields.io/discord/759188666072825867?color=7289da&logo=discord "Discord Server")](https://discord.gg/8naAwJfWN6)
+[![Join our community](https://img.shields.io/badge/slack-cncf_%23openfga-40abb8.svg?logo=slack)](https://openfga.dev/community)
 [![Twitter](https://img.shields.io/twitter/follow/openfga?color=%23179CF0&logo=twitter&style=flat-square "@openfga on Twitter")](https://twitter.com/openfga)
 
 This is an autogenerated python SDK for OpenFGA. It provides a wrapper around the [OpenFGA API definition](https://openfga.dev/api).
 
 ## Table of Contents
 
 - [About OpenFGA](#about)
@@ -57,14 +61,15 @@
       - [Batch Check](#batch-check)
       - [Expand](#expand)
       - [List Objects](#list-objects)
       - [List Relations](#list-relations)
     - [Assertions](#assertions)
       - [Read Assertions](#read-assertions)
       - [Write Assertions](#write-assertions)
+  - [Retries](#retries)
   - [API Endpoints](#api-endpoints)
   - [Models](#models)
 - [Contributing](#contributing)
   - [Issues](#issues)
   - [Pull Requests](#pull-requests)
 - [License](#license)
 
@@ -76,15 +81,15 @@
 
 
 ## Resources
 
 - [OpenFGA Documentation](https://openfga.dev/docs)
 - [OpenFGA API Documentation](https://openfga.dev/api/service)
 - [Twitter](https://twitter.com/openfga)
-- [OpenFGA Discord Community](https://discord.gg/8naAwJfWN6)
+- [OpenFGA Community](https://openfga.dev/community)
 - [Zanzibar Academy](https://zanzibar.academy)
 - [Google's Zanzibar Paper (2019)](https://research.google/pubs/pub48190/)
 
 ## Installation
 
 ### pip install
 
@@ -133,17 +138,17 @@
 
 ## Getting Started
 
 ### Initializing the API Client
 
 [Learn how to initialize your SDK](https://openfga.dev/docs/getting-started/setup-sdk-client)
 
-The documentation below refers to the `OpenFgaClient`, to read the documentation for `OpenFgaApi`, check out the [`v0.1.1` documentation](https://github.com/openfga/python-sdk/tree/v0.1.1#readme).
+We strongly recommend you initialize the `OpenFgaClient` only once and then re-use it throughout your app, otherwise you will incur the cost of having to re-initialize multiple times or at every request, the cost of reduced connection pooling and re-use, and would be particularly costly in the client credentials flow, as that flow will be preformed on every request.
 
-> The OpenFgaClient will by default retry API requests up to 15 times on 429 and 5xx errors.
+> The `OpenFgaClient` will by default retry API requests up to 15 times on 429 and 5xx errors.
 
 #### No Credentials
 
 ```python
 from openfga_sdk import ClientConfiguration, OpenFgaClient
 
 
@@ -972,14 +977,40 @@
     expectation=True,
 )]
 
 response = await fga_client.write_assertions(body, options)
 ```
 
 
+### Retries
+
+If a network request fails with a 429 or 5xx error from the server, the SDK will automatically retry the request up to 15 times with a minimum wait time of 100 milliseconds between each attempt.
+
+To customize this behavior, create a `RetryParams` object and assign values to the `max_retry` and `min_wait_in_ms` constructor parameters. `max_retry` determines the maximum number of retries (up to 15), while `min_wait_in_ms` sets the minimum wait time between retries in milliseconds.
+
+Apply your custom retry values by passing the object to the `ClientConfiguration` constructor's `retry_params` parameter.
+
+```python
+from openfga_sdk import ClientConfiguration, OpenFgaClient
+from openfga_sdk.configuration import RetryParams
+from os import environ
+
+async def main():
+    # Configure the client with custom retry settings
+    config = ClientConfiguration(
+        api_url=environ.get("FGA_API_URL"),
+        retry_params=RetryParams(max_retry=3, min_wait_in_ms=250)
+    )
+
+    # Create a client instance and read authorization models
+    async with OpenFgaClient(config) as client:
+        return await client.read_authorization_models()
+```
+
+
 ### API Endpoints
 
 Class | Method | HTTP request | Description
 ------------ | ------------- | ------------- | -------------
 *OpenFgaApi* | [**check**](https://github.com/openfga/python-sdk/blob/main/docs/OpenFgaApi.md#check) | **POST** /stores/{store_id}/check | Check whether a user is authorized to access an object
 *OpenFgaApi* | [**create_store**](https://github.com/openfga/python-sdk/blob/main/docs/OpenFgaApi.md#create_store) | **POST** /stores | Create a store
 *OpenFgaApi* | [**delete_store**](https://github.com/openfga/python-sdk/blob/main/docs/OpenFgaApi.md#delete_store) | **DELETE** /stores/{store_id} | Delete a store
@@ -993,28 +1024,30 @@
 *OpenFgaApi* | [**read_authorization_models**](https://github.com/openfga/python-sdk/blob/main/docs/OpenFgaApi.md#read_authorization_models) | **GET** /stores/{store_id}/authorization-models | Return all the authorization models for a particular store
 *OpenFgaApi* | [**read_changes**](https://github.com/openfga/python-sdk/blob/main/docs/OpenFgaApi.md#read_changes) | **GET** /stores/{store_id}/changes | Return a list of all the tuple changes
 *OpenFgaApi* | [**write**](https://github.com/openfga/python-sdk/blob/main/docs/OpenFgaApi.md#write) | **POST** /stores/{store_id}/write | Add or delete tuples from the store
 *OpenFgaApi* | [**write_assertions**](https://github.com/openfga/python-sdk/blob/main/docs/OpenFgaApi.md#write_assertions) | **PUT** /stores/{store_id}/assertions/{authorization_model_id} | Upsert assertions for an authorization model ID
 *OpenFgaApi* | [**write_authorization_model**](https://github.com/openfga/python-sdk/blob/main/docs/OpenFgaApi.md#write_authorization_model) | **POST** /stores/{store_id}/authorization-models | Create a new authorization model
 
 
+
 ### Models
 
 ## Documentation For Models
 
  - [AbortedMessageResponse](https://github.com/openfga/python-sdk/blob/main/docs/AbortedMessageResponse.md)
  - [Any](https://github.com/openfga/python-sdk/blob/main/docs/Any.md)
  - [Assertion](https://github.com/openfga/python-sdk/blob/main/docs/Assertion.md)
  - [AssertionTupleKey](https://github.com/openfga/python-sdk/blob/main/docs/AssertionTupleKey.md)
  - [AuthorizationModel](https://github.com/openfga/python-sdk/blob/main/docs/AuthorizationModel.md)
  - [CheckRequest](https://github.com/openfga/python-sdk/blob/main/docs/CheckRequest.md)
  - [CheckRequestTupleKey](https://github.com/openfga/python-sdk/blob/main/docs/CheckRequestTupleKey.md)
  - [CheckResponse](https://github.com/openfga/python-sdk/blob/main/docs/CheckResponse.md)
  - [Computed](https://github.com/openfga/python-sdk/blob/main/docs/Computed.md)
  - [Condition](https://github.com/openfga/python-sdk/blob/main/docs/Condition.md)
+ - [ConditionMetadata](https://github.com/openfga/python-sdk/blob/main/docs/ConditionMetadata.md)
  - [ConditionParamTypeRef](https://github.com/openfga/python-sdk/blob/main/docs/ConditionParamTypeRef.md)
  - [ContextualTupleKeys](https://github.com/openfga/python-sdk/blob/main/docs/ContextualTupleKeys.md)
  - [CreateStoreRequest](https://github.com/openfga/python-sdk/blob/main/docs/CreateStoreRequest.md)
  - [CreateStoreResponse](https://github.com/openfga/python-sdk/blob/main/docs/CreateStoreResponse.md)
  - [Difference](https://github.com/openfga/python-sdk/blob/main/docs/Difference.md)
  - [ErrorCode](https://github.com/openfga/python-sdk/blob/main/docs/ErrorCode.md)
  - [ExpandRequest](https://github.com/openfga/python-sdk/blob/main/docs/ExpandRequest.md)
@@ -1040,14 +1073,15 @@
  - [ReadChangesResponse](https://github.com/openfga/python-sdk/blob/main/docs/ReadChangesResponse.md)
  - [ReadRequest](https://github.com/openfga/python-sdk/blob/main/docs/ReadRequest.md)
  - [ReadRequestTupleKey](https://github.com/openfga/python-sdk/blob/main/docs/ReadRequestTupleKey.md)
  - [ReadResponse](https://github.com/openfga/python-sdk/blob/main/docs/ReadResponse.md)
  - [RelationMetadata](https://github.com/openfga/python-sdk/blob/main/docs/RelationMetadata.md)
  - [RelationReference](https://github.com/openfga/python-sdk/blob/main/docs/RelationReference.md)
  - [RelationshipCondition](https://github.com/openfga/python-sdk/blob/main/docs/RelationshipCondition.md)
+ - [SourceInfo](https://github.com/openfga/python-sdk/blob/main/docs/SourceInfo.md)
  - [Status](https://github.com/openfga/python-sdk/blob/main/docs/Status.md)
  - [Store](https://github.com/openfga/python-sdk/blob/main/docs/Store.md)
  - [Tuple](https://github.com/openfga/python-sdk/blob/main/docs/Tuple.md)
  - [TupleChange](https://github.com/openfga/python-sdk/blob/main/docs/TupleChange.md)
  - [TupleKey](https://github.com/openfga/python-sdk/blob/main/docs/TupleKey.md)
  - [TupleKeyWithoutCondition](https://github.com/openfga/python-sdk/blob/main/docs/TupleKeyWithoutCondition.md)
  - [TupleOperation](https://github.com/openfga/python-sdk/blob/main/docs/TupleOperation.md)
@@ -1085,7 +1119,8 @@
 [OpenFGA](https://github.com/openfga)
 
 ## License
 
 This project is licensed under the Apache-2.0 license. See the [LICENSE](https://github.com/openfga/python-sdk/blob/main/LICENSE) file for more info.
 
 The code in this repo was auto generated by [OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator) from a template based on the [python legacy template](https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator/src/main/resources/python-legacy), licensed under the [Apache License 2.0](https://github.com/OpenAPITools/openapi-generator/blob/master/LICENSE).
+
```

### Comparing `openfga-sdk-0.4.1/openfga_sdk.egg-info/SOURCES.txt` & `openfga-sdk-0.4.2/openfga_sdk.egg-info/SOURCES.txt`

 * *Files 0% similar despite different names*

```diff
@@ -42,14 +42,15 @@
 openfga_sdk/models/assertion_tuple_key.py
 openfga_sdk/models/authorization_model.py
 openfga_sdk/models/check_request.py
 openfga_sdk/models/check_request_tuple_key.py
 openfga_sdk/models/check_response.py
 openfga_sdk/models/computed.py
 openfga_sdk/models/condition.py
+openfga_sdk/models/condition_metadata.py
 openfga_sdk/models/condition_param_type_ref.py
 openfga_sdk/models/contextual_tuple_keys.py
 openfga_sdk/models/create_store_request.py
 openfga_sdk/models/create_store_response.py
 openfga_sdk/models/difference.py
 openfga_sdk/models/error_code.py
 openfga_sdk/models/expand_request.py
@@ -75,14 +76,15 @@
 openfga_sdk/models/read_changes_response.py
 openfga_sdk/models/read_request.py
 openfga_sdk/models/read_request_tuple_key.py
 openfga_sdk/models/read_response.py
 openfga_sdk/models/relation_metadata.py
 openfga_sdk/models/relation_reference.py
 openfga_sdk/models/relationship_condition.py
+openfga_sdk/models/source_info.py
 openfga_sdk/models/status.py
 openfga_sdk/models/store.py
 openfga_sdk/models/tuple.py
 openfga_sdk/models/tuple_change.py
 openfga_sdk/models/tuple_key.py
 openfga_sdk/models/tuple_key_without_condition.py
 openfga_sdk/models/tuple_operation.py
@@ -107,13 +109,14 @@
 openfga_sdk/sync/oauth2.py
 openfga_sdk/sync/open_fga_api.py
 openfga_sdk/sync/rest.py
 openfga_sdk/sync/client/__init__.py
 openfga_sdk/sync/client/client.py
 test/test_client.py
 test/test_client_sync.py
+test/test_configuration.py
 test/test_credentials.py
 test/test_oauth2.py
 test/test_oauth2_sync.py
 test/test_open_fga_api.py
 test/test_open_fga_api_sync.py
 test/test_validation.py
```

### Comparing `openfga-sdk-0.4.1/test/test_client.py` & `openfga-sdk-0.4.2/test/test_client.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,117 +1,123 @@
-# coding: utf-8
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
-from unittest.mock import ANY
-from unittest import IsolatedAsyncioTestCase
-from mock import patch
 from datetime import datetime
+from unittest import IsolatedAsyncioTestCase
+from unittest.mock import ANY, patch
 
 import urllib3
 
 from openfga_sdk import rest
 from openfga_sdk.client import ClientConfiguration
 from openfga_sdk.client.client import OpenFgaClient
 from openfga_sdk.client.models.assertion import ClientAssertion
 from openfga_sdk.client.models.check_request import ClientCheckRequest
-from openfga_sdk.client.models.tuple import ClientTuple
-from openfga_sdk.client.models.write_request import ClientWriteRequest
 from openfga_sdk.client.models.expand_request import ClientExpandRequest
 from openfga_sdk.client.models.list_objects_request import ClientListObjectsRequest
 from openfga_sdk.client.models.list_relations_request import ClientListRelationsRequest
 from openfga_sdk.client.models.read_changes_request import ClientReadChangesRequest
+from openfga_sdk.client.models.tuple import ClientTuple
+from openfga_sdk.client.models.write_request import ClientWriteRequest
 from openfga_sdk.client.models.write_single_response import ClientWriteSingleResponse
 from openfga_sdk.client.models.write_transaction_opts import WriteTransactionOpts
-from openfga_sdk.exceptions import ValidationException, FgaValidationException, UnauthorizedException
+from openfga_sdk.exceptions import (
+    FgaValidationException,
+    UnauthorizedException,
+    ValidationException,
+)
 from openfga_sdk.models.assertion import Assertion
 from openfga_sdk.models.authorization_model import AuthorizationModel
 from openfga_sdk.models.check_response import CheckResponse
 from openfga_sdk.models.create_store_request import CreateStoreRequest
 from openfga_sdk.models.create_store_response import CreateStoreResponse
 from openfga_sdk.models.expand_response import ExpandResponse
 from openfga_sdk.models.get_store_response import GetStoreResponse
 from openfga_sdk.models.leaf import Leaf
 from openfga_sdk.models.list_objects_response import ListObjectsResponse
 from openfga_sdk.models.list_stores_response import ListStoresResponse
 from openfga_sdk.models.node import Node
 from openfga_sdk.models.object_relation import ObjectRelation
 from openfga_sdk.models.read_assertions_response import ReadAssertionsResponse
-from openfga_sdk.models.read_authorization_model_response import ReadAuthorizationModelResponse
-from openfga_sdk.models.read_authorization_models_response import ReadAuthorizationModelsResponse
+from openfga_sdk.models.read_authorization_model_response import (
+    ReadAuthorizationModelResponse,
+)
+from openfga_sdk.models.read_authorization_models_response import (
+    ReadAuthorizationModelsResponse,
+)
 from openfga_sdk.models.read_changes_response import ReadChangesResponse
 from openfga_sdk.models.read_request_tuple_key import ReadRequestTupleKey
 from openfga_sdk.models.read_response import ReadResponse
 from openfga_sdk.models.store import Store
 from openfga_sdk.models.tuple import Tuple
 from openfga_sdk.models.tuple_change import TupleChange
 from openfga_sdk.models.tuple_key import TupleKey
 from openfga_sdk.models.tuple_key_without_condition import TupleKeyWithoutCondition
 from openfga_sdk.models.tuple_operation import TupleOperation
 from openfga_sdk.models.type_definition import TypeDefinition
 from openfga_sdk.models.users import Users
 from openfga_sdk.models.userset import Userset
-from openfga_sdk.models.usersets import Usersets
 from openfga_sdk.models.userset_tree import UsersetTree
-from openfga_sdk.models.validation_error_message_response import ValidationErrorMessageResponse
-from openfga_sdk.models.write_authorization_model_request import WriteAuthorizationModelRequest
-from openfga_sdk.models.write_authorization_model_response import WriteAuthorizationModelResponse
+from openfga_sdk.models.usersets import Usersets
+from openfga_sdk.models.validation_error_message_response import (
+    ValidationErrorMessageResponse,
+)
+from openfga_sdk.models.write_authorization_model_request import (
+    WriteAuthorizationModelRequest,
+)
+from openfga_sdk.models.write_authorization_model_response import (
+    WriteAuthorizationModelResponse,
+)
 
+store_id = "01YCP46JKYM8FJCQ37NMBYHE5X"
+request_id = "x1y2z3"
 
-store_id = '01YCP46JKYM8FJCQ37NMBYHE5X'
-request_id = 'x1y2z3'
 
 # Helper function to construct mock response
-
-
 def http_mock_response(body, status):
-    headers = urllib3.response.HTTPHeaderDict({
-        'content-type': 'application/json',
-        'Fga-Request-Id': request_id
-    })
+    headers = urllib3.response.HTTPHeaderDict(
+        {"content-type": "application/json", "Fga-Request-Id": request_id}
+    )
     return urllib3.HTTPResponse(
-        body.encode('utf-8'),
-        headers,
-        status,
-        preload_content=False
+        body.encode("utf-8"), headers, status, preload_content=False
     )
 
 
 def mock_response(body, status):
     obj = http_mock_response(body, status)
     return rest.RESTResponse(obj, obj.data)
 
 
 class TestOpenFgaClient(IsolatedAsyncioTestCase):
     """Test for OpenFGA Client"""
 
     def setUp(self):
         self.configuration = ClientConfiguration(
-            api_url='http://api.fga.example',
+            api_url="http://api.fga.example",
         )
 
     def tearDown(self):
         pass
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_list_stores(self, mock_request):
         """Test case for list_stores
 
-        Get all stores  # noqa: E501
+        Get all stores
         """
-        response_body = '''
+        response_body = """
 {
   "stores": [
     {
       "id": "01YCP46JKYM8FJCQ37NMBYHE5X",
       "name": "store1",
       "created_at": "2022-07-25T21:15:37.524Z",
       "updated_at": "2022-07-25T21:15:37.524Z",
@@ -123,24 +129,29 @@
       "created_at": "2022-07-25T21:15:37.524Z",
       "updated_at": "2022-07-25T21:15:37.524Z",
       "deleted_at": "2022-07-25T21:15:37.524Z"
     }
   ],
   "continuation_token": "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ=="
 }
-            '''
+            """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         async with OpenFgaClient(configuration) as api_client:
             api_response = await api_client.list_stores(
-                options={"page_size": 1, "continuation_token": "continuation_token_example"}
+                options={
+                    "page_size": 1,
+                    "continuation_token": "continuation_token_example",
+                }
             )
             self.assertIsInstance(api_response, ListStoresResponse)
-            self.assertEqual(api_response.continuation_token,
-                             "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==")
+            self.assertEqual(
+                api_response.continuation_token,
+                "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==",
+            )
             store1 = Store(
                 id="01YCP46JKYM8FJCQ37NMBYHE5X",
                 name="store1",
                 created_at=datetime.fromisoformat("2022-07-25T21:15:37.524+00:00"),
                 updated_at=datetime.fromisoformat("2022-07-25T21:15:37.524+00:00"),
                 deleted_at=datetime.fromisoformat("2022-07-25T21:15:37.524+00:00"),
             )
@@ -151,122 +162,119 @@
                 updated_at=datetime.fromisoformat("2022-07-25T21:15:37.524+00:00"),
                 deleted_at=datetime.fromisoformat("2022-07-25T21:15:37.524+00:00"),
             )
 
             stores = [store1, store2]
             self.assertEqual(api_response.stores, stores)
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores',
+                "GET",
+                "http://api.fga.example/stores",
                 headers=ANY,
-                query_params=[('page_size', 1), ('continuation_token',
-                                                 'continuation_token_example')],
+                query_params=[
+                    ("page_size", 1),
+                    ("continuation_token", "continuation_token_example"),
+                ],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             await api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_create_store(self, mock_request):
         """Test case for create_store
 
-        Create a store  # noqa: E501
+        Create a store
         """
-        response_body = '''{
+        response_body = """{
             "id": "01YCP46JKYM8FJCQ37NMBYHE5X",
             "name": "test_store",
             "created_at": "2022-07-25T17:41:26.607Z",
             "updated_at": "2022-07-25T17:41:26.607Z"}
-            '''
+            """
         mock_request.return_value = mock_response(response_body, 201)
         configuration = self.configuration
         async with OpenFgaClient(configuration) as api_client:
             api_response = await api_client.create_store(
-                CreateStoreRequest(name="test-store"),
-                options={}
+                CreateStoreRequest(name="test-store"), options={}
             )
             self.assertIsInstance(api_response, CreateStoreResponse)
-            self.assertEqual(api_response.id, '01YCP46JKYM8FJCQ37NMBYHE5X')
+            self.assertEqual(api_response.id, "01YCP46JKYM8FJCQ37NMBYHE5X")
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores',
+                "POST",
+                "http://api.fga.example/stores",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
                 body={"name": "test-store"},
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             await api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_get_store(self, mock_request):
         """Test case for get_store
 
-        Get all stores  # noqa: E501
+        Get all stores
         """
-        response_body = '''
+        response_body = """
 {
     "id": "01YCP46JKYM8FJCQ37NMBYHE5X",
     "name": "store1",
     "created_at": "2022-07-25T21:15:37.524Z",
     "updated_at": "2022-07-25T21:15:37.524Z"
 }
-            '''
+            """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         async with OpenFgaClient(configuration) as api_client:
-            api_response = await api_client.get_store(
-                options={}
-            )
+            api_response = await api_client.get_store(options={})
             self.assertIsInstance(api_response, GetStoreResponse)
             self.assertEqual(api_response.id, "01YCP46JKYM8FJCQ37NMBYHE5X")
             self.assertEqual(api_response.name, "store1")
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             await api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_delete_store(self, mock_request):
         """Test case for delete_store
 
-        Get all stores  # noqa: E501
+        Get all stores
         """
-        mock_request.return_value = mock_response('', 201)
+        mock_request.return_value = mock_response("", 201)
         configuration = self.configuration
         configuration.store_id = store_id
         async with OpenFgaClient(configuration) as api_client:
-            await api_client.delete_store(
-                options={}
-            )
+            await api_client.delete_store(options={})
             mock_request.assert_called_once_with(
-                'DELETE',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X',
+                "DELETE",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X",
                 headers=ANY,
                 query_params=[],
                 body=None,
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             await api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_read_authorization_models(self, mock_request):
         """Test case for read_authorization_models
 
-        Return all authorization models configured for the store  # noqa: E501
+        Return all authorization models configured for the store
         """
-        response_body = '''
+        response_body = """
 {
   "authorization_models": [{
     "id": "01G5JAVJ41T49E9TT3SKVS7X1J",
     "schema_version":"1.1",
     "type_definitions": [
       {
         "type": "document",
@@ -291,66 +299,71 @@
           }
         }
       }
     ]
   }],
   "continuation_token": "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ=="
 }
-        '''
+        """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         # Enter a context with an instance of the API client
         async with OpenFgaClient(configuration) as api_client:
 
             # Return a particular version of an authorization model
-            api_response = await api_client.read_authorization_models(
-                options={}
-            )
+            api_response = await api_client.read_authorization_models(options={})
             self.assertIsInstance(api_response, ReadAuthorizationModelsResponse)
             type_definitions = [
                 TypeDefinition(
                     type="document",
                     relations=dict(
                         reader=Userset(
                             union=Usersets(
                                 child=[
                                     Userset(this=dict()),
-                                    Userset(computed_userset=ObjectRelation(
-                                        object="",
-                                        relation="writer",
-                                    )),
+                                    Userset(
+                                        computed_userset=ObjectRelation(
+                                            object="",
+                                            relation="writer",
+                                        )
+                                    ),
                                 ],
                             ),
                         ),
                         writer=Userset(
                             this=dict(),
                         ),
-                    )
+                    ),
                 )
             ]
-            authorization_model = AuthorizationModel(id='01G5JAVJ41T49E9TT3SKVS7X1J', schema_version="1.1",
-                                                     type_definitions=type_definitions)
+            authorization_model = AuthorizationModel(
+                id="01G5JAVJ41T49E9TT3SKVS7X1J",
+                schema_version="1.1",
+                type_definitions=type_definitions,
+            )
             self.assertEqual(api_response.authorization_models, [authorization_model])
-            self.assertEqual(api_response.continuation_token,
-                             "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==")
+            self.assertEqual(
+                api_response.continuation_token,
+                "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==",
+            )
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_write_authorization_model(self, mock_request):
         """Test case for write_authorization_model
 
-        Create a new authorization model  # noqa: E501
+        Create a new authorization model
         """
         response_body = '{"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"}'
         mock_request.return_value = mock_response(response_body, 201)
         configuration = self.configuration
         configuration.store_id = store_id
         async with OpenFgaClient(configuration) as api_client:
             # example passing only required values which don't have defaults set
@@ -363,54 +376,75 @@
                             writer=Userset(
                                 this=dict(),
                             ),
                             reader=Userset(
                                 union=Usersets(
                                     child=[
                                         Userset(this=dict()),
-                                        Userset(computed_userset=ObjectRelation(
-                                            object="",
-                                            relation="writer",
-                                        )),
+                                        Userset(
+                                            computed_userset=ObjectRelation(
+                                                object="",
+                                                relation="writer",
+                                            )
+                                        ),
                                     ],
                                 ),
                             ),
-                        )
+                        ),
                     ),
                 ],
             )
             # Create a new authorization model
-            api_response = await api_client.write_authorization_model(
-                body,
-                options={}
-            )
+            api_response = await api_client.write_authorization_model(body, options={})
             self.assertIsInstance(api_response, WriteAuthorizationModelResponse)
             expected_response = WriteAuthorizationModelResponse(
-                authorization_model_id='01G5JAVJ41T49E9TT3SKVS7X1J'
+                authorization_model_id="01G5JAVJ41T49E9TT3SKVS7X1J"
             )
             self.assertEqual(api_response, expected_response)
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"schema_version": "1.1", "type_definitions": [{"type": "document", "relations": {"writer": {"this": {
-                }}, "reader": {"union": {"child": [{"this": {}}, {"computedUserset": {"object": "", "relation": "writer"}}]}}}}]},
+                body={
+                    "schema_version": "1.1",
+                    "type_definitions": [
+                        {
+                            "type": "document",
+                            "relations": {
+                                "writer": {"this": {}},
+                                "reader": {
+                                    "union": {
+                                        "child": [
+                                            {"this": {}},
+                                            {
+                                                "computedUserset": {
+                                                    "object": "",
+                                                    "relation": "writer",
+                                                }
+                                            },
+                                        ]
+                                    }
+                                },
+                            },
+                        }
+                    ],
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_read_authorization_model(self, mock_request):
         """Test case for read_authorization_model
 
-        Return a particular version of an authorization model  # noqa: E501
+        Return a particular version of an authorization model
         """
-        response_body = '''
+        response_body = """
 {
   "authorization_model": {
     "id": "01G5JAVJ41T49E9TT3SKVS7X1J",
     "schema_version":"1.1",
     "type_definitions": [
       {
         "type": "document",
@@ -434,15 +468,15 @@
             "this": {}
           }
         }
       }
     ]
   }
 }
-        '''
+        """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         # Enter a context with an instance of the API client
         async with OpenFgaClient(configuration) as api_client:
 
             # Return a particular version of an authorization model
@@ -454,46 +488,51 @@
                 TypeDefinition(
                     type="document",
                     relations=dict(
                         reader=Userset(
                             union=Usersets(
                                 child=[
                                     Userset(this=dict()),
-                                    Userset(computed_userset=ObjectRelation(
-                                        object="",
-                                        relation="writer",
-                                    )),
+                                    Userset(
+                                        computed_userset=ObjectRelation(
+                                            object="",
+                                            relation="writer",
+                                        )
+                                    ),
                                 ],
                             ),
                         ),
                         writer=Userset(
                             this=dict(),
                         ),
-                    )
+                    ),
                 )
             ]
-            authorization_model = AuthorizationModel(id='01G5JAVJ41T49E9TT3SKVS7X1J', schema_version="1.1",
-                                                     type_definitions=type_definitions)
+            authorization_model = AuthorizationModel(
+                id="01G5JAVJ41T49E9TT3SKVS7X1J",
+                schema_version="1.1",
+                type_definitions=type_definitions,
+            )
             self.assertEqual(api_response.authorization_model, authorization_model)
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_read_latest_authorization_model(self, mock_request):
         """Test case for read_latest_authorization_model
 
-        Return the latest authorization models configured for the store  # noqa: E501
+        Return the latest authorization models configured for the store
         """
-        response_body = '''
+        response_body = """
 {
   "authorization_models": [{
     "id": "01G5JAVJ41T49E9TT3SKVS7X1J",
     "schema_version":"1.1",
     "type_definitions": [
       {
         "type": "document",
@@ -518,278 +557,309 @@
           }
         }
       }
     ]
   }],
   "continuation_token": "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ=="
 }
-        '''
+        """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         # Enter a context with an instance of the API client
         async with OpenFgaClient(configuration) as api_client:
 
             # Return a particular version of an authorization model
-            api_response = await api_client.read_latest_authorization_model(
-                options={}
-            )
+            api_response = await api_client.read_latest_authorization_model(options={})
             self.assertIsInstance(api_response, ReadAuthorizationModelResponse)
             type_definitions = [
                 TypeDefinition(
                     type="document",
                     relations=dict(
                         reader=Userset(
                             union=Usersets(
                                 child=[
                                     Userset(this=dict()),
-                                    Userset(computed_userset=ObjectRelation(
-                                        object="",
-                                        relation="writer",
-                                    )),
+                                    Userset(
+                                        computed_userset=ObjectRelation(
+                                            object="",
+                                            relation="writer",
+                                        )
+                                    ),
                                 ],
                             ),
                         ),
                         writer=Userset(
                             this=dict(),
                         ),
-                    )
+                    ),
                 )
             ]
-            authorization_model = AuthorizationModel(id='01G5JAVJ41T49E9TT3SKVS7X1J', schema_version="1.1",
-                                                     type_definitions=type_definitions)
+            authorization_model = AuthorizationModel(
+                id="01G5JAVJ41T49E9TT3SKVS7X1J",
+                schema_version="1.1",
+                type_definitions=type_definitions,
+            )
             self.assertEqual(api_response.authorization_model, authorization_model)
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models",
                 headers=ANY,
-                query_params=[('page_size', 1)],
+                query_params=[("page_size", 1)],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_read_changes(self, mock_request):
         """Test case for read_changes
 
-        Return a list of all the tuple changes  # noqa: E501
+        Return a list of all the tuple changes
         """
-        response_body = '''
+        response_body = """
 {
   "changes": [
     {
       "tuple_key": {
         "object": "document:2021-budget",
         "relation": "reader",
         "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"
       },
       "operation": "TUPLE_OPERATION_WRITE",
       "timestamp": "2022-07-26T15:55:55.809Z"
     }
   ],
   "continuation_token": "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ=="
 }
-        '''
+        """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         # Enter a context with an instance of the API client
         async with OpenFgaClient(configuration) as api_client:
 
             # Return a particular version of an authorization model
             api_response = await api_client.read_changes(
                 ClientReadChangesRequest("document"),
-                options={"page_size": 1, "continuation_token": "abcdefg"}
+                options={"page_size": 1, "continuation_token": "abcdefg"},
             )
 
             self.assertIsInstance(api_response, ReadChangesResponse)
             changes = TupleChange(
-                tuple_key=TupleKey(object="document:2021-budget", relation="reader",
-                                   user="user:81684243-9356-4421-8fbf-a4f8d36aa31b"),
+                tuple_key=TupleKey(
+                    object="document:2021-budget",
+                    relation="reader",
+                    user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                ),
                 operation=TupleOperation.WRITE,
-                timestamp=datetime.fromisoformat("2022-07-26T15:55:55.809+00:00"))
+                timestamp=datetime.fromisoformat("2022-07-26T15:55:55.809+00:00"),
+            )
             read_changes = ReadChangesResponse(
-                continuation_token='eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==',
-                changes=[changes])
+                continuation_token="eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==",
+                changes=[changes],
+            )
             self.assertEqual(api_response, read_changes)
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/changes',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/changes",
                 headers=ANY,
-                query_params=[('type', 'document'), ('page_size', 1),
-                              ('continuation_token', 'abcdefg')],
+                query_params=[
+                    ("type", "document"),
+                    ("page_size", 1),
+                    ("continuation_token", "abcdefg"),
+                ],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_read(self, mock_request):
         """Test case for read
 
-        Get tuples from the store that matches a query, without following userset rewrite rules  # noqa: E501
+        Get tuples from the store that matches a query, without following userset rewrite rules
         """
-        response_body = '''
+        response_body = """
             {
   "tuples": [
     {
       "key": {
         "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
         "relation": "reader",
         "object": "document:2021-budget"
       },
       "timestamp": "2021-10-06T15:32:11.128Z"
     }
   ],
   "continuation_token": ""
 }
-        '''
+        """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         # Enter a context with an instance of the API client
         async with OpenFgaClient(configuration) as api_client:
             body = ReadRequestTupleKey(
                 object="document:2021-budget",
                 relation="reader",
                 user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
             )
             api_response = await api_client.read(
                 body=body,
-                options={"page_size": 50, "continuation_token":
-                         "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ=="}
+                options={
+                    "page_size": 50,
+                    "continuation_token": "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==",
+                },
             )
             self.assertIsInstance(api_response, ReadResponse)
-            key = TupleKey(user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
-                           relation="reader", object="document:2021-budget")
+            key = TupleKey(
+                user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                relation="reader",
+                object="document:2021-budget",
+            )
             timestamp = datetime.fromisoformat("2021-10-06T15:32:11.128+00:00")
             expected_data = ReadResponse(
-                tuples=[Tuple(key=key, timestamp=timestamp)], continuation_token='')
+                tuples=[Tuple(key=key, timestamp=timestamp)], continuation_token=""
+            )
             self.assertEqual(api_response, expected_data)
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/read',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/read",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget", "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"},
-                      "page_size": 50, "continuation_token": "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ=="},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    },
+                    "page_size": 50,
+                    "continuation_token": "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_read_empty_options(self, mock_request):
         """Test case for read with empty options
 
-        Get tuples from the store that matches a query, without following userset rewrite rules  # noqa: E501
+        Get tuples from the store that matches a query, without following userset rewrite rules
         """
-        response_body = '''
+        response_body = """
             {
   "tuples": [
     {
       "key": {
         "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
         "relation": "reader",
         "object": "document:2021-budget"
       },
       "timestamp": "2021-10-06T15:32:11.128Z"
     }
   ],
   "continuation_token": ""
 }
-        '''
+        """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         # Enter a context with an instance of the API client
         async with OpenFgaClient(configuration) as api_client:
             body = ReadRequestTupleKey(
                 object="document:2021-budget",
                 relation="reader",
                 user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
             )
-            api_response = await api_client.read(
-                body=body,
-                options={}
-            )
+            api_response = await api_client.read(body=body, options={})
             self.assertIsInstance(api_response, ReadResponse)
-            key = TupleKey(user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
-                           relation="reader", object="document:2021-budget")
+            key = TupleKey(
+                user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                relation="reader",
+                object="document:2021-budget",
+            )
             timestamp = datetime.fromisoformat("2021-10-06T15:32:11.128+00:00")
             expected_data = ReadResponse(
-                tuples=[Tuple(key=key, timestamp=timestamp)], continuation_token='')
+                tuples=[Tuple(key=key, timestamp=timestamp)], continuation_token=""
+            )
             self.assertEqual(api_response, expected_data)
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/read',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/read",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget", "relation": "reader",
-                                    "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    }
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_read_empty_body(self, mock_request):
         """Test case for read with empty body
 
-        Get tuples from the store that matches a query, without following userset rewrite rules  # noqa: E501
+        Get tuples from the store that matches a query, without following userset rewrite rules
         """
-        response_body = '''
+        response_body = """
             {
   "tuples": [
     {
       "key": {
         "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
         "relation": "reader",
         "object": "document:2021-budget"
       },
       "timestamp": "2021-10-06T15:32:11.128Z"
     }
   ],
   "continuation_token": ""
 }
-        '''
+        """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         # Enter a context with an instance of the API client
         async with OpenFgaClient(configuration) as api_client:
             body = ReadRequestTupleKey()
-            api_response = await api_client.read(
-                body=body,
-                options={}
-            )
+            api_response = await api_client.read(body=body, options={})
             self.assertIsInstance(api_response, ReadResponse)
-            key = TupleKey(user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
-                           relation="reader", object="document:2021-budget")
+            key = TupleKey(
+                user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                relation="reader",
+                object="document:2021-budget",
+            )
             timestamp = datetime.fromisoformat("2021-10-06T15:32:11.128+00:00")
             expected_data = ReadResponse(
-                tuples=[Tuple(key=key, timestamp=timestamp)], continuation_token='')
+                tuples=[Tuple(key=key, timestamp=timestamp)], continuation_token=""
+            )
             self.assertEqual(api_response, expected_data)
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/read',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/read",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
                 body={},
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_write(self, mock_request):
         """Test case for write
 
         Add tuples from the store with transaction enabled
         """
-        response_body = '{}'
+        response_body = "{}"
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         async with OpenFgaClient(configuration) as api_client:
 
             body = ClientWriteRequest(
                 writes=[
@@ -803,40 +873,59 @@
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
                     ),
                     ClientTuple(
                         object="document:2021-budget",
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
-                    )
+                    ),
                 ],
             )
             await api_client.write(
-                body,
-                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"}
+                body, options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"}
             )
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}, {"object": "document:2021-budget", "relation": "reader",
-                                                                                                                                                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c"}, {"object": "document:2021-budget", "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                            },
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c",
+                            },
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                            },
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_delete(self, mock_request):
         """Test case for delete
 
         Delete tuples from the store with transaction enabled
         """
-        response_body = '{}'
+        response_body = "{}"
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         async with OpenFgaClient(configuration) as api_client:
 
             body = ClientWriteRequest(
                 deletes=[
@@ -844,40 +933,49 @@
                         object="document:2021-budget",
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                     )
                 ],
             )
             await api_client.write(
-                body,
-                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"}
+                body, options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"}
             )
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"deletes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                  "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "deletes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_write_batch(self, mock_request):
         """Test case for write
 
         Add tuples from the store with transaction disabled
         """
         mock_request.side_effect = [
-            mock_response('{}', 200),
-            mock_response('{}', 200),
-            mock_response('{}', 200),
-            mock_response('{}', 200),
+            mock_response("{}", 200),
+            mock_response("{}", 200),
+            mock_response("{}", 200),
+            mock_response("{}", 200),
         ]
         configuration = self.configuration
         configuration.store_id = store_id
         async with OpenFgaClient(configuration) as api_client:
 
             body = ClientWriteRequest(
                 writes=[
@@ -891,108 +989,145 @@
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
                     ),
                     ClientTuple(
                         object="document:2021-budget",
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
-                    )
+                    ),
                 ],
             )
             transaction = WriteTransactionOpts(
-                disabled=True, max_per_chunk=1, max_parallel_requests=10)
+                disabled=True, max_per_chunk=1, max_parallel_requests=10
+            )
             response = await api_client.write(
                 body,
-                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
-                         "transaction": transaction}
+                options={
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                    "transaction": transaction,
+                },
             )
 
             self.assertEqual(response.deletes, None)
-            self.assertEqual(response.writes,
-                             [
-                                 ClientWriteSingleResponse(
-                                     tuple_key=ClientTuple(
-                                         object="document:2021-budget",
-                                         relation="reader",
-                                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
-                                     ),
-                                     success=True,
-                                     error=None),
-                                 ClientWriteSingleResponse(
-                                     tuple_key=ClientTuple(
-                                         object="document:2021-budget",
-                                         relation="reader",
-                                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
-                                     ),
-                                     success=True,
-                                     error=None),
-                                 ClientWriteSingleResponse(
-                                     tuple_key=ClientTuple(
-                                         object="document:2021-budget",
-                                         relation="reader",
-                                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
-                                     ),
-                                     success=True,
-                                     error=None)
-                             ]
-                             )
+            self.assertEqual(
+                response.writes,
+                [
+                    ClientWriteSingleResponse(
+                        tuple_key=ClientTuple(
+                            object="document:2021-budget",
+                            relation="reader",
+                            user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                        ),
+                        success=True,
+                        error=None,
+                    ),
+                    ClientWriteSingleResponse(
+                        tuple_key=ClientTuple(
+                            object="document:2021-budget",
+                            relation="reader",
+                            user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
+                        ),
+                        success=True,
+                        error=None,
+                    ),
+                    ClientWriteSingleResponse(
+                        tuple_key=ClientTuple(
+                            object="document:2021-budget",
+                            relation="reader",
+                            user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                        ),
+                        success=True,
+                        error=None,
+                    ),
+                ],
+            )
             self.assertEqual(mock_request.call_count, 4)
             mock_request.assert_any_call(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                 "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                 "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                 "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_write_batch_min_parallel(self, mock_request):
         """Test case for write
 
         Add tuples from the store with transaction disabled and minimum parallel request
         """
         mock_request.side_effect = [
-            mock_response('{}', 200),
-            mock_response('{}', 200),
-            mock_response('{}', 200),
-            mock_response('{}', 200),
+            mock_response("{}", 200),
+            mock_response("{}", 200),
+            mock_response("{}", 200),
+            mock_response("{}", 200),
         ]
         configuration = self.configuration
         configuration.store_id = store_id
         async with OpenFgaClient(configuration) as api_client:
 
             body = ClientWriteRequest(
                 writes=[
@@ -1006,107 +1141,144 @@
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
                     ),
                     ClientTuple(
                         object="document:2021-budget",
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
-                    )
+                    ),
                 ],
             )
             transaction = WriteTransactionOpts(
-                disabled=True, max_per_chunk=1, max_parallel_requests=1)
+                disabled=True, max_per_chunk=1, max_parallel_requests=1
+            )
             response = await api_client.write(
                 body,
-                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
-                         "transaction": transaction}
+                options={
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                    "transaction": transaction,
+                },
             )
 
             self.assertEqual(response.deletes, None)
-            self.assertEqual(response.writes,
-                             [
-                                 ClientWriteSingleResponse(
-                                     tuple_key=ClientTuple(
-                                         object="document:2021-budget",
-                                         relation="reader",
-                                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
-                                     ),
-                                     success=True,
-                                     error=None),
-                                 ClientWriteSingleResponse(
-                                     tuple_key=ClientTuple(
-                                         object="document:2021-budget",
-                                         relation="reader",
-                                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
-                                     ),
-                                     success=True,
-                                     error=None),
-                                 ClientWriteSingleResponse(
-                                     tuple_key=ClientTuple(
-                                         object="document:2021-budget",
-                                         relation="reader",
-                                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
-                                     ),
-                                     success=True,
-                                     error=None)
-                             ]
-                             )
+            self.assertEqual(
+                response.writes,
+                [
+                    ClientWriteSingleResponse(
+                        tuple_key=ClientTuple(
+                            object="document:2021-budget",
+                            relation="reader",
+                            user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                        ),
+                        success=True,
+                        error=None,
+                    ),
+                    ClientWriteSingleResponse(
+                        tuple_key=ClientTuple(
+                            object="document:2021-budget",
+                            relation="reader",
+                            user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
+                        ),
+                        success=True,
+                        error=None,
+                    ),
+                    ClientWriteSingleResponse(
+                        tuple_key=ClientTuple(
+                            object="document:2021-budget",
+                            relation="reader",
+                            user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                        ),
+                        success=True,
+                        error=None,
+                    ),
+                ],
+            )
             self.assertEqual(mock_request.call_count, 4)
             mock_request.assert_any_call(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                 "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                 "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                 "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_write_batch_larger_chunk(self, mock_request):
         """Test case for write
 
         Add tuples from the store with transaction disabled and minimum parallel request
         """
         mock_request.side_effect = [
-            mock_response('{}', 200),
-            mock_response('{}', 200),
-            mock_response('{}', 200),
+            mock_response("{}", 200),
+            mock_response("{}", 200),
+            mock_response("{}", 200),
         ]
         configuration = self.configuration
         configuration.store_id = store_id
         async with OpenFgaClient(configuration) as api_client:
 
             body = ClientWriteRequest(
                 writes=[
@@ -1120,104 +1292,136 @@
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
                     ),
                     ClientTuple(
                         object="document:2021-budget",
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
-                    )
+                    ),
                 ],
             )
             transaction = WriteTransactionOpts(
-                disabled=True, max_per_chunk=2, max_parallel_requests=2)
+                disabled=True, max_per_chunk=2, max_parallel_requests=2
+            )
             response = await api_client.write(
                 body,
-                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
-                         "transaction": transaction}
+                options={
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                    "transaction": transaction,
+                },
             )
 
             self.assertEqual(response.deletes, None)
-            self.assertEqual(response.writes,
-                             [
-                                 ClientWriteSingleResponse(
-                                     tuple_key=ClientTuple(
-                                         object="document:2021-budget",
-                                         relation="reader",
-                                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
-                                     ),
-                                     success=True,
-                                     error=None),
-                                 ClientWriteSingleResponse(
-                                     tuple_key=ClientTuple(
-                                         object="document:2021-budget",
-                                         relation="reader",
-                                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
-                                     ),
-                                     success=True,
-                                     error=None),
-                                 ClientWriteSingleResponse(
-                                     tuple_key=ClientTuple(
-                                         object="document:2021-budget",
-                                         relation="reader",
-                                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
-                                     ),
-                                     success=True,
-                                     error=None)
-                             ]
-                             )
+            self.assertEqual(
+                response.writes,
+                [
+                    ClientWriteSingleResponse(
+                        tuple_key=ClientTuple(
+                            object="document:2021-budget",
+                            relation="reader",
+                            user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                        ),
+                        success=True,
+                        error=None,
+                    ),
+                    ClientWriteSingleResponse(
+                        tuple_key=ClientTuple(
+                            object="document:2021-budget",
+                            relation="reader",
+                            user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
+                        ),
+                        success=True,
+                        error=None,
+                    ),
+                    ClientWriteSingleResponse(
+                        tuple_key=ClientTuple(
+                            object="document:2021-budget",
+                            relation="reader",
+                            user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                        ),
+                        success=True,
+                        error=None,
+                    ),
+                ],
+            )
             self.assertEqual(mock_request.call_count, 3)
             mock_request.assert_any_call(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}, {
-                    "object": "document:2021-budget", "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                            },
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c",
+                            },
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                 "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_write_batch_failed(self, mock_request):
         """Test case for write
 
         Add tuples from the store with transaction disabled where one of the request failed
         """
-        response_body = '''
+        response_body = """
 {
   "code": "validation_error",
   "message": "Generic validation error"
 }
-        '''
+        """
 
         mock_request.side_effect = [
-            mock_response('{}', 200),
-            mock_response('{}', 200),
+            mock_response("{}", 200),
+            mock_response("{}", 200),
             ValidationException(http_resp=http_mock_response(response_body, 400)),
-            mock_response('{}', 200),
+            mock_response("{}", 200),
         ]
         configuration = self.configuration
         configuration.store_id = store_id
         async with OpenFgaClient(configuration) as api_client:
 
             body = ClientWriteRequest(
                 writes=[
@@ -1231,107 +1435,150 @@
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
                     ),
                     ClientTuple(
                         object="document:2021-budget",
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
-                    )
+                    ),
                 ],
             )
             transaction = WriteTransactionOpts(
-                disabled=True, max_per_chunk=1, max_parallel_requests=10)
+                disabled=True, max_per_chunk=1, max_parallel_requests=10
+            )
             response = await api_client.write(
                 body,
-                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
-                         "transaction": transaction}
+                options={
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                    "transaction": transaction,
+                },
             )
 
             self.assertEqual(response.deletes, None)
             self.assertEqual(len(response.writes), 3)
-            self.assertEqual(response.writes[0],
-                             ClientWriteSingleResponse(
-                tuple_key=ClientTuple(
+            self.assertEqual(
+                response.writes[0],
+                ClientWriteSingleResponse(
+                    tuple_key=ClientTuple(
+                        object="document:2021-budget",
+                        relation="reader",
+                        user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    ),
+                    success=True,
+                    error=None,
+                ),
+            )
+            self.assertEqual(
+                response.writes[1].tuple_key,
+                ClientTuple(
                     object="document:2021-budget",
                     relation="reader",
-                    user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
                 ),
-                success=True,
-                error=None))
-            self.assertEqual(response.writes[1].tuple_key,
-                             ClientTuple(
-                object="document:2021-budget",
-                relation="reader",
-                user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
-            ))
+            )
             self.assertFalse(response.writes[1].success)
             self.assertIsInstance(response.writes[1].error, ValidationException)
             self.assertIsInstance(
-                response.writes[1].error.parsed_exception, ValidationErrorMessageResponse)
-            self.assertEqual(response.writes[2],
-                             ClientWriteSingleResponse(
-                tuple_key=ClientTuple(
-                    object="document:2021-budget",
-                    relation="reader",
-                    user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                response.writes[1].error.parsed_exception,
+                ValidationErrorMessageResponse,
+            )
+            self.assertEqual(
+                response.writes[2],
+                ClientWriteSingleResponse(
+                    tuple_key=ClientTuple(
+                        object="document:2021-budget",
+                        relation="reader",
+                        user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                    ),
+                    success=True,
+                    error=None,
                 ),
-                success=True,
-                error=None))
+            )
             self.assertEqual(mock_request.call_count, 4)
             mock_request.assert_any_call(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                 "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                 "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                 "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_delete_batch(self, mock_request):
         """Test case for delete
 
         Delete tuples from the store with transaction disabled but there is only 1 relationship tuple
         """
         mock_request.side_effect = [
-            mock_response('{}', 200),
-            mock_response('{}', 200),
+            mock_response("{}", 200),
+            mock_response("{}", 200),
         ]
         configuration = self.configuration
         configuration.store_id = store_id
         async with OpenFgaClient(configuration) as api_client:
 
             body = ClientWriteRequest(
                 deletes=[
@@ -1340,47 +1587,60 @@
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                     )
                 ],
                 writes=[],
             )
             transaction = WriteTransactionOpts(
-                disabled=True, max_per_chunk=1, max_parallel_requests=10)
+                disabled=True, max_per_chunk=1, max_parallel_requests=10
+            )
             await api_client.write(
                 body,
-                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
-                         "transaction": transaction}
+                options={
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                    "transaction": transaction,
+                },
             )
             mock_request.assert_any_call(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"deletes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                  "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "deletes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_write_tuples(self, mock_request):
         """Test case for write tuples
 
         Add tuples from the store with transaction enabled
         """
-        response_body = '{}'
+        response_body = "{}"
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         async with OpenFgaClient(configuration) as api_client:
 
             await api_client.write_tuples(
                 [
@@ -1394,37 +1654,57 @@
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
                     ),
                     ClientTuple(
                         object="document:2021-budget",
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
-                    )
+                    ),
                 ],
-                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"}
+                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
             )
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}, {"object": "document:2021-budget", "relation": "reader",
-                                                                                                                                                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c"}, {"object": "document:2021-budget", "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                            },
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c",
+                            },
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                            },
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_delete_tuples(self, mock_request):
         """Test case for delete tuples
 
         Add tuples from the store with transaction enabled
         """
-        response_body = '{}'
+        response_body = "{}"
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         async with OpenFgaClient(configuration) as api_client:
 
             await api_client.delete_tuples(
                 [
@@ -1438,37 +1718,56 @@
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
                     ),
                     ClientTuple(
                         object="document:2021-budget",
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
-                    )
+                    ),
                 ],
-                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"}
+                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
             )
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"deletes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}, {"object": "document:2021-budget", "relation": "reader",
-                                                                                                                                                                 "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c"}, {"object": "document:2021-budget", "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "deletes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                            },
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c",
+                            },
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                            },
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_write_batch_unauthorized(self, mock_request):
-        """Test case for write with 401 response
-        """
+        """Test case for write with 401 response"""
 
         mock_request.side_effect = UnauthorizedException(
-            http_resp=http_mock_response('{}', 401)
+            http_resp=http_mock_response("{}", 401)
         )
         configuration = self.configuration
         configuration.store_id = store_id
         async with OpenFgaClient(configuration) as api_client:
             with self.assertRaises(UnauthorizedException) as api_exception:
                 body = ClientWriteRequest(
                     writes=[
@@ -1476,40 +1775,43 @@
                             object="document:2021-budget",
                             relation="reader",
                             user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                         )
                     ],
                 )
                 transaction = WriteTransactionOpts(
-                    disabled=True, max_per_chunk=1, max_parallel_requests=10)
+                    disabled=True, max_per_chunk=1, max_parallel_requests=10
+                )
                 await api_client.write(
                     body,
-                    options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
-                             "transaction": transaction}
+                    options={
+                        "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                        "transaction": transaction,
+                    },
                 )
 
             self.assertIsInstance(api_exception.exception, UnauthorizedException)
             mock_request.assert_called()
             self.assertEqual(mock_request.call_count, 1)
 
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             await api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_check(self, mock_request):
         """Test case for check
 
-        Check whether a user is authorized to access an object  # noqa: E501
+        Check whether a user is authorized to access an object
         """
 
         # First, mock the response
         response_body = '{"allowed": true, "resolution": "1234"}'
         mock_request.return_value = mock_response(response_body, 200)
         body = ClientCheckRequest(
             user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
@@ -1524,134 +1826,157 @@
             ],
         )
         configuration = self.configuration
         configuration.store_id = store_id
         async with OpenFgaClient(configuration) as api_client:
             api_response = await api_client.check(
                 body=body,
-                options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"}
+                options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
             )
             self.assertIsInstance(api_response, CheckResponse)
             self.assertTrue(api_response.allowed)
             # Make sure the API was called with the right data
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b", "relation": "reader", "object": "document:budget"},
-                      "contextual_tuples": {"tuple_keys": [{"user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b", "relation": "writer", "object": "document:budget"}]},
-                      "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                        "relation": "reader",
+                        "object": "document:budget",
+                    },
+                    "contextual_tuples": {
+                        "tuple_keys": [
+                            {
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                                "relation": "writer",
+                                "object": "document:budget",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             await api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_check_config_auth_model(self, mock_request):
         """Test case for check
 
-        Check whether a user is authorized to access an object and the auth model is already encoded in store  # noqa: E501
+        Check whether a user is authorized to access an object and the auth model is already encoded in store
         """
 
         # First, mock the response
         response_body = '{"allowed": true, "resolution": "1234"}'
         mock_request.return_value = mock_response(response_body, 200)
         body = ClientCheckRequest(
             object="document:2021-budget",
             relation="reader",
             user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
         )
         configuration = self.configuration
         configuration.store_id = store_id
         configuration.authorization_model_id = "01GXSA8YR785C4FYS3C0RTG7B1"
         async with OpenFgaClient(configuration) as api_client:
-            api_response = await api_client.check(
-                body=body,
-                options={}
-            )
+            api_response = await api_client.check(body=body, options={})
             self.assertIsInstance(api_response, CheckResponse)
             self.assertTrue(api_response.allowed)
             # Make sure the API was called with the right data
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget",
-                                    "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}, "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    },
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             await api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_batch_check_single_request(self, mock_request):
         """Test case for check with single request
 
-        Check whether a user is authorized to access an object  # noqa: E501
+        Check whether a user is authorized to access an object
         """
 
         # First, mock the response
         response_body = '{"allowed": true, "resolution": "1234"}'
         mock_request.side_effect = [
-            mock_response('{}', 200),
+            mock_response("{}", 200),
             mock_response(response_body, 200),
         ]
         body = ClientCheckRequest(
             object="document:2021-budget",
             relation="reader",
             user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
         )
         configuration = self.configuration
         configuration.store_id = store_id
         async with OpenFgaClient(configuration) as api_client:
             api_response = await api_client.batch_check(
                 body=[body],
-                options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"}
+                options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
             )
             self.assertIsInstance(api_response, list)
             self.assertEqual(len(api_response), 1)
             self.assertEqual(api_response[0].error, None)
             self.assertTrue(api_response[0].allowed)
             self.assertEqual(api_response[0].request, body)
             # Make sure the API was called with the right data
             mock_request.assert_any_call(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01GXSA8YR785C4FYS3C0RTG7B1',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01GXSA8YR785C4FYS3C0RTG7B1",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget",
-                                    "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}, "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    },
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             await api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_batch_check_multiple_request(self, mock_request):
         """Test case for check with multiple request
 
-        Check whether a user is authorized to access an object  # noqa: E501
+        Check whether a user is authorized to access an object
         """
 
         # First, mock the response
         mock_request.side_effect = [
-            mock_response('{}', 200),
+            mock_response("{}", 200),
             mock_response('{"allowed": true, "resolution": "1234"}', 200),
             mock_response('{"allowed": false, "resolution": "1234"}', 200),
             mock_response('{"allowed": true, "resolution": "1234"}', 200),
         ]
         body1 = ClientCheckRequest(
             object="document:2021-budget",
             relation="reader",
@@ -1668,88 +1993,108 @@
             user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
         )
         configuration = self.configuration
         configuration.store_id = store_id
         async with OpenFgaClient(configuration) as api_client:
             api_response = await api_client.batch_check(
                 body=[body1, body2, body3],
-                options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
-                         "max_parallel_requests": 2}
+                options={
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                    "max_parallel_requests": 2,
+                },
             )
             self.assertIsInstance(api_response, list)
             self.assertEqual(len(api_response), 3)
             self.assertEqual(api_response[0].error, None)
             self.assertTrue(api_response[0].allowed)
             self.assertEqual(api_response[0].request, body1)
             self.assertEqual(api_response[1].error, None)
             self.assertFalse(api_response[1].allowed)
             self.assertEqual(api_response[1].request, body2)
             self.assertEqual(api_response[2].error, None)
             self.assertTrue(api_response[2].allowed)
             self.assertEqual(api_response[2].request, body3)
             # Make sure the API was called with the right data
             mock_request.assert_any_call(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01GXSA8YR785C4FYS3C0RTG7B1',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01GXSA8YR785C4FYS3C0RTG7B1",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget",
-                                    "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}, "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    },
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget",
-                                    "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c"}, "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c",
+                    },
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget",
-                                    "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d"}, "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                    },
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             await api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_batch_check_multiple_request_fail(self, mock_request):
         """Test case for check with multiple request with one request failed
 
-        Check whether a user is authorized to access an object  # noqa: E501
+        Check whether a user is authorized to access an object
         """
-        response_body = '''
+        response_body = """
 {
   "code": "validation_error",
   "message": "Generic validation error"
 }
-        '''
+        """
 
         # First, mock the response
         mock_request.side_effect = [
-            mock_response('{}', 200),
+            mock_response("{}", 200),
             mock_response('{"allowed": true, "resolution": "1234"}', 200),
             ValidationException(http_resp=http_mock_response(response_body, 400)),
             mock_response('{"allowed": false, "resolution": "1234"}', 200),
         ]
         body1 = ClientCheckRequest(
             object="document:2021-budget",
             relation="reader",
@@ -1766,167 +2111,196 @@
             user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
         )
         configuration = self.configuration
         configuration.store_id = store_id
         async with OpenFgaClient(configuration) as api_client:
             api_response = await api_client.batch_check(
                 body=[body1, body2, body3],
-                options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
-                         "max_parallel_requests": 2}
+                options={
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                    "max_parallel_requests": 2,
+                },
             )
             self.assertIsInstance(api_response, list)
             self.assertEqual(len(api_response), 3)
             self.assertEqual(api_response[0].error, None)
             self.assertTrue(api_response[0].allowed)
             self.assertEqual(api_response[0].request, body1)
             self.assertFalse(api_response[1].allowed)
             self.assertEqual(api_response[1].request, body2)
             self.assertIsInstance(api_response[1].error, ValidationException)
             self.assertIsInstance(
-                api_response[1].error.parsed_exception, ValidationErrorMessageResponse)
+                api_response[1].error.parsed_exception, ValidationErrorMessageResponse
+            )
             self.assertEqual(api_response[2].error, None)
             self.assertFalse(api_response[2].allowed)
             self.assertEqual(api_response[2].request, body3)
             # Make sure the API was called with the right data
             mock_request.assert_any_call(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01GXSA8YR785C4FYS3C0RTG7B1',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01GXSA8YR785C4FYS3C0RTG7B1",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget",
-                                    "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}, "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    },
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget",
-                                    "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c"}, "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c",
+                    },
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget",
-                                    "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d"}, "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                    },
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             await api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_expand(self, mock_request):
         """Test case for expand
 
-        Expand all relationships in userset tree format, and following userset rewrite rules.  Useful to reason about and debug a certain relationship  # noqa: E501
+        Expand all relationships in userset tree format, and following userset rewrite rules.  Useful to reason about and debug a certain relationship
         """
-        response_body = '''{
+        response_body = """{
             "tree": {"root": {"name": "document:budget#reader", "leaf": {"users": {"users": ["user:81684243-9356-4421-8fbf-a4f8d36aa31b"]}}}}}
-            '''
+            """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         async with OpenFgaClient(configuration) as api_client:
             body = ClientExpandRequest(
                 object="document:budget",
                 relation="reader",
             )
             api_response = await api_client.expand(
                 body=body,
-                options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"}
+                options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
             )
             self.assertIsInstance(api_response, ExpandResponse)
             cur_users = Users(users=["user:81684243-9356-4421-8fbf-a4f8d36aa31b"])
             leaf = Leaf(users=cur_users)
             node = Node(name="document:budget#reader", leaf=leaf)
             userTree = UsersetTree(node)
             expected_response = ExpandResponse(userTree)
             self.assertEqual(api_response, expected_response)
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/expand',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/expand",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:budget", "relation": "reader"},
-                      "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {"object": "document:budget", "relation": "reader"},
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             await api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_list_objects(self, mock_request):
         """Test case for list_objects
 
-        List objects  # noqa: E501
+        List objects
         """
-        response_body = '''
+        response_body = """
 {
   "objects": [
     "document:abcd1234"
   ]
 }
-            '''
+            """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         async with OpenFgaClient(configuration) as api_client:
             body = ClientListObjectsRequest(
                 type="document",
                 relation="reader",
                 user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
             )
             # Get all stores
-            api_response = await api_client.list_objects(body, options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"})
+            api_response = await api_client.list_objects(
+                body, options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"}
+            )
             self.assertIsInstance(api_response, ListObjectsResponse)
-            self.assertEqual(api_response.objects, ['document:abcd1234'])
+            self.assertEqual(api_response.objects, ["document:abcd1234"])
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/list-objects',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/list-objects",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={'authorization_model_id': '01GXSA8YR785C4FYS3C0RTG7B1',
-                      'type': 'document', 'relation': 'reader', 'user': 'user:81684243-9356-4421-8fbf-a4f8d36aa31b'},
+                body={
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                    "type": "document",
+                    "relation": "reader",
+                    "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             await api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_list_objects_contextual_tuples(self, mock_request):
         """Test case for list_objects
 
-        List objects  # noqa: E501
+        List objects
         """
-        response_body = '''
+        response_body = """
 {
   "objects": [
     "document:abcd1234"
   ]
 }
-            '''
+            """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         async with OpenFgaClient(configuration) as api_client:
             body = ClientListObjectsRequest(
                 type="document",
                 relation="reader",
@@ -1936,309 +2310,414 @@
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                         relation="writer",
                         object="document:budget",
                     ),
                 ],
             )
             # Get all stores
-            api_response = await api_client.list_objects(body, options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"})
+            api_response = await api_client.list_objects(
+                body, options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"}
+            )
             self.assertIsInstance(api_response, ListObjectsResponse)
-            self.assertEqual(api_response.objects, ['document:abcd1234'])
+            self.assertEqual(api_response.objects, ["document:abcd1234"])
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/list-objects',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/list-objects",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={'authorization_model_id': '01GXSA8YR785C4FYS3C0RTG7B1',
-                      'type': 'document', 'relation': 'reader', 'user': 'user:81684243-9356-4421-8fbf-a4f8d36aa31b',
-                      'contextual_tuples': {'tuple_keys': [{'object': 'document:budget', 'relation': 'writer', 'user': 'user:81684243-9356-4421-8fbf-a4f8d36aa31b'}]}},
+                body={
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                    "type": "document",
+                    "relation": "reader",
+                    "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    "contextual_tuples": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:budget",
+                                "relation": "writer",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                            }
+                        ]
+                    },
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             await api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_list_relations(self, mock_request):
         """Test case for list relations
 
-        Check whether a user is authorized to access an object  # noqa: E501
+        Check whether a user is authorized to access an object
         """
 
         # First, mock the response
         mock_request.side_effect = [
-            mock_response('{}', 200),
+            mock_response("{}", 200),
             mock_response('{"allowed": true, "resolution": "1234"}', 200),
             mock_response('{"allowed": false, "resolution": "1234"}', 200),
             mock_response('{"allowed": true, "resolution": "1234"}', 200),
         ]
         configuration = self.configuration
         configuration.store_id = store_id
         async with OpenFgaClient(configuration) as api_client:
             api_response = await api_client.list_relations(
-                body=ClientListRelationsRequest(user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
-                                                relations=["reader", "owner", "viewer"],
-                                                object="document:2021-budget"),
-                options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"}
+                body=ClientListRelationsRequest(
+                    user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    relations=["reader", "owner", "viewer"],
+                    object="document:2021-budget",
+                ),
+                options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
             )
             self.assertEqual(api_response, ["reader", "viewer"])
 
             # Make sure the API was called with the right data
             mock_request.assert_any_call(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01GXSA8YR785C4FYS3C0RTG7B1',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01GXSA8YR785C4FYS3C0RTG7B1",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget",
-                                    "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}, "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    },
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget",
-                                    "relation": "owner", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}, "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "owner",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    },
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget",
-                                    "relation": "viewer", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}, "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "viewer",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    },
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             await api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_list_relations_unauthorized(self, mock_request):
-        """Test case for list relations with 401 response
-        """
+        """Test case for list relations with 401 response"""
 
         mock_request.side_effect = UnauthorizedException(
-            http_resp=http_mock_response('{}', 401)
+            http_resp=http_mock_response("{}", 401)
         )
         configuration = self.configuration
         configuration.store_id = store_id
         async with OpenFgaClient(configuration) as api_client:
             with self.assertRaises(UnauthorizedException) as api_exception:
                 await api_client.list_relations(
-                    body=ClientListRelationsRequest(user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
-                                                    relations=["reader", "owner", "viewer"],
-                                                    object="document:2021-budget"),
-                    options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"}
+                    body=ClientListRelationsRequest(
+                        user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                        relations=["reader", "owner", "viewer"],
+                        object="document:2021-budget",
+                    ),
+                    options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
                 )
 
             self.assertIsInstance(api_exception.exception, UnauthorizedException)
             mock_request.assert_called()
             self.assertEqual(mock_request.call_count, 1)
 
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01GXSA8YR785C4FYS3C0RTG7B1',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01GXSA8YR785C4FYS3C0RTG7B1",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             await api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_read_assertions(self, mock_request):
-        """Test case for read assertions
-
-        """
-        response_body = '''
+        """Test case for read assertions"""
+        response_body = """
 {
   "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
   "assertions": [
     {
       "tuple_key": {
         "object": "document:2021-budget",
         "relation": "reader",
         "user": "user:anne"
       },
       "expectation": true
     }
   ]
 }
-        '''
+        """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         # Enter a context with an instance of the API client
         async with OpenFgaClient(configuration) as api_client:
             api_response = await api_client.read_assertions(
                 options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"}
             )
-            self.assertEqual(api_response, ReadAssertionsResponse(
-                authorization_model_id="01G5JAVJ41T49E9TT3SKVS7X1J",
-                assertions=[Assertion(
-                    tuple_key=TupleKeyWithoutCondition(object="document:2021-budget", relation="reader",
-                                                       user="user:anne"),
-                    expectation=True,
-                )]
-            ))
+            self.assertEqual(
+                api_response,
+                ReadAssertionsResponse(
+                    authorization_model_id="01G5JAVJ41T49E9TT3SKVS7X1J",
+                    assertions=[
+                        Assertion(
+                            tuple_key=TupleKeyWithoutCondition(
+                                object="document:2021-budget",
+                                relation="reader",
+                                user="user:anne",
+                            ),
+                            expectation=True,
+                        )
+                    ],
+                ),
+            )
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/assertions/01G5JAVJ41T49E9TT3SKVS7X1J',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/assertions/01G5JAVJ41T49E9TT3SKVS7X1J",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_write_assertions(self, mock_request):
         """Test case for write assertions
 
-        Get all stores  # noqa: E501
+        Get all stores
         """
-        mock_request.return_value = mock_response('', 204)
+        mock_request.return_value = mock_response("", 204)
         configuration = self.configuration
         configuration.store_id = store_id
         async with OpenFgaClient(configuration) as api_client:
             await api_client.write_assertions(
-                [ClientAssertion(user="user:anne", relation="reader",
-                                 object="document:2021-budget", expectation=True)],
-                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"}
+                [
+                    ClientAssertion(
+                        user="user:anne",
+                        relation="reader",
+                        object="document:2021-budget",
+                        expectation=True,
+                    )
+                ],
+                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
             )
             mock_request.assert_called_once_with(
-                'PUT',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/assertions/01G5JAVJ41T49E9TT3SKVS7X1J',
+                "PUT",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/assertions/01G5JAVJ41T49E9TT3SKVS7X1J",
                 headers=ANY,
-                body={"assertions": [{"tuple_key": {"object": "document:2021-budget",
-                                                    "relation": "reader", "user": "user:anne"}, "expectation": True}]},
+                body={
+                    "assertions": [
+                        {
+                            "tuple_key": {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:anne",
+                            },
+                            "expectation": True,
+                        }
+                    ]
+                },
                 query_params=[],
                 post_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_set_store_id(self, mock_request):
         """Test case for write assertions
 
-        Get all stores  # noqa: E501
+        Get all stores
         """
-        mock_request.return_value = mock_response('', 204)
+        mock_request.return_value = mock_response("", 204)
         configuration = self.configuration
         configuration.store_id = store_id
         async with OpenFgaClient(configuration) as api_client:
             api_client.set_store_id("01YCP46JKYM8FJCQ37NMBYHE5Y")
 
             await api_client.write_assertions(
-                [ClientAssertion(user="user:anne", relation="reader",
-                                 object="document:2021-budget", expectation=True)],
-                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"}
+                [
+                    ClientAssertion(
+                        user="user:anne",
+                        relation="reader",
+                        object="document:2021-budget",
+                        expectation=True,
+                    )
+                ],
+                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
             )
             self.assertEqual(api_client.get_store_id(), "01YCP46JKYM8FJCQ37NMBYHE5Y")
             mock_request.assert_called_once_with(
-                'PUT',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5Y/assertions/01G5JAVJ41T49E9TT3SKVS7X1J',
+                "PUT",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5Y/assertions/01G5JAVJ41T49E9TT3SKVS7X1J",
                 headers=ANY,
-                body={"assertions": [{"tuple_key": {"object": "document:2021-budget",
-                                                    "relation": "reader", "user": "user:anne"}, "expectation": True}]},
+                body={
+                    "assertions": [
+                        {
+                            "tuple_key": {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:anne",
+                            },
+                            "expectation": True,
+                        }
+                    ]
+                },
                 query_params=[],
                 post_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_config_auth_model(self, mock_request):
         """Test case for write assertions
 
-        Get all stores  # noqa: E501
+        Get all stores
         """
-        mock_request.return_value = mock_response('', 204)
+        mock_request.return_value = mock_response("", 204)
         configuration = self.configuration
         configuration.store_id = store_id
         configuration.authorization_model_id = "01G5JAVJ41T49E9TT3SKVS7X1J"
         async with OpenFgaClient(configuration) as api_client:
             await api_client.write_assertions(
-                [ClientAssertion(user="user:anne", relation="reader",
-                                 object="document:2021-budget", expectation=True)],
-                options={}
+                [
+                    ClientAssertion(
+                        user="user:anne",
+                        relation="reader",
+                        object="document:2021-budget",
+                        expectation=True,
+                    )
+                ],
+                options={},
+            )
+            self.assertEqual(
+                api_client.get_authorization_model_id(), "01G5JAVJ41T49E9TT3SKVS7X1J"
             )
-            self.assertEqual(api_client.get_authorization_model_id(), "01G5JAVJ41T49E9TT3SKVS7X1J")
             mock_request.assert_called_once_with(
-                'PUT',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/assertions/01G5JAVJ41T49E9TT3SKVS7X1J',
+                "PUT",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/assertions/01G5JAVJ41T49E9TT3SKVS7X1J",
                 headers=ANY,
-                body={"assertions": [{"tuple_key": {"object": "document:2021-budget",
-                                                    "relation": "reader", "user": "user:anne"}, "expectation": True}]},
+                body={
+                    "assertions": [
+                        {
+                            "tuple_key": {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:anne",
+                            },
+                            "expectation": True,
+                        }
+                    ]
+                },
                 query_params=[],
                 post_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_update_auth_model(self, mock_request):
         """Test case for write assertions
 
-        Get all stores  # noqa: E501
+        Get all stores
         """
-        mock_request.return_value = mock_response('', 204)
+        mock_request.return_value = mock_response("", 204)
         configuration = self.configuration
         configuration.store_id = store_id
         configuration.authorization_model_id = "01G5JAVJ41T49E9TT3SKVS7X1J"
         async with OpenFgaClient(configuration) as api_client:
             api_client.set_authorization_model_id("01G5JAVJ41T49E9TT3SKVS7X2J")
 
             await api_client.write_assertions(
-                [ClientAssertion(user="user:anne", relation="reader",
-                                 object="document:2021-budget", expectation=True)],
-                options={}
+                [
+                    ClientAssertion(
+                        user="user:anne",
+                        relation="reader",
+                        object="document:2021-budget",
+                        expectation=True,
+                    )
+                ],
+                options={},
             )
             mock_request.assert_called_once_with(
-                'PUT',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/assertions/01G5JAVJ41T49E9TT3SKVS7X2J',
+                "PUT",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/assertions/01G5JAVJ41T49E9TT3SKVS7X2J",
                 headers=ANY,
-                body={"assertions": [{"tuple_key": {"object": "document:2021-budget",
-                                                    "relation": "reader", "user": "user:anne"}, "expectation": True}]},
+                body={
+                    "assertions": [
+                        {
+                            "tuple_key": {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:anne",
+                            },
+                            "expectation": True,
+                        }
+                    ]
+                },
                 query_params=[],
                 post_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
     def test_configuration_store_id_invalid(self):
         """
         Test whether ApiValueError is raised if host has query
         """
         configuration = ClientConfiguration(
-            api_host='localhost',
-            api_scheme='http',
-            store_id="abcd"
+            api_host="localhost", api_scheme="http", store_id="abcd"
         )
         self.assertRaises(FgaValidationException, configuration.is_valid)
 
     def test_configuration_authorization_model_id_invalid(self):
         """
         Test whether ApiValueError is raised if host has query
         """
         configuration = ClientConfiguration(
-            api_host='localhost',
-            api_scheme='http',
+            api_host="localhost",
+            api_scheme="http",
             store_id="01H15K9J85050XTEDPVM8DJM78",
-            authorization_model_id="abcd"
+            authorization_model_id="abcd",
         )
         self.assertRaises(FgaValidationException, configuration.is_valid)
```

### Comparing `openfga-sdk-0.4.1/test/test_client_sync.py` & `openfga-sdk-0.4.2/test/test_client_sync.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,117 +1,123 @@
-# coding: utf-8
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
-from unittest.mock import ANY
-from unittest import IsolatedAsyncioTestCase
-from mock import patch
 from datetime import datetime
+from unittest import IsolatedAsyncioTestCase
+from unittest.mock import ANY, patch
 
 import urllib3
 
-from openfga_sdk.sync.client.client import OpenFgaClient
-from openfga_sdk.sync import rest
 from openfga_sdk.client import ClientConfiguration
 from openfga_sdk.client.models.assertion import ClientAssertion
 from openfga_sdk.client.models.check_request import ClientCheckRequest
-from openfga_sdk.client.models.tuple import ClientTuple
-from openfga_sdk.client.models.write_request import ClientWriteRequest
 from openfga_sdk.client.models.expand_request import ClientExpandRequest
 from openfga_sdk.client.models.list_objects_request import ClientListObjectsRequest
 from openfga_sdk.client.models.list_relations_request import ClientListRelationsRequest
 from openfga_sdk.client.models.read_changes_request import ClientReadChangesRequest
+from openfga_sdk.client.models.tuple import ClientTuple
+from openfga_sdk.client.models.write_request import ClientWriteRequest
 from openfga_sdk.client.models.write_single_response import ClientWriteSingleResponse
 from openfga_sdk.client.models.write_transaction_opts import WriteTransactionOpts
-from openfga_sdk.exceptions import ValidationException, FgaValidationException, UnauthorizedException
+from openfga_sdk.exceptions import (
+    FgaValidationException,
+    UnauthorizedException,
+    ValidationException,
+)
 from openfga_sdk.models.assertion import Assertion
 from openfga_sdk.models.authorization_model import AuthorizationModel
 from openfga_sdk.models.check_response import CheckResponse
 from openfga_sdk.models.create_store_request import CreateStoreRequest
 from openfga_sdk.models.create_store_response import CreateStoreResponse
 from openfga_sdk.models.expand_response import ExpandResponse
 from openfga_sdk.models.get_store_response import GetStoreResponse
 from openfga_sdk.models.leaf import Leaf
 from openfga_sdk.models.list_objects_response import ListObjectsResponse
 from openfga_sdk.models.list_stores_response import ListStoresResponse
 from openfga_sdk.models.node import Node
 from openfga_sdk.models.object_relation import ObjectRelation
 from openfga_sdk.models.read_assertions_response import ReadAssertionsResponse
-from openfga_sdk.models.read_authorization_model_response import ReadAuthorizationModelResponse
-from openfga_sdk.models.read_authorization_models_response import ReadAuthorizationModelsResponse
+from openfga_sdk.models.read_authorization_model_response import (
+    ReadAuthorizationModelResponse,
+)
+from openfga_sdk.models.read_authorization_models_response import (
+    ReadAuthorizationModelsResponse,
+)
 from openfga_sdk.models.read_changes_response import ReadChangesResponse
 from openfga_sdk.models.read_request_tuple_key import ReadRequestTupleKey
 from openfga_sdk.models.read_response import ReadResponse
 from openfga_sdk.models.store import Store
 from openfga_sdk.models.tuple import Tuple
 from openfga_sdk.models.tuple_change import TupleChange
 from openfga_sdk.models.tuple_key import TupleKey
 from openfga_sdk.models.tuple_key_without_condition import TupleKeyWithoutCondition
 from openfga_sdk.models.tuple_operation import TupleOperation
 from openfga_sdk.models.type_definition import TypeDefinition
 from openfga_sdk.models.users import Users
 from openfga_sdk.models.userset import Userset
-from openfga_sdk.models.usersets import Usersets
 from openfga_sdk.models.userset_tree import UsersetTree
-from openfga_sdk.models.validation_error_message_response import ValidationErrorMessageResponse
-from openfga_sdk.models.write_authorization_model_request import WriteAuthorizationModelRequest
-from openfga_sdk.models.write_authorization_model_response import WriteAuthorizationModelResponse
+from openfga_sdk.models.usersets import Usersets
+from openfga_sdk.models.validation_error_message_response import (
+    ValidationErrorMessageResponse,
+)
+from openfga_sdk.models.write_authorization_model_request import (
+    WriteAuthorizationModelRequest,
+)
+from openfga_sdk.models.write_authorization_model_response import (
+    WriteAuthorizationModelResponse,
+)
+from openfga_sdk.sync import rest
+from openfga_sdk.sync.client.client import OpenFgaClient
 
+store_id = "01YCP46JKYM8FJCQ37NMBYHE5X"
+request_id = "x1y2z3"
 
-store_id = '01YCP46JKYM8FJCQ37NMBYHE5X'
-request_id = 'x1y2z3'
 
 # Helper function to construct mock response
-
-
 def http_mock_response(body, status):
-    headers = urllib3.response.HTTPHeaderDict({
-        'content-type': 'application/json',
-        'Fga-Request-Id': request_id
-    })
+    headers = urllib3.response.HTTPHeaderDict(
+        {"content-type": "application/json", "Fga-Request-Id": request_id}
+    )
     return urllib3.HTTPResponse(
-        body.encode('utf-8'),
-        headers,
-        status,
-        preload_content=False
+        body.encode("utf-8"), headers, status, preload_content=False
     )
 
 
 def mock_response(body, status):
     obj = http_mock_response(body, status)
     return rest.RESTResponse(obj, obj.data)
 
 
 class TestOpenFgaClient(IsolatedAsyncioTestCase):
     """Test for OpenFGA Client"""
 
     def setUp(self):
         self.configuration = ClientConfiguration(
-            api_url='http://api.fga.example',
+            api_url="http://api.fga.example",
         )
 
     def tearDown(self):
         pass
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_list_stores(self, mock_request):
         """Test case for list_stores
 
-        Get all stores  # noqa: E501
+        Get all stores
         """
-        response_body = '''
+        response_body = """
 {
   "stores": [
     {
       "id": "01YCP46JKYM8FJCQ37NMBYHE5X",
       "name": "store1",
       "created_at": "2022-07-25T21:15:37.524Z",
       "updated_at": "2022-07-25T21:15:37.524Z",
@@ -123,24 +129,29 @@
       "created_at": "2022-07-25T21:15:37.524Z",
       "updated_at": "2022-07-25T21:15:37.524Z",
       "deleted_at": "2022-07-25T21:15:37.524Z"
     }
   ],
   "continuation_token": "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ=="
 }
-            '''
+            """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         with OpenFgaClient(configuration) as api_client:
             api_response = api_client.list_stores(
-                options={"page_size": 1, "continuation_token": "continuation_token_example"}
+                options={
+                    "page_size": 1,
+                    "continuation_token": "continuation_token_example",
+                }
             )
             self.assertIsInstance(api_response, ListStoresResponse)
-            self.assertEqual(api_response.continuation_token,
-                             "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==")
+            self.assertEqual(
+                api_response.continuation_token,
+                "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==",
+            )
             store1 = Store(
                 id="01YCP46JKYM8FJCQ37NMBYHE5X",
                 name="store1",
                 created_at=datetime.fromisoformat("2022-07-25T21:15:37.524+00:00"),
                 updated_at=datetime.fromisoformat("2022-07-25T21:15:37.524+00:00"),
                 deleted_at=datetime.fromisoformat("2022-07-25T21:15:37.524+00:00"),
             )
@@ -151,122 +162,119 @@
                 updated_at=datetime.fromisoformat("2022-07-25T21:15:37.524+00:00"),
                 deleted_at=datetime.fromisoformat("2022-07-25T21:15:37.524+00:00"),
             )
 
             stores = [store1, store2]
             self.assertEqual(api_response.stores, stores)
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores',
+                "GET",
+                "http://api.fga.example/stores",
                 headers=ANY,
-                query_params=[('page_size', 1), ('continuation_token',
-                                                 'continuation_token_example')],
+                query_params=[
+                    ("page_size", 1),
+                    ("continuation_token", "continuation_token_example"),
+                ],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_create_store(self, mock_request):
         """Test case for create_store
 
-        Create a store  # noqa: E501
+        Create a store
         """
-        response_body = '''{
+        response_body = """{
             "id": "01YCP46JKYM8FJCQ37NMBYHE5X",
             "name": "test_store",
             "created_at": "2022-07-25T17:41:26.607Z",
             "updated_at": "2022-07-25T17:41:26.607Z"}
-            '''
+            """
         mock_request.return_value = mock_response(response_body, 201)
         configuration = self.configuration
         with OpenFgaClient(configuration) as api_client:
             api_response = api_client.create_store(
-                CreateStoreRequest(name="test-store"),
-                options={}
+                CreateStoreRequest(name="test-store"), options={}
             )
             self.assertIsInstance(api_response, CreateStoreResponse)
-            self.assertEqual(api_response.id, '01YCP46JKYM8FJCQ37NMBYHE5X')
+            self.assertEqual(api_response.id, "01YCP46JKYM8FJCQ37NMBYHE5X")
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores',
+                "POST",
+                "http://api.fga.example/stores",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
                 body={"name": "test-store"},
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_get_store(self, mock_request):
         """Test case for get_store
 
-        Get all stores  # noqa: E501
+        Get all stores
         """
-        response_body = '''
+        response_body = """
 {
     "id": "01YCP46JKYM8FJCQ37NMBYHE5X",
     "name": "store1",
     "created_at": "2022-07-25T21:15:37.524Z",
     "updated_at": "2022-07-25T21:15:37.524Z"
 }
-            '''
+            """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         with OpenFgaClient(configuration) as api_client:
-            api_response = api_client.get_store(
-                options={}
-            )
+            api_response = api_client.get_store(options={})
             self.assertIsInstance(api_response, GetStoreResponse)
             self.assertEqual(api_response.id, "01YCP46JKYM8FJCQ37NMBYHE5X")
             self.assertEqual(api_response.name, "store1")
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_delete_store(self, mock_request):
         """Test case for delete_store
 
-        Get all stores  # noqa: E501
+        Get all stores
         """
-        mock_request.return_value = mock_response('', 201)
+        mock_request.return_value = mock_response("", 201)
         configuration = self.configuration
         configuration.store_id = store_id
         with OpenFgaClient(configuration) as api_client:
-            api_client.delete_store(
-                options={}
-            )
+            api_client.delete_store(options={})
             mock_request.assert_called_once_with(
-                'DELETE',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X',
+                "DELETE",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X",
                 headers=ANY,
                 query_params=[],
                 body=None,
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_read_authorization_models(self, mock_request):
         """Test case for read_authorization_models
 
-        Return all authorization models configured for the store  # noqa: E501
+        Return all authorization models configured for the store
         """
-        response_body = '''
+        response_body = """
 {
   "authorization_models": [{
     "id": "01G5JAVJ41T49E9TT3SKVS7X1J",
     "schema_version":"1.1",
     "type_definitions": [
       {
         "type": "document",
@@ -291,66 +299,71 @@
           }
         }
       }
     ]
   }],
   "continuation_token": "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ=="
 }
-        '''
+        """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         # Enter a context with an instance of the API client
         with OpenFgaClient(configuration) as api_client:
 
             # Return a particular version of an authorization model
-            api_response = api_client.read_authorization_models(
-                options={}
-            )
+            api_response = api_client.read_authorization_models(options={})
             self.assertIsInstance(api_response, ReadAuthorizationModelsResponse)
             type_definitions = [
                 TypeDefinition(
                     type="document",
                     relations=dict(
                         reader=Userset(
                             union=Usersets(
                                 child=[
                                     Userset(this=dict()),
-                                    Userset(computed_userset=ObjectRelation(
-                                        object="",
-                                        relation="writer",
-                                    )),
+                                    Userset(
+                                        computed_userset=ObjectRelation(
+                                            object="",
+                                            relation="writer",
+                                        )
+                                    ),
                                 ],
                             ),
                         ),
                         writer=Userset(
                             this=dict(),
                         ),
-                    )
+                    ),
                 )
             ]
-            authorization_model = AuthorizationModel(id='01G5JAVJ41T49E9TT3SKVS7X1J', schema_version="1.1",
-                                                     type_definitions=type_definitions)
+            authorization_model = AuthorizationModel(
+                id="01G5JAVJ41T49E9TT3SKVS7X1J",
+                schema_version="1.1",
+                type_definitions=type_definitions,
+            )
             self.assertEqual(api_response.authorization_models, [authorization_model])
-            self.assertEqual(api_response.continuation_token,
-                             "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==")
+            self.assertEqual(
+                api_response.continuation_token,
+                "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==",
+            )
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_write_authorization_model(self, mock_request):
         """Test case for write_authorization_model
 
-        Create a new authorization model  # noqa: E501
+        Create a new authorization model
         """
         response_body = '{"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"}'
         mock_request.return_value = mock_response(response_body, 201)
         configuration = self.configuration
         configuration.store_id = store_id
         with OpenFgaClient(configuration) as api_client:
             # example passing only required values which don't have defaults set
@@ -363,54 +376,75 @@
                             writer=Userset(
                                 this=dict(),
                             ),
                             reader=Userset(
                                 union=Usersets(
                                     child=[
                                         Userset(this=dict()),
-                                        Userset(computed_userset=ObjectRelation(
-                                            object="",
-                                            relation="writer",
-                                        )),
+                                        Userset(
+                                            computed_userset=ObjectRelation(
+                                                object="",
+                                                relation="writer",
+                                            )
+                                        ),
                                     ],
                                 ),
                             ),
-                        )
+                        ),
                     ),
                 ],
             )
             # Create a new authorization model
-            api_response = api_client.write_authorization_model(
-                body,
-                options={}
-            )
+            api_response = api_client.write_authorization_model(body, options={})
             self.assertIsInstance(api_response, WriteAuthorizationModelResponse)
             expected_response = WriteAuthorizationModelResponse(
-                authorization_model_id='01G5JAVJ41T49E9TT3SKVS7X1J'
+                authorization_model_id="01G5JAVJ41T49E9TT3SKVS7X1J"
             )
             self.assertEqual(api_response, expected_response)
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"schema_version": "1.1", "type_definitions": [{"type": "document", "relations": {"writer": {"this": {
-                }}, "reader": {"union": {"child": [{"this": {}}, {"computedUserset": {"object": "", "relation": "writer"}}]}}}}]},
+                body={
+                    "schema_version": "1.1",
+                    "type_definitions": [
+                        {
+                            "type": "document",
+                            "relations": {
+                                "writer": {"this": {}},
+                                "reader": {
+                                    "union": {
+                                        "child": [
+                                            {"this": {}},
+                                            {
+                                                "computedUserset": {
+                                                    "object": "",
+                                                    "relation": "writer",
+                                                }
+                                            },
+                                        ]
+                                    }
+                                },
+                            },
+                        }
+                    ],
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_read_authorization_model(self, mock_request):
         """Test case for read_authorization_model
 
-        Return a particular version of an authorization model  # noqa: E501
+        Return a particular version of an authorization model
         """
-        response_body = '''
+        response_body = """
 {
   "authorization_model": {
     "id": "01G5JAVJ41T49E9TT3SKVS7X1J",
     "schema_version":"1.1",
     "type_definitions": [
       {
         "type": "document",
@@ -434,15 +468,15 @@
             "this": {}
           }
         }
       }
     ]
   }
 }
-        '''
+        """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         # Enter a context with an instance of the API client
         with OpenFgaClient(configuration) as api_client:
 
             # Return a particular version of an authorization model
@@ -454,46 +488,51 @@
                 TypeDefinition(
                     type="document",
                     relations=dict(
                         reader=Userset(
                             union=Usersets(
                                 child=[
                                     Userset(this=dict()),
-                                    Userset(computed_userset=ObjectRelation(
-                                        object="",
-                                        relation="writer",
-                                    )),
+                                    Userset(
+                                        computed_userset=ObjectRelation(
+                                            object="",
+                                            relation="writer",
+                                        )
+                                    ),
                                 ],
                             ),
                         ),
                         writer=Userset(
                             this=dict(),
                         ),
-                    )
+                    ),
                 )
             ]
-            authorization_model = AuthorizationModel(id='01G5JAVJ41T49E9TT3SKVS7X1J', schema_version="1.1",
-                                                     type_definitions=type_definitions)
+            authorization_model = AuthorizationModel(
+                id="01G5JAVJ41T49E9TT3SKVS7X1J",
+                schema_version="1.1",
+                type_definitions=type_definitions,
+            )
             self.assertEqual(api_response.authorization_model, authorization_model)
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_read_latest_authorization_model(self, mock_request):
         """Test case for read_latest_authorization_model
 
-        Return the latest authorization models configured for the store  # noqa: E501
+        Return the latest authorization models configured for the store
         """
-        response_body = '''
+        response_body = """
 {
   "authorization_models": [{
     "id": "01G5JAVJ41T49E9TT3SKVS7X1J",
     "schema_version":"1.1",
     "type_definitions": [
       {
         "type": "document",
@@ -518,278 +557,309 @@
           }
         }
       }
     ]
   }],
   "continuation_token": "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ=="
 }
-        '''
+        """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         # Enter a context with an instance of the API client
         with OpenFgaClient(configuration) as api_client:
 
             # Return a particular version of an authorization model
-            api_response = api_client.read_latest_authorization_model(
-                options={}
-            )
+            api_response = api_client.read_latest_authorization_model(options={})
             self.assertIsInstance(api_response, ReadAuthorizationModelResponse)
             type_definitions = [
                 TypeDefinition(
                     type="document",
                     relations=dict(
                         reader=Userset(
                             union=Usersets(
                                 child=[
                                     Userset(this=dict()),
-                                    Userset(computed_userset=ObjectRelation(
-                                        object="",
-                                        relation="writer",
-                                    )),
+                                    Userset(
+                                        computed_userset=ObjectRelation(
+                                            object="",
+                                            relation="writer",
+                                        )
+                                    ),
                                 ],
                             ),
                         ),
                         writer=Userset(
                             this=dict(),
                         ),
-                    )
+                    ),
                 )
             ]
-            authorization_model = AuthorizationModel(id='01G5JAVJ41T49E9TT3SKVS7X1J', schema_version="1.1",
-                                                     type_definitions=type_definitions)
+            authorization_model = AuthorizationModel(
+                id="01G5JAVJ41T49E9TT3SKVS7X1J",
+                schema_version="1.1",
+                type_definitions=type_definitions,
+            )
             self.assertEqual(api_response.authorization_model, authorization_model)
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models",
                 headers=ANY,
-                query_params=[('page_size', 1)],
+                query_params=[("page_size", 1)],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_read_changes(self, mock_request):
         """Test case for read_changes
 
-        Return a list of all the tuple changes  # noqa: E501
+        Return a list of all the tuple changes
         """
-        response_body = '''
+        response_body = """
 {
   "changes": [
     {
       "tuple_key": {
         "object": "document:2021-budget",
         "relation": "reader",
         "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"
       },
       "operation": "TUPLE_OPERATION_WRITE",
       "timestamp": "2022-07-26T15:55:55.809Z"
     }
   ],
   "continuation_token": "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ=="
 }
-        '''
+        """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         # Enter a context with an instance of the API client
         with OpenFgaClient(configuration) as api_client:
 
             # Return a particular version of an authorization model
             api_response = api_client.read_changes(
                 ClientReadChangesRequest("document"),
-                options={"page_size": 1, "continuation_token": "abcdefg"}
+                options={"page_size": 1, "continuation_token": "abcdefg"},
             )
 
             self.assertIsInstance(api_response, ReadChangesResponse)
             changes = TupleChange(
-                tuple_key=TupleKey(object="document:2021-budget", relation="reader",
-                                   user="user:81684243-9356-4421-8fbf-a4f8d36aa31b"),
+                tuple_key=TupleKey(
+                    object="document:2021-budget",
+                    relation="reader",
+                    user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                ),
                 operation=TupleOperation.WRITE,
-                timestamp=datetime.fromisoformat("2022-07-26T15:55:55.809+00:00"))
+                timestamp=datetime.fromisoformat("2022-07-26T15:55:55.809+00:00"),
+            )
             read_changes = ReadChangesResponse(
-                continuation_token='eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==',
-                changes=[changes])
+                continuation_token="eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==",
+                changes=[changes],
+            )
             self.assertEqual(api_response, read_changes)
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/changes',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/changes",
                 headers=ANY,
-                query_params=[('type', 'document'), ('page_size', 1),
-                              ('continuation_token', 'abcdefg')],
+                query_params=[
+                    ("type", "document"),
+                    ("page_size", 1),
+                    ("continuation_token", "abcdefg"),
+                ],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_read(self, mock_request):
         """Test case for read
 
-        Get tuples from the store that matches a query, without following userset rewrite rules  # noqa: E501
+        Get tuples from the store that matches a query, without following userset rewrite rules
         """
-        response_body = '''
+        response_body = """
             {
   "tuples": [
     {
       "key": {
         "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
         "relation": "reader",
         "object": "document:2021-budget"
       },
       "timestamp": "2021-10-06T15:32:11.128Z"
     }
   ],
   "continuation_token": ""
 }
-        '''
+        """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         # Enter a context with an instance of the API client
         with OpenFgaClient(configuration) as api_client:
             body = ReadRequestTupleKey(
                 object="document:2021-budget",
                 relation="reader",
                 user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
             )
             api_response = api_client.read(
                 body=body,
-                options={"page_size": 50, "continuation_token":
-                         "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ=="}
+                options={
+                    "page_size": 50,
+                    "continuation_token": "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==",
+                },
             )
             self.assertIsInstance(api_response, ReadResponse)
-            key = TupleKey(user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
-                           relation="reader", object="document:2021-budget")
+            key = TupleKey(
+                user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                relation="reader",
+                object="document:2021-budget",
+            )
             timestamp = datetime.fromisoformat("2021-10-06T15:32:11.128+00:00")
             expected_data = ReadResponse(
-                tuples=[Tuple(key=key, timestamp=timestamp)], continuation_token='')
+                tuples=[Tuple(key=key, timestamp=timestamp)], continuation_token=""
+            )
             self.assertEqual(api_response, expected_data)
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/read',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/read",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget", "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"},
-                      "page_size": 50, "continuation_token": "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ=="},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    },
+                    "page_size": 50,
+                    "continuation_token": "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_read_empty_options(self, mock_request):
         """Test case for read with empty options
 
-        Get tuples from the store that matches a query, without following userset rewrite rules  # noqa: E501
+        Get tuples from the store that matches a query, without following userset rewrite rules
         """
-        response_body = '''
+        response_body = """
             {
   "tuples": [
     {
       "key": {
         "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
         "relation": "reader",
         "object": "document:2021-budget"
       },
       "timestamp": "2021-10-06T15:32:11.128Z"
     }
   ],
   "continuation_token": ""
 }
-        '''
+        """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         # Enter a context with an instance of the API client
         with OpenFgaClient(configuration) as api_client:
             body = ReadRequestTupleKey(
                 object="document:2021-budget",
                 relation="reader",
                 user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
             )
-            api_response = api_client.read(
-                body=body,
-                options={}
-            )
+            api_response = api_client.read(body=body, options={})
             self.assertIsInstance(api_response, ReadResponse)
-            key = TupleKey(user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
-                           relation="reader", object="document:2021-budget")
+            key = TupleKey(
+                user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                relation="reader",
+                object="document:2021-budget",
+            )
             timestamp = datetime.fromisoformat("2021-10-06T15:32:11.128+00:00")
             expected_data = ReadResponse(
-                tuples=[Tuple(key=key, timestamp=timestamp)], continuation_token='')
+                tuples=[Tuple(key=key, timestamp=timestamp)], continuation_token=""
+            )
             self.assertEqual(api_response, expected_data)
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/read',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/read",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget", "relation": "reader",
-                                    "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    }
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_read_empty_body(self, mock_request):
         """Test case for read with empty body
 
-        Get tuples from the store that matches a query, without following userset rewrite rules  # noqa: E501
+        Get tuples from the store that matches a query, without following userset rewrite rules
         """
-        response_body = '''
+        response_body = """
             {
   "tuples": [
     {
       "key": {
         "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
         "relation": "reader",
         "object": "document:2021-budget"
       },
       "timestamp": "2021-10-06T15:32:11.128Z"
     }
   ],
   "continuation_token": ""
 }
-        '''
+        """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         # Enter a context with an instance of the API client
         with OpenFgaClient(configuration) as api_client:
             body = ReadRequestTupleKey()
-            api_response = api_client.read(
-                body=body,
-                options={}
-            )
+            api_response = api_client.read(body=body, options={})
             self.assertIsInstance(api_response, ReadResponse)
-            key = TupleKey(user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
-                           relation="reader", object="document:2021-budget")
+            key = TupleKey(
+                user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                relation="reader",
+                object="document:2021-budget",
+            )
             timestamp = datetime.fromisoformat("2021-10-06T15:32:11.128+00:00")
             expected_data = ReadResponse(
-                tuples=[Tuple(key=key, timestamp=timestamp)], continuation_token='')
+                tuples=[Tuple(key=key, timestamp=timestamp)], continuation_token=""
+            )
             self.assertEqual(api_response, expected_data)
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/read',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/read",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
                 body={},
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_write(self, mock_request):
         """Test case for write
 
         Add tuples from the store with transaction enabled
         """
-        response_body = '{}'
+        response_body = "{}"
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         with OpenFgaClient(configuration) as api_client:
 
             body = ClientWriteRequest(
                 writes=[
@@ -803,40 +873,59 @@
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
                     ),
                     ClientTuple(
                         object="document:2021-budget",
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
-                    )
+                    ),
                 ],
             )
             api_client.write(
-                body,
-                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"}
+                body, options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"}
             )
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}, {"object": "document:2021-budget", "relation": "reader",
-                                                                                                                                                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c"}, {"object": "document:2021-budget", "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                            },
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c",
+                            },
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                            },
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_delete(self, mock_request):
         """Test case for delete
 
         Delete tuples from the store with transaction enabled
         """
-        response_body = '{}'
+        response_body = "{}"
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         with OpenFgaClient(configuration) as api_client:
 
             body = ClientWriteRequest(
                 deletes=[
@@ -844,40 +933,49 @@
                         object="document:2021-budget",
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                     )
                 ],
             )
             api_client.write(
-                body,
-                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"}
+                body, options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"}
             )
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"deletes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                  "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "deletes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_write_batch(self, mock_request):
         """Test case for write
 
         Add tuples from the store with transaction disabled
         """
         mock_request.side_effect = [
-            mock_response('{}', 200),
-            mock_response('{}', 200),
-            mock_response('{}', 200),
-            mock_response('{}', 200),
+            mock_response("{}", 200),
+            mock_response("{}", 200),
+            mock_response("{}", 200),
+            mock_response("{}", 200),
         ]
         configuration = self.configuration
         configuration.store_id = store_id
         with OpenFgaClient(configuration) as api_client:
 
             body = ClientWriteRequest(
                 writes=[
@@ -891,108 +989,145 @@
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
                     ),
                     ClientTuple(
                         object="document:2021-budget",
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
-                    )
+                    ),
                 ],
             )
             transaction = WriteTransactionOpts(
-                disabled=True, max_per_chunk=1, max_parallel_requests=10)
+                disabled=True, max_per_chunk=1, max_parallel_requests=10
+            )
             response = api_client.write(
                 body,
-                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
-                         "transaction": transaction}
+                options={
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                    "transaction": transaction,
+                },
             )
 
             self.assertEqual(response.deletes, None)
-            self.assertEqual(response.writes,
-                             [
-                                 ClientWriteSingleResponse(
-                                     tuple_key=ClientTuple(
-                                         object="document:2021-budget",
-                                         relation="reader",
-                                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
-                                     ),
-                                     success=True,
-                                     error=None),
-                                 ClientWriteSingleResponse(
-                                     tuple_key=ClientTuple(
-                                         object="document:2021-budget",
-                                         relation="reader",
-                                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
-                                     ),
-                                     success=True,
-                                     error=None),
-                                 ClientWriteSingleResponse(
-                                     tuple_key=ClientTuple(
-                                         object="document:2021-budget",
-                                         relation="reader",
-                                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
-                                     ),
-                                     success=True,
-                                     error=None)
-                             ]
-                             )
+            self.assertEqual(
+                response.writes,
+                [
+                    ClientWriteSingleResponse(
+                        tuple_key=ClientTuple(
+                            object="document:2021-budget",
+                            relation="reader",
+                            user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                        ),
+                        success=True,
+                        error=None,
+                    ),
+                    ClientWriteSingleResponse(
+                        tuple_key=ClientTuple(
+                            object="document:2021-budget",
+                            relation="reader",
+                            user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
+                        ),
+                        success=True,
+                        error=None,
+                    ),
+                    ClientWriteSingleResponse(
+                        tuple_key=ClientTuple(
+                            object="document:2021-budget",
+                            relation="reader",
+                            user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                        ),
+                        success=True,
+                        error=None,
+                    ),
+                ],
+            )
             self.assertEqual(mock_request.call_count, 4)
             mock_request.assert_any_call(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                 "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                 "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                 "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_write_batch_min_parallel(self, mock_request):
         """Test case for write
 
         Add tuples from the store with transaction disabled and minimum parallel request
         """
         mock_request.side_effect = [
-            mock_response('{}', 200),
-            mock_response('{}', 200),
-            mock_response('{}', 200),
-            mock_response('{}', 200),
+            mock_response("{}", 200),
+            mock_response("{}", 200),
+            mock_response("{}", 200),
+            mock_response("{}", 200),
         ]
         configuration = self.configuration
         configuration.store_id = store_id
         with OpenFgaClient(configuration) as api_client:
 
             body = ClientWriteRequest(
                 writes=[
@@ -1006,107 +1141,144 @@
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
                     ),
                     ClientTuple(
                         object="document:2021-budget",
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
-                    )
+                    ),
                 ],
             )
             transaction = WriteTransactionOpts(
-                disabled=True, max_per_chunk=1, max_parallel_requests=1)
+                disabled=True, max_per_chunk=1, max_parallel_requests=1
+            )
             response = api_client.write(
                 body,
-                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
-                         "transaction": transaction}
+                options={
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                    "transaction": transaction,
+                },
             )
 
             self.assertEqual(response.deletes, None)
-            self.assertEqual(response.writes,
-                             [
-                                 ClientWriteSingleResponse(
-                                     tuple_key=ClientTuple(
-                                         object="document:2021-budget",
-                                         relation="reader",
-                                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
-                                     ),
-                                     success=True,
-                                     error=None),
-                                 ClientWriteSingleResponse(
-                                     tuple_key=ClientTuple(
-                                         object="document:2021-budget",
-                                         relation="reader",
-                                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
-                                     ),
-                                     success=True,
-                                     error=None),
-                                 ClientWriteSingleResponse(
-                                     tuple_key=ClientTuple(
-                                         object="document:2021-budget",
-                                         relation="reader",
-                                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
-                                     ),
-                                     success=True,
-                                     error=None)
-                             ]
-                             )
+            self.assertEqual(
+                response.writes,
+                [
+                    ClientWriteSingleResponse(
+                        tuple_key=ClientTuple(
+                            object="document:2021-budget",
+                            relation="reader",
+                            user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                        ),
+                        success=True,
+                        error=None,
+                    ),
+                    ClientWriteSingleResponse(
+                        tuple_key=ClientTuple(
+                            object="document:2021-budget",
+                            relation="reader",
+                            user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
+                        ),
+                        success=True,
+                        error=None,
+                    ),
+                    ClientWriteSingleResponse(
+                        tuple_key=ClientTuple(
+                            object="document:2021-budget",
+                            relation="reader",
+                            user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                        ),
+                        success=True,
+                        error=None,
+                    ),
+                ],
+            )
             self.assertEqual(mock_request.call_count, 4)
             mock_request.assert_any_call(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                 "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                 "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                 "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_write_batch_larger_chunk(self, mock_request):
         """Test case for write
 
         Add tuples from the store with transaction disabled and minimum parallel request
         """
         mock_request.side_effect = [
-            mock_response('{}', 200),
-            mock_response('{}', 200),
-            mock_response('{}', 200),
+            mock_response("{}", 200),
+            mock_response("{}", 200),
+            mock_response("{}", 200),
         ]
         configuration = self.configuration
         configuration.store_id = store_id
         with OpenFgaClient(configuration) as api_client:
 
             body = ClientWriteRequest(
                 writes=[
@@ -1120,104 +1292,136 @@
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
                     ),
                     ClientTuple(
                         object="document:2021-budget",
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
-                    )
+                    ),
                 ],
             )
             transaction = WriteTransactionOpts(
-                disabled=True, max_per_chunk=2, max_parallel_requests=2)
+                disabled=True, max_per_chunk=2, max_parallel_requests=2
+            )
             response = api_client.write(
                 body,
-                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
-                         "transaction": transaction}
+                options={
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                    "transaction": transaction,
+                },
             )
 
             self.assertEqual(response.deletes, None)
-            self.assertEqual(response.writes,
-                             [
-                                 ClientWriteSingleResponse(
-                                     tuple_key=ClientTuple(
-                                         object="document:2021-budget",
-                                         relation="reader",
-                                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
-                                     ),
-                                     success=True,
-                                     error=None),
-                                 ClientWriteSingleResponse(
-                                     tuple_key=ClientTuple(
-                                         object="document:2021-budget",
-                                         relation="reader",
-                                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
-                                     ),
-                                     success=True,
-                                     error=None),
-                                 ClientWriteSingleResponse(
-                                     tuple_key=ClientTuple(
-                                         object="document:2021-budget",
-                                         relation="reader",
-                                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
-                                     ),
-                                     success=True,
-                                     error=None)
-                             ]
-                             )
+            self.assertEqual(
+                response.writes,
+                [
+                    ClientWriteSingleResponse(
+                        tuple_key=ClientTuple(
+                            object="document:2021-budget",
+                            relation="reader",
+                            user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                        ),
+                        success=True,
+                        error=None,
+                    ),
+                    ClientWriteSingleResponse(
+                        tuple_key=ClientTuple(
+                            object="document:2021-budget",
+                            relation="reader",
+                            user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
+                        ),
+                        success=True,
+                        error=None,
+                    ),
+                    ClientWriteSingleResponse(
+                        tuple_key=ClientTuple(
+                            object="document:2021-budget",
+                            relation="reader",
+                            user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                        ),
+                        success=True,
+                        error=None,
+                    ),
+                ],
+            )
             self.assertEqual(mock_request.call_count, 3)
             mock_request.assert_any_call(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}, {
-                    "object": "document:2021-budget", "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                            },
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c",
+                            },
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                 "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_write_batch_failed(self, mock_request):
         """Test case for write
 
         Add tuples from the store with transaction disabled where one of the request failed
         """
-        response_body = '''
+        response_body = """
 {
   "code": "validation_error",
   "message": "Generic validation error"
 }
-        '''
+        """
 
         mock_request.side_effect = [
-            mock_response('{}', 200),
-            mock_response('{}', 200),
+            mock_response("{}", 200),
+            mock_response("{}", 200),
             ValidationException(http_resp=http_mock_response(response_body, 400)),
-            mock_response('{}', 200),
+            mock_response("{}", 200),
         ]
         configuration = self.configuration
         configuration.store_id = store_id
         with OpenFgaClient(configuration) as api_client:
 
             body = ClientWriteRequest(
                 writes=[
@@ -1231,107 +1435,150 @@
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
                     ),
                     ClientTuple(
                         object="document:2021-budget",
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
-                    )
+                    ),
                 ],
             )
             transaction = WriteTransactionOpts(
-                disabled=True, max_per_chunk=1, max_parallel_requests=10)
+                disabled=True, max_per_chunk=1, max_parallel_requests=10
+            )
             response = api_client.write(
                 body,
-                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
-                         "transaction": transaction}
+                options={
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                    "transaction": transaction,
+                },
             )
 
             self.assertEqual(response.deletes, None)
             self.assertEqual(len(response.writes), 3)
-            self.assertEqual(response.writes[0],
-                             ClientWriteSingleResponse(
-                tuple_key=ClientTuple(
+            self.assertEqual(
+                response.writes[0],
+                ClientWriteSingleResponse(
+                    tuple_key=ClientTuple(
+                        object="document:2021-budget",
+                        relation="reader",
+                        user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    ),
+                    success=True,
+                    error=None,
+                ),
+            )
+            self.assertEqual(
+                response.writes[1].tuple_key,
+                ClientTuple(
                     object="document:2021-budget",
                     relation="reader",
-                    user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
                 ),
-                success=True,
-                error=None))
-            self.assertEqual(response.writes[1].tuple_key,
-                             ClientTuple(
-                object="document:2021-budget",
-                relation="reader",
-                user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
-            ))
+            )
             self.assertFalse(response.writes[1].success)
             self.assertIsInstance(response.writes[1].error, ValidationException)
             self.assertIsInstance(
-                response.writes[1].error.parsed_exception, ValidationErrorMessageResponse)
-            self.assertEqual(response.writes[2],
-                             ClientWriteSingleResponse(
-                tuple_key=ClientTuple(
-                    object="document:2021-budget",
-                    relation="reader",
-                    user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                response.writes[1].error.parsed_exception,
+                ValidationErrorMessageResponse,
+            )
+            self.assertEqual(
+                response.writes[2],
+                ClientWriteSingleResponse(
+                    tuple_key=ClientTuple(
+                        object="document:2021-budget",
+                        relation="reader",
+                        user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                    ),
+                    success=True,
+                    error=None,
                 ),
-                success=True,
-                error=None))
+            )
             self.assertEqual(mock_request.call_count, 4)
             mock_request.assert_any_call(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                 "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                 "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                 "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_delete_batch(self, mock_request):
         """Test case for delete
 
         Delete tuples from the store with transaction disabled but there is only 1 relationship tuple
         """
         mock_request.side_effect = [
-            mock_response('{}', 200),
-            mock_response('{}', 200),
+            mock_response("{}", 200),
+            mock_response("{}", 200),
         ]
         configuration = self.configuration
         configuration.store_id = store_id
         with OpenFgaClient(configuration) as api_client:
 
             body = ClientWriteRequest(
                 deletes=[
@@ -1340,47 +1587,60 @@
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                     )
                 ],
                 writes=[],
             )
             transaction = WriteTransactionOpts(
-                disabled=True, max_per_chunk=1, max_parallel_requests=10)
+                disabled=True, max_per_chunk=1, max_parallel_requests=10
+            )
             api_client.write(
                 body,
-                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
-                         "transaction": transaction}
+                options={
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                    "transaction": transaction,
+                },
             )
             mock_request.assert_any_call(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"deletes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                  "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "deletes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_write_tuples(self, mock_request):
         """Test case for write tuples
 
         Add tuples from the store with transaction enabled
         """
-        response_body = '{}'
+        response_body = "{}"
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         with OpenFgaClient(configuration) as api_client:
 
             api_client.write_tuples(
                 [
@@ -1394,37 +1654,57 @@
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
                     ),
                     ClientTuple(
                         object="document:2021-budget",
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
-                    )
+                    ),
                 ],
-                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"}
+                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
             )
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}, {"object": "document:2021-budget", "relation": "reader",
-                                                                                                                                                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c"}, {"object": "document:2021-budget", "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                            },
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c",
+                            },
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                            },
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_delete_tuples(self, mock_request):
         """Test case for delete tuples
 
         Add tuples from the store with transaction enabled
         """
-        response_body = '{}'
+        response_body = "{}"
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         with OpenFgaClient(configuration) as api_client:
 
             api_client.delete_tuples(
                 [
@@ -1438,37 +1718,56 @@
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31c",
                     ),
                     ClientTuple(
                         object="document:2021-budget",
                         relation="reader",
                         user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
-                    )
+                    ),
                 ],
-                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"}
+                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
             )
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"deletes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}, {"object": "document:2021-budget", "relation": "reader",
-                                                                                                                                                                 "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c"}, {"object": "document:2021-budget", "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "deletes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                            },
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c",
+                            },
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                            },
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_write_batch_unauthorized(self, mock_request):
-        """Test case for write with 401 response
-        """
+        """Test case for write with 401 response"""
 
         mock_request.side_effect = UnauthorizedException(
-            http_resp=http_mock_response('{}', 401)
+            http_resp=http_mock_response("{}", 401)
         )
         configuration = self.configuration
         configuration.store_id = store_id
         with OpenFgaClient(configuration) as api_client:
             with self.assertRaises(UnauthorizedException) as api_exception:
                 body = ClientWriteRequest(
                     writes=[
@@ -1476,40 +1775,43 @@
                             object="document:2021-budget",
                             relation="reader",
                             user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                         )
                     ],
                 )
                 transaction = WriteTransactionOpts(
-                    disabled=True, max_per_chunk=1, max_parallel_requests=10)
+                    disabled=True, max_per_chunk=1, max_parallel_requests=10
+                )
                 api_client.write(
                     body,
-                    options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
-                             "transaction": transaction}
+                    options={
+                        "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                        "transaction": transaction,
+                    },
                 )
 
             self.assertIsInstance(api_exception.exception, UnauthorizedException)
             mock_request.assert_called()
             self.assertEqual(mock_request.call_count, 1)
 
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_check(self, mock_request):
         """Test case for check
 
-        Check whether a user is authorized to access an object  # noqa: E501
+        Check whether a user is authorized to access an object
         """
 
         # First, mock the response
         response_body = '{"allowed": true, "resolution": "1234"}'
         mock_request.return_value = mock_response(response_body, 200)
         body = ClientCheckRequest(
             user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
@@ -1524,134 +1826,157 @@
             ],
         )
         configuration = self.configuration
         configuration.store_id = store_id
         with OpenFgaClient(configuration) as api_client:
             api_response = api_client.check(
                 body=body,
-                options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"}
+                options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
             )
             self.assertIsInstance(api_response, CheckResponse)
             self.assertTrue(api_response.allowed)
             # Make sure the API was called with the right data
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b", "relation": "reader", "object": "document:budget"},
-                      "contextual_tuples": {"tuple_keys": [{"user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b", "relation": "writer", "object": "document:budget"}]},
-                      "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                        "relation": "reader",
+                        "object": "document:budget",
+                    },
+                    "contextual_tuples": {
+                        "tuple_keys": [
+                            {
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                                "relation": "writer",
+                                "object": "document:budget",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_check_config_auth_model(self, mock_request):
         """Test case for check
 
-        Check whether a user is authorized to access an object and the auth model is already encoded in store  # noqa: E501
+        Check whether a user is authorized to access an object and the auth model is already encoded in store
         """
 
         # First, mock the response
         response_body = '{"allowed": true, "resolution": "1234"}'
         mock_request.return_value = mock_response(response_body, 200)
         body = ClientCheckRequest(
             object="document:2021-budget",
             relation="reader",
             user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
         )
         configuration = self.configuration
         configuration.store_id = store_id
         configuration.authorization_model_id = "01GXSA8YR785C4FYS3C0RTG7B1"
         with OpenFgaClient(configuration) as api_client:
-            api_response = api_client.check(
-                body=body,
-                options={}
-            )
+            api_response = api_client.check(body=body, options={})
             self.assertIsInstance(api_response, CheckResponse)
             self.assertTrue(api_response.allowed)
             # Make sure the API was called with the right data
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget",
-                                    "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}, "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    },
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_batch_check_single_request(self, mock_request):
         """Test case for check with single request
 
-        Check whether a user is authorized to access an object  # noqa: E501
+        Check whether a user is authorized to access an object
         """
 
         # First, mock the response
         response_body = '{"allowed": true, "resolution": "1234"}'
         mock_request.side_effect = [
-            mock_response('{}', 200),
+            mock_response("{}", 200),
             mock_response(response_body, 200),
         ]
         body = ClientCheckRequest(
             object="document:2021-budget",
             relation="reader",
             user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
         )
         configuration = self.configuration
         configuration.store_id = store_id
         with OpenFgaClient(configuration) as api_client:
             api_response = api_client.batch_check(
                 body=[body],
-                options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"}
+                options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
             )
             self.assertIsInstance(api_response, list)
             self.assertEqual(len(api_response), 1)
             self.assertEqual(api_response[0].error, None)
             self.assertTrue(api_response[0].allowed)
             self.assertEqual(api_response[0].request, body)
             # Make sure the API was called with the right data
             mock_request.assert_any_call(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01GXSA8YR785C4FYS3C0RTG7B1',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01GXSA8YR785C4FYS3C0RTG7B1",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget",
-                                    "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}, "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    },
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_batch_check_multiple_request(self, mock_request):
         """Test case for check with multiple request
 
-        Check whether a user is authorized to access an object  # noqa: E501
+        Check whether a user is authorized to access an object
         """
 
         # First, mock the response
         mock_request.side_effect = [
-            mock_response('{}', 200),
+            mock_response("{}", 200),
             mock_response('{"allowed": true, "resolution": "1234"}', 200),
             mock_response('{"allowed": false, "resolution": "1234"}', 200),
             mock_response('{"allowed": true, "resolution": "1234"}', 200),
         ]
         body1 = ClientCheckRequest(
             object="document:2021-budget",
             relation="reader",
@@ -1668,88 +1993,108 @@
             user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
         )
         configuration = self.configuration
         configuration.store_id = store_id
         with OpenFgaClient(configuration) as api_client:
             api_response = api_client.batch_check(
                 body=[body1, body2, body3],
-                options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
-                         "max_parallel_requests": 2}
+                options={
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                    "max_parallel_requests": 2,
+                },
             )
             self.assertIsInstance(api_response, list)
             self.assertEqual(len(api_response), 3)
             self.assertEqual(api_response[0].error, None)
             self.assertTrue(api_response[0].allowed)
             self.assertEqual(api_response[0].request, body1)
             self.assertEqual(api_response[1].error, None)
             self.assertFalse(api_response[1].allowed)
             self.assertEqual(api_response[1].request, body2)
             self.assertEqual(api_response[2].error, None)
             self.assertTrue(api_response[2].allowed)
             self.assertEqual(api_response[2].request, body3)
             # Make sure the API was called with the right data
             mock_request.assert_any_call(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01GXSA8YR785C4FYS3C0RTG7B1',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01GXSA8YR785C4FYS3C0RTG7B1",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget",
-                                    "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}, "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    },
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget",
-                                    "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c"}, "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c",
+                    },
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget",
-                                    "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d"}, "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                    },
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_batch_check_multiple_request_fail(self, mock_request):
         """Test case for check with multiple request with one request failed
 
-        Check whether a user is authorized to access an object  # noqa: E501
+        Check whether a user is authorized to access an object
         """
-        response_body = '''
+        response_body = """
 {
   "code": "validation_error",
   "message": "Generic validation error"
 }
-        '''
+        """
 
         # First, mock the response
         mock_request.side_effect = [
-            mock_response('{}', 200),
+            mock_response("{}", 200),
             mock_response('{"allowed": true, "resolution": "1234"}', 200),
             ValidationException(http_resp=http_mock_response(response_body, 400)),
             mock_response('{"allowed": false, "resolution": "1234"}', 200),
         ]
         body1 = ClientCheckRequest(
             object="document:2021-budget",
             relation="reader",
@@ -1766,168 +2111,196 @@
             user="user:81684243-9356-4421-8fbf-a4f8d36aa31d",
         )
         configuration = self.configuration
         configuration.store_id = store_id
         with OpenFgaClient(configuration) as api_client:
             api_response = api_client.batch_check(
                 body=[body1, body2, body3],
-                options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
-                         "max_parallel_requests": 2}
+                options={
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                    "max_parallel_requests": 2,
+                },
             )
             self.assertIsInstance(api_response, list)
             self.assertEqual(len(api_response), 3)
             self.assertEqual(api_response[0].error, None)
             self.assertTrue(api_response[0].allowed)
             self.assertEqual(api_response[0].request, body1)
             self.assertFalse(api_response[1].allowed)
             self.assertEqual(api_response[1].request, body2)
             self.assertIsInstance(api_response[1].error, ValidationException)
             self.assertIsInstance(
-                api_response[1].error.parsed_exception, ValidationErrorMessageResponse)
+                api_response[1].error.parsed_exception, ValidationErrorMessageResponse
+            )
             self.assertEqual(api_response[2].error, None)
             self.assertFalse(api_response[2].allowed)
             self.assertEqual(api_response[2].request, body3)
             # Make sure the API was called with the right data
             mock_request.assert_any_call(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01GXSA8YR785C4FYS3C0RTG7B1',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01GXSA8YR785C4FYS3C0RTG7B1",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget",
-                                    "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}, "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    },
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget",
-                                    "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c"}, "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31c",
+                    },
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget",
-                                    "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d"}, "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31d",
+                    },
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_expand(self, mock_request):
         """Test case for expand
 
-        Expand all relationships in userset tree format, and following userset rewrite rules.  Useful to reason about and debug a certain relationship  # noqa: E501
+        Expand all relationships in userset tree format, and following userset rewrite rules.  Useful to reason about and debug a certain relationship
         """
-        response_body = '''{
+        response_body = """{
             "tree": {"root": {"name": "document:budget#reader", "leaf": {"users": {"users": ["user:81684243-9356-4421-8fbf-a4f8d36aa31b"]}}}}}
-            '''
+            """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         with OpenFgaClient(configuration) as api_client:
             body = ClientExpandRequest(
                 object="document:budget",
                 relation="reader",
             )
             api_response = api_client.expand(
                 body=body,
-                options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"}
+                options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
             )
             self.assertIsInstance(api_response, ExpandResponse)
             cur_users = Users(users=["user:81684243-9356-4421-8fbf-a4f8d36aa31b"])
             leaf = Leaf(users=cur_users)
             node = Node(name="document:budget#reader", leaf=leaf)
             userTree = UsersetTree(node)
             expected_response = ExpandResponse(userTree)
             self.assertEqual(api_response, expected_response)
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/expand',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/expand",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:budget", "relation": "reader"},
-                      "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {"object": "document:budget", "relation": "reader"},
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_list_objects(self, mock_request):
         """Test case for list_objects
 
-        List objects  # noqa: E501
+        List objects
         """
-        response_body = '''
+        response_body = """
 {
   "objects": [
     "document:abcd1234"
   ]
 }
-            '''
+            """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         with OpenFgaClient(configuration) as api_client:
             body = ClientListObjectsRequest(
                 type="document",
                 relation="reader",
                 user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
             )
             # Get all stores
             api_response = api_client.list_objects(
-                body, options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"})
+                body, options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"}
+            )
             self.assertIsInstance(api_response, ListObjectsResponse)
-            self.assertEqual(api_response.objects, ['document:abcd1234'])
+            self.assertEqual(api_response.objects, ["document:abcd1234"])
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/list-objects',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/list-objects",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={'authorization_model_id': '01GXSA8YR785C4FYS3C0RTG7B1',
-                      'type': 'document', 'relation': 'reader', 'user': 'user:81684243-9356-4421-8fbf-a4f8d36aa31b'},
+                body={
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                    "type": "document",
+                    "relation": "reader",
+                    "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_list_objects_contextual_tuples(self, mock_request):
         """Test case for list_objects
 
-        List objects  # noqa: E501
+        List objects
         """
-        response_body = '''
+        response_body = """
 {
   "objects": [
     "document:abcd1234"
   ]
 }
-            '''
+            """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         with OpenFgaClient(configuration) as api_client:
             body = ClientListObjectsRequest(
                 type="document",
                 relation="reader",
@@ -1938,309 +2311,413 @@
                         relation="writer",
                         object="document:budget",
                     ),
                 ],
             )
             # Get all stores
             api_response = api_client.list_objects(
-                body, options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"})
+                body, options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"}
+            )
             self.assertIsInstance(api_response, ListObjectsResponse)
-            self.assertEqual(api_response.objects, ['document:abcd1234'])
+            self.assertEqual(api_response.objects, ["document:abcd1234"])
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/list-objects',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/list-objects",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={'authorization_model_id': '01GXSA8YR785C4FYS3C0RTG7B1',
-                      'type': 'document', 'relation': 'reader', 'user': 'user:81684243-9356-4421-8fbf-a4f8d36aa31b',
-                      'contextual_tuples': {'tuple_keys': [{'object': 'document:budget', 'relation': 'writer', 'user': 'user:81684243-9356-4421-8fbf-a4f8d36aa31b'}]}},
+                body={
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                    "type": "document",
+                    "relation": "reader",
+                    "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    "contextual_tuples": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:budget",
+                                "relation": "writer",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                            }
+                        ]
+                    },
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_list_relations(self, mock_request):
         """Test case for list relations
 
-        Check whether a user is authorized to access an object  # noqa: E501
+        Check whether a user is authorized to access an object
         """
 
         # First, mock the response
         mock_request.side_effect = [
-            mock_response('{}', 200),
+            mock_response("{}", 200),
             mock_response('{"allowed": true, "resolution": "1234"}', 200),
             mock_response('{"allowed": false, "resolution": "1234"}', 200),
             mock_response('{"allowed": true, "resolution": "1234"}', 200),
         ]
         configuration = self.configuration
         configuration.store_id = store_id
         with OpenFgaClient(configuration) as api_client:
             api_response = api_client.list_relations(
-                body=ClientListRelationsRequest(user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
-                                                relations=["reader", "owner", "viewer"],
-                                                object="document:2021-budget"),
-                options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"}
+                body=ClientListRelationsRequest(
+                    user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    relations=["reader", "owner", "viewer"],
+                    object="document:2021-budget",
+                ),
+                options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
             )
             self.assertEqual(api_response, ["reader", "viewer"])
 
             # Make sure the API was called with the right data
             mock_request.assert_any_call(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01GXSA8YR785C4FYS3C0RTG7B1',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01GXSA8YR785C4FYS3C0RTG7B1",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget",
-                                    "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}, "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    },
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget",
-                                    "relation": "owner", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}, "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "owner",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    },
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             mock_request.assert_any_call(
-                'POST',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check',
+                "POST",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/check",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget",
-                                    "relation": "viewer", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}, "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "viewer",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    },
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_list_relations_unauthorized(self, mock_request):
-        """Test case for list relations with 401 response
-        """
+        """Test case for list relations with 401 response"""
 
         mock_request.side_effect = UnauthorizedException(
-            http_resp=http_mock_response('{}', 401)
+            http_resp=http_mock_response("{}", 401)
         )
         configuration = self.configuration
         configuration.store_id = store_id
         with OpenFgaClient(configuration) as api_client:
             with self.assertRaises(UnauthorizedException) as api_exception:
                 api_client.list_relations(
-                    body=ClientListRelationsRequest(user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
-                                                    relations=["reader", "owner", "viewer"],
-                                                    object="document:2021-budget"),
-                    options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"}
+                    body=ClientListRelationsRequest(
+                        user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                        relations=["reader", "owner", "viewer"],
+                        object="document:2021-budget",
+                    ),
+                    options={"authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
                 )
 
             self.assertIsInstance(api_exception.exception, UnauthorizedException)
             mock_request.assert_called()
             self.assertEqual(mock_request.call_count, 1)
 
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01GXSA8YR785C4FYS3C0RTG7B1',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/authorization-models/01GXSA8YR785C4FYS3C0RTG7B1",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
             api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_read_assertions(self, mock_request):
-        """Test case for read assertions
-
-        """
-        response_body = '''
+        """Test case for read assertions"""
+        response_body = """
 {
   "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
   "assertions": [
     {
       "tuple_key": {
         "object": "document:2021-budget",
         "relation": "reader",
         "user": "user:anne"
       },
       "expectation": true
     }
   ]
 }
-        '''
+        """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         # Enter a context with an instance of the API client
         with OpenFgaClient(configuration) as api_client:
             api_response = api_client.read_assertions(
                 options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"}
             )
-            self.assertEqual(api_response, ReadAssertionsResponse(
-                authorization_model_id="01G5JAVJ41T49E9TT3SKVS7X1J",
-                assertions=[Assertion(
-                    tuple_key=TupleKeyWithoutCondition(object="document:2021-budget", relation="reader",
-                                                       user="user:anne"),
-                    expectation=True,
-                )]
-            ))
+            self.assertEqual(
+                api_response,
+                ReadAssertionsResponse(
+                    authorization_model_id="01G5JAVJ41T49E9TT3SKVS7X1J",
+                    assertions=[
+                        Assertion(
+                            tuple_key=TupleKeyWithoutCondition(
+                                object="document:2021-budget",
+                                relation="reader",
+                                user="user:anne",
+                            ),
+                            expectation=True,
+                        )
+                    ],
+                ),
+            )
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/assertions/01G5JAVJ41T49E9TT3SKVS7X1J',
+                "GET",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/assertions/01G5JAVJ41T49E9TT3SKVS7X1J",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_write_assertions(self, mock_request):
         """Test case for write assertions
 
-        Get all stores  # noqa: E501
+        Get all stores
         """
-        mock_request.return_value = mock_response('', 204)
+        mock_request.return_value = mock_response("", 204)
         configuration = self.configuration
         configuration.store_id = store_id
         with OpenFgaClient(configuration) as api_client:
             api_client.write_assertions(
-                [ClientAssertion(user="user:anne", relation="reader",
-                                 object="document:2021-budget", expectation=True)],
-                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"}
+                [
+                    ClientAssertion(
+                        user="user:anne",
+                        relation="reader",
+                        object="document:2021-budget",
+                        expectation=True,
+                    )
+                ],
+                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
             )
             mock_request.assert_called_once_with(
-                'PUT',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/assertions/01G5JAVJ41T49E9TT3SKVS7X1J',
+                "PUT",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/assertions/01G5JAVJ41T49E9TT3SKVS7X1J",
                 headers=ANY,
-                body={"assertions": [{"tuple_key": {"object": "document:2021-budget",
-                                                    "relation": "reader", "user": "user:anne"}, "expectation": True}]},
+                body={
+                    "assertions": [
+                        {
+                            "tuple_key": {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:anne",
+                            },
+                            "expectation": True,
+                        }
+                    ]
+                },
                 query_params=[],
                 post_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_set_store_id(self, mock_request):
         """Test case for write assertions
 
-        Get all stores  # noqa: E501
+        Get all stores
         """
-        mock_request.return_value = mock_response('', 204)
+        mock_request.return_value = mock_response("", 204)
         configuration = self.configuration
         configuration.store_id = store_id
         with OpenFgaClient(configuration) as api_client:
             api_client.set_store_id("01YCP46JKYM8FJCQ37NMBYHE5Y")
 
             api_client.write_assertions(
-                [ClientAssertion(user="user:anne", relation="reader",
-                                 object="document:2021-budget", expectation=True)],
-                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"}
+                [
+                    ClientAssertion(
+                        user="user:anne",
+                        relation="reader",
+                        object="document:2021-budget",
+                        expectation=True,
+                    )
+                ],
+                options={"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
             )
             self.assertEqual(api_client.get_store_id(), "01YCP46JKYM8FJCQ37NMBYHE5Y")
             mock_request.assert_called_once_with(
-                'PUT',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5Y/assertions/01G5JAVJ41T49E9TT3SKVS7X1J',
+                "PUT",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5Y/assertions/01G5JAVJ41T49E9TT3SKVS7X1J",
                 headers=ANY,
-                body={"assertions": [{"tuple_key": {"object": "document:2021-budget",
-                                                    "relation": "reader", "user": "user:anne"}, "expectation": True}]},
+                body={
+                    "assertions": [
+                        {
+                            "tuple_key": {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:anne",
+                            },
+                            "expectation": True,
+                        }
+                    ]
+                },
                 query_params=[],
                 post_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_config_auth_model(self, mock_request):
         """Test case for write assertions
 
-        Get all stores  # noqa: E501
+        Get all stores
         """
-        mock_request.return_value = mock_response('', 204)
+        mock_request.return_value = mock_response("", 204)
         configuration = self.configuration
         configuration.store_id = store_id
         configuration.authorization_model_id = "01G5JAVJ41T49E9TT3SKVS7X1J"
         with OpenFgaClient(configuration) as api_client:
             api_client.write_assertions(
-                [ClientAssertion(user="user:anne", relation="reader",
-                                 object="document:2021-budget", expectation=True)],
-                options={}
+                [
+                    ClientAssertion(
+                        user="user:anne",
+                        relation="reader",
+                        object="document:2021-budget",
+                        expectation=True,
+                    )
+                ],
+                options={},
+            )
+            self.assertEqual(
+                api_client.get_authorization_model_id(), "01G5JAVJ41T49E9TT3SKVS7X1J"
             )
-            self.assertEqual(api_client.get_authorization_model_id(), "01G5JAVJ41T49E9TT3SKVS7X1J")
             mock_request.assert_called_once_with(
-                'PUT',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/assertions/01G5JAVJ41T49E9TT3SKVS7X1J',
+                "PUT",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/assertions/01G5JAVJ41T49E9TT3SKVS7X1J",
                 headers=ANY,
-                body={"assertions": [{"tuple_key": {"object": "document:2021-budget",
-                                                    "relation": "reader", "user": "user:anne"}, "expectation": True}]},
+                body={
+                    "assertions": [
+                        {
+                            "tuple_key": {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:anne",
+                            },
+                            "expectation": True,
+                        }
+                    ]
+                },
                 query_params=[],
                 post_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     def test_update_auth_model(self, mock_request):
         """Test case for write assertions
 
-        Get all stores  # noqa: E501
+        Get all stores
         """
-        mock_request.return_value = mock_response('', 204)
+        mock_request.return_value = mock_response("", 204)
         configuration = self.configuration
         configuration.store_id = store_id
         configuration.authorization_model_id = "01G5JAVJ41T49E9TT3SKVS7X1J"
         with OpenFgaClient(configuration) as api_client:
             api_client.set_authorization_model_id("01G5JAVJ41T49E9TT3SKVS7X2J")
 
             api_client.write_assertions(
-                [ClientAssertion(user="user:anne", relation="reader",
-                                 object="document:2021-budget", expectation=True)],
-                options={}
+                [
+                    ClientAssertion(
+                        user="user:anne",
+                        relation="reader",
+                        object="document:2021-budget",
+                        expectation=True,
+                    )
+                ],
+                options={},
             )
             mock_request.assert_called_once_with(
-                'PUT',
-                'http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/assertions/01G5JAVJ41T49E9TT3SKVS7X2J',
+                "PUT",
+                "http://api.fga.example/stores/01YCP46JKYM8FJCQ37NMBYHE5X/assertions/01G5JAVJ41T49E9TT3SKVS7X2J",
                 headers=ANY,
-                body={"assertions": [{"tuple_key": {"object": "document:2021-budget",
-                                                    "relation": "reader", "user": "user:anne"}, "expectation": True}]},
+                body={
+                    "assertions": [
+                        {
+                            "tuple_key": {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:anne",
+                            },
+                            "expectation": True,
+                        }
+                    ]
+                },
                 query_params=[],
                 post_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
     def test_configuration_store_id_invalid(self):
         """
         Test whether ApiValueError is raised if host has query
         """
         configuration = ClientConfiguration(
-            api_host='localhost',
-            api_scheme='http',
-            store_id="abcd"
+            api_host="localhost", api_scheme="http", store_id="abcd"
         )
         self.assertRaises(FgaValidationException, configuration.is_valid)
 
     def test_configuration_authorization_model_id_invalid(self):
         """
         Test whether ApiValueError is raised if host has query
         """
         configuration = ClientConfiguration(
-            api_host='localhost',
-            api_scheme='http',
+            api_host="localhost",
+            api_scheme="http",
             store_id="01H15K9J85050XTEDPVM8DJM78",
-            authorization_model_id="abcd"
+            authorization_model_id="abcd",
         )
         self.assertRaises(FgaValidationException, configuration.is_valid)
```

### Comparing `openfga-sdk-0.4.1/test/test_credentials.py` & `openfga-sdk-0.4.2/test/test_credentials.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,25 +1,22 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 from unittest import IsolatedAsyncioTestCase
 
 import openfga_sdk
-
 from openfga_sdk.credentials import CredentialConfiguration, Credentials
 
 
 class TestCredentials(IsolatedAsyncioTestCase):
     """Credentials unit test"""
 
     def setUp(self):
@@ -38,109 +35,140 @@
 
     def test_method_none(self):
         """
         Test credential with method none is valid
         """
         credential = Credentials("none")
         credential.validate_credentials_config()
-        self.assertEqual(credential.method, 'none')
+        self.assertEqual(credential.method, "none")
 
     def test_method_default(self):
         """
         Test credential with not method is default to none
         """
         credential = Credentials()
         credential.validate_credentials_config()
-        self.assertEqual(credential.method, 'none')
+        self.assertEqual(credential.method, "none")
 
     def test_configuration_api_token(self):
         """
         Test credential with method api_token and appropriate configuration is valid
         """
         credential = Credentials(
-            method="api_token", configuration=CredentialConfiguration(api_token='ABCDEFG'))
+            method="api_token",
+            configuration=CredentialConfiguration(api_token="ABCDEFG"),
+        )
         credential.validate_credentials_config()
-        self.assertEqual(credential.method, 'api_token')
-        self.assertEqual(credential.configuration.api_token, 'ABCDEFG')
+        self.assertEqual(credential.method, "api_token")
+        self.assertEqual(credential.configuration.api_token, "ABCDEFG")
 
     def test_configuration_api_token_missing_configuration(self):
         """
         Test credential with method api_token but configuration is not specified
         """
         credential = Credentials(method="api_token")
         with self.assertRaises(openfga_sdk.ApiValueError):
             credential.validate_credentials_config()
 
     def test_configuration_api_token_missing_token(self):
         """
         Test credential with method api_token but configuration is missing token
         """
-        credential = Credentials(method="api_token", configuration=CredentialConfiguration())
+        credential = Credentials(
+            method="api_token", configuration=CredentialConfiguration()
+        )
         with self.assertRaises(openfga_sdk.ApiValueError):
             credential.validate_credentials_config()
 
     def test_configuration_api_token_empty_token(self):
         """
         Test credential with method api_token but configuration has empty token
         """
         credential = Credentials(
-            method="api_token", configuration=CredentialConfiguration(api_token=''))
+            method="api_token", configuration=CredentialConfiguration(api_token="")
+        )
         with self.assertRaises(openfga_sdk.ApiValueError):
             credential.validate_credentials_config()
 
     def test_configuration_client_credentials(self):
         """
         Test credential with method client_credentials and appropriate configuration is valid
         """
-        credential = Credentials(method="client_credentials",
-                                 configuration=CredentialConfiguration(client_id='myclientid',
-                                                                       client_secret='mysecret', api_issuer='www.testme.com', api_audience='myaudience'))
+        credential = Credentials(
+            method="client_credentials",
+            configuration=CredentialConfiguration(
+                client_id="myclientid",
+                client_secret="mysecret",
+                api_issuer="issuer.fga.example",
+                api_audience="myaudience",
+            ),
+        )
         credential.validate_credentials_config()
-        self.assertEqual(credential.method, 'client_credentials')
+        self.assertEqual(credential.method, "client_credentials")
 
     def test_configuration_client_credentials_missing_config(self):
         """
         Test credential with method client_credentials and configuration is missing
         """
         credential = Credentials(method="client_credentials")
         with self.assertRaises(openfga_sdk.ApiValueError):
             credential.validate_credentials_config()
 
     def test_configuration_client_credentials_missing_client_id(self):
         """
         Test credential with method client_credentials and configuration is missing client id
         """
-        credential = Credentials(method="client_credentials",
-                                 configuration=CredentialConfiguration(
-                                     client_secret='mysecret', api_issuer='www.testme.com', api_audience='myaudience'))
+        credential = Credentials(
+            method="client_credentials",
+            configuration=CredentialConfiguration(
+                client_secret="mysecret",
+                api_issuer="issuer.fga.example",
+                api_audience="myaudience",
+            ),
+        )
         with self.assertRaises(openfga_sdk.ApiValueError):
             credential.validate_credentials_config()
 
     def test_configuration_client_credentials_missing_client_secret(self):
         """
         Test credential with method client_credentials and configuration is missing client secret
         """
-        credential = Credentials(method="client_credentials",
-                                 configuration=CredentialConfiguration(client_id='myclientid',
-                                                                       api_issuer='www.testme.com', api_audience='myaudience'))
+        credential = Credentials(
+            method="client_credentials",
+            configuration=CredentialConfiguration(
+                client_id="myclientid",
+                api_issuer="issuer.fga.example",
+                api_audience="myaudience",
+            ),
+        )
         with self.assertRaises(openfga_sdk.ApiValueError):
             credential.validate_credentials_config()
 
     def test_configuration_client_credentials_missing_api_issuer(self):
         """
         Test credential with method client_credentials and configuration is missing api issuer
         """
-        credential = Credentials(method="client_credentials",
-                                 configuration=CredentialConfiguration(client_id='myclientid',
-                                                                       client_secret='mysecret', api_audience='myaudience'))
+        credential = Credentials(
+            method="client_credentials",
+            configuration=CredentialConfiguration(
+                client_id="myclientid",
+                client_secret="mysecret",
+                api_audience="myaudience",
+            ),
+        )
         with self.assertRaises(openfga_sdk.ApiValueError):
             credential.validate_credentials_config()
 
     def test_configuration_client_credentials_missing_api_audience(self):
         """
         Test credential with method client_credentials and configuration is missing api audience
         """
-        credential = Credentials(method="client_credentials",
-                                 configuration=CredentialConfiguration(client_id='myclientid',
-                                                                       client_secret='mysecret', api_issuer='www.testme.com'))
+        credential = Credentials(
+            method="client_credentials",
+            configuration=CredentialConfiguration(
+                client_id="myclientid",
+                client_secret="mysecret",
+                api_issuer="issuer.fga.example",
+            ),
+        )
         with self.assertRaises(openfga_sdk.ApiValueError):
             credential.validate_credentials_config()
```

### Comparing `openfga-sdk-0.4.1/test/test_open_fga_api.py` & `openfga-sdk-0.4.2/test/test_open_fga_api_sync.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,343 +1,368 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 import unittest
-from unittest.mock import ANY
-from unittest import IsolatedAsyncioTestCase
-from mock import patch
 from datetime import datetime
+from unittest import IsolatedAsyncioTestCase
+from unittest.mock import ANY, patch
 
 import urllib3
 
-import openfga_sdk
-from openfga_sdk import rest
-from openfga_sdk.api import open_fga_api
-from openfga_sdk.credentials import Credentials, CredentialConfiguration
-from openfga_sdk.exceptions import FgaValidationException, ApiValueError, NotFoundException, RateLimitExceededError, ServiceException, ValidationException, FGA_REQUEST_ID
+import openfga_sdk.sync
+from openfga_sdk.configuration import Configuration
+from openfga_sdk.credentials import CredentialConfiguration, Credentials
+from openfga_sdk.exceptions import (
+    FGA_REQUEST_ID,
+    ApiValueError,
+    FgaValidationException,
+    NotFoundException,
+    RateLimitExceededError,
+    ServiceException,
+    ValidationException,
+)
 from openfga_sdk.models.assertion import Assertion
 from openfga_sdk.models.authorization_model import AuthorizationModel
 from openfga_sdk.models.check_request import CheckRequest
 from openfga_sdk.models.check_response import CheckResponse
 from openfga_sdk.models.create_store_request import CreateStoreRequest
 from openfga_sdk.models.create_store_response import CreateStoreResponse
 from openfga_sdk.models.error_code import ErrorCode
 from openfga_sdk.models.expand_request import ExpandRequest
 from openfga_sdk.models.expand_request_tuple_key import ExpandRequestTupleKey
 from openfga_sdk.models.expand_response import ExpandResponse
 from openfga_sdk.models.get_store_response import GetStoreResponse
 from openfga_sdk.models.internal_error_code import InternalErrorCode
-from openfga_sdk.models.internal_error_message_response import InternalErrorMessageResponse
+from openfga_sdk.models.internal_error_message_response import (
+    InternalErrorMessageResponse,
+)
 from openfga_sdk.models.leaf import Leaf
 from openfga_sdk.models.list_objects_request import ListObjectsRequest
 from openfga_sdk.models.list_objects_response import ListObjectsResponse
 from openfga_sdk.models.list_stores_response import ListStoresResponse
 from openfga_sdk.models.node import Node
 from openfga_sdk.models.not_found_error_code import NotFoundErrorCode
 from openfga_sdk.models.object_relation import ObjectRelation
-from openfga_sdk.models.path_unknown_error_message_response import PathUnknownErrorMessageResponse
+from openfga_sdk.models.path_unknown_error_message_response import (
+    PathUnknownErrorMessageResponse,
+)
 from openfga_sdk.models.read_assertions_response import ReadAssertionsResponse
-from openfga_sdk.models.read_authorization_model_response import ReadAuthorizationModelResponse
+from openfga_sdk.models.read_authorization_model_response import (
+    ReadAuthorizationModelResponse,
+)
 from openfga_sdk.models.read_changes_response import ReadChangesResponse
 from openfga_sdk.models.read_request import ReadRequest
 from openfga_sdk.models.read_request_tuple_key import ReadRequestTupleKey
 from openfga_sdk.models.read_response import ReadResponse
 from openfga_sdk.models.store import Store
 from openfga_sdk.models.tuple import Tuple
 from openfga_sdk.models.tuple_change import TupleChange
 from openfga_sdk.models.tuple_key import TupleKey
 from openfga_sdk.models.tuple_key_without_condition import TupleKeyWithoutCondition
-from openfga_sdk.models.write_request_writes import WriteRequestWrites
-from openfga_sdk.models.write_request_deletes import WriteRequestDeletes
 from openfga_sdk.models.tuple_operation import TupleOperation
 from openfga_sdk.models.type_definition import TypeDefinition
 from openfga_sdk.models.users import Users
 from openfga_sdk.models.userset import Userset
 from openfga_sdk.models.userset_tree import UsersetTree
 from openfga_sdk.models.usersets import Usersets
-from openfga_sdk.models.validation_error_message_response import ValidationErrorMessageResponse
+from openfga_sdk.models.validation_error_message_response import (
+    ValidationErrorMessageResponse,
+)
 from openfga_sdk.models.write_assertions_request import WriteAssertionsRequest
-from openfga_sdk.models.write_authorization_model_request import WriteAuthorizationModelRequest
-from openfga_sdk.models.write_authorization_model_response import WriteAuthorizationModelResponse
+from openfga_sdk.models.write_authorization_model_request import (
+    WriteAuthorizationModelRequest,
+)
+from openfga_sdk.models.write_authorization_model_response import (
+    WriteAuthorizationModelResponse,
+)
 from openfga_sdk.models.write_request import WriteRequest
+from openfga_sdk.models.write_request_deletes import WriteRequestDeletes
+from openfga_sdk.models.write_request_writes import WriteRequestWrites
+from openfga_sdk.sync import open_fga_api, rest
+from openfga_sdk.sync.api_client import ApiClient
 
-store_id = '01H0H015178Y2V4CX10C2KGHF4'
-request_id = 'x1y2z3'
-
-# Helper function to construct mock response
+store_id = "01H0H015178Y2V4CX10C2KGHF4"
+request_id = "x1y2z3"
 
 
+# Helper function to construct mock response
 def http_mock_response(body, status):
-    headers = urllib3.response.HTTPHeaderDict({
-        'content-type': 'application/json',
-        'Fga-Request-Id': request_id
-    })
+    headers = urllib3.response.HTTPHeaderDict(
+        {"content-type": "application/json", "Fga-Request-Id": request_id}
+    )
     return urllib3.HTTPResponse(
-        body.encode('utf-8'),
-        headers,
-        status,
-        preload_content=False
+        body.encode("utf-8"), headers, status, preload_content=False
     )
 
 
 def mock_response(body, status):
     obj = http_mock_response(body, status)
     return rest.RESTResponse(obj, obj.data)
 
 
-class TestOpenFgaApi(IsolatedAsyncioTestCase):
-    """OpenFgaApi unit test stubs"""
+class TestOpenFgaApiSync(IsolatedAsyncioTestCase):
+    """openfga_sdk.sync.OpenFgaApi unit test stubs"""
 
     def setUp(self):
-        self.configuration = openfga_sdk.Configuration(
-            api_url='http://api.fga.example',
+        self.configuration = Configuration(
+            api_url="http://api.fga.example",
         )
 
     def tearDown(self):
         pass
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_check(self, mock_request):
         """Test case for check
 
-        Check whether a user is authorized to access an object  # noqa: E501
+        Check whether a user is authorized to access an object
         """
 
         # First, mock the response
         response_body = '{"allowed": true, "resolution": "1234"}'
         mock_request.return_value = mock_response(response_body, 200)
 
         configuration = self.configuration
         configuration.store_id = store_id
-        async with openfga_sdk.ApiClient(configuration) as api_client:
+        with ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
             body = CheckRequest(
                 tuple_key=TupleKey(
                     object="document:2021-budget",
                     relation="reader",
                     user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                 ),
                 authorization_model_id="01GXSA8YR785C4FYS3C0RTG7B1",
             )
-            api_response = await api_instance.check(
+            api_response = api_instance.check(
                 body=body,
             )
             self.assertIsInstance(api_response, CheckResponse)
             self.assertTrue(api_response.allowed)
             # Make sure the API was called with the right data
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/check',
+                "POST",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/check",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget",
-                                    "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}, "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    },
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
-            await api_client.close()
+            api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_create_store(self, mock_request):
         """Test case for create_store
 
-        Create a store  # noqa: E501
+        Create a store
         """
-        response_body = '''{
+        response_body = """{
             "id": "01YCP46JKYM8FJCQ37NMBYHE5X",
             "name": "test_store",
             "created_at": "2022-07-25T17:41:26.607Z",
             "updated_at": "2022-07-25T17:41:26.607Z"}
-            '''
+            """
         mock_request.return_value = mock_response(response_body, 201)
 
         configuration = self.configuration
-        async with openfga_sdk.ApiClient(configuration) as api_client:
+        with ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
             body = CreateStoreRequest(
                 name="test-store",
             )
-            api_response = await api_instance.create_store(
+            api_response = api_instance.create_store(
                 body=body,
             )
             self.assertIsInstance(api_response, CreateStoreResponse)
-            self.assertEqual(api_response.id, '01YCP46JKYM8FJCQ37NMBYHE5X')
+            self.assertEqual(api_response.id, "01YCP46JKYM8FJCQ37NMBYHE5X")
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores',
+                "POST",
+                "http://api.fga.example/stores",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
                 body={"name": "test-store"},
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
-            await api_client.close()
+            api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_delete_store(self, mock_request):
         """Test case for delete_store
 
-        Delete a store  # noqa: E501
+        Delete a store
         """
-        response_body = ''
+        response_body = ""
         mock_request.return_value = mock_response(response_body, 201)
         configuration = self.configuration
         configuration.store_id = store_id
-        async with openfga_sdk.ApiClient(configuration) as api_client:
+        with ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
-            await api_instance.delete_store()
+            api_instance.delete_store()
             mock_request.assert_called_once_with(
-                'DELETE',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4',
+                "DELETE",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4",
                 headers=ANY,
                 query_params=[],
                 body=None,
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
-            await api_client.close()
+            api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_expand(self, mock_request):
         """Test case for expand
 
-        Expand all relationships in userset tree format, and following userset rewrite rules.  Useful to reason about and debug a certain relationship  # noqa: E501
+        Expand all relationships in userset tree format, and following userset rewrite rules.  Useful to reason about and debug a certain relationship
         """
-        response_body = '''{
+        response_body = """{
             "tree": {"root": {"name": "document:budget#reader", "leaf": {"users": {"users": ["user:81684243-9356-4421-8fbf-a4f8d36aa31b"]}}}}}
-            '''
+            """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
-        async with openfga_sdk.ApiClient(configuration) as api_client:
+        with ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
             body = ExpandRequest(
                 tuple_key=ExpandRequestTupleKey(
                     object="document:budget",
                     relation="reader",
                 ),
                 authorization_model_id="01GXSA8YR785C4FYS3C0RTG7B1",
             )
-            api_response = await api_instance.expand(
+            api_response = api_instance.expand(
                 body=body,
             )
             self.assertIsInstance(api_response, ExpandResponse)
             cur_users = Users(users=["user:81684243-9356-4421-8fbf-a4f8d36aa31b"])
             leaf = Leaf(users=cur_users)
             node = Node(name="document:budget#reader", leaf=leaf)
             userTree = UsersetTree(node)
             expected_response = ExpandResponse(userTree)
             self.assertEqual(api_response, expected_response)
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/expand',
+                "POST",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/expand",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:budget", "relation": "reader"},
-                      "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {"object": "document:budget", "relation": "reader"},
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
-            await api_client.close()
+            api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_get_store(self, mock_request):
         """Test case for get_store
 
-        Get a store  # noqa: E501
+        Get a store
         """
-        response_body = '''{
+        response_body = """{
   "id": "01H0H015178Y2V4CX10C2KGHF4",
   "name": "test_store",
   "created_at": "2022-07-25T20:45:10.485Z",
   "updated_at": "2022-07-25T20:45:10.485Z"
 }
-            '''
+            """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
-        async with openfga_sdk.ApiClient(configuration) as api_client:
+        with ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
             # Get a store
-            api_response = await api_instance.get_store()
+            api_response = api_instance.get_store()
             self.assertIsInstance(api_response, GetStoreResponse)
-            self.assertEqual(api_response.id, '01H0H015178Y2V4CX10C2KGHF4')
-            self.assertEqual(api_response.name, 'test_store')
+            self.assertEqual(api_response.id, "01H0H015178Y2V4CX10C2KGHF4")
+            self.assertEqual(api_response.name, "test_store")
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4',
+                "GET",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
-            await api_client.close()
+            api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_list_objects(self, mock_request):
         """Test case for list_objects
 
-        List objects  # noqa: E501
+        List objects
         """
-        response_body = '''
+        response_body = """
 {
   "objects": [
     "document:abcd1234"
   ]
 }
-            '''
+            """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
-        async with openfga_sdk.ApiClient(configuration) as api_client:
+        with ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
             body = ListObjectsRequest(
                 authorization_model_id="01G5JAVJ41T49E9TT3SKVS7X1J",
                 type="document",
                 relation="reader",
                 user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
             )
             # Get all stores
-            api_response = await api_instance.list_objects(body)
+            api_response = api_instance.list_objects(body)
             self.assertIsInstance(api_response, ListObjectsResponse)
-            self.assertEqual(api_response.objects, ['document:abcd1234'])
+            self.assertEqual(api_response.objects, ["document:abcd1234"])
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/list-objects',
+                "POST",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/list-objects",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={'authorization_model_id': '01G5JAVJ41T49E9TT3SKVS7X1J',
-                      'type': 'document', 'relation': 'reader', 'user': 'user:81684243-9356-4421-8fbf-a4f8d36aa31b'},
+                body={
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                    "type": "document",
+                    "relation": "reader",
+                    "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
-            await api_client.close()
+            api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_list_stores(self, mock_request):
         """Test case for list_stores
 
-        Get all stores  # noqa: E501
+        Get all stores
         """
-        response_body = '''
+        response_body = """
 {
   "stores": [
     {
       "id": "01YCP46JKYM8FJCQ37NMBYHE5X",
       "name": "store1",
       "created_at": "2022-07-25T21:15:37.524Z",
       "updated_at": "2022-07-25T21:15:37.524Z",
@@ -349,27 +374,29 @@
       "created_at": "2022-07-25T21:15:37.524Z",
       "updated_at": "2022-07-25T21:15:37.524Z",
       "deleted_at": "2022-07-25T21:15:37.524Z"
     }
   ],
   "continuation_token": "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ=="
 }
-            '''
+            """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
-        async with openfga_sdk.ApiClient(configuration) as api_client:
+        with ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
             # Get all stores
-            api_response = await api_instance.list_stores(
+            api_response = api_instance.list_stores(
                 page_size=1,
                 continuation_token="continuation_token_example",
             )
             self.assertIsInstance(api_response, ListStoresResponse)
-            self.assertEqual(api_response.continuation_token,
-                             "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==")
+            self.assertEqual(
+                api_response.continuation_token,
+                "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==",
+            )
             store1 = Store(
                 id="01YCP46JKYM8FJCQ37NMBYHE5X",
                 name="store1",
                 created_at=datetime.fromisoformat("2022-07-25T21:15:37.524+00:00"),
                 updated_at=datetime.fromisoformat("2022-07-25T21:15:37.524+00:00"),
                 deleted_at=datetime.fromisoformat("2022-07-25T21:15:37.524+00:00"),
             )
@@ -380,137 +407,152 @@
                 updated_at=datetime.fromisoformat("2022-07-25T21:15:37.524+00:00"),
                 deleted_at=datetime.fromisoformat("2022-07-25T21:15:37.524+00:00"),
             )
 
             stores = [store1, store2]
             self.assertEqual(api_response.stores, stores)
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores',
+                "GET",
+                "http://api.fga.example/stores",
                 headers=ANY,
-                query_params=[('page_size', 1), ('continuation_token',
-                                                 'continuation_token_example')],
+                query_params=[
+                    ("page_size", 1),
+                    ("continuation_token", "continuation_token_example"),
+                ],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
-            await api_client.close()
+            api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_read(self, mock_request):
         """Test case for read
 
-        Get tuples from the store that matches a query, without following userset rewrite rules  # noqa: E501
+        Get tuples from the store that matches a query, without following userset rewrite rules
         """
-        response_body = '''
+        response_body = """
             {
   "tuples": [
     {
       "key": {
         "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
         "relation": "reader",
         "object": "document:2021-budget"
       },
       "timestamp": "2021-10-06T15:32:11.128Z"
     }
   ],
   "continuation_token": ""
 }
-        '''
+        """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
-        async with openfga_sdk.ApiClient(configuration) as api_client:
+        with ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
             body = ReadRequest(
                 tuple_key=ReadRequestTupleKey(
                     object="document:2021-budget",
                     relation="reader",
                     user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                 ),
                 page_size=50,
                 continuation_token="eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==",
             )
-            api_response = await api_instance.read(
+            api_response = api_instance.read(
                 body=body,
             )
             self.assertIsInstance(api_response, ReadResponse)
-            key = TupleKey(user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
-                           relation="reader", object="document:2021-budget")
+            key = TupleKey(
+                user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                relation="reader",
+                object="document:2021-budget",
+            )
             timestamp = datetime.fromisoformat("2021-10-06T15:32:11.128+00:00")
             expected_data = ReadResponse(
-                tuples=[Tuple(key=key, timestamp=timestamp)], continuation_token='')
+                tuples=[Tuple(key=key, timestamp=timestamp)], continuation_token=""
+            )
             self.assertEqual(api_response, expected_data)
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/read',
+                "POST",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/read",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget", "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"},
-                      "page_size": 50, "continuation_token": "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ=="},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    },
+                    "page_size": 50,
+                    "continuation_token": "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_read_assertions(self, mock_request):
         """Test case for read_assertions
 
-        Read assertions for an authorization model ID  # noqa: E501
+        Read assertions for an authorization model ID
         """
-        response_body = '''
+        response_body = """
 {
   "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
   "assertions": [
     {
       "tuple_key": {
         "object": "document:2021-budget",
         "relation": "reader",
         "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"
       },
       "expectation": true
     }
   ]
 }
-        '''
+        """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
-        async with openfga_sdk.ApiClient(configuration) as api_client:
+        with ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
-            api_response = await api_instance.read_assertions(
+            api_response = api_instance.read_assertions(
                 "01G5JAVJ41T49E9TT3SKVS7X1J",
             )
             self.assertIsInstance(api_response, ReadAssertionsResponse)
-            self.assertEqual(api_response.authorization_model_id, '01G5JAVJ41T49E9TT3SKVS7X1J')
+            self.assertEqual(
+                api_response.authorization_model_id, "01G5JAVJ41T49E9TT3SKVS7X1J"
+            )
             assertion = Assertion(
                 tuple_key=TupleKeyWithoutCondition(
                     object="document:2021-budget",
                     relation="reader",
                     user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                 ),
                 expectation=True,
             )
             self.assertEqual(api_response.assertions, [assertion])
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/assertions/01G5JAVJ41T49E9TT3SKVS7X1J',
+                "GET",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/assertions/01G5JAVJ41T49E9TT3SKVS7X1J",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_read_authorization_model(self, mock_request):
         """Test case for read_authorization_model
 
-        Return a particular version of an authorization model  # noqa: E501
+        Return a particular version of an authorization model
         """
-        response_body = '''
+        response_body = """
 {
   "authorization_model": {
     "id": "01G5JAVJ41T49E9TT3SKVS7X1J",
     "schema_version":"1.1",
     "type_definitions": [
       {
         "type": "document",
@@ -534,129 +576,140 @@
             "this": {}
           }
         }
       }
     ]
   }
 }
-        '''
+        """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         # Enter a context with an instance of the API client
-        async with openfga_sdk.ApiClient(configuration) as api_client:
+        with ApiClient(configuration) as api_client:
             # Create an instance of the API class
             api_instance = open_fga_api.OpenFgaApi(api_client)
 
             # Return a particular version of an authorization model
-            api_response = await api_instance.read_authorization_model(
+            api_response = api_instance.read_authorization_model(
                 "01G5JAVJ41T49E9TT3SKVS7X1J",
             )
             self.assertIsInstance(api_response, ReadAuthorizationModelResponse)
             type_definitions = [
                 TypeDefinition(
                     type="document",
                     relations=dict(
                         reader=Userset(
                             union=Usersets(
                                 child=[
                                     Userset(this=dict()),
-                                    Userset(computed_userset=ObjectRelation(
-                                        object="",
-                                        relation="writer",
-                                    )),
+                                    Userset(
+                                        computed_userset=ObjectRelation(
+                                            object="",
+                                            relation="writer",
+                                        )
+                                    ),
                                 ],
                             ),
                         ),
                         writer=Userset(
                             this=dict(),
                         ),
-                    )
+                    ),
                 )
             ]
-            authorization_model = AuthorizationModel(id='01G5JAVJ41T49E9TT3SKVS7X1J', schema_version="1.1",
-                                                     type_definitions=type_definitions)
+            authorization_model = AuthorizationModel(
+                id="01G5JAVJ41T49E9TT3SKVS7X1J",
+                schema_version="1.1",
+                type_definitions=type_definitions,
+            )
             self.assertEqual(api_response.authorization_model, authorization_model)
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J',
+                "GET",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_read_changes(self, mock_request):
         """Test case for read_changes
 
-        Return a list of all the tuple changes  # noqa: E501
+        Return a list of all the tuple changes
         """
-        response_body = '''
+        response_body = """
 {
   "changes": [
     {
       "tuple_key": {
         "object": "document:2021-budget",
         "relation": "reader",
         "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"
       },
       "operation": "TUPLE_OPERATION_WRITE",
       "timestamp": "2022-07-26T15:55:55.809Z"
     }
   ],
   "continuation_token": "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ=="
 }
-        '''
+        """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         # Enter a context with an instance of the API client
-        async with openfga_sdk.ApiClient(configuration) as api_client:
+        with ApiClient(configuration) as api_client:
             # Create an instance of the API class
             api_instance = open_fga_api.OpenFgaApi(api_client)
 
             # Return a particular version of an authorization model
-            api_response = await api_instance.read_changes(
-                page_size=1,
-                continuation_token="abcdefg",
-                type="document"
+            api_response = api_instance.read_changes(
+                page_size=1, continuation_token="abcdefg", type="document"
             )
             self.assertIsInstance(api_response, ReadChangesResponse)
             changes = TupleChange(
-                tuple_key=TupleKey(object="document:2021-budget", relation="reader",
-                                   user="user:81684243-9356-4421-8fbf-a4f8d36aa31b"),
+                tuple_key=TupleKey(
+                    object="document:2021-budget",
+                    relation="reader",
+                    user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                ),
                 operation=TupleOperation.WRITE,
-                timestamp=datetime.fromisoformat("2022-07-26T15:55:55.809+00:00"))
+                timestamp=datetime.fromisoformat("2022-07-26T15:55:55.809+00:00"),
+            )
             read_changes = ReadChangesResponse(
-                continuation_token='eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==',
-                changes=[changes])
+                continuation_token="eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==",
+                changes=[changes],
+            )
             self.assertEqual(api_response, read_changes)
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/changes',
+                "GET",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/changes",
                 headers=ANY,
-                query_params=[('type', 'document'), ('page_size', 1),
-                              ('continuation_token', 'abcdefg')],
+                query_params=[
+                    ("type", "document"),
+                    ("page_size", 1),
+                    ("continuation_token", "abcdefg"),
+                ],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_write(self, mock_request):
         """Test case for write
 
-        Add tuples from the store  # noqa: E501
+        Add tuples from the store
         """
-        response_body = '{}'
+        response_body = "{}"
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         # Enter a context with an instance of the API client
-        async with openfga_sdk.ApiClient(configuration) as api_client:
+        with ApiClient(configuration) as api_client:
             # Create an instance of the API class
             api_instance = open_fga_api.OpenFgaApi(api_client)
 
             # example passing only required values which don't have defaults set
 
             body = WriteRequest(
                 writes=WriteRequestWrites(
@@ -666,41 +719,51 @@
                             relation="reader",
                             user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                         )
                     ],
                 ),
                 authorization_model_id="01G5JAVJ41T49E9TT3SKVS7X1J",
             )
-            await api_instance.write(
+            api_instance.write(
                 body,
             )
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/write',
+                "POST",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                 "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_write_delete(self, mock_request):
         """Test case for write
 
-        Delete tuples from the store  # noqa: E501
+        Delete tuples from the store
         """
-        response_body = '{}'
+        response_body = "{}"
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         # Enter a context with an instance of the API client
-        async with openfga_sdk.ApiClient(configuration) as api_client:
+        with ApiClient(configuration) as api_client:
             # Create an instance of the API class
             api_instance = open_fga_api.OpenFgaApi(api_client)
 
             # example passing only required values which don't have defaults set
 
             body = WriteRequest(
                 deletes=WriteRequestDeletes(
@@ -710,41 +773,51 @@
                             relation="reader",
                             user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                         )
                     ],
                 ),
                 authorization_model_id="01G5JAVJ41T49E9TT3SKVS7X1J",
             )
-            await api_instance.write(
+            api_instance.write(
                 body,
             )
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/write',
+                "POST",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"deletes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                  "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "deletes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_write_assertions(self, mock_request):
         """Test case for write_assertions
 
-        Upsert assertions for an authorization model ID  # noqa: E501
+        Upsert assertions for an authorization model ID
         """
-        response_body = ''
+        response_body = ""
         mock_request.return_value = mock_response(response_body, 204)
         configuration = self.configuration
         configuration.store_id = store_id
         # Enter a context with an instance of the API client
-        async with openfga_sdk.ApiClient(configuration) as api_client:
+        with ApiClient(configuration) as api_client:
             # Create an instance of the API class
             api_instance = open_fga_api.OpenFgaApi(api_client)
 
             # example passing only required values which don't have defaults set
             body = WriteAssertionsRequest(
                 assertions=[
                     Assertion(
@@ -754,41 +827,51 @@
                             user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                         ),
                         expectation=True,
                     )
                 ],
             )
             # Upsert assertions for an authorization model ID
-            await api_instance.write_assertions(
+            api_instance.write_assertions(
                 authorization_model_id="xyz0123",
                 body=body,
             )
             mock_request.assert_called_once_with(
-                'PUT',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/assertions/xyz0123',
+                "PUT",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/assertions/xyz0123",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"assertions": [{"expectation": True, "tuple_key": {
-                    "object": "document:2021-budget", "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}}]},
+                body={
+                    "assertions": [
+                        {
+                            "expectation": True,
+                            "tuple_key": {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                            },
+                        }
+                    ]
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_write_authorization_model(self, mock_request):
         """Test case for write_authorization_model
 
-        Create a new authorization model  # noqa: E501
+        Create a new authorization model
         """
         response_body = '{"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"}'
         mock_request.return_value = mock_response(response_body, 201)
         configuration = self.configuration
         configuration.store_id = store_id
-        async with openfga_sdk.ApiClient(configuration) as api_client:
+        with ApiClient(configuration) as api_client:
             # Create an instance of the API class
             api_instance = open_fga_api.OpenFgaApi(api_client)
 
             # example passing only required values which don't have defaults set
             body = WriteAuthorizationModelRequest(
                 schema_version="1.1",
                 type_definitions=[
@@ -798,465 +881,595 @@
                             writer=Userset(
                                 this=dict(),
                             ),
                             reader=Userset(
                                 union=Usersets(
                                     child=[
                                         Userset(this=dict()),
-                                        Userset(computed_userset=ObjectRelation(
-                                            object="",
-                                            relation="writer",
-                                        )),
+                                        Userset(
+                                            computed_userset=ObjectRelation(
+                                                object="",
+                                                relation="writer",
+                                            )
+                                        ),
                                     ],
                                 ),
                             ),
-                        )
+                        ),
                     ),
                 ],
             )
             # Create a new authorization model
-            api_response = await api_instance.write_authorization_model(
-                body
-            )
+            api_response = api_instance.write_authorization_model(body)
             self.assertIsInstance(api_response, WriteAuthorizationModelResponse)
             expected_response = WriteAuthorizationModelResponse(
-                authorization_model_id='01G5JAVJ41T49E9TT3SKVS7X1J'
+                authorization_model_id="01G5JAVJ41T49E9TT3SKVS7X1J"
             )
             self.assertEqual(api_response, expected_response)
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/authorization-models',
+                "POST",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/authorization-models",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"schema_version": "1.1", "type_definitions": [{"type": "document", "relations": {"writer": {"this": {
-                }}, "reader": {"union": {"child": [{"this": {}}, {"computedUserset": {"object": "", "relation": "writer"}}]}}}}]},
+                body={
+                    "schema_version": "1.1",
+                    "type_definitions": [
+                        {
+                            "type": "document",
+                            "relations": {
+                                "writer": {"this": {}},
+                                "reader": {
+                                    "union": {
+                                        "child": [
+                                            {"this": {}},
+                                            {
+                                                "computedUserset": {
+                                                    "object": "",
+                                                    "relation": "writer",
+                                                }
+                                            },
+                                        ]
+                                    }
+                                },
+                            },
+                        }
+                    ],
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
     def test_default_scheme(self):
         """
         Ensure default scheme is https
         """
-        configuration = openfga_sdk.Configuration(
-            api_host='localhost'
-        )
-        self.assertEqual(configuration.api_scheme, 'https')
+        configuration = Configuration(api_host="localhost")
+        self.assertEqual(configuration.api_scheme, "https")
 
     def test_host_port(self):
         """
         Ensure host has port will not raise error
         """
-        configuration = openfga_sdk.Configuration(
-            api_host='localhost:3000'
-        )
-        self.assertEqual(configuration.api_host, 'localhost:3000')
+        configuration = Configuration(api_host="localhost:3000")
+        self.assertEqual(configuration.api_host, "localhost:3000")
 
     def test_configuration_missing_host(self):
         """
         Test whether FgaValidationException is raised if configuration does not have host specified
         """
-        configuration = openfga_sdk.Configuration(
-            api_scheme='http'
-        )
+        configuration = Configuration(api_scheme="http")
         self.assertRaises(FgaValidationException, configuration.is_valid)
 
     def test_configuration_missing_scheme(self):
         """
         Test whether FgaValidationException is raised if configuration does not have scheme specified
         """
-        configuration = openfga_sdk.Configuration(
-            api_host='localhost'
-        )
+        configuration = Configuration(api_host="localhost")
         configuration.api_scheme = None
         self.assertRaises(FgaValidationException, configuration.is_valid)
 
     def test_configuration_bad_scheme(self):
         """
         Test whether ApiValueError is raised if scheme is bad
         """
-        configuration = openfga_sdk.Configuration(
-            api_host='localhost',
-            api_scheme='foo'
-        )
+        configuration = Configuration(api_host="localhost", api_scheme="foo")
         self.assertRaises(ApiValueError, configuration.is_valid)
 
     def test_configuration_bad_host(self):
         """
         Test whether ApiValueError is raised if host is bad
         """
-        configuration = openfga_sdk.Configuration(
-            api_host='/',
-            api_scheme='foo'
-        )
+        configuration = Configuration(api_host="/", api_scheme="foo")
         self.assertRaises(ApiValueError, configuration.is_valid)
 
     def test_configuration_has_path(self):
         """
         Test whether ApiValueError is raised if host has path
         """
-        configuration = openfga_sdk.Configuration(
-            api_host='localhost/mypath',
-            api_scheme='http'
-        )
+        configuration = Configuration(api_host="localhost/mypath", api_scheme="http")
         self.assertRaises(ApiValueError, configuration.is_valid)
 
     def test_configuration_has_query(self):
         """
         Test whether ApiValueError is raised if host has query
         """
-        configuration = openfga_sdk.Configuration(
-            api_host='localhost?mypath=foo',
-            api_scheme='http'
+        configuration = Configuration(
+            api_host="localhost?mypath=foo", api_scheme="http"
         )
         self.assertRaises(ApiValueError, configuration.is_valid)
 
     def test_configuration_store_id_invalid(self):
         """
         Test whether ApiValueError is raised if host has query
         """
-        configuration = openfga_sdk.Configuration(
-            api_host='localhost',
-            api_scheme='http',
-            store_id="abcd"
+        configuration = Configuration(
+            api_host="localhost", api_scheme="http", store_id="abcd"
         )
         self.assertRaises(FgaValidationException, configuration.is_valid)
 
     def test_url(self):
         """
         Ensure that api_url is set and validated
         """
-        configuration = openfga_sdk.Configuration(
-            api_url='http://localhost:8080'
-        )
-        self.assertEqual(configuration.api_url, 'http://localhost:8080')
+        configuration = Configuration(api_url="http://localhost:8080")
+        self.assertEqual(configuration.api_url, "http://localhost:8080")
         configuration.is_valid()
 
     def test_url_with_scheme_and_host(self):
         """
         Ensure that api_url takes precedence over api_host and scheme
         """
-        configuration = openfga_sdk.Configuration(
-            api_url='http://localhost:8080',
-            api_host='localhost:8080',
-            api_scheme='foo'
+        configuration = Configuration(
+            api_url="http://localhost:8080", api_host="localhost:8080", api_scheme="foo"
         )
-        self.assertEqual(configuration.api_url, 'http://localhost:8080')
+        self.assertEqual(configuration.api_url, "http://localhost:8080")
         configuration.is_valid()  # Should not throw and complain about scheme being invalid
 
     async def test_bad_configuration_read_authorization_model(self):
         """
         Test whether FgaValidationException is raised for API (reading authorization models)
         with configuration is having incorrect API scheme
         """
-        configuration = openfga_sdk.Configuration(
-            api_scheme='bad',
+        configuration = Configuration(
+            api_scheme="bad",
             api_host="api.fga.example",
         )
-        configuration.store_id = 'xyz123'
+        configuration.store_id = "xyz123"
         # Enter a context with an instance of the API client
-        async with openfga_sdk.ApiClient(configuration) as api_client:
+        with ApiClient(configuration) as api_client:
             # Create an instance of the API class
             api_instance = open_fga_api.OpenFgaApi(api_client)
 
             # expects FgaValidationException to be thrown because api_scheme is bad
             with self.assertRaises(ApiValueError):
-                await api_instance.read_authorization_models(
-                    page_size=1,
-                    continuation_token="abcdefg"
+                api_instance.read_authorization_models(
+                    page_size=1, continuation_token="abcdefg"
                 )
 
     async def test_configuration_missing_storeid(self):
         """
         Test whether FgaValidationException is raised for API (reading authorization models)
         required store ID but configuration is missing store ID
         """
-        configuration = openfga_sdk.Configuration(
-            api_scheme='http',
+        configuration = Configuration(
+            api_scheme="http",
             api_host="api.fga.example",
         )
         # Notice the store_id is not set
         # Enter a context with an instance of the API client
-        async with openfga_sdk.ApiClient(configuration) as api_client:
+        with ApiClient(configuration) as api_client:
             # Create an instance of the API class
             api_instance = open_fga_api.OpenFgaApi(api_client)
 
             # expects FgaValidationException to be thrown because store_id is not specified
             with self.assertRaises(FgaValidationException):
-                await api_instance.read_authorization_models(
-                    page_size=1,
-                    continuation_token="abcdefg"
+                api_instance.read_authorization_models(
+                    page_size=1, continuation_token="abcdefg"
                 )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_400_error(self, mock_request):
         """
         Test to ensure 400 errors are handled properly
         """
-        response_body = '''
+        response_body = """
 {
   "code": "validation_error",
   "message": "Generic validation error"
 }
-        '''
+        """
         mock_request.side_effect = ValidationException(
-            http_resp=http_mock_response(response_body, 400))
+            http_resp=http_mock_response(response_body, 400)
+        )
 
         configuration = self.configuration
         configuration.store_id = store_id
-        async with openfga_sdk.ApiClient(configuration) as api_client:
+        with ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
             body = CheckRequest(
                 tuple_key=TupleKey(
                     object="document:2021-budget",
                     relation="reader",
                     user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                 ),
             )
             with self.assertRaises(ValidationException) as api_exception:
-                await api_instance.check(
+                api_instance.check(
                     body=body,
                 )
-            self.assertIsInstance(api_exception.exception.parsed_exception,
-                                  ValidationErrorMessageResponse)
-            self.assertEqual(api_exception.exception.parsed_exception.code,
-                             ErrorCode.VALIDATION_ERROR)
-            self.assertEqual(api_exception.exception.parsed_exception.message,
-                             "Generic validation error")
-            self.assertEqual(api_exception.exception.header.get(FGA_REQUEST_ID), request_id)
+            self.assertIsInstance(
+                api_exception.exception.parsed_exception, ValidationErrorMessageResponse
+            )
+            self.assertEqual(
+                api_exception.exception.parsed_exception.code,
+                ErrorCode.VALIDATION_ERROR,
+            )
+            self.assertEqual(
+                api_exception.exception.parsed_exception.message,
+                "Generic validation error",
+            )
+            self.assertEqual(
+                api_exception.exception.header.get(FGA_REQUEST_ID), request_id
+            )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_404_error(self, mock_request):
         """
         Test to ensure 404 errors are handled properly
         """
-        response_body = '''
+        response_body = """
 {
   "code": "undefined_endpoint",
   "message": "Endpoint not enabled"
 }
-        '''
+        """
         mock_request.side_effect = NotFoundException(
-            http_resp=http_mock_response(response_body, 404))
+            http_resp=http_mock_response(response_body, 404)
+        )
 
         configuration = self.configuration
         configuration.store_id = store_id
-        async with openfga_sdk.ApiClient(configuration) as api_client:
+        with ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
             body = CheckRequest(
                 tuple_key=TupleKey(
                     object="document:2021-budget",
                     relation="reader",
                     user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                 ),
             )
             with self.assertRaises(NotFoundException) as api_exception:
-                await api_instance.check(
+                api_instance.check(
                     body=body,
                 )
-            self.assertIsInstance(api_exception.exception.parsed_exception,
-                                  PathUnknownErrorMessageResponse)
-            self.assertEqual(api_exception.exception.parsed_exception.code,
-                             NotFoundErrorCode.UNDEFINED_ENDPOINT)
-            self.assertEqual(api_exception.exception.parsed_exception.message,
-                             "Endpoint not enabled")
+            self.assertIsInstance(
+                api_exception.exception.parsed_exception,
+                PathUnknownErrorMessageResponse,
+            )
+            self.assertEqual(
+                api_exception.exception.parsed_exception.code,
+                NotFoundErrorCode.UNDEFINED_ENDPOINT,
+            )
+            self.assertEqual(
+                api_exception.exception.parsed_exception.message, "Endpoint not enabled"
+            )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_429_error_no_retry(self, mock_request):
         """
         Test to ensure 429 errors are handled properly.
         For this case, there is no retry configured
         """
-        response_body = '''
+        response_body = """
 {
   "code": "rate_limit_exceeded",
   "message": "Rate Limit exceeded"
 }
-        '''
+        """
         mock_request.side_effect = RateLimitExceededError(
-            http_resp=http_mock_response(response_body, 429))
+            http_resp=http_mock_response(response_body, 429)
+        )
 
         retry = openfga_sdk.configuration.RetryParams(0, 10)
         configuration = self.configuration
         configuration.store_id = store_id
         configuration.retry_params = retry
-        async with openfga_sdk.ApiClient(configuration) as api_client:
+        with ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
             body = CheckRequest(
                 tuple_key=TupleKey(
                     object="document:2021-budget",
                     relation="reader",
                     user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                 ),
             )
             with self.assertRaises(RateLimitExceededError) as api_exception:
-                await api_instance.check(
+                api_instance.check(
                     body=body,
                 )
             self.assertIsInstance(api_exception.exception, RateLimitExceededError)
             mock_request.assert_called()
             self.assertEqual(mock_request.call_count, 1)
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_429_error_first_error(self, mock_request):
         """
         Test to ensure 429 errors are handled properly.
         For this case, retry is configured and only the first time has error
         """
         response_body = '{"allowed": true, "resolution": "1234"}'
-        error_response_body = '''
+        error_response_body = """
 {
   "code": "rate_limit_exceeded",
   "message": "Rate Limit exceeded"
 }
-        '''
-        mock_request.side_effect = [RateLimitExceededError(http_resp=http_mock_response(
-            error_response_body, 429)), mock_response(response_body, 200)]
+        """
+        mock_request.side_effect = [
+            RateLimitExceededError(
+                http_resp=http_mock_response(error_response_body, 429)
+            ),
+            mock_response(response_body, 200),
+        ]
 
         retry = openfga_sdk.configuration.RetryParams(1, 10)
         configuration = self.configuration
         configuration.store_id = store_id
         configuration.retry_params = retry
-        async with openfga_sdk.ApiClient(configuration) as api_client:
+        with ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
             body = CheckRequest(
                 tuple_key=TupleKey(
                     object="document:2021-budget",
                     relation="reader",
                     user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                 ),
             )
-            api_response = await api_instance.check(
+            api_response = api_instance.check(
                 body=body,
             )
             self.assertIsInstance(api_response, CheckResponse)
             self.assertTrue(api_response.allowed)
             mock_request.assert_called()
             self.assertEqual(mock_request.call_count, 2)
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_500_error(self, mock_request):
         """
         Test to ensure 500 errors are handled properly
         """
-        response_body = '''
+        response_body = """
 {
   "code": "internal_error",
   "message": "Internal Server Error"
 }
-        '''
+        """
         mock_request.side_effect = ServiceException(
-            http_resp=http_mock_response(response_body, 500))
+            http_resp=http_mock_response(response_body, 500)
+        )
+
+        configuration = self.configuration
+        configuration.store_id = store_id
+        configuration.retry_params.max_retry = 0
+
+        with ApiClient(configuration) as api_client:
+            api_instance = open_fga_api.OpenFgaApi(api_client)
+            body = CheckRequest(
+                tuple_key=TupleKey(
+                    object="document:2021-budget",
+                    relation="reader",
+                    user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                ),
+            )
+            with self.assertRaises(ServiceException) as api_exception:
+                api_instance.check(
+                    body=body,
+                )
+            self.assertIsInstance(
+                api_exception.exception.parsed_exception, InternalErrorMessageResponse
+            )
+            self.assertEqual(
+                api_exception.exception.parsed_exception.code,
+                InternalErrorCode.INTERNAL_ERROR,
+            )
+            self.assertEqual(
+                api_exception.exception.parsed_exception.message,
+                "Internal Server Error",
+            )
+            mock_request.assert_called()
+            self.assertEqual(mock_request.call_count, 1)
+
+        @patch.object(rest.RESTClientObject, "request")
+        async def test_500_error(self, mock_request):
+            """
+            Test to ensure 5xx retries are handled properly
+            """
+            response_body = """
+    {
+      "code": "internal_error",
+      "message": "Internal Server Error"
+    }
+            """
+            mock_request.side_effect = [
+                ServiceException(http_resp=http_mock_response(response_body, 500)),
+                ServiceException(http_resp=http_mock_response(response_body, 502)),
+                ServiceException(http_resp=http_mock_response(response_body, 503)),
+                ServiceException(http_resp=http_mock_response(response_body, 504)),
+                mock_response(response_body, 200),
+            ]
+
+            retry = openfga_sdk.configuration.RetryParams(5, 10)
+            configuration = self.configuration
+            configuration.store_id = store_id
+            configuration.retry_params = retry
+
+            with ApiClient(configuration) as api_client:
+                api_instance = open_fga_api.OpenFgaApi(api_client)
+                body = CheckRequest(
+                    tuple_key=TupleKey(
+                        object="document:2021-budget",
+                        relation="reader",
+                        user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    ),
+                )
 
+                api_response = api_instance.check(
+                    body=body,
+                )
+
+                self.assertIsInstance(api_response, CheckResponse)
+                mock_request.assert_called()
+                self.assertEqual(mock_request.call_count, 5)
+
+    @patch.object(rest.RESTClientObject, "request")
+    async def test_501_error_retry(self, mock_request):
+        """
+        Test to ensure 501 responses are not auto-retried
+        """
+        response_body = """
+{
+  "code": "not_implemented",
+  "message": "Not Implemented"
+}
+        """
+        mock_request.side_effect = [
+            ServiceException(http_resp=http_mock_response(response_body, 501)),
+            ServiceException(http_resp=http_mock_response(response_body, 501)),
+            ServiceException(http_resp=http_mock_response(response_body, 501)),
+            mock_response(response_body, 200),
+        ]
+
+        retry = openfga_sdk.configuration.RetryParams(5, 10)
         configuration = self.configuration
         configuration.store_id = store_id
-        async with openfga_sdk.ApiClient(configuration) as api_client:
+        configuration.retry_params = retry
+
+        with ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
             body = CheckRequest(
                 tuple_key=TupleKey(
                     object="document:2021-budget",
                     relation="reader",
                     user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                 ),
             )
             with self.assertRaises(ServiceException) as api_exception:
-                await api_instance.check(
+                api_instance.check(
                     body=body,
                 )
-            self.assertIsInstance(api_exception.exception.parsed_exception,
-                                  InternalErrorMessageResponse)
-            self.assertEqual(api_exception.exception.parsed_exception.code,
-                             InternalErrorCode.INTERNAL_ERROR)
-            self.assertEqual(api_exception.exception.parsed_exception.message,
-                             "Internal Server Error")
+            mock_request.assert_called()
+            self.assertEqual(mock_request.call_count, 1)
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_check_api_token(self, mock_request):
         """Test case for API token
 
         Check whether API token is send when configuration specifies credential method as api_token
         """
 
         # First, mock the response
         response_body = '{"allowed": true}'
         mock_request.return_value = mock_response(response_body, 200)
 
         configuration = self.configuration
         configuration.store_id = store_id
         configuration.credentials = Credentials(
-            method='api_token', configuration=CredentialConfiguration(api_token='TOKEN1'))
-        async with openfga_sdk.ApiClient(configuration) as api_client:
+            method="api_token",
+            configuration=CredentialConfiguration(api_token="TOKEN1"),
+        )
+        with ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
             body = CheckRequest(
                 tuple_key=TupleKey(
                     object="document:2021-budget",
                     relation="reader",
                     user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                 ),
             )
-            api_response = await api_instance.check(
+            api_response = api_instance.check(
                 body=body,
             )
             self.assertIsInstance(api_response, CheckResponse)
             self.assertTrue(api_response.allowed)
             # Make sure the API was called with the right data
             expected_headers = urllib3.response.HTTPHeaderDict(
-                {'Accept': 'application/json', 'Content-Type': 'application/json', 'User-Agent': 'openfga-sdk python/0.4.1', 'Authorization': 'Bearer TOKEN1'})
+                {
+                    "Accept": "application/json",
+                    "Content-Type": "application/json",
+                    "User-Agent": "openfga-sdk python/0.4.2",
+                    "Authorization": "Bearer TOKEN1",
+                }
+            )
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/check',
+                "POST",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/check",
                 headers=expected_headers,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget", "relation": "reader",
-                                    "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    }
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_check_custom_header(self, mock_request):
         """Test case for custom header
 
         Check whether custom header can be added
         """
 
         # First, mock the response
         response_body = '{"allowed": true}'
         mock_request.return_value = mock_response(response_body, 200)
 
         configuration = self.configuration
         configuration.store_id = store_id
-        async with openfga_sdk.ApiClient(configuration) as api_client:
+        with ApiClient(configuration) as api_client:
             api_client.set_default_header("Custom Header", "custom value")
             api_instance = open_fga_api.OpenFgaApi(api_client)
             body = CheckRequest(
                 tuple_key=TupleKey(
                     object="document:2021-budget",
                     relation="reader",
                     user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                 ),
             )
-            api_response = await api_instance.check(
+            api_response = api_instance.check(
                 body=body,
             )
             self.assertIsInstance(api_response, CheckResponse)
             self.assertTrue(api_response.allowed)
             # Make sure the API was called with the right data
             expected_headers = urllib3.response.HTTPHeaderDict(
-                {'Accept': 'application/json', 'Content-Type': 'application/json', 'User-Agent': 'openfga-sdk python/0.4.1', 'Custom Header': 'custom value'})
+                {
+                    "Accept": "application/json",
+                    "Content-Type": "application/json",
+                    "User-Agent": "openfga-sdk python/0.4.2",
+                    "Custom Header": "custom value",
+                }
+            )
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/check',
+                "POST",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/check",
                 headers=expected_headers,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget", "relation": "reader",
-                                    "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    }
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
 
-if __name__ == '__main__':
+if __name__ == "__main__":
     unittest.main()
```

### Comparing `openfga-sdk-0.4.1/test/test_open_fga_api_sync.py` & `openfga-sdk-0.4.2/test/test_open_fga_api.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,344 +1,367 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 import unittest
-from unittest.mock import ANY
-from unittest import IsolatedAsyncioTestCase
-from mock import patch
 from datetime import datetime
+from unittest import IsolatedAsyncioTestCase
+from unittest.mock import ANY, patch
 
 import urllib3
 
-import openfga_sdk.sync
-from openfga_sdk.sync import rest, open_fga_api
-from openfga_sdk.sync.api_client import ApiClient
-from openfga_sdk.credentials import Credentials, CredentialConfiguration
-from openfga_sdk.configuration import Configuration
-from openfga_sdk.exceptions import FgaValidationException, ApiValueError, NotFoundException, RateLimitExceededError, ServiceException, ValidationException, FGA_REQUEST_ID
+import openfga_sdk
+from openfga_sdk import rest
+from openfga_sdk.api import open_fga_api
+from openfga_sdk.credentials import CredentialConfiguration, Credentials
+from openfga_sdk.exceptions import (
+    FGA_REQUEST_ID,
+    ApiValueError,
+    FgaValidationException,
+    NotFoundException,
+    RateLimitExceededError,
+    ServiceException,
+    ValidationException,
+)
 from openfga_sdk.models.assertion import Assertion
 from openfga_sdk.models.authorization_model import AuthorizationModel
 from openfga_sdk.models.check_request import CheckRequest
 from openfga_sdk.models.check_response import CheckResponse
 from openfga_sdk.models.create_store_request import CreateStoreRequest
 from openfga_sdk.models.create_store_response import CreateStoreResponse
 from openfga_sdk.models.error_code import ErrorCode
 from openfga_sdk.models.expand_request import ExpandRequest
 from openfga_sdk.models.expand_request_tuple_key import ExpandRequestTupleKey
 from openfga_sdk.models.expand_response import ExpandResponse
 from openfga_sdk.models.get_store_response import GetStoreResponse
 from openfga_sdk.models.internal_error_code import InternalErrorCode
-from openfga_sdk.models.internal_error_message_response import InternalErrorMessageResponse
+from openfga_sdk.models.internal_error_message_response import (
+    InternalErrorMessageResponse,
+)
 from openfga_sdk.models.leaf import Leaf
 from openfga_sdk.models.list_objects_request import ListObjectsRequest
 from openfga_sdk.models.list_objects_response import ListObjectsResponse
 from openfga_sdk.models.list_stores_response import ListStoresResponse
 from openfga_sdk.models.node import Node
 from openfga_sdk.models.not_found_error_code import NotFoundErrorCode
 from openfga_sdk.models.object_relation import ObjectRelation
-from openfga_sdk.models.path_unknown_error_message_response import PathUnknownErrorMessageResponse
+from openfga_sdk.models.path_unknown_error_message_response import (
+    PathUnknownErrorMessageResponse,
+)
 from openfga_sdk.models.read_assertions_response import ReadAssertionsResponse
-from openfga_sdk.models.read_authorization_model_response import ReadAuthorizationModelResponse
+from openfga_sdk.models.read_authorization_model_response import (
+    ReadAuthorizationModelResponse,
+)
 from openfga_sdk.models.read_changes_response import ReadChangesResponse
 from openfga_sdk.models.read_request import ReadRequest
 from openfga_sdk.models.read_request_tuple_key import ReadRequestTupleKey
 from openfga_sdk.models.read_response import ReadResponse
 from openfga_sdk.models.store import Store
 from openfga_sdk.models.tuple import Tuple
 from openfga_sdk.models.tuple_change import TupleChange
 from openfga_sdk.models.tuple_key import TupleKey
 from openfga_sdk.models.tuple_key_without_condition import TupleKeyWithoutCondition
-from openfga_sdk.models.write_request_writes import WriteRequestWrites
-from openfga_sdk.models.write_request_deletes import WriteRequestDeletes
 from openfga_sdk.models.tuple_operation import TupleOperation
 from openfga_sdk.models.type_definition import TypeDefinition
 from openfga_sdk.models.users import Users
 from openfga_sdk.models.userset import Userset
 from openfga_sdk.models.userset_tree import UsersetTree
 from openfga_sdk.models.usersets import Usersets
-from openfga_sdk.models.validation_error_message_response import ValidationErrorMessageResponse
+from openfga_sdk.models.validation_error_message_response import (
+    ValidationErrorMessageResponse,
+)
 from openfga_sdk.models.write_assertions_request import WriteAssertionsRequest
-from openfga_sdk.models.write_authorization_model_request import WriteAuthorizationModelRequest
-from openfga_sdk.models.write_authorization_model_response import WriteAuthorizationModelResponse
+from openfga_sdk.models.write_authorization_model_request import (
+    WriteAuthorizationModelRequest,
+)
+from openfga_sdk.models.write_authorization_model_response import (
+    WriteAuthorizationModelResponse,
+)
 from openfga_sdk.models.write_request import WriteRequest
+from openfga_sdk.models.write_request_deletes import WriteRequestDeletes
+from openfga_sdk.models.write_request_writes import WriteRequestWrites
 
-store_id = '01H0H015178Y2V4CX10C2KGHF4'
-request_id = 'x1y2z3'
-
-# Helper function to construct mock response
+store_id = "01H0H015178Y2V4CX10C2KGHF4"
+request_id = "x1y2z3"
 
 
+# Helper function to construct mock response
 def http_mock_response(body, status):
-    headers = urllib3.response.HTTPHeaderDict({
-        'content-type': 'application/json',
-        'Fga-Request-Id': request_id
-    })
+    headers = urllib3.response.HTTPHeaderDict(
+        {"content-type": "application/json", "Fga-Request-Id": request_id}
+    )
     return urllib3.HTTPResponse(
-        body.encode('utf-8'),
-        headers,
-        status,
-        preload_content=False
+        body.encode("utf-8"), headers, status, preload_content=False
     )
 
 
 def mock_response(body, status):
     obj = http_mock_response(body, status)
     return rest.RESTResponse(obj, obj.data)
 
 
-class TestOpenFgaApiSync(IsolatedAsyncioTestCase):
-    """openfga_sdk.sync.OpenFgaApi unit test stubs"""
+class TestOpenFgaApi(IsolatedAsyncioTestCase):
+    """OpenFgaApi unit test stubs"""
 
     def setUp(self):
-        self.configuration = Configuration(
-            api_url='http://api.fga.example',
+        self.configuration = openfga_sdk.Configuration(
+            api_url="http://api.fga.example",
         )
 
     def tearDown(self):
         pass
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_check(self, mock_request):
         """Test case for check
 
-        Check whether a user is authorized to access an object  # noqa: E501
+        Check whether a user is authorized to access an object
         """
 
         # First, mock the response
         response_body = '{"allowed": true, "resolution": "1234"}'
         mock_request.return_value = mock_response(response_body, 200)
 
         configuration = self.configuration
         configuration.store_id = store_id
-        with ApiClient(configuration) as api_client:
+        async with openfga_sdk.ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
             body = CheckRequest(
                 tuple_key=TupleKey(
                     object="document:2021-budget",
                     relation="reader",
                     user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                 ),
                 authorization_model_id="01GXSA8YR785C4FYS3C0RTG7B1",
             )
-            api_response = api_instance.check(
+            api_response = await api_instance.check(
                 body=body,
             )
             self.assertIsInstance(api_response, CheckResponse)
             self.assertTrue(api_response.allowed)
             # Make sure the API was called with the right data
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/check',
+                "POST",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/check",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget",
-                                    "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}, "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    },
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
-            api_client.close()
+            await api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_create_store(self, mock_request):
         """Test case for create_store
 
-        Create a store  # noqa: E501
+        Create a store
         """
-        response_body = '''{
+        response_body = """{
             "id": "01YCP46JKYM8FJCQ37NMBYHE5X",
             "name": "test_store",
             "created_at": "2022-07-25T17:41:26.607Z",
             "updated_at": "2022-07-25T17:41:26.607Z"}
-            '''
+            """
         mock_request.return_value = mock_response(response_body, 201)
 
         configuration = self.configuration
-        with ApiClient(configuration) as api_client:
+        async with openfga_sdk.ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
             body = CreateStoreRequest(
                 name="test-store",
             )
-            api_response = api_instance.create_store(
+            api_response = await api_instance.create_store(
                 body=body,
             )
             self.assertIsInstance(api_response, CreateStoreResponse)
-            self.assertEqual(api_response.id, '01YCP46JKYM8FJCQ37NMBYHE5X')
+            self.assertEqual(api_response.id, "01YCP46JKYM8FJCQ37NMBYHE5X")
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores',
+                "POST",
+                "http://api.fga.example/stores",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
                 body={"name": "test-store"},
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
-            api_client.close()
+            await api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_delete_store(self, mock_request):
         """Test case for delete_store
 
-        Delete a store  # noqa: E501
+        Delete a store
         """
-        response_body = ''
+        response_body = ""
         mock_request.return_value = mock_response(response_body, 201)
         configuration = self.configuration
         configuration.store_id = store_id
-        with ApiClient(configuration) as api_client:
+        async with openfga_sdk.ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
-            api_instance.delete_store()
+            await api_instance.delete_store()
             mock_request.assert_called_once_with(
-                'DELETE',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4',
+                "DELETE",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4",
                 headers=ANY,
                 query_params=[],
                 body=None,
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
-            api_client.close()
+            await api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_expand(self, mock_request):
         """Test case for expand
 
-        Expand all relationships in userset tree format, and following userset rewrite rules.  Useful to reason about and debug a certain relationship  # noqa: E501
+        Expand all relationships in userset tree format, and following userset rewrite rules.  Useful to reason about and debug a certain relationship
         """
-        response_body = '''{
+        response_body = """{
             "tree": {"root": {"name": "document:budget#reader", "leaf": {"users": {"users": ["user:81684243-9356-4421-8fbf-a4f8d36aa31b"]}}}}}
-            '''
+            """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
-        with ApiClient(configuration) as api_client:
+        async with openfga_sdk.ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
             body = ExpandRequest(
                 tuple_key=ExpandRequestTupleKey(
                     object="document:budget",
                     relation="reader",
                 ),
                 authorization_model_id="01GXSA8YR785C4FYS3C0RTG7B1",
             )
-            api_response = api_instance.expand(
+            api_response = await api_instance.expand(
                 body=body,
             )
             self.assertIsInstance(api_response, ExpandResponse)
             cur_users = Users(users=["user:81684243-9356-4421-8fbf-a4f8d36aa31b"])
             leaf = Leaf(users=cur_users)
             node = Node(name="document:budget#reader", leaf=leaf)
             userTree = UsersetTree(node)
             expected_response = ExpandResponse(userTree)
             self.assertEqual(api_response, expected_response)
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/expand',
+                "POST",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/expand",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:budget", "relation": "reader"},
-                      "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1"},
+                body={
+                    "tuple_key": {"object": "document:budget", "relation": "reader"},
+                    "authorization_model_id": "01GXSA8YR785C4FYS3C0RTG7B1",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
-            api_client.close()
+            await api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_get_store(self, mock_request):
         """Test case for get_store
 
-        Get a store  # noqa: E501
+        Get a store
         """
-        response_body = '''{
+        response_body = """{
   "id": "01H0H015178Y2V4CX10C2KGHF4",
   "name": "test_store",
   "created_at": "2022-07-25T20:45:10.485Z",
   "updated_at": "2022-07-25T20:45:10.485Z"
 }
-            '''
+            """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
-        with ApiClient(configuration) as api_client:
+        async with openfga_sdk.ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
             # Get a store
-            api_response = api_instance.get_store()
+            api_response = await api_instance.get_store()
             self.assertIsInstance(api_response, GetStoreResponse)
-            self.assertEqual(api_response.id, '01H0H015178Y2V4CX10C2KGHF4')
-            self.assertEqual(api_response.name, 'test_store')
+            self.assertEqual(api_response.id, "01H0H015178Y2V4CX10C2KGHF4")
+            self.assertEqual(api_response.name, "test_store")
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4',
+                "GET",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
-            api_client.close()
+            await api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_list_objects(self, mock_request):
         """Test case for list_objects
 
-        List objects  # noqa: E501
+        List objects
         """
-        response_body = '''
+        response_body = """
 {
   "objects": [
     "document:abcd1234"
   ]
 }
-            '''
+            """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
-        with ApiClient(configuration) as api_client:
+        async with openfga_sdk.ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
             body = ListObjectsRequest(
                 authorization_model_id="01G5JAVJ41T49E9TT3SKVS7X1J",
                 type="document",
                 relation="reader",
                 user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
             )
             # Get all stores
-            api_response = api_instance.list_objects(body)
+            api_response = await api_instance.list_objects(body)
             self.assertIsInstance(api_response, ListObjectsResponse)
-            self.assertEqual(api_response.objects, ['document:abcd1234'])
+            self.assertEqual(api_response.objects, ["document:abcd1234"])
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/list-objects',
+                "POST",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/list-objects",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={'authorization_model_id': '01G5JAVJ41T49E9TT3SKVS7X1J',
-                      'type': 'document', 'relation': 'reader', 'user': 'user:81684243-9356-4421-8fbf-a4f8d36aa31b'},
+                body={
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                    "type": "document",
+                    "relation": "reader",
+                    "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
-            api_client.close()
+            await api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_list_stores(self, mock_request):
         """Test case for list_stores
 
-        Get all stores  # noqa: E501
+        Get all stores
         """
-        response_body = '''
+        response_body = """
 {
   "stores": [
     {
       "id": "01YCP46JKYM8FJCQ37NMBYHE5X",
       "name": "store1",
       "created_at": "2022-07-25T21:15:37.524Z",
       "updated_at": "2022-07-25T21:15:37.524Z",
@@ -350,27 +373,29 @@
       "created_at": "2022-07-25T21:15:37.524Z",
       "updated_at": "2022-07-25T21:15:37.524Z",
       "deleted_at": "2022-07-25T21:15:37.524Z"
     }
   ],
   "continuation_token": "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ=="
 }
-            '''
+            """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
-        with ApiClient(configuration) as api_client:
+        async with openfga_sdk.ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
             # Get all stores
-            api_response = api_instance.list_stores(
+            api_response = await api_instance.list_stores(
                 page_size=1,
                 continuation_token="continuation_token_example",
             )
             self.assertIsInstance(api_response, ListStoresResponse)
-            self.assertEqual(api_response.continuation_token,
-                             "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==")
+            self.assertEqual(
+                api_response.continuation_token,
+                "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==",
+            )
             store1 = Store(
                 id="01YCP46JKYM8FJCQ37NMBYHE5X",
                 name="store1",
                 created_at=datetime.fromisoformat("2022-07-25T21:15:37.524+00:00"),
                 updated_at=datetime.fromisoformat("2022-07-25T21:15:37.524+00:00"),
                 deleted_at=datetime.fromisoformat("2022-07-25T21:15:37.524+00:00"),
             )
@@ -381,137 +406,152 @@
                 updated_at=datetime.fromisoformat("2022-07-25T21:15:37.524+00:00"),
                 deleted_at=datetime.fromisoformat("2022-07-25T21:15:37.524+00:00"),
             )
 
             stores = [store1, store2]
             self.assertEqual(api_response.stores, stores)
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores',
+                "GET",
+                "http://api.fga.example/stores",
                 headers=ANY,
-                query_params=[('page_size', 1), ('continuation_token',
-                                                 'continuation_token_example')],
+                query_params=[
+                    ("page_size", 1),
+                    ("continuation_token", "continuation_token_example"),
+                ],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
-            api_client.close()
+            await api_client.close()
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_read(self, mock_request):
         """Test case for read
 
-        Get tuples from the store that matches a query, without following userset rewrite rules  # noqa: E501
+        Get tuples from the store that matches a query, without following userset rewrite rules
         """
-        response_body = '''
+        response_body = """
             {
   "tuples": [
     {
       "key": {
         "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
         "relation": "reader",
         "object": "document:2021-budget"
       },
       "timestamp": "2021-10-06T15:32:11.128Z"
     }
   ],
   "continuation_token": ""
 }
-        '''
+        """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
-        with ApiClient(configuration) as api_client:
+        async with openfga_sdk.ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
             body = ReadRequest(
                 tuple_key=ReadRequestTupleKey(
                     object="document:2021-budget",
                     relation="reader",
                     user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                 ),
                 page_size=50,
                 continuation_token="eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==",
             )
-            api_response = api_instance.read(
+            api_response = await api_instance.read(
                 body=body,
             )
             self.assertIsInstance(api_response, ReadResponse)
-            key = TupleKey(user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
-                           relation="reader", object="document:2021-budget")
+            key = TupleKey(
+                user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                relation="reader",
+                object="document:2021-budget",
+            )
             timestamp = datetime.fromisoformat("2021-10-06T15:32:11.128+00:00")
             expected_data = ReadResponse(
-                tuples=[Tuple(key=key, timestamp=timestamp)], continuation_token='')
+                tuples=[Tuple(key=key, timestamp=timestamp)], continuation_token=""
+            )
             self.assertEqual(api_response, expected_data)
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/read',
+                "POST",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/read",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget", "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"},
-                      "page_size": 50, "continuation_token": "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ=="},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    },
+                    "page_size": 50,
+                    "continuation_token": "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_read_assertions(self, mock_request):
         """Test case for read_assertions
 
-        Read assertions for an authorization model ID  # noqa: E501
+        Read assertions for an authorization model ID
         """
-        response_body = '''
+        response_body = """
 {
   "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
   "assertions": [
     {
       "tuple_key": {
         "object": "document:2021-budget",
         "relation": "reader",
         "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"
       },
       "expectation": true
     }
   ]
 }
-        '''
+        """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
-        with ApiClient(configuration) as api_client:
+        async with openfga_sdk.ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
-            api_response = api_instance.read_assertions(
+            api_response = await api_instance.read_assertions(
                 "01G5JAVJ41T49E9TT3SKVS7X1J",
             )
             self.assertIsInstance(api_response, ReadAssertionsResponse)
-            self.assertEqual(api_response.authorization_model_id, '01G5JAVJ41T49E9TT3SKVS7X1J')
+            self.assertEqual(
+                api_response.authorization_model_id, "01G5JAVJ41T49E9TT3SKVS7X1J"
+            )
             assertion = Assertion(
                 tuple_key=TupleKeyWithoutCondition(
                     object="document:2021-budget",
                     relation="reader",
                     user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                 ),
                 expectation=True,
             )
             self.assertEqual(api_response.assertions, [assertion])
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/assertions/01G5JAVJ41T49E9TT3SKVS7X1J',
+                "GET",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/assertions/01G5JAVJ41T49E9TT3SKVS7X1J",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_read_authorization_model(self, mock_request):
         """Test case for read_authorization_model
 
-        Return a particular version of an authorization model  # noqa: E501
+        Return a particular version of an authorization model
         """
-        response_body = '''
+        response_body = """
 {
   "authorization_model": {
     "id": "01G5JAVJ41T49E9TT3SKVS7X1J",
     "schema_version":"1.1",
     "type_definitions": [
       {
         "type": "document",
@@ -535,129 +575,140 @@
             "this": {}
           }
         }
       }
     ]
   }
 }
-        '''
+        """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         # Enter a context with an instance of the API client
-        with ApiClient(configuration) as api_client:
+        async with openfga_sdk.ApiClient(configuration) as api_client:
             # Create an instance of the API class
             api_instance = open_fga_api.OpenFgaApi(api_client)
 
             # Return a particular version of an authorization model
-            api_response = api_instance.read_authorization_model(
+            api_response = await api_instance.read_authorization_model(
                 "01G5JAVJ41T49E9TT3SKVS7X1J",
             )
             self.assertIsInstance(api_response, ReadAuthorizationModelResponse)
             type_definitions = [
                 TypeDefinition(
                     type="document",
                     relations=dict(
                         reader=Userset(
                             union=Usersets(
                                 child=[
                                     Userset(this=dict()),
-                                    Userset(computed_userset=ObjectRelation(
-                                        object="",
-                                        relation="writer",
-                                    )),
+                                    Userset(
+                                        computed_userset=ObjectRelation(
+                                            object="",
+                                            relation="writer",
+                                        )
+                                    ),
                                 ],
                             ),
                         ),
                         writer=Userset(
                             this=dict(),
                         ),
-                    )
+                    ),
                 )
             ]
-            authorization_model = AuthorizationModel(id='01G5JAVJ41T49E9TT3SKVS7X1J', schema_version="1.1",
-                                                     type_definitions=type_definitions)
+            authorization_model = AuthorizationModel(
+                id="01G5JAVJ41T49E9TT3SKVS7X1J",
+                schema_version="1.1",
+                type_definitions=type_definitions,
+            )
             self.assertEqual(api_response.authorization_model, authorization_model)
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J',
+                "GET",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/authorization-models/01G5JAVJ41T49E9TT3SKVS7X1J",
                 headers=ANY,
                 query_params=[],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_read_changes(self, mock_request):
         """Test case for read_changes
 
-        Return a list of all the tuple changes  # noqa: E501
+        Return a list of all the tuple changes
         """
-        response_body = '''
+        response_body = """
 {
   "changes": [
     {
       "tuple_key": {
         "object": "document:2021-budget",
         "relation": "reader",
         "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"
       },
       "operation": "TUPLE_OPERATION_WRITE",
       "timestamp": "2022-07-26T15:55:55.809Z"
     }
   ],
   "continuation_token": "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ=="
 }
-        '''
+        """
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         # Enter a context with an instance of the API client
-        with ApiClient(configuration) as api_client:
+        async with openfga_sdk.ApiClient(configuration) as api_client:
             # Create an instance of the API class
             api_instance = open_fga_api.OpenFgaApi(api_client)
 
             # Return a particular version of an authorization model
-            api_response = api_instance.read_changes(
-                page_size=1,
-                continuation_token="abcdefg",
-                type="document"
+            api_response = await api_instance.read_changes(
+                page_size=1, continuation_token="abcdefg", type="document"
             )
             self.assertIsInstance(api_response, ReadChangesResponse)
             changes = TupleChange(
-                tuple_key=TupleKey(object="document:2021-budget", relation="reader",
-                                   user="user:81684243-9356-4421-8fbf-a4f8d36aa31b"),
+                tuple_key=TupleKey(
+                    object="document:2021-budget",
+                    relation="reader",
+                    user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                ),
                 operation=TupleOperation.WRITE,
-                timestamp=datetime.fromisoformat("2022-07-26T15:55:55.809+00:00"))
+                timestamp=datetime.fromisoformat("2022-07-26T15:55:55.809+00:00"),
+            )
             read_changes = ReadChangesResponse(
-                continuation_token='eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==',
-                changes=[changes])
+                continuation_token="eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==",
+                changes=[changes],
+            )
             self.assertEqual(api_response, read_changes)
             mock_request.assert_called_once_with(
-                'GET',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/changes',
+                "GET",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/changes",
                 headers=ANY,
-                query_params=[('type', 'document'), ('page_size', 1),
-                              ('continuation_token', 'abcdefg')],
+                query_params=[
+                    ("type", "document"),
+                    ("page_size", 1),
+                    ("continuation_token", "abcdefg"),
+                ],
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_write(self, mock_request):
         """Test case for write
 
-        Add tuples from the store  # noqa: E501
+        Add tuples from the store
         """
-        response_body = '{}'
+        response_body = "{}"
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         # Enter a context with an instance of the API client
-        with ApiClient(configuration) as api_client:
+        async with openfga_sdk.ApiClient(configuration) as api_client:
             # Create an instance of the API class
             api_instance = open_fga_api.OpenFgaApi(api_client)
 
             # example passing only required values which don't have defaults set
 
             body = WriteRequest(
                 writes=WriteRequestWrites(
@@ -667,41 +718,51 @@
                             relation="reader",
                             user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                         )
                     ],
                 ),
                 authorization_model_id="01G5JAVJ41T49E9TT3SKVS7X1J",
             )
-            api_instance.write(
+            await api_instance.write(
                 body,
             )
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/write',
+                "POST",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"writes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                 "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "writes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_write_delete(self, mock_request):
         """Test case for write
 
-        Delete tuples from the store  # noqa: E501
+        Delete tuples from the store
         """
-        response_body = '{}'
+        response_body = "{}"
         mock_request.return_value = mock_response(response_body, 200)
         configuration = self.configuration
         configuration.store_id = store_id
         # Enter a context with an instance of the API client
-        with ApiClient(configuration) as api_client:
+        async with openfga_sdk.ApiClient(configuration) as api_client:
             # Create an instance of the API class
             api_instance = open_fga_api.OpenFgaApi(api_client)
 
             # example passing only required values which don't have defaults set
 
             body = WriteRequest(
                 deletes=WriteRequestDeletes(
@@ -711,41 +772,51 @@
                             relation="reader",
                             user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                         )
                     ],
                 ),
                 authorization_model_id="01G5JAVJ41T49E9TT3SKVS7X1J",
             )
-            api_instance.write(
+            await api_instance.write(
                 body,
             )
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/write',
+                "POST",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/write",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"deletes": {"tuple_keys": [{"object": "document:2021-budget", "relation": "reader",
-                                                  "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}]}, "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"},
+                body={
+                    "deletes": {
+                        "tuple_keys": [
+                            {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                            }
+                        ]
+                    },
+                    "authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J",
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_write_assertions(self, mock_request):
         """Test case for write_assertions
 
-        Upsert assertions for an authorization model ID  # noqa: E501
+        Upsert assertions for an authorization model ID
         """
-        response_body = ''
+        response_body = ""
         mock_request.return_value = mock_response(response_body, 204)
         configuration = self.configuration
         configuration.store_id = store_id
         # Enter a context with an instance of the API client
-        with ApiClient(configuration) as api_client:
+        async with openfga_sdk.ApiClient(configuration) as api_client:
             # Create an instance of the API class
             api_instance = open_fga_api.OpenFgaApi(api_client)
 
             # example passing only required values which don't have defaults set
             body = WriteAssertionsRequest(
                 assertions=[
                     Assertion(
@@ -755,41 +826,51 @@
                             user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                         ),
                         expectation=True,
                     )
                 ],
             )
             # Upsert assertions for an authorization model ID
-            api_instance.write_assertions(
+            await api_instance.write_assertions(
                 authorization_model_id="xyz0123",
                 body=body,
             )
             mock_request.assert_called_once_with(
-                'PUT',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/assertions/xyz0123',
+                "PUT",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/assertions/xyz0123",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"assertions": [{"expectation": True, "tuple_key": {
-                    "object": "document:2021-budget", "relation": "reader", "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}}]},
+                body={
+                    "assertions": [
+                        {
+                            "expectation": True,
+                            "tuple_key": {
+                                "object": "document:2021-budget",
+                                "relation": "reader",
+                                "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                            },
+                        }
+                    ]
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_write_authorization_model(self, mock_request):
         """Test case for write_authorization_model
 
-        Create a new authorization model  # noqa: E501
+        Create a new authorization model
         """
         response_body = '{"authorization_model_id": "01G5JAVJ41T49E9TT3SKVS7X1J"}'
         mock_request.return_value = mock_response(response_body, 201)
         configuration = self.configuration
         configuration.store_id = store_id
-        with ApiClient(configuration) as api_client:
+        async with openfga_sdk.ApiClient(configuration) as api_client:
             # Create an instance of the API class
             api_instance = open_fga_api.OpenFgaApi(api_client)
 
             # example passing only required values which don't have defaults set
             body = WriteAuthorizationModelRequest(
                 schema_version="1.1",
                 type_definitions=[
@@ -799,465 +880,599 @@
                             writer=Userset(
                                 this=dict(),
                             ),
                             reader=Userset(
                                 union=Usersets(
                                     child=[
                                         Userset(this=dict()),
-                                        Userset(computed_userset=ObjectRelation(
-                                            object="",
-                                            relation="writer",
-                                        )),
+                                        Userset(
+                                            computed_userset=ObjectRelation(
+                                                object="",
+                                                relation="writer",
+                                            )
+                                        ),
                                     ],
                                 ),
                             ),
-                        )
+                        ),
                     ),
                 ],
             )
             # Create a new authorization model
-            api_response = api_instance.write_authorization_model(
-                body
-            )
+            api_response = await api_instance.write_authorization_model(body)
             self.assertIsInstance(api_response, WriteAuthorizationModelResponse)
             expected_response = WriteAuthorizationModelResponse(
-                authorization_model_id='01G5JAVJ41T49E9TT3SKVS7X1J'
+                authorization_model_id="01G5JAVJ41T49E9TT3SKVS7X1J"
             )
             self.assertEqual(api_response, expected_response)
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/authorization-models',
+                "POST",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/authorization-models",
                 headers=ANY,
                 query_params=[],
                 post_params=[],
-                body={"schema_version": "1.1", "type_definitions": [{"type": "document", "relations": {"writer": {"this": {
-                }}, "reader": {"union": {"child": [{"this": {}}, {"computedUserset": {"object": "", "relation": "writer"}}]}}}}]},
+                body={
+                    "schema_version": "1.1",
+                    "type_definitions": [
+                        {
+                            "type": "document",
+                            "relations": {
+                                "writer": {"this": {}},
+                                "reader": {
+                                    "union": {
+                                        "child": [
+                                            {"this": {}},
+                                            {
+                                                "computedUserset": {
+                                                    "object": "",
+                                                    "relation": "writer",
+                                                }
+                                            },
+                                        ]
+                                    }
+                                },
+                            },
+                        }
+                    ],
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
     def test_default_scheme(self):
         """
         Ensure default scheme is https
         """
-        configuration = Configuration(
-            api_host='localhost'
-        )
-        self.assertEqual(configuration.api_scheme, 'https')
+        configuration = openfga_sdk.Configuration(api_host="localhost")
+        self.assertEqual(configuration.api_scheme, "https")
 
     def test_host_port(self):
         """
         Ensure host has port will not raise error
         """
-        configuration = Configuration(
-            api_host='localhost:3000'
-        )
-        self.assertEqual(configuration.api_host, 'localhost:3000')
+        configuration = openfga_sdk.Configuration(api_host="localhost:3000")
+        self.assertEqual(configuration.api_host, "localhost:3000")
 
     def test_configuration_missing_host(self):
         """
         Test whether FgaValidationException is raised if configuration does not have host specified
         """
-        configuration = Configuration(
-            api_scheme='http'
-        )
+        configuration = openfga_sdk.Configuration(api_scheme="http")
         self.assertRaises(FgaValidationException, configuration.is_valid)
 
     def test_configuration_missing_scheme(self):
         """
         Test whether FgaValidationException is raised if configuration does not have scheme specified
         """
-        configuration = Configuration(
-            api_host='localhost'
-        )
+        configuration = openfga_sdk.Configuration(api_host="localhost")
         configuration.api_scheme = None
         self.assertRaises(FgaValidationException, configuration.is_valid)
 
     def test_configuration_bad_scheme(self):
         """
         Test whether ApiValueError is raised if scheme is bad
         """
-        configuration = Configuration(
-            api_host='localhost',
-            api_scheme='foo'
+        configuration = openfga_sdk.Configuration(
+            api_host="localhost", api_scheme="foo"
         )
         self.assertRaises(ApiValueError, configuration.is_valid)
 
     def test_configuration_bad_host(self):
         """
         Test whether ApiValueError is raised if host is bad
         """
-        configuration = Configuration(
-            api_host='/',
-            api_scheme='foo'
-        )
+        configuration = openfga_sdk.Configuration(api_host="/", api_scheme="foo")
         self.assertRaises(ApiValueError, configuration.is_valid)
 
     def test_configuration_has_path(self):
         """
         Test whether ApiValueError is raised if host has path
         """
-        configuration = Configuration(
-            api_host='localhost/mypath',
-            api_scheme='http'
+        configuration = openfga_sdk.Configuration(
+            api_host="localhost/mypath", api_scheme="http"
         )
         self.assertRaises(ApiValueError, configuration.is_valid)
 
     def test_configuration_has_query(self):
         """
         Test whether ApiValueError is raised if host has query
         """
-        configuration = Configuration(
-            api_host='localhost?mypath=foo',
-            api_scheme='http'
+        configuration = openfga_sdk.Configuration(
+            api_host="localhost?mypath=foo", api_scheme="http"
         )
         self.assertRaises(ApiValueError, configuration.is_valid)
 
     def test_configuration_store_id_invalid(self):
         """
         Test whether ApiValueError is raised if host has query
         """
-        configuration = Configuration(
-            api_host='localhost',
-            api_scheme='http',
-            store_id="abcd"
+        configuration = openfga_sdk.Configuration(
+            api_host="localhost", api_scheme="http", store_id="abcd"
         )
         self.assertRaises(FgaValidationException, configuration.is_valid)
 
     def test_url(self):
         """
         Ensure that api_url is set and validated
         """
-        configuration = Configuration(
-            api_url='http://localhost:8080'
-        )
-        self.assertEqual(configuration.api_url, 'http://localhost:8080')
+        configuration = openfga_sdk.Configuration(api_url="http://localhost:8080")
+        self.assertEqual(configuration.api_url, "http://localhost:8080")
         configuration.is_valid()
 
     def test_url_with_scheme_and_host(self):
         """
         Ensure that api_url takes precedence over api_host and scheme
         """
-        configuration = Configuration(
-            api_url='http://localhost:8080',
-            api_host='localhost:8080',
-            api_scheme='foo'
+        configuration = openfga_sdk.Configuration(
+            api_url="http://localhost:8080", api_host="localhost:8080", api_scheme="foo"
         )
-        self.assertEqual(configuration.api_url, 'http://localhost:8080')
+        self.assertEqual(configuration.api_url, "http://localhost:8080")
         configuration.is_valid()  # Should not throw and complain about scheme being invalid
 
     async def test_bad_configuration_read_authorization_model(self):
         """
         Test whether FgaValidationException is raised for API (reading authorization models)
         with configuration is having incorrect API scheme
         """
-        configuration = Configuration(
-            api_scheme='bad',
+        configuration = openfga_sdk.Configuration(
+            api_scheme="bad",
             api_host="api.fga.example",
         )
-        configuration.store_id = 'xyz123'
+        configuration.store_id = "xyz123"
         # Enter a context with an instance of the API client
-        with ApiClient(configuration) as api_client:
+        async with openfga_sdk.ApiClient(configuration) as api_client:
             # Create an instance of the API class
             api_instance = open_fga_api.OpenFgaApi(api_client)
 
             # expects FgaValidationException to be thrown because api_scheme is bad
             with self.assertRaises(ApiValueError):
-                api_instance.read_authorization_models(
-                    page_size=1,
-                    continuation_token="abcdefg"
+                await api_instance.read_authorization_models(
+                    page_size=1, continuation_token="abcdefg"
                 )
 
     async def test_configuration_missing_storeid(self):
         """
         Test whether FgaValidationException is raised for API (reading authorization models)
         required store ID but configuration is missing store ID
         """
-        configuration = Configuration(
-            api_scheme='http',
+        configuration = openfga_sdk.Configuration(
+            api_scheme="http",
             api_host="api.fga.example",
         )
         # Notice the store_id is not set
         # Enter a context with an instance of the API client
-        with ApiClient(configuration) as api_client:
+        async with openfga_sdk.ApiClient(configuration) as api_client:
             # Create an instance of the API class
             api_instance = open_fga_api.OpenFgaApi(api_client)
 
             # expects FgaValidationException to be thrown because store_id is not specified
             with self.assertRaises(FgaValidationException):
-                api_instance.read_authorization_models(
-                    page_size=1,
-                    continuation_token="abcdefg"
+                await api_instance.read_authorization_models(
+                    page_size=1, continuation_token="abcdefg"
                 )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_400_error(self, mock_request):
         """
         Test to ensure 400 errors are handled properly
         """
-        response_body = '''
+        response_body = """
 {
   "code": "validation_error",
   "message": "Generic validation error"
 }
-        '''
+        """
         mock_request.side_effect = ValidationException(
-            http_resp=http_mock_response(response_body, 400))
+            http_resp=http_mock_response(response_body, 400)
+        )
 
         configuration = self.configuration
         configuration.store_id = store_id
-        with ApiClient(configuration) as api_client:
+        async with openfga_sdk.ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
             body = CheckRequest(
                 tuple_key=TupleKey(
                     object="document:2021-budget",
                     relation="reader",
                     user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                 ),
             )
             with self.assertRaises(ValidationException) as api_exception:
-                api_instance.check(
+                await api_instance.check(
                     body=body,
                 )
-            self.assertIsInstance(api_exception.exception.parsed_exception,
-                                  ValidationErrorMessageResponse)
-            self.assertEqual(api_exception.exception.parsed_exception.code,
-                             ErrorCode.VALIDATION_ERROR)
-            self.assertEqual(api_exception.exception.parsed_exception.message,
-                             "Generic validation error")
-            self.assertEqual(api_exception.exception.header.get(FGA_REQUEST_ID), request_id)
+            self.assertIsInstance(
+                api_exception.exception.parsed_exception, ValidationErrorMessageResponse
+            )
+            self.assertEqual(
+                api_exception.exception.parsed_exception.code,
+                ErrorCode.VALIDATION_ERROR,
+            )
+            self.assertEqual(
+                api_exception.exception.parsed_exception.message,
+                "Generic validation error",
+            )
+            self.assertEqual(
+                api_exception.exception.header.get(FGA_REQUEST_ID), request_id
+            )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_404_error(self, mock_request):
         """
         Test to ensure 404 errors are handled properly
         """
-        response_body = '''
+        response_body = """
 {
   "code": "undefined_endpoint",
   "message": "Endpoint not enabled"
 }
-        '''
+        """
         mock_request.side_effect = NotFoundException(
-            http_resp=http_mock_response(response_body, 404))
+            http_resp=http_mock_response(response_body, 404)
+        )
 
         configuration = self.configuration
         configuration.store_id = store_id
-        with ApiClient(configuration) as api_client:
+        async with openfga_sdk.ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
             body = CheckRequest(
                 tuple_key=TupleKey(
                     object="document:2021-budget",
                     relation="reader",
                     user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                 ),
             )
             with self.assertRaises(NotFoundException) as api_exception:
-                api_instance.check(
+                await api_instance.check(
                     body=body,
                 )
-            self.assertIsInstance(api_exception.exception.parsed_exception,
-                                  PathUnknownErrorMessageResponse)
-            self.assertEqual(api_exception.exception.parsed_exception.code,
-                             NotFoundErrorCode.UNDEFINED_ENDPOINT)
-            self.assertEqual(api_exception.exception.parsed_exception.message,
-                             "Endpoint not enabled")
+            self.assertIsInstance(
+                api_exception.exception.parsed_exception,
+                PathUnknownErrorMessageResponse,
+            )
+            self.assertEqual(
+                api_exception.exception.parsed_exception.code,
+                NotFoundErrorCode.UNDEFINED_ENDPOINT,
+            )
+            self.assertEqual(
+                api_exception.exception.parsed_exception.message, "Endpoint not enabled"
+            )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_429_error_no_retry(self, mock_request):
         """
         Test to ensure 429 errors are handled properly.
         For this case, there is no retry configured
         """
-        response_body = '''
+        response_body = """
 {
   "code": "rate_limit_exceeded",
   "message": "Rate Limit exceeded"
 }
-        '''
+        """
         mock_request.side_effect = RateLimitExceededError(
-            http_resp=http_mock_response(response_body, 429))
+            http_resp=http_mock_response(response_body, 429)
+        )
 
         retry = openfga_sdk.configuration.RetryParams(0, 10)
         configuration = self.configuration
         configuration.store_id = store_id
         configuration.retry_params = retry
-        with ApiClient(configuration) as api_client:
+        async with openfga_sdk.ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
             body = CheckRequest(
                 tuple_key=TupleKey(
                     object="document:2021-budget",
                     relation="reader",
                     user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                 ),
             )
             with self.assertRaises(RateLimitExceededError) as api_exception:
-                api_instance.check(
+                await api_instance.check(
                     body=body,
                 )
             self.assertIsInstance(api_exception.exception, RateLimitExceededError)
             mock_request.assert_called()
             self.assertEqual(mock_request.call_count, 1)
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_429_error_first_error(self, mock_request):
         """
         Test to ensure 429 errors are handled properly.
         For this case, retry is configured and only the first time has error
         """
         response_body = '{"allowed": true, "resolution": "1234"}'
-        error_response_body = '''
+        error_response_body = """
 {
   "code": "rate_limit_exceeded",
   "message": "Rate Limit exceeded"
 }
-        '''
-        mock_request.side_effect = [RateLimitExceededError(http_resp=http_mock_response(
-            error_response_body, 429)), mock_response(response_body, 200)]
+        """
+        mock_request.side_effect = [
+            RateLimitExceededError(
+                http_resp=http_mock_response(error_response_body, 429)
+            ),
+            mock_response(response_body, 200),
+        ]
 
         retry = openfga_sdk.configuration.RetryParams(1, 10)
         configuration = self.configuration
         configuration.store_id = store_id
         configuration.retry_params = retry
-        with ApiClient(configuration) as api_client:
+        async with openfga_sdk.ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
             body = CheckRequest(
                 tuple_key=TupleKey(
                     object="document:2021-budget",
                     relation="reader",
                     user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                 ),
             )
-            api_response = api_instance.check(
+            api_response = await api_instance.check(
                 body=body,
             )
             self.assertIsInstance(api_response, CheckResponse)
             self.assertTrue(api_response.allowed)
             mock_request.assert_called()
             self.assertEqual(mock_request.call_count, 2)
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_500_error(self, mock_request):
         """
         Test to ensure 500 errors are handled properly
         """
-        response_body = '''
+        response_body = """
 {
   "code": "internal_error",
   "message": "Internal Server Error"
 }
-        '''
+        """
         mock_request.side_effect = ServiceException(
-            http_resp=http_mock_response(response_body, 500))
+            http_resp=http_mock_response(response_body, 500)
+        )
 
         configuration = self.configuration
         configuration.store_id = store_id
-        with ApiClient(configuration) as api_client:
+        configuration.retry_params.max_retry = 0
+
+        async with openfga_sdk.ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
             body = CheckRequest(
                 tuple_key=TupleKey(
                     object="document:2021-budget",
                     relation="reader",
                     user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                 ),
             )
             with self.assertRaises(ServiceException) as api_exception:
-                api_instance.check(
+                await api_instance.check(
                     body=body,
                 )
-            self.assertIsInstance(api_exception.exception.parsed_exception,
-                                  InternalErrorMessageResponse)
-            self.assertEqual(api_exception.exception.parsed_exception.code,
-                             InternalErrorCode.INTERNAL_ERROR)
-            self.assertEqual(api_exception.exception.parsed_exception.message,
-                             "Internal Server Error")
+            self.assertIsInstance(
+                api_exception.exception.parsed_exception, InternalErrorMessageResponse
+            )
+            self.assertEqual(
+                api_exception.exception.parsed_exception.code,
+                InternalErrorCode.INTERNAL_ERROR,
+            )
+            self.assertEqual(
+                api_exception.exception.parsed_exception.message,
+                "Internal Server Error",
+            )
+            mock_request.assert_called()
+            self.assertEqual(mock_request.call_count, 1)
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
+    async def test_500_error_retry(self, mock_request):
+        """
+        Test to ensure 5xxx retries  are handled properly
+        """
+        response_body = """
+{
+  "code": "internal_error",
+  "message": "Internal Server Error"
+}
+        """
+        mock_request.side_effect = [
+            ServiceException(http_resp=http_mock_response(response_body, 500)),
+            ServiceException(http_resp=http_mock_response(response_body, 502)),
+            ServiceException(http_resp=http_mock_response(response_body, 503)),
+            ServiceException(http_resp=http_mock_response(response_body, 504)),
+            mock_response(response_body, 200),
+        ]
+
+        retry = openfga_sdk.configuration.RetryParams(5, 10)
+        configuration = self.configuration
+        configuration.store_id = store_id
+        configuration.retry_params = retry
+
+        async with openfga_sdk.ApiClient(configuration) as api_client:
+            api_instance = open_fga_api.OpenFgaApi(api_client)
+            body = CheckRequest(
+                tuple_key=TupleKey(
+                    object="document:2021-budget",
+                    relation="reader",
+                    user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                ),
+            )
+
+            api_response = await api_instance.check(
+                body=body,
+            )
+
+            self.assertIsInstance(api_response, CheckResponse)
+            mock_request.assert_called()
+            self.assertEqual(mock_request.call_count, 5)
+
+    @patch.object(rest.RESTClientObject, "request")
+    async def test_501_error_retry(self, mock_request):
+        """
+        Test to ensure 501 responses are not auto-retried
+        """
+        response_body = """
+{
+  "code": "not_implemented",
+  "message": "Not Implemented"
+}
+        """
+        mock_request.side_effect = [
+            ServiceException(http_resp=http_mock_response(response_body, 501)),
+            ServiceException(http_resp=http_mock_response(response_body, 501)),
+            ServiceException(http_resp=http_mock_response(response_body, 501)),
+            mock_response(response_body, 200),
+        ]
+
+        retry = openfga_sdk.configuration.RetryParams(5, 10)
+        configuration = self.configuration
+        configuration.store_id = store_id
+        configuration.retry_params = retry
+
+        async with openfga_sdk.ApiClient(configuration) as api_client:
+            api_instance = open_fga_api.OpenFgaApi(api_client)
+            body = CheckRequest(
+                tuple_key=TupleKey(
+                    object="document:2021-budget",
+                    relation="reader",
+                    user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                ),
+            )
+            with self.assertRaises(ServiceException) as api_exception:
+                await api_instance.check(
+                    body=body,
+                )
+            mock_request.assert_called()
+            self.assertEqual(mock_request.call_count, 1)
+
+    @patch.object(rest.RESTClientObject, "request")
     async def test_check_api_token(self, mock_request):
         """Test case for API token
 
         Check whether API token is send when configuration specifies credential method as api_token
         """
 
         # First, mock the response
         response_body = '{"allowed": true}'
         mock_request.return_value = mock_response(response_body, 200)
 
         configuration = self.configuration
         configuration.store_id = store_id
         configuration.credentials = Credentials(
-            method='api_token', configuration=CredentialConfiguration(api_token='TOKEN1'))
-        with ApiClient(configuration) as api_client:
+            method="api_token",
+            configuration=CredentialConfiguration(api_token="TOKEN1"),
+        )
+        async with openfga_sdk.ApiClient(configuration) as api_client:
             api_instance = open_fga_api.OpenFgaApi(api_client)
             body = CheckRequest(
                 tuple_key=TupleKey(
                     object="document:2021-budget",
                     relation="reader",
                     user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                 ),
             )
-            api_response = api_instance.check(
+            api_response = await api_instance.check(
                 body=body,
             )
             self.assertIsInstance(api_response, CheckResponse)
             self.assertTrue(api_response.allowed)
             # Make sure the API was called with the right data
             expected_headers = urllib3.response.HTTPHeaderDict(
-                {'Accept': 'application/json', 'Content-Type': 'application/json', 'User-Agent': 'openfga-sdk python/0.4.1', 'Authorization': 'Bearer TOKEN1'})
+                {
+                    "Accept": "application/json",
+                    "Content-Type": "application/json",
+                    "User-Agent": "openfga-sdk python/0.4.2",
+                    "Authorization": "Bearer TOKEN1",
+                }
+            )
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/check',
+                "POST",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/check",
                 headers=expected_headers,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget", "relation": "reader",
-                                    "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    }
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
-    @patch.object(rest.RESTClientObject, 'request')
+    @patch.object(rest.RESTClientObject, "request")
     async def test_check_custom_header(self, mock_request):
         """Test case for custom header
 
         Check whether custom header can be added
         """
 
         # First, mock the response
         response_body = '{"allowed": true}'
         mock_request.return_value = mock_response(response_body, 200)
 
         configuration = self.configuration
         configuration.store_id = store_id
-        with ApiClient(configuration) as api_client:
+        async with openfga_sdk.ApiClient(configuration) as api_client:
             api_client.set_default_header("Custom Header", "custom value")
             api_instance = open_fga_api.OpenFgaApi(api_client)
             body = CheckRequest(
                 tuple_key=TupleKey(
                     object="document:2021-budget",
                     relation="reader",
                     user="user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                 ),
             )
-            api_response = api_instance.check(
+            api_response = await api_instance.check(
                 body=body,
             )
             self.assertIsInstance(api_response, CheckResponse)
             self.assertTrue(api_response.allowed)
             # Make sure the API was called with the right data
             expected_headers = urllib3.response.HTTPHeaderDict(
-                {'Accept': 'application/json', 'Content-Type': 'application/json', 'User-Agent': 'openfga-sdk python/0.4.1', 'Custom Header': 'custom value'})
+                {
+                    "Accept": "application/json",
+                    "Content-Type": "application/json",
+                    "User-Agent": "openfga-sdk python/0.4.2",
+                    "Custom Header": "custom value",
+                }
+            )
             mock_request.assert_called_once_with(
-                'POST',
-                'http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/check',
+                "POST",
+                "http://api.fga.example/stores/01H0H015178Y2V4CX10C2KGHF4/check",
                 headers=expected_headers,
                 query_params=[],
                 post_params=[],
-                body={"tuple_key": {"object": "document:2021-budget", "relation": "reader",
-                                    "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b"}},
+                body={
+                    "tuple_key": {
+                        "object": "document:2021-budget",
+                        "relation": "reader",
+                        "user": "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
+                    }
+                },
                 _preload_content=ANY,
-                _request_timeout=None
+                _request_timeout=None,
             )
 
 
-if __name__ == '__main__':
+if __name__ == "__main__":
     unittest.main()
```

### Comparing `openfga-sdk-0.4.1/test/test_validation.py` & `openfga-sdk-0.4.2/test/test_validation.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,16 +1,14 @@
-# coding: utf-8
-
 """
    Python SDK for OpenFGA
 
    API version: 0.1
    Website: https://openfga.dev
    Documentation: https://openfga.dev/docs
-   Support: https://discord.gg/8naAwJfWN6
+   Support: https://openfga.dev/community
    License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)
 
    NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 """
 
 import unittest
 
@@ -23,26 +21,47 @@
     def setUp(self):
         pass
 
     def tearDown(self):
         pass
 
     def test_is_well_formed_ulid_string_valid_ulids(self):
-        self.assertEqual(is_well_formed_ulid_string(
-            "01H0GVCS1HCQM6SJRJ4A026FZ9"), True, "Should be True")
-        self.assertEqual(is_well_formed_ulid_string(
-            "01H0GVD9ACPFKGMWJV0Y93ZM7H"), True, "Should be True")
-        self.assertEqual(is_well_formed_ulid_string(
-            "01H0GVDH0FRZ4WAFED6T9KZYZR"), True, "Should be True")
-        self.assertEqual(is_well_formed_ulid_string(
-            "01H0GVDSW72AZ8QV3R0HJ91QBX"), True, "Should be True")
+        self.assertEqual(
+            is_well_formed_ulid_string("01H0GVCS1HCQM6SJRJ4A026FZ9"),
+            True,
+            "Should be True",
+        )
+        self.assertEqual(
+            is_well_formed_ulid_string("01H0GVD9ACPFKGMWJV0Y93ZM7H"),
+            True,
+            "Should be True",
+        )
+        self.assertEqual(
+            is_well_formed_ulid_string("01H0GVDH0FRZ4WAFED6T9KZYZR"),
+            True,
+            "Should be True",
+        )
+        self.assertEqual(
+            is_well_formed_ulid_string("01H0GVDSW72AZ8QV3R0HJ91QBX"),
+            True,
+            "Should be True",
+        )
 
     def test_is_well_formed_ulid_string_invalid_ulids(self):
         self.assertEqual(is_well_formed_ulid_string("abc"), False, "Should be False")
         self.assertEqual(is_well_formed_ulid_string(123), False, "Should be False")
         self.assertEqual(is_well_formed_ulid_string(None), False, "Should be False")
-        self.assertEqual(is_well_formed_ulid_string(
-            "01H0GVDSW72AZ8QV3R0HJ91QBXa"), False, "Should be False")
-        self.assertEqual(is_well_formed_ulid_string(
-            "b523ad13-8adb-4803-a6db-013ac50197ca"), False, "Should be False")
-        self.assertEqual(is_well_formed_ulid_string(
-            "9240BFC0-DA00-457B-A328-FC370A598D60"), False, "Should be False")
+        self.assertEqual(
+            is_well_formed_ulid_string("01H0GVDSW72AZ8QV3R0HJ91QBXa"),
+            False,
+            "Should be False",
+        )
+        self.assertEqual(
+            is_well_formed_ulid_string("b523ad13-8adb-4803-a6db-013ac50197ca"),
+            False,
+            "Should be False",
+        )
+        self.assertEqual(
+            is_well_formed_ulid_string("9240BFC0-DA00-457B-A328-FC370A598D60"),
+            False,
+            "Should be False",
+        )
```

