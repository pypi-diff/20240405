# Comparing `tmp/dateroll-0.2.2-py3-none-any.whl.zip` & `tmp/dateroll-0.2.3-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,42 +1,44 @@
-Zip file size: 467645 bytes, number of entries: 40
--rw-r--r--  2.0 unx     1086 b- defN 24-Mar-29 20:42 dateroll/__init__.py
+Zip file size: 468020 bytes, number of entries: 42
+-rw-r--r--  2.0 unx     1086 b- defN 24-Apr-05 15:27 dateroll/__init__.py
 -rw-r--r--  2.0 unx        0 b- defN 24-Feb-29 23:50 dateroll/__main__.py
--rw-r--r--  2.0 unx     3272 b- defN 24-Apr-01 22:24 dateroll/pretty.py
--rw-r--r--  2.0 unx     4255 b- defN 24-Apr-03 13:30 dateroll/settings.py
--rw-r--r--  2.0 unx     1425 b- defN 24-Mar-28 22:33 dateroll/tblfmt.py
--rw-r--r--  2.0 unx     4493 b- defN 24-Apr-01 16:43 dateroll/utils.py
+-rw-r--r--  2.0 unx      454 b- defN 24-Apr-05 16:06 dateroll/cli.py
+-rw-r--r--  2.0 unx     3232 b- defN 24-Apr-05 15:27 dateroll/pretty.py
+-rw-r--r--  2.0 unx     4233 b- defN 24-Apr-05 15:27 dateroll/settings.py
+-rw-r--r--  2.0 unx     1440 b- defN 24-Apr-05 15:27 dateroll/tblfmt.py
+-rw-r--r--  2.0 unx     4526 b- defN 24-Apr-05 15:27 dateroll/utils.py
 -rw-r--r--  2.0 unx        0 b- defN 24-Feb-29 23:50 dateroll/calendars/__init__.py
 -rw-r--r--  2.0 unx        0 b- defN 24-Feb-29 23:50 dateroll/calendars/__main__.py
--rw-r--r--  2.0 unx    11084 b- defN 24-Apr-03 21:28 dateroll/calendars/calendarmath.py
--rw-r--r--  2.0 unx     9172 b- defN 24-Apr-03 21:28 dateroll/calendars/calendars.py
+-rw-r--r--  2.0 unx    11076 b- defN 24-Apr-05 15:27 dateroll/calendars/calendarmath.py
+-rw-r--r--  2.0 unx     9327 b- defN 24-Apr-05 15:27 dateroll/calendars/calendars.py
 -rw-r--r--  2.0 unx     2197 b- defN 24-Mar-26 16:39 dateroll/calendars/sampledata.py
 -rw-r--r--  2.0 unx        0 b- defN 24-Feb-29 23:50 dateroll/date/__init__.py
 -rw-r--r--  2.0 unx        0 b- defN 24-Feb-29 23:50 dateroll/date/__main__.py
--rw-r--r--  2.0 unx     8499 b- defN 24-Apr-03 20:42 dateroll/date/date.py
+-rw-r--r--  2.0 unx     8483 b- defN 24-Apr-05 15:27 dateroll/date/date.py
 -rw-r--r--  2.0 unx        0 b- defN 24-Feb-29 23:50 dateroll/ddh/__init__.py
 -rw-r--r--  2.0 unx        0 b- defN 24-Feb-29 23:50 dateroll/ddh/__main__.py
--rw-r--r--  2.0 unx     2725 b- defN 24-Apr-03 13:30 dateroll/ddh/ddh.py
+-rw-r--r--  2.0 unx     2624 b- defN 24-Apr-05 15:27 dateroll/ddh/ddh.py
 -rw-r--r--  2.0 unx        0 b- defN 24-Feb-29 23:50 dateroll/duration/__init__.py
 -rw-r--r--  2.0 unx        0 b- defN 24-Feb-29 23:50 dateroll/duration/__main__.py
--rw-r--r--  2.0 unx    24755 b- defN 24-Apr-03 20:49 dateroll/duration/duration.py
+-rw-r--r--  2.0 unx    24999 b- defN 24-Apr-05 15:27 dateroll/duration/duration.py
 -rw-r--r--  2.0 unx        0 b- defN 24-Feb-29 23:50 dateroll/parser/__init__.py
 -rw-r--r--  2.0 unx        0 b- defN 24-Feb-29 23:50 dateroll/parser/__main__.py
--rw-r--r--  2.0 unx     6211 b- defN 24-Apr-03 13:30 dateroll/parser/parser.py
--rw-r--r--  2.0 unx    12159 b- defN 24-Apr-03 20:31 dateroll/parser/parsers.py
--rw-r--r--  2.0 unx     1135 b- defN 24-Mar-26 16:39 dateroll/parser/patterns.py
+-rw-r--r--  2.0 unx     6106 b- defN 24-Apr-05 15:27 dateroll/parser/parser.py
+-rw-r--r--  2.0 unx    11758 b- defN 24-Apr-05 15:27 dateroll/parser/parsers.py
+-rw-r--r--  2.0 unx     1226 b- defN 24-Apr-05 15:27 dateroll/parser/patterns.py
 -rw-r--r--  2.0 unx  1607067 b- defN 24-Feb-29 23:50 dateroll/sampledata/ALL.csv
 -rw-r--r--  2.0 unx    39446 b- defN 24-Feb-29 23:50 dateroll/sampledata/BR.csv
 -rw-r--r--  2.0 unx    26400 b- defN 24-Feb-29 23:50 dateroll/sampledata/ECB.csv
 -rw-r--r--  2.0 unx    50116 b- defN 24-Feb-29 23:50 dateroll/sampledata/FED.csv
 -rw-r--r--  2.0 unx    43461 b- defN 24-Feb-29 23:50 dateroll/sampledata/LN.csv
 -rw-r--r--  2.0 unx    50116 b- defN 24-Feb-29 23:50 dateroll/sampledata/NY.csv
 -rw-r--r--  2.0 unx   459162 b- defN 24-Feb-29 23:50 dateroll/sampledata/WE.csv
 -rw-r--r--  2.0 unx        0 b- defN 24-Feb-29 23:50 dateroll/schedule/__init__.py
 -rw-r--r--  2.0 unx        0 b- defN 24-Feb-29 23:50 dateroll/schedule/__main__.py
--rw-r--r--  2.0 unx     5262 b- defN 24-Mar-29 20:18 dateroll/schedule/schedule.py
--rw-r--r--  2.0 unx    11357 b- defN 24-Apr-03 21:29 dateroll-0.2.2.dist-info/LICENSE
--rw-r--r--  2.0 unx     1141 b- defN 24-Apr-03 21:29 dateroll-0.2.2.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Apr-03 21:29 dateroll-0.2.2.dist-info/WHEEL
--rw-r--r--  2.0 unx        9 b- defN 24-Apr-03 21:29 dateroll-0.2.2.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     3259 b- defN 24-Apr-03 21:29 dateroll-0.2.2.dist-info/RECORD
-40 files, 2389356 bytes uncompressed, 462457 bytes compressed:  80.7%
+-rw-r--r--  2.0 unx     5239 b- defN 24-Apr-05 15:27 dateroll/schedule/schedule.py
+-rw-r--r--  2.0 unx    11357 b- defN 24-Apr-05 16:08 dateroll-0.2.3.dist-info/LICENSE
+-rw-r--r--  2.0 unx     1151 b- defN 24-Apr-05 16:08 dateroll-0.2.3.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-Apr-05 16:08 dateroll-0.2.3.dist-info/WHEEL
+-rw-r--r--  2.0 unx       45 b- defN 24-Apr-05 16:08 dateroll-0.2.3.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx        9 b- defN 24-Apr-05 16:08 dateroll-0.2.3.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     3426 b- defN 24-Apr-05 16:08 dateroll-0.2.3.dist-info/RECORD
+42 files, 2389854 bytes uncompressed, 462568 bytes compressed:  80.7%
```

## zipnote {}

```diff
@@ -1,13 +1,16 @@
 Filename: dateroll/__init__.py
 Comment: 
 
 Filename: dateroll/__main__.py
 Comment: 
 
+Filename: dateroll/cli.py
+Comment: 
+
 Filename: dateroll/pretty.py
 Comment: 
 
 Filename: dateroll/settings.py
 Comment: 
 
 Filename: dateroll/tblfmt.py
@@ -99,23 +102,26 @@
 
 Filename: dateroll/schedule/__main__.py
 Comment: 
 
 Filename: dateroll/schedule/schedule.py
 Comment: 
 
-Filename: dateroll-0.2.2.dist-info/LICENSE
+Filename: dateroll-0.2.3.dist-info/LICENSE
+Comment: 
+
+Filename: dateroll-0.2.3.dist-info/METADATA
 Comment: 
 
-Filename: dateroll-0.2.2.dist-info/METADATA
+Filename: dateroll-0.2.3.dist-info/WHEEL
 Comment: 
 
-Filename: dateroll-0.2.2.dist-info/WHEEL
+Filename: dateroll-0.2.3.dist-info/entry_points.txt
 Comment: 
 
-Filename: dateroll-0.2.2.dist-info/top_level.txt
+Filename: dateroll-0.2.3.dist-info/top_level.txt
 Comment: 
 
-Filename: dateroll-0.2.2.dist-info/RECORD
+Filename: dateroll-0.2.3.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## dateroll/__init__.py

 * *Ordering differences only*

```diff
@@ -1,7 +1,8 @@
+
 from dateroll.ddh.ddh import ddh
 from dateroll.date.date import Date
 from dateroll.duration.duration import Duration
 from dateroll.schedule.schedule import Schedule
 from dateroll.calendars.calendarmath import CalendarMath
 from dateroll.calendars.calendarmath import Calendars
 from dateroll.parser.parser import Parser
@@ -10,15 +11,14 @@
 import dateroll.calendars.calendars as calendarModule
 import dateroll.settings as settingsModule
 
 settings = settingsModule.settings
 calmath = calendarmathModule.calmath
 cals = calendarmathModule.calmath.cals
 
-
 # for backwards compatibility testing
 # import sys
 # import traceback
 # try:
 #     from dateroll.ddh.ddh import calmath, cals, ddh
 #     from dateroll.date.date import Date
 #     from dateroll.duration.duration import Duration
```

## dateroll/pretty.py

```diff
@@ -1,12 +1,10 @@
 import calendar
 import datetime
 
-from dateroll.settings import settings
-
 calendar.setfirstweekday(calendar.SUNDAY)
 
 from dateroll.utils import color
 
 
 def replacer(i, c, txt1, cals):
     bef = str(i).rjust(3)
@@ -28,15 +26,15 @@
         color holidays/weekends as grey
     """
     if dt2 > dt1:
         _1, _2 = dt1, dt2
     else:
         _1, _2 = dt2, dt1
 
-    banner = f'From {_1}, to {_2}, holidays: {cals}'
+    banner = f"From {_1}, to {_2}, holidays: {cals}"
     print(banner)
 
     y1, m1, d1 = _1.year, _1.month, _1.day
     y2, m2, d2 = _2.year, _2.month, _2.day
 
     c1 = calendar.month(y1, m1)
     c1s = str(c1).splitlines()
```

## dateroll/settings.py

```diff
@@ -1,19 +1,16 @@
 import importlib.util
 import pathlib
 import warnings
 
 path = pathlib.Path("~/.dateroll/settings.py").expanduser()
 
-ctx_conv = '_ctx_convention'
+ctx_conv = "_ctx_convention"
 
-default_settings = {
-    "convention": "MDY",
-    "twodigityear_cutoff": 2050
-}
+default_settings = {"convention": "MDY", "twodigityear_cutoff": 2050}
 
 default_settings_validation = {
     "debug": (lambda x: isinstance(x, bool), TypeError("debug must be bool")),
     "convention": (
         lambda x: isinstance(x, str) and x in ["YMD", "MDY", "DMY"],
         ValueError('must be one of "MDY", "DMY" or "YMD".'),
     ),
@@ -75,16 +72,14 @@
         with path.open("w") as f:
             txt = f"# Dateroll settings file\n# {path}\n\n"
             for k, v in self.__dict__.items():
                 if not k.startswith("__") and k in default_settings:
                     txt += f"{k}={repr(v)}\n"
             f.write(txt)
 
-    
-
     def validate(self, user_settings):
         """
         2 tests:
             user settings key in default settings
             user settings value passes default settings value check
         1 adjustment:
             append default settings not in user settings for a complete set of settings
@@ -102,18 +97,18 @@
                     raise exc
 
         for k, v in default_settings.items():
             if k not in user_settings:
                 user_settings[k] = v
 
         return user_settings
-    
+
     def __getattribute__(self, k):
-        if k=='convention':
-            if hasattr(self,'_convention_override'):
+        if k == "convention":
+            if hasattr(self, "_convention_override"):
                 return self._convention_override
 
         return super().__getattribute__(k)
 
     def __setattr__(self, k, v):
         """
         if a new setting value, validate and save
@@ -140,8 +135,7 @@
 
 
 settings = Settings()
 
 if __name__ == "__main__":  # pragma: no cover
     # settings = Settings()
     ...
-
```

## dateroll/tblfmt.py

```diff
@@ -1,48 +1,52 @@
 def pretty_table(ld, col_widths=None):
-    if len(ld)==0:
+    if len(ld) == 0:
         return ""
     headers = list(ld[0].keys())
     data = [headers] + [list(d.values()) for d in ld]
 
     if col_widths is None:
-        col_widths = [max(max([len(str(d[h])) for d in ld]),len(h))+2 for h in headers]
+        col_widths = [
+            max(max([len(str(d[h])) for d in ld]), len(h)) + 2 for h in headers
+        ]
 
     x = ""
-    
+
     # Print the top border
-    x += '┌'
+    x += "┌"
     for i, width in enumerate(col_widths):
-        end = ('┬' if i < len(col_widths)-1 else '┐\n')
-        x+= '─' * (width + 2) + end
-    
+        end = "┬" if i < len(col_widths) - 1 else "┐\n"
+        x += "─" * (width + 2) + end
+
     # Print the header row
     for i, width in enumerate(col_widths):
-        end = ('  ' if i < len(col_widths)-1 else '  │\n')
-        x += '│' + f'{data[0][i]:^{width}}'+ end
+        end = "  " if i < len(col_widths) - 1 else "  │\n"
+        x += "│" + f"{data[0][i]:^{width}}" + end
 
     # Print the middle border
-    x += '├'
-    
+    x += "├"
+
     for i, width in enumerate(col_widths):
-        end = ('┼' if i < len(col_widths)-1 else  '┤\n')
-        x += '─' * (width + 2) + end
+        end = "┼" if i < len(col_widths) - 1 else "┤\n"
+        x += "─" * (width + 2) + end
 
     # Print the table data
     for row in data[1:]:
         for i, width in enumerate(col_widths):
-            end = ('  ' if i < len(col_widths)-1 else '  │\n' )
-            x += '│' + f'{row[i]:<{width}}' + end
-    
+            end = "  " if i < len(col_widths) - 1 else "  │\n"
+            x += "│" + f"{row[i]:<{width}}" + end
+
     # Print the bottom border
-    x += '└'
+    x += "└"
     for i, width in enumerate(col_widths):
-        end = ('┴' if i < len(col_widths)-1 else '┘\n')
-        x += '─' * (width + 2)+end
+        end = "┴" if i < len(col_widths) - 1 else "┘\n"
+        x += "─" * (width + 2) + end
 
     return x
 
-if __name__ == '__main__':  # pragma:no cover
+
+if __name__ == "__main__":  # pragma:no cover
     from dateroll import cals
+
     data = cals._calsdata
     s = pretty_table(data)
     print(s)
```

## dateroll/utils.py

```diff
@@ -1,17 +1,17 @@
 import calendar
-import fcntl
-import functools
-import pathlib
 import re
-import time
 
+# from dateroll.date import date as dateModule
+# from dateroll.ddh import ddh as ddhModule
 from dateroll.parser import patterns
-from dateroll.date import date as dateModule
-from dateroll.ddh import ddh as ddhModule
+
+import dateroll.date.date as dateModule
+import dateroll.ddh.ddh as ddhModule
+
 
 XPRINT_ON = False
 
 DEBUG_COLORS = {
     "blue": "\033[94m",
     "cyan": "\033[96m",
     "green": "\033[92m",
@@ -126,47 +126,48 @@
         month_str_numb = month_dict.get(month_str, None)
         if month_str_numb is None:
 
             raise ValueError("Month name is wrong")
         s = patterns.MONTHNAMES.sub(month_str_numb, s.capitalize())
     return s
 
+
 convention_map = {"YMD": r"%Y-%m-%d", "DMY": r"%d/%m/%Y", "MDY": r"%m/%d/%Y"}
 
 
 def str_or_date(s):
-    if isinstance(s,str):
+    if isinstance(s, str):
         d = ddhModule.ddh(s)
-    elif isinstance(s,dateModule.DateLike):
+    elif isinstance(s, dateModule.DateLike):
         d = dateModule.Date.from_datetime(s)
     else:
-        raise Exception('Slicing only supports dateroll datestrings')
+        raise Exception("Slicing only supports dateroll datestrings")
     return d
 
 
-def date_slice(s:slice,l:list):
-    '''
+def date_slice(s: slice, l: list):
+    """
     s[t1:]   -- after t1 (inclusive)
     s[:t2]   -- before t2 (inclusive)
     s[t1:t2]  -- between t1 and t2 (inclusive)
-    
-    '''
-    start,stop,step = s.start,s.stop,s.step
+
+    """
+    start, stop, step = s.start, s.stop, s.step
     if start is not None and stop is None and step is None:
         # after
         start = str_or_date(start)
         return [i for i in l if i >= start]
     elif start is None and stop is not None and step is None:
         # before
         stop = str_or_date(stop)
         return [i for i in l if i <= stop]
     elif start is not None and stop is not None:
         # between
         start = str_or_date(start)
         stop = str_or_date(stop)
-        return [i for i in l if i >= start and i <=stop]
+        return [i for i in l if i >= start and i <= stop]
     elif start is None and stop is None and step is None:
         # all
         return list(l.keys())
     elif step is not None:
         # neither
-        raise Exception('Slicing only supports start, stop, and start+stop, not step.')
+        raise Exception("Slicing only supports start, stop, and start+stop, not step.")
```

## dateroll/calendars/calendarmath.py

```diff
@@ -1,13 +1,12 @@
 import datetime
 import math
 import os
 import pathlib
 import pickle
-import time
 
 import dateroll.date.date as dateModule
 from dateroll.calendars.calendars import Calendars
 
 PARENT_LOCATION = pathlib.Path.home() / ".dateroll/"
 PARENT_LOCATION.mkdir(exist_ok=True)
 MODULE_LOCATION = PARENT_LOCATION / "calendars/"
@@ -356,12 +355,12 @@
         Show names of cals and unions
         """
         return f'{self.__class__.__name__}(home="{self.home}")\nCals: {self.cals.keys()}\nUnions: {list(self.fwd.keys())}'
 
 
 calmath = CalendarMath()
 
-if __name__=='__main__':  # pragma:no cover
-    from dateroll.settings import settings
+if __name__ == "__main__":  # pragma:no cover
     from dateroll import ddh
+    from dateroll.settings import settings
     import code
-    code.interact(local=dict(globals(),**locals()))
+    # code.interact(local=dict(globals(),**locals()))
```

## dateroll/calendars/calendars.py

```diff
@@ -53,15 +53,15 @@
             ls = f.readlines()
             l = []
             for i in ls:
                 dt = datetime.date(int(i[0:4]), int(i[5:7]), int(i[8:10]))
                 if dt >= INCEPTION:
                     l.append(dt)
 
-            ds = DateSet(l,name=name)
+            ds = DateSet(l, name=name)
             data[name] = ds
     return data
 
 
 class Drawer:
     def __init__(self, cals):
 
@@ -121,37 +121,37 @@
         od = OrderedDict(d)
         self._data = od
 
     def add(self, item):
         dt = date_check(item)
         self._data[dt] = True
         if self.name is not None:
-            tothing = f' to {self.name}'
+            tothing = f" to {self.name}"
         else:
-            tothing = ''
-        print(f'[dateroll] {item} added{tothing}.')
+            tothing = ""
+        print(f"[dateroll] {item} added{tothing}.")
 
     def __contains__(self, item):
         if isinstance(item, dateModule.Date):
             item = item.date
         if isinstance(item, datetime.datetime):
             item = datetime.date(item.year, item.month, item.day)
         return item in self._data
 
     def extend(self, items):
         if not isinstance(items, SetLike):
             raise TypeError("Must be cast-able into set")
         extension = {date_check(i): None for i in items if i is not None}
         self._data.update(extension)
 
-    def __getitem__(self,k):
-        if isinstance(k,slice):
-            return date_slice(k,self._data)
+    def __getitem__(self, k):
+        if isinstance(k, slice):
+            return date_slice(k, self._data)
         else:
-            raise TypeError('Indexation on DateSet only accepts date string slicing')
+            raise TypeError("Indexation on DateSet only accepts date string slicing")
 
     def __iter__(self):
         return iter(self._data)
 
     def __len__(self):
         return len(self._data)
 
@@ -212,23 +212,22 @@
 
         if k in self.db.keys():
             raise Exception(f"{k} exists already, delete first.if you want to replace.")
 
         self.write = True
         with Drawer(self) as db:
             # value must be a set-like list of dates
-            verified = DateSet(v,name=k)
+            verified = DateSet(v, name=k)
             db[k] = verified
-        
-        print(f'[dateroll] {k} now has {len(verified)} holidays.')
+
+        print(f"[dateroll] {k} now has {len(verified)} holidays.")
 
     def __getitem__(self, k):
         return self.get(k)
 
-
     def __getattr__(self, k):
         """
         allows for dot notation
         """
         if k in CALENDARS_ATTRIBUTES:
             return super().__getattribute__(k)
         else:
@@ -288,28 +287,36 @@
         with Drawer(self) as db:
             for i in sorted(db.keys()):
                 l = db.get(i)
                 years = {}
                 for j in l:
                     if j.year > 1950 and j.year < 2050:
                         if j.year in years:
-                            years[j.year]+=1
+                            years[j.year] += 1
                         else:
-                            years[j.year]=1
-            
-                num_this_year = years.get(datetime.date.today().year,0)
+                            years[j.year] = 1
+
+                num_this_year = years.get(datetime.date.today().year, 0)
                 if len(l) > 0:
                     n = len(l)
                     mn = min(l).strftime(conv)
                     mx = max(l).strftime(conv)
                 else:
                     n, mn, mx = 0, "", ""
-                data.append({'name':i,'non-working days':n,'oldest':mn,'newest':mx,'# this year':num_this_year})
+                data.append(
+                    {
+                        "name": i,
+                        "non-working days": n,
+                        "oldest": mn,
+                        "newest": mx,
+                        "# this year": num_this_year,
+                    }
+                )
         return data
-    
+
     def __str__(self):
         data = self._calsdata
         s = pretty_table(data)
         return s
 
     def __repr__(self):
         return self.__str__()
@@ -323,13 +330,9 @@
 
     @property
     def info(self):
         print(self.__str__)
 
 
 if __name__ == "__main__":  # pragma: no cover
-    
-    
-    ...
-    
 
-    
+    ...
```

## dateroll/date/date.py

```diff
@@ -191,15 +191,15 @@
                 dt = o.date
             elif isinstance(o, datetime.datetime):
                 # truncates time!
                 dt = datetime.date(o.year, o.month, o.day)
             else:
                 if isinstance(o, datetime.date):
                     dt = o
-          
+
             relative_delta = dateutil.relativedelta.relativedelta(self.date, dt)
             return Duration.from_relativedelta(
                 relative_delta, _anchor_start=dt, _anchor_end=self.date
             )
 
         elif isinstance(o, Duration) or "Duration" in o.__class__.__name__:
             # date + duration
@@ -262,29 +262,31 @@
 
     def to_string(self):
         """
         should print as string according to convention
         """
         mask = utils.convention_map[settings.convention]
         return self.strftime(mask)
-    
 
     def __str__(self):
         return self.to_string()
-    
 
     # Backwards compatibility with datetime.datetime, some 3rd party libraries assume subclasses have <1d properties, we assume 00:00:00
 
     @property
     def hour(self):
         return 0
+
     @property
     def minute(self):
         return 0
+
     @property
     def second(self):
         return 0
+
     @property
     def microsecond(self):
         return 0
 
+
 DateLike = DateLike + (Date,)
```

## dateroll/ddh/ddh.py

```diff
@@ -9,25 +9,25 @@
 
 datroll.* better than native because you can add datestrings to date objects
 
 ddh('t') +'3m' .... it's relaly close to the base but little extra.
 
 """
 
-# import dateroll.calendars.calendarmath as calendarmathModule
 import dateroll.date.date as dateModule
 import dateroll.duration.duration as durationModule
 import dateroll.schedule.schedule as scheduleModule
 import dateroll.calendars.calendarmath as calendarmathModule
 import dateroll.calendars.calendars as calendarModule
 import dateroll.settings as settingsModule
-# from dateroll.settings import settings
+
 
 DEBUG = False
 
+
 class ddh:
     Date = dateModule.Date
     Duration = durationModule.Duration
     Schedule = scheduleModule.Schedule
     settings = settingsModule.settings
     calmath = calendarmathModule.calmath
     hols = calendarmathModule.calmath.cals
@@ -39,14 +39,15 @@
             return dateModule.Date.from_datetime(o)
         elif isinstance(o, durationModule.DurationLike):
             obj = durationModule.Duration.from_relativedelta(o)
         else:
             raise TypeError(f"ddh() cannot handle {type(o).__name__})")
 
         return obj
+
     @staticmethod
     def purge_all():
         """
         dangerous, deletes all calendars and lockfiles
         """
         p = pathlib.Path("~/.dateroll").expanduser()
         import glob
@@ -55,44 +56,49 @@
         for file in files:
             if not file.endswith("lockfile"):
                 if pathlib.Path(file).is_file():
                     os.remove(file)
         ddh.hols._purge_all()
         ddh.calmath._purge_all()
 
-
     class YMD:
         global settings
+
         def __init__(self):
             pass
+
         def __enter__(self):
-            ddh.settings._convention_override = 'YMD'
-        def __exit__(self,*e):
+            ddh.settings._convention_override = "YMD"
+
+        def __exit__(self, *e):
             del ddh.settings._convention_override
 
     class MDY:
         global settings
+
         def __init__(self):
             pass
+
         def __enter__(self):
-            ddh.settings._convention_override = 'MDY'
-        def __exit__(self,*e):
+            ddh.settings._convention_override = "MDY"
+
+        def __exit__(self, *e):
             del ddh.settings._convention_override
 
     class DMY:
         global settings
+
         def __init__(self):
             pass
+
         def __enter__(self):
-            ddh.settings._convention_override = 'DMY'
-        def __exit__(self,*e):
+            ddh.settings._convention_override = "DMY"
+
+        def __exit__(self, *e):
             del ddh.settings._convention_override
 
 
 if __name__ == "__main__":  # pragma:no cover
 
-    ddh('t-1y3m')
-    
-    ...
-
+    ddh("t-1y3m")
 
-    
+    ...
```

## dateroll/duration/duration.py

```diff
@@ -1,30 +1,30 @@
+import code
 import copy
 import datetime
 import math
 import warnings
 
 import dateutil
 import dateutil.relativedelta
 import numpy as np
 
+import dateroll
 import dateroll.calendars.calendarmath as calendarmathModule
 import dateroll.date.date as dateModule
 import dateroll.parser.parsers as parsersModule
 import dateroll.utils as utils
 from dateroll.settings import settings
 from dateroll.utils import add_none, combine_none, xprint
 
 # NOTE: functools cache is defined starting from python 3.9
 # older versions of python can use functools lru_cache(maxsize=None)
 # for now, leave this commented out because it is not used
 
 
-
-
 cals = calendarmathModule.calmath.cals
 
 period_order = (*"yhsqmwd", "cals", "modifier")
 
 DurationLike = (dateutil.relativedelta, datetime.timedelta)
 WEEKEND_CALENDAR = "WE"
 
@@ -189,20 +189,20 @@
         return parsersModule.parseDurationString(o)
 
     @staticmethod
     def from_relativedelta(rd, _anchor_start=None, _anchor_end=None):
         if isinstance(rd, Duration):
             return rd
         elif isinstance(rd, dateutil.relativedelta.relativedelta):
-            if _anchor_start < _anchor_end:
-                a = _anchor_start
-                b = _anchor_start
-            else:
-                a= _anchor_end
-                b = _anchor_start
+            if _anchor_start is not None and _anchor_end is not None:
+                if _anchor_start < _anchor_end:
+                    ...
+
+                else:
+                    _anchor_start, _anchor_end = _anchor_end, _anchor_start
 
             return Duration(
                 years=rd.years,
                 months=rd.months,
                 days=rd.days,
                 _anchor_start=_anchor_start,
                 _anchor_end=_anchor_end,
@@ -475,19 +475,28 @@
                     (Date + Duration)
                 or  (Duration + Date)
             if direction < 0:
                         (Date - Duration)
             NOT (Duration - Date)
                 Date.__rsub__ throws TypeError before it gets here (non-sensical situation)
             """
+
             modifed = self.adjust_from_date(b, direction)
             dt = dateModule.Date.from_datetime(modifed)
 
             return dt
 
+        elif isinstance(b, str):
+
+            dur_str = self.to_string()
+            dur_str = f"{dur_str}{b}"
+            dur = dateroll.ddh(dur_str)
+
+            return dur
+
         else:
             raise NotImplementedError
 
     def adjust_from_date(self, date_unadj, direction):
         """
         4 steps:
             1 - if being subtracted, negate
@@ -513,15 +522,15 @@
                 else None
             )
         else:
             negated_self = self
             xprint("negation: none") if self.debug else None
 
         # 2 non-holiday adjustments, add D,M,Y
-        if isinstance(date_unadj,dateModule.Date):
+        if isinstance(date_unadj, dateModule.Date):
             date_unadj = date_unadj.date
         date_nonhol_adj = date_unadj + negated_self.relativedelta
         (
             xprint(lbl="cal adj", before=date_unadj, after=date_nonhol_adj)
             if self.debug
             else None
         )
@@ -655,15 +664,15 @@
         if copy_self.bd is not None:
             copy_self.bd = -1 * float(self.bd)
 
         return copy_self
 
     def __pos__(self):
         return self
-    
+
     def __str__(self):
         return self.to_string()
 
     def __repr__(self):
         """
         repr sorts units by seniority specificed in global
 
@@ -679,27 +688,27 @@
                     v = '"' + "u".join(v) + '"'
                 constructor += f"{k}={str(v)}, "
         return f'{self.__class__.__name__}({constructor.rstrip(", ")})'
 
     def __gt__(a, b):
         if isinstance(b, int):
             if b == 0:
-                tdy = dateModule.Date.from_string('t')
-                return (tdy+a)>tdy
+                tdy = dateModule.Date.from_string("t")
+                return (tdy + a) > tdy
             else:
                 b = Duration(days=b)
 
         return a.just_days > b.just_days
 
     def __ge__(a, b):
         if isinstance(b, int):
             if b == 0:
                 tdy = datetime.date.today()
-                return (tdy+a)>=tdy
-            
+                return (tdy + a) >= tdy
+
             b = Duration(days=b)
         return a.just_days >= b.just_days
 
     def __lt__(a, b):
         if isinstance(b, int):
             b = Duration(days=b)
 
@@ -757,13 +766,13 @@
             output += f"{self.days:+}d"
         if self.bd:
             output += f"{int(self.bd):+}bd"
         if self.cals:
             output += f'|{"u".join(self.cals)}'
         if self.modified:
             output += f"/MOD"
-        if output=="":
+        if output == "":
             output = "+0d"
         return output
 
 
 DurationLike = (Duration, datetime.timedelta, dateutil.relativedelta.relativedelta)
```

## dateroll/parser/parser.py

```diff
@@ -114,14 +114,15 @@
 
     @classmethod
     def parse_one_part(cls, untouched):
         letters = [chr(i) for i in range(65, 65 + 26)]
 
         def gen():
             yield letters.pop(0)
+
         notoday = parsersModule.parseTodayString(untouched)
 
         dates, nodates = parsersModule.parseManyDateStrings(notoday, gen)
 
         durations, nodatesordurations = parsersModule.parseManyDurationString(
             nodates, gen
         )
@@ -183,14 +184,13 @@
 def parse_to_native(string):
     return Parser(string, use_native_types=True)
 
 
 def parse_to_dateroll(string):
     return Parser(string)
 
-if __name__=='__main__': # pragma:no cover
-    from dateroll import ddh
+
+if __name__ == "__main__":  # pragma:no cover
     import dateroll
+    from dateroll import ddh
+
     dateroll.settings.convention = "MDY"
-    x = ddh('-1y2q3m4w5d6BD')
-    # x = ddh('t') + ddh('+3m') + ddh('-2y')+ ddh('700bd')-ddh('t')
-    print(x)
```

## dateroll/parser/parsers.py

```diff
@@ -1,21 +1,18 @@
 import calendar
 import datetime
 import re
-import math
 
 import dateroll.date.date as dt
 import dateroll.duration.duration as dur
 from dateroll import utils
 from dateroll.parser import patterns
 from dateroll.schedule.schedule import Schedule
 from dateroll.settings import settings
 
-import code
-
 TODAYSTRINGVALUES = ["today", "t0", "t"]
 
 
 def validate_year(y):
     """
     validate year using settings twodigityear_cutoff, and convert all 2-digit years to 4-digit
     """
@@ -192,15 +189,15 @@
         pattern = patterns.DMY
     elif settings.convention == "YMD":
         pattern = patterns.YMD
 
     dates = {}
     matches = re.findall(pattern, s)
     res = s
-    
+
     for match, _, _, _ in matches:
         # must hav 4 components per match
         # match 0 is 1st capture group = whole thing
         # match 1,2,3 are the y/m/d's as strings
 
         date = parseDateString(match)
         date = dt.Date.from_datetime(date)
@@ -218,49 +215,43 @@
     Starts with empty, and adds as finds from incoming tuple
     """
     # operator becomes multiplier
     duration_constructor_args = {}
 
     # get initial multplier (if any)
     op = capture_groups[1]
-
-    mult = 1
-    if op == "+" or op == "":
-        mult = 1
-    elif op == "-":
-        mult = -1
+    mult = -1 if op == "-" else 1
 
     # get all the pairs
-    for i in range(2, 12, 2):
+    for i in range(2, 26, 2):
         number = capture_groups[i]
         unit = capture_groups[i + 1]
 
         if number and unit:
             # cast number to integer y,s,q,m,w,d
             number = int(number) if unit != "bd" else float(number)
             if unit in duration_constructor_args:
                 raise ParserStringsError(
                     "Only 1 number of each unit per duration string (i.e. no 5d3d or 7m1m)"
                 )
             duration_constructor_args[unit] = number * mult
-    
-    # attach calendars if any
-    cals = capture_groups[13:21]
 
+    # attach calendars if any
+    cals = capture_groups[27:38]
     # remove empty strings from cals
     cals = tuple(filter(lambda x: x != "", cals))
     for cal in cals:
         (
             duration_constructor_args.setdefault("cals", []).append(cal)
             if cal and cal.isupper()
             else None
         )
 
     # attach roll if any
-    modified = capture_groups[22]
+    modified = capture_groups[39]
     if modified:
         duration_constructor_args["modified"] = True
 
     # add signed bd's if implicit scenario
     if "bd" not in duration_constructor_args and "BD" not in duration_constructor_args:
         if modified or len(cals) > 0:
             duration_constructor_args["bd"] = float(0.0) * mult
@@ -314,33 +305,26 @@
                 WE -> by default is weekend calendar (list of all sat and sun from -100y to +100y)
                 NY -> new york federal holidays
                 EU -> ECB holidays
             calender unions: repreating calendars with "u" for union
                 WEuNY -> all weekend holidays + NY holidays
                 WUuNYuEU -> union of all 3 sets
         modifier after  /
-                /MOD means modified the direction of travel for bd's to stay in current month 
+                /MOD means modified the direction of travel for bd's to stay in current month
     """
     durations = {}
     matches = re.findall(patterns.COMPLETE_DURATION, s)
-    
-    for idx,match in enumerate(matches):
+
+    for idx, match in enumerate(matches):
         duration_string = match[0]
         duration = parseDurationString(duration_string)
-
-        if idx==1:
-            # its because there is bd in string, eg ddh('-1y3bd), so need to flip the sign of bd when main sign is neg
-            op = -1 if '-' in matches[0][0] else 1
-            if isinstance(duration.bd,(float,int)):
-                duration.bd = op * duration.bd 
-        
         next_letter = next(gen())
         s = s.replace(duration_string, "+" + next_letter, 1)
         durations[next_letter] = duration
-    
+
     return durations, s
 
 
 def parseScheduleString(s):
     """
     takes a schedule string as "start,stop,step"
     where start resolves to a date
@@ -404,11 +388,13 @@
 
     try:
         total = eval(s, {}, things)
         return total
     except Exception as e:
         raise ParserStringsError("Cannot recognize as date math", s)
 
-if __name__=='__main__':  # pragma:no cover
+
+if __name__ == "__main__":  # pragma:no cover
     from dateroll.ddh.ddh import ddh
-    x = ddh('111422414')
-    print(x)
+
+    x = ddh("111422414")
+    print(x)
```

## dateroll/parser/patterns.py

```diff
@@ -13,20 +13,18 @@
 YMD = f"(({Y}){_}({M}){_}({D}))"
 MDY = f"(({M}){_}({D}){_}({Y}))"
 DMY = f"(({D}){_}({M}){_}({Y}))"
 
 # DurationString patterns
 PERIOD_LETTER = r"(?:bd|BD|[dDwWmMqQsShHyY])"
 DATE_PERIOD = f"(?:({NUMBER})({PERIOD_LETTER}))"
-REPEATING_DATE_PERIODS = (
-    f"(?:{DATE_PERIOD}{DATE_PERIOD}?{DATE_PERIOD}?{DATE_PERIOD}?{DATE_PERIOD}?)"
-)
+REPEATING_DATE_PERIODS = f"(?:{DATE_PERIOD}{DATE_PERIOD}?{DATE_PERIOD}?{DATE_PERIOD}?{DATE_PERIOD}?{DATE_PERIOD}?{DATE_PERIOD}?{DATE_PERIOD}?{DATE_PERIOD}?{DATE_PERIOD}?{DATE_PERIOD}?{DATE_PERIOD}?)"
 PIPE = r"(\|)?"
 CAL = r"([A-Z]{2,3})"
-OPTIONAL_CALS = f"(?:u{CAL})?" * 7
+OPTIONAL_CALS = f"(?:u{CAL})?" * 10
 CALS = f"{CAL}{OPTIONAL_CALS}"
 REPEATING_CALUNIONS = f" ?(?:{PIPE}) ?{CALS}"
 ROLL = r" ?(/)? ?(MOD) ?"
 PIPE_ROLL = f"(?:{ROLL})?"
 PIPE_REPEAT_CAL_UNION = f"(?:{REPEATING_CALUNIONS})?"
 COMPLETE_DURATION = (
     f"({OPERATOR}{REPEATING_DATE_PERIODS} ?{PIPE_REPEAT_CAL_UNION}{PIPE_ROLL})"
```

## dateroll/schedule/schedule.py

```diff
@@ -5,20 +5,21 @@
 import dateroll.calendars.calendarmath as calendarmathModule
 import dateroll.parser.parsers as parsersModule
 from dateroll import pretty
 from dateroll.date import date as dateModule
 from dateroll.duration import duration as durationModule
 from dateroll.ddh import ddh as ddhModule
 from dateroll import utils
-from dateroll import settings
+
 
 class Schedule:
-    '''
+    """
     list-like schedule generator
-    '''
+    """
+
     def __init__(self, start, stop, step, origin_string=None):
 
         self.start = start
         self.stop = stop
         self.step = step
         self.origin_string = origin_string
         if self.step >= 0:
@@ -36,27 +37,27 @@
         if isinstance(string, str):
             return parsersModule.parseScheduleString(string)
         else:
             raise TypeError(f"Must be string not {type(string).__name__}")
 
     def __len__(self):
         return self.num_dates
-    
+
     @property
     def list(self):
-        '''
+        """
         returns list of dates
-        '''
+        """
         return self._dates
 
     @property
     def dates(self):
-        '''
+        """
         returns list of dates
-        '''
+        """
         return self._dates
 
     def run(self):
         """
         gives the date range
         direction of date generations is given by the sign of step
         """
@@ -83,27 +84,27 @@
     @property
     def cal(self):
         _ = pretty.pretty_between_two_dates(
             self.start, self.stop, self.cals, calendarmathModule.calmath
         )
         print(_)
 
-    def __getitem__(self,k):
-        if isinstance(k,int):
+    def __getitem__(self, k):
+        if isinstance(k, int):
             return self._dates[k]
-        elif isinstance(k,str):
+        elif isinstance(k, str):
             d = ddhModule.ddh(k)
             if d in self._dates:
                 return d
             else:
                 raise KeyError(d)
-        elif isinstance(k,slice):
-            return utils.date_slice(k,self._dates)
+        elif isinstance(k, slice):
+            return utils.date_slice(k, self._dates)
         else:
-            raise TypeError('Indexation only support ints, date strings, or slices.')
+            raise TypeError("Indexation only support ints, date strings, or slices.")
 
     def __str__(self):
         s = f"""Schedule:
     start      : {self.start}
     stop       : {self.start}
     step       : {self.start}
     direction  : {self.direction}
@@ -143,15 +144,15 @@
 
     @property
     def split(self):
         list_of_dates = self._dates
         start = list_of_dates[:-1]
         stop = list_of_dates[1:]
         df = pd.DataFrame({"start": start, "stop": stop})
-        df['step']=df.stop-df.start
+        df["step"] = df.stop - df.start
         df.index.name = "per"
 
         return df
 
     @property
     def split_bond(self):
         """
```

## Comparing `dateroll-0.2.2.dist-info/LICENSE` & `dateroll-0.2.3.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `dateroll-0.2.2.dist-info/METADATA` & `dateroll-0.2.3.dist-info/METADATA`

 * *Files 4% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 Metadata-Version: 2.1
 Name: dateroll
-Version: 0.2.2
-Summary: dateroll makes working with dates less painful.
+Version: 0.2.3
+Summary: dateroll makes working with dates in python easy and fun.
 Home-page: https://github.com/disentcorp/dateroll
 Author: Anthony Malizzio
 Author-email: anthony.malizzio@disent.com
 License: Apache Software License
 Classifier: Development Status :: 3 - Alpha
 Classifier: Intended Audience :: Science/Research
 Classifier: Intended Audience :: Developers
```

## Comparing `dateroll-0.2.2.dist-info/RECORD` & `dateroll-0.2.3.dist-info/RECORD`

 * *Files 15% similar despite different names*

```diff
@@ -1,40 +1,42 @@
-dateroll/__init__.py,sha256=-QMxKOSsxa3L4VWY3mf9j_-ucYXjVfkAyRNAaAtJAeY,1086
+dateroll/__init__.py,sha256=QXvtdQ_y8FavrFvLWiP4U9afYCJciQx81KJeuKgjibg,1086
 dateroll/__main__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-dateroll/pretty.py,sha256=XOuG6HV9Vl2HmR0WLtA3s_xNG3rl_xvIuxKPvr68O-w,3272
-dateroll/settings.py,sha256=3NPbbKR4ARRDGpCLeitoRdmd7jtbC-zTQxJl96a7ABc,4255
-dateroll/tblfmt.py,sha256=gxe09Ie2L2sSa6NO8s_RPfB98LvIIjFk1z16SRYYTls,1425
-dateroll/utils.py,sha256=08ixVKtXEjnNzNfojakggw1k9DgYadup45141Gi6Cas,4493
+dateroll/cli.py,sha256=UpkP8Q0DZX7kBtAdHJ4HWS6VWThMdQcq6jAIKBQr3NI,454
+dateroll/pretty.py,sha256=E88FW6G7Gtm0m7Jz4APcc5dgfqcNI_penmpOCHuFj5M,3232
+dateroll/settings.py,sha256=CKj3mvl5xctZYCnRitCm2y44q-gDoYL8O5fIHzUoI6I,4233
+dateroll/tblfmt.py,sha256=ndAXGkB-N8jg95ubhzjHo5_bBGaOWbiugADw6vHGNAI,1440
+dateroll/utils.py,sha256=39bpLwjHajvJgk17KnEeMNohQVXmLhIzaXK8_E5I7zw,4526
 dateroll/calendars/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 dateroll/calendars/__main__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-dateroll/calendars/calendarmath.py,sha256=fYcNTAv7agSHh7ausK6OaGvmW4nmzWo_cvI9lWiSPQI,11084
-dateroll/calendars/calendars.py,sha256=God2XmMhizDyzeIsF_By00tWiLiTg0hbTCkd5M10Ghc,9172
+dateroll/calendars/calendarmath.py,sha256=klWpOLCb4yZC1ZL9_fya1GFviMpC9Q0PD-BBNiZhFYY,11076
+dateroll/calendars/calendars.py,sha256=_3LZYng2lOTwi_bJsz_hvDfcynq2X69wU7CgrG7QYxI,9327
 dateroll/calendars/sampledata.py,sha256=ghTTa32jzBhj4woZA5CbyoMa7Ao5o6LhJt6jg2kWDI4,2197
 dateroll/date/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 dateroll/date/__main__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-dateroll/date/date.py,sha256=f62gFYr1lmVYwFHf0EQRq3wQtxGF1Da2N_G-lVb9BL4,8499
+dateroll/date/date.py,sha256=Yleds-frxDRH3iwO4xhLZTfUzYKVtvYgcbIIXnNrPM4,8483
 dateroll/ddh/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 dateroll/ddh/__main__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-dateroll/ddh/ddh.py,sha256=07EJ816njt4jT-mARF2SGylA458emJXN31n1jG61wmQ,2725
+dateroll/ddh/ddh.py,sha256=hHQAsC5H018GoG-7Vecv6KSG3plcu1dO6I2RyubR71c,2624
 dateroll/duration/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 dateroll/duration/__main__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-dateroll/duration/duration.py,sha256=RfplI4Jism1nyAFBIA2faEHFUSAPz21IXFO-tOiWEQA,24755
+dateroll/duration/duration.py,sha256=jvREjqSyaz5kLI9E4-myY14jXFfeYoIbN38Fh726s7k,24999
 dateroll/parser/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 dateroll/parser/__main__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-dateroll/parser/parser.py,sha256=9ZzUiDloVGrUv8KX0cglawbVVaGw_xaUPjwiXvpVWBg,6211
-dateroll/parser/parsers.py,sha256=jFGTnXv37ESCasRrxJ27ayblsetypWgHHpMQaWP24Qg,12159
-dateroll/parser/patterns.py,sha256=15H8jgOy7Uv1g0Dkl4oXij4J-e8pu7qMJdeVQfpCKaA,1135
+dateroll/parser/parser.py,sha256=XJeVEG6zZKvH8MJc5gnbPUrZOwOdzEijb21ykBAoLUM,6106
+dateroll/parser/parsers.py,sha256=cqHYCxFCzzzvLdbStSaCD3XCAWhA8pWxH7qHY3ueSgM,11758
+dateroll/parser/patterns.py,sha256=BNTw_P8s8mOounQSjSle8tHss9zEosJ3TJGuDGR-XOE,1226
 dateroll/sampledata/ALL.csv,sha256=jv0ywBTvHgplgNCnVT_AhE_vYwZuLfUkZedetp-gFL4,1607067
 dateroll/sampledata/BR.csv,sha256=IsTNxR1y56KHgDmixaTpfLZKaTVxJ8VTPL07lRAxfmM,39446
 dateroll/sampledata/ECB.csv,sha256=QygTagRWTxlgBNEDRfAl-NcQjXj9FSIkRlXi9Cfoywk,26400
 dateroll/sampledata/FED.csv,sha256=WhzeD5Zbrcg4zQ3EK06Yzh9l6-Od7PJ6xZcTvZy6Hy4,50116
 dateroll/sampledata/LN.csv,sha256=5jwkCP6XhDjrXM6dCeIanYt1Lkt5TES114GL9e5ZZFA,43461
 dateroll/sampledata/NY.csv,sha256=WhzeD5Zbrcg4zQ3EK06Yzh9l6-Od7PJ6xZcTvZy6Hy4,50116
 dateroll/sampledata/WE.csv,sha256=dea9eFyNBwyBGYbXqPjoT84tdIgvRwO34oJ42eT0KJs,459162
 dateroll/schedule/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 dateroll/schedule/__main__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-dateroll/schedule/schedule.py,sha256=0ut4lzPDHcxy8ADRGQu9aGL7QxNXI3NMXAh84YlxdSc,5262
-dateroll-0.2.2.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
-dateroll-0.2.2.dist-info/METADATA,sha256=w7xqOfaUqDWv4qwIda1pcujeTj9K3UBzrS4vBNhXAX8,1141
-dateroll-0.2.2.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-dateroll-0.2.2.dist-info/top_level.txt,sha256=_nTOdTwmFVeheA44KYWK_l1Z73ynrc4bNPtBClgbmJc,9
-dateroll-0.2.2.dist-info/RECORD,,
+dateroll/schedule/schedule.py,sha256=4NZ464ZVPCIjhMGPl7x4Mq6P9a-pse8S-jPZ2eASXR0,5239
+dateroll-0.2.3.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
+dateroll-0.2.3.dist-info/METADATA,sha256=ZduE0p0wh2QHo6x0EXJXldzQczTuSHLSllGPe5i9iRs,1151
+dateroll-0.2.3.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+dateroll-0.2.3.dist-info/entry_points.txt,sha256=fEcUHKc7HDriJXgfix9A16mvMZGmMo93lHXJNvzmDBg,45
+dateroll-0.2.3.dist-info/top_level.txt,sha256=_nTOdTwmFVeheA44KYWK_l1Z73ynrc4bNPtBClgbmJc,9
+dateroll-0.2.3.dist-info/RECORD,,
```

