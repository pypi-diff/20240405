# Comparing `tmp/text_lloom-0.1.tar.gz` & `tmp/text_lloom-0.2.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "text_lloom-0.1.tar", max compression
+gzip compressed data, was "text_lloom-0.2.tar", max compression
```

## Comparing `text_lloom-0.1.tar` & `text_lloom-0.2.tar`

### file list

```diff
@@ -1,13 +1,13 @@
--rw-r--r--   0        0        0       39 2024-02-02 13:27:07.282735 text_lloom-0.1/README.md
--rw-r--r--   0        0        0      540 2024-03-29 00:05:35.050267 text_lloom-0.1/pyproject.toml
--rw-r--r--   0        0        0     1818 2024-03-29 00:07:57.707634 text_lloom-0.1/src/text_lloom/__init__.py
--rw-r--r--   0        0        0      738 2024-02-28 09:09:42.891236 text_lloom-0.1/src/text_lloom/concept.py
--rw-r--r--   0        0        0    54584 2024-03-22 11:52:54.976989 text_lloom-0.1/src/text_lloom/concept_induction.py
--rw-r--r--   0        0        0    12290 2024-03-08 09:30:26.443347 text_lloom-0.1/src/text_lloom/llm.py
--rw-r--r--   0        0        0     7784 2024-02-28 01:05:49.223109 text_lloom-0.1/src/text_lloom/prompts.py
--rw-r--r--   0        0        0     1164 2024-03-22 09:58:57.839845 text_lloom-0.1/src/text_lloom/static/index.css
--rw-r--r--   0        0        0  1551037 2024-03-22 09:58:57.840135 text_lloom-0.1/src/text_lloom/static/index.js
--rw-r--r--   0        0        0      721 2024-03-22 09:58:49.154869 text_lloom-0.1/src/text_lloom/static/index_select.css
--rw-r--r--   0        0        0    11032 2024-03-22 09:58:49.154917 text_lloom-0.1/src/text_lloom/static/index_select.js
--rw-r--r--   0        0        0    22573 2024-03-22 11:50:48.876241 text_lloom-0.1/src/text_lloom/workbench.py
--rw-r--r--   0        0        0      972 1970-01-01 00:00:00.000000 text_lloom-0.1/PKG-INFO
+-rw-r--r--   0        0        0       39 2024-02-02 13:27:07.282735 text_lloom-0.2/README.md
+-rw-r--r--   0        0        0      540 2024-04-05 00:12:03.770009 text_lloom-0.2/pyproject.toml
+-rw-r--r--   0        0        0     2002 2024-04-05 00:10:24.889068 text_lloom-0.2/src/text_lloom/__init__.py
+-rw-r--r--   0        0        0      738 2024-02-28 09:09:42.891236 text_lloom-0.2/src/text_lloom/concept.py
+-rw-r--r--   0        0        0    55435 2024-04-04 23:56:34.287030 text_lloom-0.2/src/text_lloom/concept_induction.py
+-rw-r--r--   0        0        0    12290 2024-03-08 09:30:26.443347 text_lloom-0.2/src/text_lloom/llm.py
+-rw-r--r--   0        0        0     7784 2024-02-28 01:05:49.223109 text_lloom-0.2/src/text_lloom/prompts.py
+-rw-r--r--   0        0        0     1099 2024-04-05 00:10:36.281208 text_lloom-0.2/src/text_lloom/static/index.css
+-rw-r--r--   0        0        0  1552666 2024-04-05 00:10:36.281367 text_lloom-0.2/src/text_lloom/static/index.js
+-rw-r--r--   0        0        0      721 2024-04-05 00:10:31.414543 text_lloom-0.2/src/text_lloom/static/index_select.css
+-rw-r--r--   0        0        0    11032 2024-04-05 00:10:31.414499 text_lloom-0.2/src/text_lloom/static/index_select.js
+-rw-r--r--   0        0        0    22735 2024-04-04 22:51:13.487436 text_lloom-0.2/src/text_lloom/workbench.py
+-rw-r--r--   0        0        0      972 1970-01-01 00:00:00.000000 text_lloom-0.2/PKG-INFO
```

### Comparing `text_lloom-0.1/pyproject.toml` & `text_lloom-0.2/pyproject.toml`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 [tool.poetry]
 name = "text_lloom"
-version = "0.1"
+version = "0.2"
 description = "Concept Induction to analyze unstructured text"
 authors = ["Michelle Lam <mlam4@cs.stanford.edu>"]
 readme = "README.md"
 
 [tool.poetry.dependencies]
 python = "^3.9"
 bertopic = "^0.16.0"
```

### Comparing `text_lloom-0.1/src/text_lloom/__init__.py` & `text_lloom-0.2/src/text_lloom/__init__.py`

 * *Files 7% similar despite different names*

```diff
@@ -39,14 +39,16 @@
     _css = CSS
     name = traitlets.Unicode().tag(sync=True)
 
     data = traitlets.Unicode().tag(sync=True)  # syncs the widget's `data` property
     data_items = traitlets.Unicode().tag(sync=True)  # syncs the widget's `data_items` property
     data_items_wide = traitlets.Unicode().tag(sync=True)  # syncs the widget's `data_items_wide` property
     metadata = traitlets.Unicode().tag(sync=True)  # syncs the widget's `metadata` property
+    slice_col = traitlets.Unicode().tag(sync=True)  # syncs the widget's `slice_col` property
+    norm_by = traitlets.Unicode().tag(sync=True)  # syncs the widget's `norm_by` property
   
 """
 CONCEPT SELECT WIDGET
 Widget instantiated with anywidget that displays the concepts for selection
 """
 class ConceptSelectWidget(anywidget.AnyWidget):
     _esm = ESM_select
```

### Comparing `text_lloom-0.1/src/text_lloom/concept.py` & `text_lloom-0.2/src/text_lloom/concept.py`

 * *Files identical despite different names*

### Comparing `text_lloom-0.1/src/text_lloom/concept_induction.py` & `text_lloom-0.2/src/text_lloom/concept_induction.py`

 * *Files 5% similar despite different names*

```diff
@@ -33,15 +33,15 @@
     # uses current package visibility
     from .llm import multi_query_gpt_wrapper, calc_cost_by_tokens
     from .prompts import *
     from .concept import Concept
     from .__init__ import MatrixWidget, ConceptSelectWidget
 
 # CONSTANTS ================================
-NAN_SCORE = -0.01  # Numerical score to use in place of NaN values for matrix viz
+NAN_SCORE = 0  # Numerical score to use in place of NaN values for matrix viz
 OUTLIER_CRITERIA = "Did the example not match any of the above concepts?"
 SCORE_DF_OUT_COLS = ["doc_id", "text", "concept_id", "concept_name", "concept_prompt", "score", "rationale", "highlight"]
 
 
 # HELPER functions ================================
 
 def json_load(s, top_level_key=None):
@@ -1038,32 +1038,44 @@
         # Numeric column: Create bins
         if slice_bounds is not None:
             # Use provided bin boundaries
             bins = slice_bounds_to_bins(slice_bounds)
         else:
             # Automatically create bins using percentiles
             bin_assn = pd.qcut(df[slice_col], q=max_slice_bins, duplicates="drop", labels=None)
-            bins = sorted(bin_assn.unique(), key=lambda x: x.left, reverse=False)
+            bins = sorted(bin_assn.unique(), key=lambda x: x.left if (isinstance(x, pd.Interval)) else 0, reverse=False)
+        def get_bin_name(bin):
+            if isinstance(bin, pd.Interval):
+                return f"({bin.left}, {bin.right}]"
+            return f"{bin}"
+        def get_bin_fn(bin):
+            if isinstance(bin, pd.Interval):
+                return {"x": slice_col, "fn": _slice_fn_num, "args": [bin.left, bin.right]}
+            elif pd.isna(bin):
+                return {"x": slice_col, "fn": lambda x: pd.isna(x), "args": []}
+            return {"x": slice_col, "fn": _slice_fn_cat, "args": [bin]}
         groupings = {
-            f"Bin: ({bin.left}, {bin.right}]": {"x": slice_col, "fn": _slice_fn_num, "args": [bin.left, bin.right]} for bin in bins
+            get_bin_name(bin): get_bin_fn(bin) for bin in bins
         }
     elif is_string_dtype(df[slice_col]):
         # String column: Create groupings based on unique values
+        def get_group_name(group_name):
+            return f"{group_name}"
         groupings = {
-            group_name: {"x": slice_col, "fn": _slice_fn_cat, "args": [group_name]} for group_name in df[slice_col].unique()
+            get_group_name(group_name): {"x": slice_col, "fn": _slice_fn_cat, "args": [group_name]} for group_name in df[slice_col].unique()
         }
     else:
-        raise ValueError(f"Slice column type not supported: {df[slice_col].dtype}. Please convert this column to ")
+        raise ValueError(f"Slice column type not supported: {df[slice_col].dtype}. Please convert this column to numeric or string type.")
         groupings = {}
     return groupings
 
 # Helper function for `visualize()` to generate the underlying dataframes
 # Parameters:
 # - threshold: float (minimum score of positive class)
-def prep_vis_dfs(df, score_df, doc_id_col, doc_col, score_col, df_filtered, df_bullets, concepts, cols_to_show, slice_col, max_slice_bins, slice_bounds, show_highlights, norm_by, debug=False, threshold=None, outlier_threshold=0.75):
+def prep_vis_dfs(df, score_df, doc_id_col, doc_col, score_col, df_filtered, df_bullets, concepts, cols_to_show, slice_col, max_slice_bins, slice_bounds, show_highlights, norm_by=None, debug=False, threshold=None, outlier_threshold=0.75):
     # TODO: codebook info
 
     # Handle groupings
     # Add the "All" grouping by default
     groupings = {
         "All": {"x": None, "fn": None, "args": None},
     }
@@ -1091,17 +1103,18 @@
     item_df = None
     item_df_wide = None
 
     df_bullets[doc_id_col] = df_bullets[doc_id_col].astype(str)
     df_bullets = df_bullets.groupby(doc_id_col).agg(lambda x: list(x)).reset_index()
 
     # Rationale df
-    rationale_col = "rationale"
+    rationale_col = "score rationale"
     highlight_col = "highlight"
-    rationale_df = score_df[[doc_id_col, "concept_name", rationale_col, highlight_col]]
+    rationale_df = score_df[[doc_id_col, "concept_name", "rationale", highlight_col]]
+    rationale_df.rename(columns={"rationale": rationale_col}, inplace=True)
     rationale_df[doc_id_col] = rationale_df[doc_id_col].astype(str)
 
     # Prep data for each group
     for group_name, group_filtering in groupings.items():
         filter_x = group_filtering["x"]
         filter_func = group_filtering["fn"]
         filter_args = group_filtering["args"]
@@ -1124,15 +1137,15 @@
         # Match with filtered example text
         filtered_ex_col = "quotes"
         df_filtered = get_text_col_and_rename(df_filtered, doc_id_col, new_col_name=filtered_ex_col)
         df_filtered[doc_id_col] = df_filtered[doc_id_col].astype(str)
         cur_df = cur_df.merge(df_filtered, on=doc_id_col, how="left")
 
         # Match with bullets
-        bullets_col = "bullets"
+        bullets_col = "text bullets"
         df_bullets = get_text_col_and_rename(df_bullets, doc_id_col, new_col_name=bullets_col)
         cur_df = cur_df.merge(df_bullets, on=doc_id_col, how="left")
 
         # Item df
         item_df_cols = [doc_id_col, doc_col, filtered_ex_col, bullets_col] + cols_to_show
         cur_item_df = pd.melt(cur_df, id_vars=item_df_cols, value_vars=concept_names, var_name="concept", value_name="concept score")
         cur_item_df["id"] = group_name # cols: ex_col, concept, concept_score, id (cluster id)
@@ -1174,15 +1187,15 @@
             item_df_wide = cur_item_df_wide
         else:
             item_df_wide = pd.concat([item_df_wide, cur_item_df_wide])
 
         # Metadata
         cluster_avg_overall_score = NAN_SCORE  # TEMPLATE SCORE for datasets without scores
         item_metadata[group_name] = {
-            "Slice size": f"{len(cur_df)} examples",
+            "Slice size": f"{len(cur_df)} documents",
         }
 
         # Matrix df
         for concept in concept_names:
             cur_scores = [clean_score(x, threshold) for x in cur_df[concept].tolist()]
             if len(cur_scores) > 0:
                 matches = [x for x in cur_scores if x > outlier_threshold]
@@ -1214,15 +1227,15 @@
         return row[val_col] / concept_ct
 
     # Add absolute count
     matrix_df["n"] = [row["value"] for _, row in matrix_df.iterrows()]
     if norm_by == "slice":
         # Normalize by slice
         matrix_df["value"] = [calc_norm_by_slice(row) for _, row in matrix_df.iterrows()]
-    else:
+    elif norm_by == "concept":
         # Normalize by concept
         matrix_df["value"] = [calc_norm_by_concept(row, "value") for _, row in matrix_df.iterrows()]
     
     # Replace any 0s with NAN_SCORE
     matrix_df["value"] = [NAN_SCORE if x == 0 else x for x in matrix_df["value"].tolist()]
 
     # Metadata
@@ -1233,23 +1246,23 @@
             cur_df = score_df[(score_df["concept_id"] == c.id) & (score_df[doc_id_col].isin(ex_ids))]
             ex = cur_df[highlight_col].unique().tolist()
         else:
             ex = []
         res = {
             "Criteria": f"<br>{c.prompt}",
             "Summary": f"<br>{c.summary}",
-            "Matches": f"{concept_cts[c.name]} examples",
+            "Concept matches": f"{concept_cts[c.name]} documents",
             "Representative examples": f"{format_bullets(ex, add_quotes=True)}"
         }
         return res
     
     concept_metadata = {c.name: get_concept_metadata(c) for c in concepts.values()}
     concept_metadata["Outlier"] = {
         "Criteria": OUTLIER_CRITERIA,
-        "Concept matches": f"{concept_cts['Outlier']} examples",
+        "Concept matches": f"{concept_cts['Outlier']} documents",
     }
     metadata_dict = {
         "items": item_metadata,
         "concepts": concept_metadata,
     }
 
     return matrix_df, item_df, item_df_wide, metadata_dict
@@ -1270,26 +1283,32 @@
 # - cols_to_show: list of strings (column names to show in visualization)
 # - slice_col: string (column name to slice by)
 # - max_slice_bins: int (maximum number of slices to show)
 # - slice_bounds: list of numbers (manual boundaries for slices)
 # - show_highlights: boolean (whether to show highlights)
 # - norm_by: string (column name to normalize by; either "slice" or "concept")
 # - debug: boolean (whether to print debug statements)
-def visualize(in_df, score_df, doc_col, doc_id_col, score_col, df_filtered, df_bullets, concepts, cols_to_show=[], slice_col=None, max_slice_bins=None, slice_bounds=None, show_highlights=False, norm_by="concept", debug=False):
+def visualize(in_df, score_df, doc_col, doc_id_col, score_col, df_filtered, df_bullets, concepts, cols_to_show=[], slice_col=None, max_slice_bins=None, slice_bounds=None, show_highlights=False, norm_by=None, debug=False):
     matrix_df, item_df, item_df_wide, metadata_dict = prep_vis_dfs(in_df, score_df, doc_id_col, doc_col, score_col, df_filtered, df_bullets, concepts, cols_to_show=cols_to_show, slice_col=slice_col, max_slice_bins=max_slice_bins, slice_bounds=slice_bounds,show_highlights=show_highlights, norm_by=norm_by, debug=debug)
 
     data = matrix_df.to_json(orient='records')
     data_items = item_df.to_json(orient='records')
     data_items_wide = item_df_wide.to_json(orient='records')
     md = json.dumps(metadata_dict)
+    if slice_col is None:
+        slice_col = ""
+    if norm_by is None:
+        norm_by = ""
     w = MatrixWidget(
         data=data, 
         data_items=data_items,
         data_items_wide=data_items_wide, 
-        metadata=md
+        metadata=md,
+        slice_col=slice_col,
+        norm_by=norm_by,
     )
     return w, matrix_df, item_df, item_df_wide
 
 def get_select_widget(concepts_json):
     w = ConceptSelectWidget(
         data=concepts_json,
     )
```

### Comparing `text_lloom-0.1/src/text_lloom/llm.py` & `text_lloom-0.2/src/text_lloom/llm.py`

 * *Files identical despite different names*

### Comparing `text_lloom-0.1/src/text_lloom/prompts.py` & `text_lloom-0.2/src/text_lloom/prompts.py`

 * *Files identical despite different names*

### Comparing `text_lloom-0.1/src/text_lloom/static/index.css` & `text_lloom-0.2/src/text_lloom/static/index.css`

 * *Files 8% similar despite different names*

```diff
@@ -1 +1 @@
-table.svelte-dsaf7t.svelte-dsaf7t{width:100%}.isSortable.svelte-dsaf7t.svelte-dsaf7t,.isClickable.svelte-dsaf7t.svelte-dsaf7t{cursor:pointer}tr.svelte-dsaf7t th select.svelte-dsaf7t{width:100%}td{height:1px}table,th,td{border-bottom:1px solid #e6e6e6;border-collapse:collapse}thead th{position:sticky;top:0;z-index:1;background:#fff;padding-block:10px;padding-inline:10px}.score-col{font-size:14px;text-align:center;height:100%}.overview-card{padding-block:10px;padding-inline:20px;border-radius:10px;border:1px solid #e6e6e6;font-size:16px;overflow-y:scroll}.overview-card-left{float:left;width:60%;height:100%}.overview-card-right{float:right;width:30%;height:100%}.highlight-card{padding-inline:20px;border-radius:10px;border:1px solid #e6e6e6;overflow-y:scroll;max-height:600px}.row{clear:both;margin-bottom:21px}.overview-hist{max-width:100%}.matrix-widget{display:flex;flex-direction:row;justify-content:space-between}.matrix-view{min-height:750px}.matrix{float:left;overflow-x:scroll}.tables{float:right;padding:0 20px;overflow-x:scroll;max-width:70%;border-radius:10px;border:1px solid #e6e6e6}.tables p{font-size:14px}h2{font-size:16px}h3{font-size:14px}
+table.svelte-dsaf7t.svelte-dsaf7t{width:100%}.isSortable.svelte-dsaf7t.svelte-dsaf7t,.isClickable.svelte-dsaf7t.svelte-dsaf7t{cursor:pointer}tr.svelte-dsaf7t th select.svelte-dsaf7t{width:100%}td{height:1px}table,th,td{border-bottom:1px solid #e6e6e6;border-collapse:collapse}thead th{position:sticky;top:0;z-index:1;background:#fff;padding-block:10px;padding-inline:10px}.score-col{font-size:14px;text-align:center;height:100%}.overview-card{padding-block:10px;padding-inline:20px;border-radius:10px;border:1px solid #e6e6e6;font-size:16px;overflow-y:scroll}.overview-card-left{float:left;width:60%;height:100%}.overview-card-right{float:right;width:30%;height:100%}.highlight-card{padding-inline:20px;border-radius:10px;border:1px solid #e6e6e6;overflow-y:scroll;max-height:600px}.row{clear:both;margin-bottom:21px}.overview-hist{max-width:100%}.matrix-view{min-height:750px}.matrix{float:left;max-width:30%;overflow-x:clip}.tables{float:right;padding:0 20px;overflow-x:scroll;max-width:65%;border-radius:10px;border:1px solid #e6e6e6}.tables p{font-size:14px}h2{font-size:16px}h3{font-size:14px}
```

### Comparing `text_lloom-0.1/src/text_lloom/static/index.js` & `text_lloom-0.2/src/text_lloom/static/index.js`

 * *Files 1% similar despite different names*

#### js-beautify {}

```diff
@@ -2,15 +2,15 @@
 var _W = (e, t, n) => t in e ? wW(e, t, {
     enumerable: !0,
     configurable: !0,
     writable: !0,
     value: n
 }) : e[t] = n;
 var Oo = (e, t, n) => (_W(e, typeof t != "symbol" ? t + "" : t, n), n);
-import * as Yn from "https://esm.sh/d3@7";
+import * as pt from "https://esm.sh/d3@7";
 
 function dt() {}
 
 function T2(e, t) {
     for (const n in t)
         e[n] = t[n];
     return (
@@ -85,48 +85,48 @@
         for (let i = 0; i < n; i++)
             t[i] = -1;
         return t;
     }
     return -1;
 }
 
-function yt(e) {
+function bt(e) {
     return e ?? "";
 }
 
-function $e(e, t) {
+function Ce(e, t) {
     e.appendChild(t);
 }
 
-function we(e, t, n) {
+function pe(e, t, n) {
     e.insertBefore(t, n || null);
 }
 
-function xe(e) {
+function ge(e) {
     e.parentNode && e.parentNode.removeChild(e);
 }
 
 function cl(e, t) {
     for (let n = 0; n < e.length; n += 1)
         e[n] && e[n].d(t);
 }
 
-function ge(e) {
+function he(e) {
     return document.createElement(e);
 }
 
 function SW(e) {
     return document.createElementNS("http://www.w3.org/2000/svg", e);
 }
 
 function Si(e) {
     return document.createTextNode(e);
 }
 
-function ct() {
+function rt() {
     return Si(" ");
 }
 
 function lf() {
     return Si("");
 }
 
@@ -151,31 +151,31 @@
     e.value = t ?? "";
 }
 
 function AW(e, t, n, i) {
     n == null ? e.style.removeProperty(t) : e.style.setProperty(t, n, i ? "important" : "");
 }
 
-function $k(e, t, n) {
+function Ck(e, t, n) {
     for (let i = 0; i < e.options.length; i += 1) {
         const r = e.options[i];
         if (r.__value === t) {
             r.selected = !0;
             return;
         }
     }
     (!n || t !== void 0) && (e.selectedIndex = -1);
 }
 
-function $W(e) {
+function CW(e) {
     const t = e.querySelector(":checked");
     return t && t.__value;
 }
 
-function CW(e, t, {
+function $W(e, t, {
     bubbles: n = !1,
     cancelable: i = !1
 } = {}) {
     return new CustomEvent(e, {
         detail: t,
         bubbles: n,
         cancelable: i
@@ -211,15 +211,15 @@
      * @param {HTMLElement | SVGElement} anchor
      * @returns {void}
      */
     m(t, n, i = null) {
         this.e || (this.is_svg ? this.e = SW(
             /** @type {keyof SVGElementTagNameMap} */
             n.nodeName
-        ) : this.e = ge(
+        ) : this.e = he(
             /** @type {keyof HTMLElementTagNameMap} */
             n.nodeType === 11 ? "TEMPLATE" : n.nodeName
         ), this.t = n.tagName !== "TEMPLATE" ? n : (
             /** @type {HTMLTemplateElement} */
             n.content
         ), this.c(t)), this.i(i);
     }
@@ -232,31 +232,31 @@
             this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes
         );
     }
     /**
      * @returns {void} */
     i(t) {
         for (let n = 0; n < this.n.length; n += 1)
-            we(this.t, this.n[n], t);
+            pe(this.t, this.n[n], t);
     }
     /**
      * @param {string} html
      * @returns {void}
      */
     p(t) {
         this.d(), this.h(t), this.i(this.a);
     }
     /**
      * @returns {void} */
     d() {
-        this.n.forEach(xe);
+        this.n.forEach(ge);
     }
 }
 
-function Ck(e, t) {
+function $k(e, t) {
     return new e(t);
 }
 let ah;
 
 function jd(e) {
     ah = e;
 }
@@ -278,15 +278,15 @@
 function d_() {
     const e = c_();
     return (t, n, {
         cancelable: i = !1
     } = {}) => {
         const r = e.$$.callbacks[t];
         if (r) {
-            const s = CW(
+            const s = $W(
                 /** @type {string} */
                 t,
                 n, {
                     cancelable: i
                 }
             );
             return r.slice().forEach((o) => {
@@ -360,28 +360,28 @@
     const t = [],
         n = [];
     cc.forEach((i) => e.indexOf(i) === -1 ? t.push(i) : n.push(i)), n.forEach((i) => i()), cc = t;
 }
 const Xp = /* @__PURE__ */ new Set();
 let yu;
 
-function mn() {
+function yn() {
     yu = {
         r: 0,
         c: [],
         p: yu
         // parent group
     };
 }
 
-function yn() {
+function bn() {
     yu.r || wo(yu.c), yu = yu.p;
 }
 
-function he(e, t) {
+function me(e, t) {
     e && e.i && (Xp.delete(e), e.i(t));
 }
 
 function Se(e, t, n, i) {
     if (e && e.o) {
         if (Xp.has(e))
             return;
@@ -430,26 +430,26 @@
     i !== void 0 && (e.$$.bound[i] = n, n(e.$$.ctx[i]));
 }
 
 function oi(e) {
     e && e.c();
 }
 
-function Bn(e, t, n) {
+function Un(e, t, n) {
     const {
         fragment: i,
         after_update: r
     } = e.$$;
     i && i.m(t, n), Sm(() => {
         const s = e.$$.on_mount.map(R9).filter(L9);
         e.$$.on_destroy ? e.$$.on_destroy.push(...s) : wo(s), e.$$.on_mount = [];
     }), r.forEach(Sm);
 }
 
-function Un(e, t) {
+function jn(e, t) {
     const n = e.$$;
     n.fragment !== null && (OW(n.after_update), wo(n.on_destroy), n.fragment && n.fragment.d(t), n.on_destroy = n.fragment = null, n.ctx = []);
 }
 
 function DW(e, t) {
     e.$$.dirty[0] === -1 && (Zl.push(e), FW(), e.$$.dirty.fill(0)), e.$$.dirty[t / 31 | 0] |= 1 << t % 31;
 }
@@ -482,18 +482,18 @@
     let c = !1;
     if (l.ctx = n ? n(e, t.props || {}, (f, d, ...h) => {
             const g = h.length ? h[0] : d;
             return l.ctx && r(l.ctx[f], l.ctx[f] = g) && (!l.skip_bound && l.bound[f] && l.bound[f](g), c && DW(e, f)), d;
         }) : [], l.update(), c = !0, wo(l.before_update), l.fragment = i ? i(l.ctx) : !1, t.target) {
         if (t.hydrate) {
             const f = kW(t.target);
-            l.fragment && l.fragment.l(f), f.forEach(xe);
+            l.fragment && l.fragment.l(f), f.forEach(ge);
         } else
             l.fragment && l.fragment.c();
-        t.intro && he(e.$$.fragment), Bn(e, t.target, t.anchor), P9();
+        t.intro && me(e.$$.fragment), Un(e, t.target, t.anchor), P9();
     }
     jd(u);
 }
 class ks {
     constructor() {
         /**
          * ### PRIVATE API
@@ -510,15 +510,15 @@
          *
          * @type {any}
          */
         Oo(this, "$$set");
     }
     /** @returns {void} */
     $destroy() {
-        Un(this, 1), this.$destroy = dt;
+        jn(this, 1), this.$destroy = dt;
     }
     /**
      * @template {Extract<keyof Events, string>} K
      * @param {K} type
      * @param {((e: Events[K]) => void) | null | undefined} callback
      * @returns {() => void}
      */
@@ -544,194 +544,198 @@
     v: /* @__PURE__ */ new Set()
 })).v.add(RW);
 
 function LW(e) {
     let t;
     return {
         c() {
-            t = ge("div"), t.innerHTML = "";
+            t = he("div"), t.innerHTML = "";
         },
         m(n, i) {
-            we(n, t, i);
+            pe(n, t, i);
         },
         p: dt,
         i: dt,
         o: dt,
         d(n) {
-            n && xe(t);
+            n && ge(t);
         }
     };
 }
 let Nk = 200,
     IW = 150,
-    PW = 80,
+    PW = 60,
     zW = 300,
     BW = 60;
 
 function UW(e, t, n) {
     let {
         data: i
     } = t, {
         div: r
     } = t, {
         numConcepts: s
     } = t, {
         numSlices: o
-    } = t, a;
-    const u = d_();
+    } = t, {
+        sliceCol: a
+    } = t, {
+        normBy: u
+    } = t, l;
+    const c = d_();
     f_(() => {
-        l(i);
+        f(i);
     });
 
-    function l(M) {
-        if (M != null && s > 0) {
-            let E = JSON.parse(M);
+    function f(P) {
+        if (P != null && s > 0) {
+            let S = JSON.parse(P);
             const $ = Nk + PW * o,
                 C = zW + BW * s,
-                O = "#82C1FB";
-            a = new c(r).size([$, C]).options({
+                D = "#82C1FB";
+            l = new d(r).size([$, C]).options({
                 highlightScope: "matrix",
                 showSlider: !1,
                 preserveRowOrder: !0,
                 preserveColumnOrder: !0,
                 sortOnAxisClick: !1
             }).font({
                 family: "system-ui",
                 size: 10
             }).columns({
                 row: "concept",
                 column: "id",
                 value: "value",
                 detail: "example"
             }).colors({
-                above: O,
-                below: O,
+                above: D,
+                below: D,
                 row: "#eee"
-            }).data(E), a.render();
+            }).data(S), l.render();
         }
     }
-    class c {
-        constructor(E = document.createElement("DIV")) {
-            this._container = E, this._options = new f(), this.partitions = new _(this), this._dataset = null, this._fieldNames = new m(), this.chartData = null, this.measures = new w(this._getMeasureSvg()), this.scales = new N(), this.renderer = new k(this);
+    class d {
+        constructor(S = document.createElement("DIV")) {
+            this._container = S, this._options = new h(), this.partitions = new A(this), this._dataset = null, this._fieldNames = new b(), this.chartData = null, this.measures = new _(this._getMeasureSvg()), this.scales = new N(), this.renderer = new T(this);
         }
         get fieldNames() {
             return this._fieldNames;
         }
-        size(E) {
-            return arguments.length ? (this.measures.width = E[0], this.measures.height = E[1], this) : [this.measures.width, this.measures.height];
+        size(S) {
+            return arguments.length ? (this.measures.width = S[0], this.measures.height = S[1], this) : [this.measures.width, this.measures.height];
         }
-        colors(E) {
-            return arguments.length ? (this.renderer.colors.row = E.row, this.renderer.colors.above = E.above, this.renderer.colors.below = E.below, this.renderer.colors.label = E.label, this) : this.renderer.colors;
+        colors(S) {
+            return arguments.length ? (this.renderer.colors.row = S.row, this.renderer.colors.above = S.above, this.renderer.colors.below = S.below, this.renderer.colors.label = S.label, this) : this.renderer.colors;
         }
-        margin(E) {
-            return arguments.length ? (this.measures.margin.left = E.left, this.measures.margin.right = E.right, this.measures.margin.top = E.top, this.measures.margin.bottom = E.bottom, this) : this.measures.margin;
+        margin(S) {
+            return arguments.length ? (this.measures.margin.left = S.left, this.measures.margin.right = S.right, this.measures.margin.top = S.top, this.measures.margin.bottom = S.bottom, this) : this.measures.margin;
         }
-        options(E) {
-            return arguments.length ? (this._options = Object.assign(this._options, E), this) : this._options;
+        options(S) {
+            return arguments.length ? (this._options = Object.assign(this._options, S), this) : this._options;
         }
-        columns(E) {
-            return arguments.length ? (this._fieldNames.column = E.column, this._fieldNames.row = E.row, this._fieldNames.value = E.value, this._fieldNames.detail = E.detail, this) : this._fieldNames;
+        columns(S) {
+            return arguments.length ? (this._fieldNames.column = S.column, this._fieldNames.row = S.row, this._fieldNames.value = S.value, this._fieldNames.detail = S.detail, this) : this._fieldNames;
         }
-        font(E) {
-            return arguments.length ? (this.measures.font.family(E.family), this.measures.font.size(E.size), this) : this.measures.font;
+        font(S) {
+            return arguments.length ? (this.measures.font.family(S.family), this.measures.font.size(S.size), this) : this.measures.font;
         }
-        data(E) {
-            return arguments.length ? (this._dataset = E, this) : this._dataset;
+        data(S) {
+            return arguments.length ? (this._dataset = S, this) : this._dataset;
         }
-        events(E) {
-            return arguments.length ? (this.renderer.rows.onclick = E.onclick, this.renderer.rows.onhover = E.onhover, this.renderer.rows.oncancel = E.oncancel, this) : {
+        events(S) {
+            return arguments.length ? (this.renderer.rows.onclick = S.onclick, this.renderer.rows.onhover = S.onhover, this.renderer.rows.oncancel = S.oncancel, this) : {
                 onclick: this.renderer.onclick,
                 onhover: this.renderer.onhover,
                 oncancel: this.renderer.oncancel
             };
         }
         render() {
-            const E = this._options;
-            return this.chartData = new d(this._dataset, this._fieldNames), this.chartData.numberIsPercentage = E.numberIsPercentage, this.chartData.preserveColumnOrder = E.preserveColumnOrder, this.chartData.preserveRowOrder = E.preserveRowOrder, this.chartData.numOfTopBottom = E.numberOfTopBottom, this.chartData.process(), this.measures.initialize(this.chartData, E.showSlider), this.scales.initialize(this), this.partitions.initialize(), this._container.appendChild(this.partitions.chartArea), this.renderer.rows.highlight = I[E.highlightScope], this.renderer.rows.showTooltip = E.showTooltip, this.renderer.rows.showAnnotation = E.showAnnotation, this.renderer.rows.sortOnAxisClick = E.sortOnAxisClick, this.renderer.columns.sortOnAxisClick = E.sortOnAxisClick, this.renderer.render(), E.showSlider && new D(this, E.sliderCaption).render(), this.partitions.adjustScrollableBlocks(), this;
+            const S = this._options;
+            return this.chartData = new g(this._dataset, this._fieldNames), this.chartData.numberIsPercentage = S.numberIsPercentage, this.chartData.preserveColumnOrder = S.preserveColumnOrder, this.chartData.preserveRowOrder = S.preserveRowOrder, this.chartData.numOfTopBottom = S.numberOfTopBottom, this.chartData.process(), this.measures.initialize(this.chartData, S.showSlider), this.scales.initialize(this), this.partitions.initialize(), this._container.appendChild(this.partitions.chartArea), this.renderer.rows.highlight = O[S.highlightScope], this.renderer.rows.showTooltip = S.showTooltip, this.renderer.rows.showAnnotation = S.showAnnotation, this.renderer.rows.sortOnAxisClick = S.sortOnAxisClick, this.renderer.columns.sortOnAxisClick = S.sortOnAxisClick, this.renderer.render(), S.showSlider && new R(this, S.sliderCaption).render(), this.partitions.adjustScrollableBlocks(), this;
         }
         _getMeasureSvg() {
-            const E = Yn.select(this._container).append("svg").attr("width", 0).attr("height", 0).style("position", "absolute").style("visibility", "hidden");
-            return E.append("text"), E;
+            const S = pt.select(this._container).append("svg").attr("width", 0).attr("height", 0).style("position", "absolute").style("visibility", "hidden");
+            return S.append("text"), S;
         }
     }
-    class f {
+    class h {
         constructor() {
             this.numberIsPercentage = !1, this.preserveRowOrder = !1, this.preserveColumnOrder = !1, this.showSlider = !0, this.sliderCaption = "Value", this.highlightScope = "matrix", this.numberOfTopBottom = 5, this.showTooltip = !0, this.showAnnotation = !0, this.sortOnAxisClick = !0;
         }
     }
-    class d {
-        constructor(E, $) {
-            this._dataset = E, this._fieldNames = $, this.numberIsPercentage = !1, this.preserveColumnOrder = !1, this.preserveRowOrder = !1, this.columns = null, this.rows = null, this.level = 0, this.defaultLevel = 0, this.average = 0, this.min = 0, this.max = 0, this.numOfTopBottom = 5;
+    class g {
+        constructor(S, $) {
+            this._dataset = S, this._fieldNames = $, this.numberIsPercentage = !1, this.preserveColumnOrder = !1, this.preserveRowOrder = !1, this.columns = null, this.rows = null, this.level = 0, this.defaultLevel = 0, this.average = 0, this.min = 0, this.max = 0, this.numOfTopBottom = 5;
         }
-        resetColumns(E) {
+        resetColumns(S) {
             this.columns.forEach(($) => {
-                $ !== E && ($.order = y.none);
+                $ !== S && ($.order = v.none);
             });
         }
-        resetRows(E) {
+        resetRows(S) {
             this.rows.forEach(($) => {
-                $ !== E && ($.order = y.none);
+                $ !== S && ($.order = v.none);
             });
         }
         process() {
-            const E = this._fieldNames,
-                $ = Yn.group(this._dataset, (L) => L[E.row]);
-            this.columns = [...new Set(this._dataset.map((L) => L[E.column]))].map((L, P) => new h(L, P)), this.preserveColumnOrder || (this.columns.sort((L, P) => L.name.localeCompare(P.name)), this.columns.forEach((L, P) => L.position = P));
+            const S = this._fieldNames,
+                $ = pt.group(this._dataset, (z) => z[S.row]);
+            this.columns = [...new Set(this._dataset.map((z) => z[S.column]))].map((z, H) => new p(z, H)), this.preserveColumnOrder || (this.columns.sort((z, H) => z.name.localeCompare(H.name)), this.columns.forEach((z, H) => z.position = H));
             const C = [...$.keys()];
-            this.preserveRowOrder || C.sort((L, P) => L.localeCompare(P)), this.rows = C.map((L, P) => {
-                const z = $.get(L),
-                    V = this.columns.map((se) => {
-                        const ee = z.find((ue) => ue[E.column] === se.name);
-                        return new p(L, se.name, ee ? +ee[E.value] : null, ee[E.detail]);
+            this.preserveRowOrder || C.sort((z, H) => z.localeCompare(H)), this.rows = C.map((z, H) => {
+                const G = $.get(z),
+                    te = this.columns.map((ae) => {
+                        const U = G.find((ie) => ie[S.column] === ae.name);
+                        return new y(z, ae.name, U ? +U[S.value] : null, U[S.detail]);
                     }),
-                    X = new g(L, P, V);
-                return X.markBounds(), X;
+                    K = new m(z, H, te);
+                return K.markBounds(), K;
             });
-            const O = this.rows.flatMap((L) => L.cells).filter((L) => L.value).sort((L, P) => L.value - P.value);
-            O[0].flag |= b.min, O[O.length - 1].flag |= b.max, O.slice(0, this.numOfTopBottom).forEach((L) => L.flag |= b.bottomGroup), O.slice(-this.numOfTopBottom).forEach((L) => L.flag |= b.topGroup);
-            const R = O.reduce((L, P) => L + P.value, 0);
-            this.level = this.defaultLevel = this.average = R / O.length, this.min = O[0].value, this.max = O[O.length - 1].value;
+            const D = this.rows.flatMap((z) => z.cells).filter((z) => z.value).sort((z, H) => z.value - H.value);
+            D[0].flag |= x.min, D[D.length - 1].flag |= x.max, D.slice(0, this.numOfTopBottom).forEach((z) => z.flag |= x.bottomGroup), D.slice(-this.numOfTopBottom).forEach((z) => z.flag |= x.topGroup);
+            const I = D.reduce((z, H) => z + H.value, 0);
+            this.level = this.defaultLevel = this.average = I / D.length, this.min = D[0].value, this.max = D[D.length - 1].value;
         }
     }
-    class h {
-        constructor(E, $) {
-            this.name = E, this.position = $, this.order = y.none;
+    class p {
+        constructor(S, $) {
+            this.name = S, this.position = $, this.order = v.none;
         }
     }
-    class g {
-        constructor(E, $, C) {
-            this.name = E, this.position = $, this.order = y.none, this.cells = C;
+    class m {
+        constructor(S, $, C) {
+            this.name = S, this.position = $, this.order = v.none, this.cells = C;
         }
         markBounds() {
-            const E = [...this.cells].filter(($) => $.value).sort(($, C) => $.value - C.value);
-            E[0].flag |= b.rowMin, E[E.length - 1].flag |= b.rowMax;
+            const S = [...this.cells].filter(($) => $.value).sort(($, C) => $.value - C.value);
+            S[0].flag |= x.rowMin, S[S.length - 1].flag |= x.rowMax;
         }
     }
-    class p {
-        constructor(E, $, C, O) {
-            this.row = E, this.column = $, this.value = C, this.detail = O, this.flag = b.unspecified;
+    class y {
+        constructor(S, $, C, D) {
+            this.row = S, this.column = $, this.value = C, this.detail = D, this.flag = x.unspecified;
         }
     }
-    class m {
-        constructor(E, $, C, O) {
-            this.column = E, this.row = $, this.value = C, this.detail = O;
+    class b {
+        constructor(S, $, C, D) {
+            this.column = S, this.row = $, this.value = C, this.detail = D;
         }
     }
-    class y {
+    class v {
         static get none() {
             return 0;
         }
         static get ascending() {
             return 1;
         }
         static get descending() {
             return 2;
         }
     }
-    class b {
+    class x {
         static get unspecified() {
             return 0;
         }
         static get min() {
             return 1;
         }
         static get max() {
@@ -746,38 +750,38 @@
         static get bottomGroup() {
             return 16;
         }
         static get topGroup() {
             return 32;
         }
     }
-    class v {
-        constructor(E, $, C, O, R) {
-            this._svg = E, this._font = $, this._charBox = null, this._box = this._initBox(C, O, R), this.left = 0, this.top = 0, this.getBBox = null, this.calcTextWidth = null, this.calcPosition = null;
+    class w {
+        constructor(S, $, C, D, I) {
+            this._svg = S, this._font = $, this._charBox = null, this._box = this._initBox(C, D, I), this.left = 0, this.top = 0, this.getBBox = null, this.calcTextWidth = null, this.calcPosition = null;
         }
         get box() {
             return this._box;
         }
         get offset() {
             return 10;
         }
-        show(E, $, C, O) {
+        show(S, $, C, D) {
             this._charBox || (this._charBox = this.getBBox("M"));
-            const R = this,
-                L = 1.4,
-                P = this._calcWidth($);
-            this._box.style("visibility", "visible").select("rect").attr("width", P + 10).attr("height", `${$.length * L + 0.5}em`), z("backtext", "white", 3), z("foretext"), this.move(E, C, O);
-
-            function z(V, X, se) {
-                R._box.selectAll("." + V).data($).join(
-                    (ee) => {
-                        ee.append("text").attr("class", V).attr("dy", (ue, G) => `${L * G + 1}em`).attr("stroke", X).attr("stroke-width", se).text((ue) => ue);
+            const I = this,
+                z = 1.4,
+                H = this._calcWidth($);
+            this._box.style("visibility", "visible").select("rect").attr("width", H + 10).attr("height", `${$.length * z + 0.5}em`), G("backtext", "white", 3), G("foretext"), this.move(S, C, D);
+
+            function G(te, K, ae) {
+                I._box.selectAll("." + te).data($).join(
+                    (U) => {
+                        U.append("text").attr("class", te).attr("dy", (ie, le) => `${z * le + 1}em`).attr("stroke", K).attr("stroke-width", ae).text((ie) => ie);
                     },
-                    (ee) => ee.text((ue) => ue),
-                    (ee) => ee.remove()
+                    (U) => U.text((ie) => ie),
+                    (U) => U.remove()
                 );
             }
         }
         // wrap(text, wrapWidth, yAxisAdjustment = 0) {
         //   text.each(function() {
         //     var text = d3.select(this),
         //         words = text.text().split(/\s+/).reverse(),
@@ -797,223 +801,219 @@
         //         line = [word];
         //         tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
         //       }
         //     }
         //   });
         //   return 0;
         // }
-        move(E, $, C) {
+        move(S, $, C) {
             if (this._box) {
-                const O = $ && C ? new DOMPoint($, C) : this._convertCoordinate(E, this._svg),
-                    R = this._box.node().getBBox(),
+                const D = $ && C ? new DOMPoint($, C) : this._convertCoordinate(S, this._svg),
+                    I = this._box.node().getBBox(),
                     {
-                        left: L,
-                        top: P
-                    } = this.calcPosition(O, R);
-                this.left = L + this.offset, this.top = P + this.offset, this._box.attr("transform", `translate(${this.left},${this.top})`);
+                        left: z,
+                        top: H
+                    } = this.calcPosition(D, I);
+                this.left = z + this.offset, this.top = H + this.offset, this._box.attr("transform", `translate(${this.left},${this.top})`);
             }
         }
         hide() {
             this._box && this._box.style("visibility", "hidden");
         }
-        _initBox(E, $, C) {
-            const O = this._svg.append("g").attr("fill", "black").call((R) => {
-                R.append("rect").attr("opacity", $).attr("stroke", C).attr("stroke-width", 0.5).attr("rx", 4).attr("ry", 4).attr("x", -5).attr("y", -5).attr("fill", E);
+        _initBox(S, $, C) {
+            const D = this._svg.append("g").attr("fill", "black").call((I) => {
+                I.append("rect").attr("opacity", $).attr("stroke", C).attr("stroke-width", 0.5).attr("rx", 4).attr("ry", 4).attr("x", -5).attr("y", -5).attr("fill", S);
             });
-            return this._font.applyTo(O), O;
+            return this._font.applyTo(D), D;
         }
-        _calcWidth(E) {
+        _calcWidth(S) {
             let $ = 0;
-            return E.forEach((C) => {
-                const O = this.calcTextWidth(C);
-                O > $ && ($ = O);
+            return S.forEach((C) => {
+                const D = this.calcTextWidth(C);
+                D > $ && ($ = D);
             }), $;
         }
-        _convertCoordinate(E, $) {
+        _convertCoordinate(S, $) {
             const C = this._svg.node().createSVGPoint();
-            return C.x = E.clientX, C.y = E.clientY, C.matrixTransform($.node().getScreenCTM().inverse());
+            return C.x = S.clientX, C.y = S.clientY, C.matrixTransform($.node().getScreenCTM().inverse());
         }
     }
-    class x extends v {
-        constructor(E, $, C, O, R) {
-            super(E, $, C, O, R), this._pointer = null;
-        }
-        show(E, $, C, O, R, L) {
-            super.show(E, $, C, O);
-            const P = this.box.node().getBBox();
-            this.move(E, C + R - this.offset, O + R - this.offset);
-            const z = this.offset / 2;
-            let V = this.left,
-                X = this.top,
-                se = V - z,
-                ee = X - z,
-                ue = se + 30,
-                G = ee + P.height;
-            V < C && (se = C - R - z, ue = se - 30, V = C - R - P.width), X < O && (ee = O - R - z, G = ee - P.height, X = O - R - P.height), this.box.attr("transform", `translate(${V},${X})`), this._removePointer(), this._pointer = this._svg.append("path").attr("fill", "none").attr("stroke", L).attr("stroke-width", 2).attr("d", `M ${C} ${O} L ${se} ${ee} L ${se} ${G} L ${ue} ${G}`);
+    class E extends w {
+        constructor(S, $, C, D, I) {
+            super(S, $, C, D, I), this._pointer = null;
+        }
+        show(S, $, C, D, I, z) {
+            super.show(S, $, C, D);
+            const H = this.box.node().getBBox();
+            this.move(S, C + I - this.offset, D + I - this.offset);
+            const G = this.offset / 2;
+            let te = this.left,
+                K = this.top,
+                ae = te - G,
+                U = K - G,
+                ie = ae + 30,
+                le = U + H.height;
+            te < C && (ae = C - I - G, ie = ae - 30, te = C - I - H.width), K < D && (U = D - I - G, le = U - H.height, K = D - I - H.height), this.box.attr("transform", `translate(${te},${K})`), this._removePointer(), this._pointer = this._svg.append("path").attr("fill", "none").attr("stroke", z).attr("stroke-width", 2).attr("d", `M ${C} ${D} L ${ae} ${U} L ${ae} ${le} L ${ie} ${le}`);
         }
         hide() {
             super.hide(), this._removePointer();
         }
         _removePointer() {
             this._pointer && (this._pointer.remove(), this._pointer = null);
         }
     }
-    class w {
-        constructor(E) {
-            this._svg = E, this.font = new S(), this.padding = 10, this.margin = {
+    class _ {
+        constructor(S) {
+            this._svg = S, this.font = new k(), this.padding = 10, this.margin = {
                 left: 0,
                 right: 0,
                 top: 0,
                 bottom: 0
             }, this.width = 0, this.height = 0, this.sliderHeight = 20, this.columnHeight = 0, this.rowWidth = 0, this._minRadius = 25, this.bubbleRadius = 0, this.bubbleDiameter = 0;
         }
-        initialize(E, $) {
-            this._calculateLabels(E), this._calculateBubbleRadius(E, $);
+        initialize(S, $) {
+            this._calculateLabels(S), this._calculateBubbleRadius(S, $);
         }
-        _calculateLabels(E) {
-            let $ = "";
-            const C = (O, R) => {
-                let L = 0;
-                return O.forEach((P) => {
-                    P = $.concat(P);
-                    const z = this.calculateStringWidth(P, void 0, R);
-                    z > L && (L = z);
-                }), L;
-            };
-            this.columnHeight = C(E.columns.map((O) => this.trim(O.name) + "M")), this.rowWidth = this.margin.left + C(E.rows.map((O) => O.name + "MM"), this.font.clone().weight("bold")), this.columnHeight = IW, this.rowWidth = Nk;
+        _calculateLabels(S) {
+            this.columnHeight = IW, this.rowWidth = Nk;
         }
-        _calculateBubbleRadius(E, $) {
+        // if (chartData.columns.length > 0) {
+        // }
+        // if (chartData.rows.length > 0) {
+        //     this.rowWidth = this.margin.left + max(chartData.rows.map(r => r.name + "MM"), this.font.clone().weight("bold"));
+        // }
+        _calculateBubbleRadius(S, $) {
             const C = this.width - this.rowWidth,
-                O = this.height - this.columnHeight - this.padding * 2 - ($ ? this.sliderHeight : 0),
-                R = E.rows.length,
-                L = E.columns.length,
-                P = (O / R - this.padding) / 2,
-                z = C / L / 2;
-            if (P < z)
-                this.bubbleRadius = P;
+                D = this.height - this.columnHeight - this.padding * 2 - ($ ? this.sliderHeight : 0),
+                I = S.rows.length,
+                z = S.columns.length,
+                H = (D / I - this.padding) / 2,
+                G = C / z / 2;
+            if (H < G)
+                this.bubbleRadius = H;
             else {
-                const V = R * z;
-                this.bubbleRadius = z > O ? z - (V - O) / R / 2 : z;
+                const te = I * G;
+                this.bubbleRadius = G > D ? G - (te - D) / I / 2 : G;
             }
             this.bubbleRadius < this._minRadius && (this.bubbleRadius = this._minRadius), this.bubbleDiameter = this.bubbleRadius * 2;
         }
-        getBBox(E, $, C) {
-            const O = C ?? this.font,
-                R = this._svg.select("text");
-            return R ? (O.applyTo(R), R.text(E), $ && R.attr("transform", `rotate(${$})`), R.node().getBBox()) : null;
-        }
-        calculateStringWidth(E, $, C) {
-            const O = this.getBBox(E, $, C);
-            return O ? Math.sqrt(O.width * O.width + O.height * O.height) : E.length * this.font.size;
+        getBBox(S, $, C) {
+            const D = C ?? this.font,
+                I = this._svg.select("text");
+            return I ? (D.applyTo(I), I.text(S), $ && I.attr("transform", `rotate(${$})`), I.node().getBBox()) : null;
+        }
+        calculateStringWidth(S, $, C) {
+            const D = this.getBBox(S, $, C);
+            return D ? Math.sqrt(D.width * D.width + D.height * D.height) : S.length * this.font.size;
         }
-        trim(E) {
-            return E.length > 100 ? `${E.substr(0, 10)}...` : E;
+        trim(S) {
+            return S.length > 100 ? `${S.substr(0, 10)}...` : S;
         }
     }
-    class S {
-        constructor(E = "", $ = "10pt", C = "normal", O = "normal") {
-            this._family = E, this._size = $, this._style = C, this._weight = O;
+    class k {
+        constructor(S = "", $ = "10pt", C = "normal", D = "normal") {
+            this._family = S, this._size = $, this._style = C, this._weight = D;
         }
-        family(E) {
-            return arguments.length ? (this._family = E, this) : this._family;
+        family(S) {
+            return arguments.length ? (this._family = S, this) : this._family;
         }
-        size(E) {
-            return arguments.length ? (this._size = E, this) : this._size;
+        size(S) {
+            return arguments.length ? (this._size = S, this) : this._size;
         }
-        style(E) {
-            return arguments.length ? (this._style = E, this) : this._style;
+        style(S) {
+            return arguments.length ? (this._style = S, this) : this._style;
         }
-        weight(E) {
-            return arguments.length ? (this._weight = E, this) : this._weight;
+        weight(S) {
+            return arguments.length ? (this._weight = S, this) : this._weight;
         }
-        applyTo(E) {
-            E = E instanceof HTMLElement ? Yn.select(E) : E, E.style("font-family", this._family).style("font-size", isNaN(+this._size) ? this._size : `${this._size}pt`).style("font-style", this._style).style("font-weight", this._weight);
+        applyTo(S) {
+            S = S instanceof HTMLElement ? pt.select(S) : S, S.style("font-family", this._family).style("font-size", isNaN(+this._size) ? this._size : `${this._size}pt`).style("font-style", this._style).style("font-weight", this._weight);
         }
         clone() {
-            return new S(this._family, this._size, this._style, this._weight);
+            return new k(this._family, this._size, this._style, this._weight);
         }
     }
-    class _ {
-        constructor(E) {
-            this._chart = E, this.chartArea = this._createDiv(), this.mainBlock = this._createDiv(), this.slider = this._createDiv(), this.columnBlock = this._createDiv(), this.placeHolder = this._createDiv(), this.columns = this._createDiv(), this.matrixBlock = this._createDiv(), this.rows = this._createDiv(), this.matrix = this._createDiv();
+    class A {
+        constructor(S) {
+            this._chart = S, this.chartArea = this._createDiv(), this.mainBlock = this._createDiv(), this.slider = this._createDiv(), this.columnBlock = this._createDiv(), this.placeHolder = this._createDiv(), this.columns = this._createDiv(), this.matrixBlock = this._createDiv(), this.rows = this._createDiv(), this.matrix = this._createDiv();
         }
         initialize() {
             this._initStyles(), this._initLayout(), this._adjustSize();
         }
         adjustScrollableBlocks() {
-            const E = this.matrix.offsetHeight - this.matrix.clientHeight,
+            const S = this.matrix.offsetHeight - this.matrix.clientHeight,
                 $ = this.matrix.offsetWidth - this.matrix.clientWidth;
-            E && (this.rows.style.height = `${this.rows.clientHeight - E}px`), $ && (this.columns.style.width = `${this.columns.clientWidth - $}px`);
+            S && (this.rows.style.height = `${this.rows.clientHeight - S}px`), $ && (this.columns.style.width = `${this.columns.clientWidth - $}px`);
         }
-        changeFont(E) {
-            this.chartArea.style.font = E.shorthand;
+        changeFont(S) {
+            this.chartArea.style.font = S.shorthand;
         }
         _adjustSize() {
-            const E = this._chart.measures;
-            this.chartArea.style.height = `${E.height}px`, this._chart.options().showSlider && (this.slider.style.height = `${E.sliderHeight}px`), this.columns.style.height = `${E.columnHeight}px`, this.columns.style.width = `${E.width - E.rowWidth - E.margin.left}px`, this.placeHolder.style.width = `${E.rowWidth + E.margin.left}px`, this.placeHolder.style.height = `${E.columnHeight}px`, this.rows.style.width = `${E.rowWidth + E.margin.left}px`, this.matrix.style.width = `${E.width + E.margin.right + E.rowWidth}px`;
+            const S = this._chart.measures;
+            this.chartArea.style.height = `${S.height}px`, this._chart.options().showSlider && (this.slider.style.height = `${S.sliderHeight}px`), this.columns.style.height = `${S.columnHeight}px`, this.columns.style.width = `${S.width - S.rowWidth - S.margin.left}px`, this.placeHolder.style.width = `${S.rowWidth + S.margin.left}px`, this.placeHolder.style.height = `${S.columnHeight}px`, this.rows.style.width = `${S.rowWidth + S.margin.left}px`, this.matrix.style.width = `${S.width + S.margin.right + S.rowWidth}px`;
         }
         _createDiv() {
             return document.createElement("div");
         }
         _initStyles() {
-            const E = this._chart.measures,
-                $ = E.width + E.margin.left + E.margin.right;
+            const S = this._chart.measures,
+                $ = S.width + S.margin.left + S.margin.right;
             let C = this.chartArea.style;
-            C.display = "flex", C.flexDirection = "column", C.cursor = "default", C.userSelect = "none", E.font.applyTo(this.chartArea), C = this.mainBlock.style, C.display = "flex", C.flexDirection = "column", C.flexGrow = 1, C.height = "1px", C = this.columnBlock.style, C.textAlign = "left", C.display = "flex", C.flexDirection = "row", C.flexShrink = 0, C.width = "1px", C = this.placeHolder.style, C.flexShrink = 0, C.backgroundColor = "white", C = this.columns.style, C.paddingTop = "5px", C.paddingBottom = "5px", C.overflow = "hidden", C.flexShrink = 0, C.width = `${$}px`, C = this.matrixBlock.style, C.display = "flex", C.flexDirection = "row", C.flexGrow = 0, C.width = "1px", C.overflowY = "auto", C.textAlign = "left", C.width = `${$}px`, C = this.rows.style, C.overflow = "hidden", C.flexShrink = 0, C = this.matrix.style, C.overflowX = "auto", this.matrix.onscroll = (O) => {
+            C.display = "flex", C.flexDirection = "column", C.cursor = "default", C.userSelect = "none", S.font.applyTo(this.chartArea), C = this.mainBlock.style, C.display = "flex", C.flexDirection = "column", C.flexGrow = 1, C.height = "1px", C = this.columnBlock.style, C.textAlign = "left", C.display = "flex", C.flexDirection = "row", C.flexShrink = 0, C.width = "1px", C = this.placeHolder.style, C.flexShrink = 0, C.backgroundColor = "white", C = this.columns.style, C.paddingTop = "5px", C.paddingBottom = "5px", C.overflow = "hidden", C.flexShrink = 0, C.width = `${$}px`, C = this.matrixBlock.style, C.display = "flex", C.flexDirection = "row", C.flexGrow = 0, C.width = "1px", C.overflowY = "auto", C.textAlign = "left", C.width = `${$}px`, C = this.rows.style, C.overflow = "hidden", C.flexShrink = 0, C = this.matrix.style, C.overflowX = "auto", this.matrix.onscroll = (D) => {
                 this.columns.scrollLeft = this.matrix.scrollLeft, this.rows.scrollTop = this.matrix.scrollTop;
             };
         }
         _initLayout() {
             this.chartArea.appendChild(this.mainBlock), this.mainBlock.appendChild(this.slider), this.mainBlock.appendChild(this.columnBlock), this.mainBlock.appendChild(this.matrixBlock), this.columnBlock.appendChild(this.placeHolder), this.columnBlock.appendChild(this.columns), this.matrixBlock.appendChild(this.rows), this.matrixBlock.appendChild(this.matrix);
         }
     }
-    class k {
-        constructor(E) {
-            this.chart = E, this.colors = {
+    class T {
+        constructor(S) {
+            this.chart = S, this.colors = {
                 row: "#caf0f8",
                 above: "#ffd166",
                 below: "#118ab2",
-                label: "black"
+                label: "#3c3c43"
             }, this.matrix = {
                 svg: null,
                 g: null,
                 og: null,
                 ig: null
-            }, this.columns = new F(this), this.rows = new T(this), this._uuid = `uu${Date.now()}${Math.floor(Math.random() * 1e4)}`;
+            }, this.columns = new L(this), this.rows = new F(this), this._uuid = `uu${Date.now()}${Math.floor(Math.random() * 1e4)}`;
         }
         render() {
             this._initMatrix(), this._renderGradients(), this.columns.render(), this.rows.render();
         }
-        _createSvg(E, $, C) {
-            return Yn.select(E).append("svg").attr("width", $ + 100).attr("height", C);
+        _createSvg(S, $, C) {
+            return pt.select(S).append("svg").attr("width", $ + 100).attr("height", C);
         }
-        _transform(E, $) {
-            return `translate(${E},${$})`;
+        _transform(S, $) {
+            return `translate(${S},${$})`;
         }
         _initMatrix() {
-            const E = this.chart,
+            const S = this.chart,
                 $ = this.matrix;
-            $.svg = this._createSvg(E.partitions.matrix, E.scales.maxX, E.scales.maxY), $.g = $.svg.append("g"), $.og = $.g.append("g"), $.ig = $.svg.append("g").attr("transform", this._transform(0, E.measures.padding / 2));
+            $.svg = this._createSvg(S.partitions.matrix, S.scales.maxX, S.scales.maxY), $.g = $.svg.append("g"), $.og = $.g.append("g"), $.ig = $.svg.append("g").attr("transform", this._transform(0, S.measures.padding / 2));
         }
-        uid(E) {
-            return `${this._uuid}_${E}`;
+        uid(S) {
+            return `${this._uuid}_${S}`;
         }
         _renderGradients() {
-            const E = this.chart,
+            const S = this.chart,
                 $ = (C) => {
-                    this.matrix.g.append("linearGradient").attr("id", this.uid(C ? "descending" : "ascending")).attr("x1", 0).attr("x2", E.measures.rowWidth + E.chartData.columns.length * E.measures.bubbleDiameter).attr("y1", "100%").attr("y2", "100%").attr("gradientUnits", "userSpaceOnUse").call((O) => {
-                        O.append("stop").attr("stop-color", this.colors.row).attr("stop-opacity", C ? 1 : 0).attr("offset", 0), O.append("stop").attr("stop-color", this.colors.row).attr("stop-opacity", C ? 0 : 1).attr("offset", 1);
+                    this.matrix.g.append("linearGradient").attr("id", this.uid(C ? "descending" : "ascending")).attr("x1", 0).attr("x2", S.measures.rowWidth + S.chartData.columns.length * S.measures.bubbleDiameter).attr("y1", "100%").attr("y2", "100%").attr("gradientUnits", "userSpaceOnUse").call((D) => {
+                        D.append("stop").attr("stop-color", this.colors.row).attr("stop-opacity", C ? 1 : 0).attr("offset", 0), D.append("stop").attr("stop-color", this.colors.row).attr("stop-opacity", C ? 0 : 1).attr("offset", 1);
                     });
                 };
             $(!1), $(!0);
         }
     }
-    class A {
-        constructor(E) {
-            this._mainRenderer = E, this.duration = 500;
+    class M {
+        constructor(S) {
+            this._mainRenderer = S, this.duration = 500;
         }
         get chart() {
             return this._mainRenderer.chart;
         }
         get matrix() {
             return this._mainRenderer.matrix;
         }
@@ -1022,292 +1022,277 @@
         }
         get rows() {
             return this._mainRenderer.rows;
         }
         get columns() {
             return this._mainRenderer.columns;
         }
-        uid(E) {
-            return this._mainRenderer.uid(E);
+        uid(S) {
+            return this._mainRenderer.uid(S);
         }
-        url(E) {
-            return `url(#${E})`;
+        url(S) {
+            return `url(#${S})`;
         }
     }
-    class F extends A {
-        constructor(E) {
-            super(E), this.text = null, this._arrow = null, this.labels = null, this.axis = null, this._focused = null, this.sortOnAxisClick = !0;
+    class L extends M {
+        constructor(S) {
+            super(S), this.text = null, this._arrow = null, this.labels = null, this.axis = null, this._focused = null, this.sortOnAxisClick = !0;
         }
         render() {
-            const E = this.chart,
-                O = Yn.select(E.partitions.columns).append("svg").attr("width", E.scales.maxX + E.measures.rowWidth + 0).attr("height", E.measures.columnHeight + 0).append("g");
-            this.labels = this._renderGroups(O, `translate(0,${E.measures.columnHeight})`, "start", (R) => {
-                this.text = R.append("text").attr("y", 0).attr("dy", "-0.25em").attr("transform", "rotate(-45)").attr("fill", this.colors.label).text(this._trim.bind(this)).on("click", this._click.bind(this)).on("pointerenter", this._handlePointerEnter.bind(this)).on("pointerleave", this._handlePointerLeave.bind(this));
-            }), this.axis = this._renderGroups(this.matrix.og, void 0, "middle", (R) => {
-                R.append("line").attr("y1", 0).attr("y2", E.scales.maxY).attr("stroke-width", 1).attr("stroke", "#8d99ae");
+            const S = this.chart,
+                D = pt.select(S.partitions.columns).append("svg").attr("width", S.scales.maxX + S.measures.rowWidth + 0).attr("height", S.measures.columnHeight + 0).append("g");
+            D.append("text").text(a).attr("y", 10).attr("x", 10).attr("font-weight", "bold").attr("font-size", 12), this.labels = this._renderGroups(D, `translate(0,${S.measures.columnHeight})`, "start", (z) => {
+                this.text = z.append("text").attr("y", 0).attr("dy", "-0.25em").attr("transform", "rotate(-45)").attr("fill", this.colors.label).text(this._trim.bind(this)).on("click", this._click.bind(this)).on("pointerenter", this._handlePointerEnter.bind(this)).on("pointerleave", this._handlePointerLeave.bind(this));
+            });
+            const I = "#a7a7a7";
+            this.axis = this._renderGroups(this.matrix.og, void 0, "middle", (z) => {
+                z.append("line").attr("y1", 0).attr("y2", S.scales.maxY).attr("stroke-width", 1).attr("stroke", I);
             });
         }
-        _renderGroups(E, $, C, O) {
-            const R = this.chart,
-                L = E.append("g");
-            return $ && L.attr("transform", $), L.selectAll("g").data(R.chartData.columns).join("g").attr("text-anchor", C).attr("transform", (P, z) => `translate(${R.scales.x(z) + R.measures.bubbleRadius},0)`).call(O);
+        _renderGroups(S, $, C, D) {
+            const I = this.chart,
+                z = S.append("g");
+            return $ && z.attr("transform", $), z.selectAll("g").data(I.chartData.columns).join("g").attr("text-anchor", C).attr("transform", (H, G) => `translate(${I.scales.x(G) + I.measures.bubbleRadius},0)`).call(D);
         }
-        _trim(E) {
-            return this.chart.measures.trim("" + E.name);
+        _trim(S) {
+            return this.chart.measures.trim("" + S.name);
         }
-        _click(E, $) {
+        _click(S, $) {
             this._sort($), this._arrow && this._arrow.attr("d", (C) => {
-                if ($.order !== y.none && $.name === C.name) {
-                    const O = this.chart.measures.getBBox(this._trim(C)),
-                        R = O.height / 2 + 1,
-                        L = O.width,
-                        P = 5;
-                    return $.order === y.descending ? `M 0 ${R} L ${L} ${R} L ${L} ${R + P} L 0 ${R}` : `M 0 ${R} L 0 ${R + P} L ${L} ${R} L 0 ${R}`;
+                if ($.order !== v.none && $.name === C.name) {
+                    const D = this.chart.measures.getBBox(this._trim(C)),
+                        I = D.height / 2 + 1,
+                        z = D.width,
+                        H = 5;
+                    return $.order === v.descending ? `M 0 ${I} L ${z} ${I} L ${z} ${I + H} L 0 ${I}` : `M 0 ${I} L 0 ${I + H} L ${z} ${I} L 0 ${I}`;
                 }
-            }), this._focused !== $ ? (this.columns.axis.select("line").attr("stroke-width", (C) => C.name === $.name ? 2 : 1), this.columns.text.attr("font-weight", (C) => C.name === $.name ? "bold" : ""), this._focused = $, u("message", {
+            }), this._focused !== $ ? (this.columns.axis.select("line").attr("stroke-width", (C) => C.name === $.name ? 2 : 1), this.columns.text.attr("font-weight", (C) => C.name === $.name ? "bold" : ""), this._focused = $, c("message", {
                 selection_type: "col",
                 col: "" + $.name,
                 row: null,
                 sortOrder: $.order
-            }), this.rows._rowFocused != null && (this.rows._bubbleRects.attr("stroke-width", 0), this.rows._labelRects.attr("stroke-width", 0), this.rows._rowFocused = null)) : (this.columns.axis.select("line").attr("stroke-width", 1), this.columns.text.attr("font-weight", ""), this._focused = null, u("message", {
+            }), this.rows._rowFocused != null && (this.rows._bubbleRects.attr("stroke-width", 0), this.rows._labelRects.attr("stroke-width", 0), this.rows._rowFocused = null)) : (this.columns.axis.select("line").attr("stroke-width", 1), this.columns.text.attr("font-weight", ""), this._focused = null, c("message", {
                 selection_type: "col",
                 col: null,
                 row: null,
                 sortOrder: $.order
             }));
         }
-        _sort(E) {
+        _sort(S) {
             if (this.sortOnAxisClick) {
-                let z = function(V) {
-                    V.transition().duration((X, se) => se * P).attr("transform", (X) => {
-                        let se = 0;
-                        for (let ee = 0; ee < L.length; ee++)
-                            if (L[ee].row === X) {
-                                X.position = se = ee;
+                let G = function(te) {
+                    te.transition().duration((K, ae) => ae * H).attr("transform", (K) => {
+                        let ae = 0;
+                        for (let U = 0; U < z.length; U++)
+                            if (z[U].row === K) {
+                                K.position = ae = U;
                                 break;
                             }
-                        return `translate(0,${$.chart.scales.y(se)})`;
+                        return `translate(0,${$.chart.scales.y(ae)})`;
                     });
                 };
                 const $ = this,
                     C = this.chart.chartData,
-                    O = C.columns,
-                    R = O.indexOf(E),
-                    L = C.rows.map((V) => ({
-                        row: V,
-                        column: V.cells[R]
+                    D = C.columns,
+                    I = D.indexOf(S),
+                    z = C.rows.map((te) => ({
+                        row: te,
+                        column: te.cells[I]
                     }));
-                C.resetColumns(E), E.order === y.none ? E.order = y.descending : E.order === y.descending ? E.order = y.ascending : E.order = y.none, E.order === y.ascending ? L.sort((V, X) => V.column.value - X.column.value) : E.order === y.descending && L.sort((V, X) => X.column.value - V.column.value);
-                const P = this.duration / C.rows.length;
-                z(this.rows.axis), z(this.rows.labels), this.rows.relocateAnnotation();
+                C.resetColumns(S), S.order === v.none ? S.order = v.descending : S.order === v.descending ? S.order = v.ascending : S.order = v.none, S.order === v.ascending ? z.sort((te, K) => te.column.value - K.column.value) : S.order === v.descending && z.sort((te, K) => K.column.value - te.column.value);
+                const H = this.duration / C.rows.length;
+                G(this.rows.axis), G(this.rows.labels), this.rows.relocateAnnotation();
             }
         }
-        _handlePointerEnter(E, $) {
-            this.onhover && this.onhover(E, $), this.axis.select("line").attr("stroke-width", (C) => C.name === $.name || this._focused != null && C.name === this._focused.name ? 2 : 1), this.text.attr("font-weight", (C) => C.name === $.name || this._focused != null && C.name === this._focused.name ? "bold" : "");
+        _handlePointerEnter(S, $) {
+            this.onhover && this.onhover(S, $), this.axis.select("line").attr("stroke-width", (C) => C.name === $.name || this._focused != null && C.name === this._focused.name ? 2 : 1), this.text.attr("font-weight", (C) => C.name === $.name || this._focused != null && C.name === this._focused.name ? "bold" : "");
         }
-        _handlePointerLeave(E, $) {
-            this._focused == null ? (this.oncancel && this.oncancel(E, $), this.axis.select("line").attr("stroke-width", 1), this.text.attr("font-weight", "")) : (this.axis.select("line").attr("stroke-width", (C) => C.name === this._focused.name ? 2 : 1), this.text.attr("font-weight", (C) => C.name === this._focused.name ? "bold" : ""));
+        _handlePointerLeave(S, $) {
+            this._focused == null ? (this.oncancel && this.oncancel(S, $), this.axis.select("line").attr("stroke-width", 1), this.text.attr("font-weight", "")) : (this.axis.select("line").attr("stroke-width", (C) => C.name === this._focused.name ? 2 : 1), this.text.attr("font-weight", (C) => C.name === this._focused.name ? "bold" : ""));
         }
     }
-    class T extends A {
-        constructor(E) {
-            super(E), this._tooltip = null, this._annotation = null, this.labels = null, this.axis = null, this.highlight = I.matrix, this.showTooltip = !0, this.showAnnotation = !0, this.sortOnAxisClick = !0, this._labelRects = null, this._bubbleRects = null, this._bubbles = null, this._focused = null, this._rowFocused = null, this.onhover = null, this.oncancel = null, this.onclick = null;
+    class F extends M {
+        constructor(S) {
+            super(S), this._tooltip = null, this._annotation = null, this.labels = null, this.axis = null, this.highlight = O.matrix, this.showTooltip = !0, this.showAnnotation = !0, this.sortOnAxisClick = !0, this._labelRects = null, this._bubbleRects = null, this._bubbles = null, this._focused = null, this._rowFocused = null, this.onhover = null, this.oncancel = null, this.onclick = null;
         }
         get bubbles() {
             return this._bubbles;
         }
         render() {
             this._initInfoLayer();
-            const E = this.chart,
-                $ = Yn.select(E.partitions.rows).append("svg").attr("width", E.measures.rowWidth).attr("height", E.scales.maxY).append("g").attr("transform", `translate(0,${E.measures.padding / 2})`);
-            this.labels = this._renderGroups($, (O) => {
-                this._labelRects = this._renderRect(O, 1, E.measures.rowWidth + 10).on("click", this._click.bind(this)), O.append("text").attr("font-weight", "bold").attr("y", E.measures.bubbleRadius).attr("dx", "1em").attr("dy", "0.25em").attr("fill", this.colors.label).text((R) => R.name).on("click", this._click.bind(this));
+            const S = this.chart,
+                $ = pt.select(S.partitions.rows).append("svg").attr("width", S.measures.rowWidth).attr("height", S.scales.maxY).append("g").attr("transform", `translate(0,${S.measures.padding / 2})`);
+            this.labels = this._renderGroups($, (D) => {
+                this._labelRects = this._renderRect(D, 1, S.measures.rowWidth + 10).on("click", this._click.bind(this)), D.append("text").attr("font-weight", "bold").attr("y", S.measures.bubbleRadius).attr("dx", "1em").attr("dy", "0.25em").attr("fill", this.colors.label).text((I) => I.name).on("click", this._click.bind(this));
             });
-            const C = E.chartData.columns.length * E.measures.bubbleDiameter;
-            this.axis = this._renderGroups(this.matrix.ig.append("g"), (O) => {
-                this._bubbleRects = this._renderRect(O, -11, C + 10), this._bubbles = O.append("g").selectAll("g").data((R) => R.cells).join("g").attr("transform", (R, L) => `translate(${E.scales.x(L) + E.measures.bubbleRadius},0)`).call((R) => {
-                    R.append("circle").attr("class", "bubble").attr("fill", (L) => L.value >= E.chartData.average ? this.colors.above : this.colors.below).attr("opacity", 0.5).attr("stroke-width", 2).attr("cy", E.measures.bubbleRadius).attr("r", 0);
-                }).on("click", this._handleClick.bind(this)), this._bubbles.selectAll("circle").transition().ease(Yn.easeBounce).duration(500).attr("r", (R) => R.value ? E.scales.r(R.value) : 0);
+            const C = S.chartData.columns.length * S.measures.bubbleDiameter;
+            this.axis = this._renderGroups(this.matrix.ig.append("g"), (D) => {
+                this._bubbleRects = this._renderRect(D, -11, C + 10), this._bubbles = D.append("g").selectAll("g").data((I) => I.cells).join("g").attr("transform", (I, z) => `translate(${S.scales.x(z) + S.measures.bubbleRadius},0)`).call((I) => {
+                    I.append("circle").attr("class", "bubble").attr("fill", (z) => z.value >= S.chartData.average ? this.colors.above : this.colors.below).attr("opacity", 0.5).attr("stroke-width", 2).attr("cy", S.measures.bubbleRadius).attr("r", 0);
+                }).on("click", this._handleClick.bind(this)).on("pointerenter", this._handlePointerEnter.bind(this)).on("pointermove", this._handlePointerMove.bind(this)).on("pointerleave", this._handlePointerLeave.bind(this)), this._bubbles.selectAll("circle").transition().ease(pt.easeBounce).duration(500).attr("r", (I) => I.value ? S.scales.r(I.value) : 0);
             });
         }
-        // this.highlightBubbles(); // TEMP: remove highlighting
-        relocateAnnotation(E = !0) {
+        // this.highlightBubbles(); // Remove highlighting
+        relocateAnnotation(S = !0) {
             if (this._focused) {
                 const $ = () => this._showAnnotation(null, this._focused);
-                this._annotation.hide(), E ? setTimeout($, this.duration) : $();
+                this._annotation.hide(), S ? setTimeout($, this.duration) : $();
             }
         }
-        _handleClick(E, $) {
-            this.chart, this.onclick && this.onclick(E, $);
+        _handleClick(S, $) {
+            this.chart, this.onclick && this.onclick(S, $);
         }
-        _showAnnotation(E, $) {}
-        // const
-        //     a = this._annotation,
-        //     getPosition = (axis, name) => {
-        //         const obj = axis.find(d => d.name === name);
-        //         return obj ? obj.position : 0;
-        //     }
-        // if (this.showAnnotation) {
-        //     const
-        //         cx = c.scales.x(getPosition(c.chartData.columns, d.column)),
-        //         cy = c.scales.y(getPosition(c.chartData.rows, d.row)),
-        //         r = c.scales.r(d.value),
-        //         color = d.value >= c.chartData.level ? this.colors.above : this.colors.below;
-        //     this._focused = d;
-        //     a.hide();
-        //     a.show(
-        //         null, this._getTooltipContent(d),
-        //         cx + c.measures.bubbleRadius,
-        //         cy + c.measures.bubbleRadius + c.measures.padding / 2,
-        //         r, d3.color(color).darker(1));
-        // }
-        _handlePointerEnter(E, $) {
-            this.chart, this.onhover && this.onhover(E, $), this.columns.axis.select("line").attr("stroke-width", (C) => C.name === $.column ? 2 : 1), this.columns.text.attr("font-weight", (C) => C.name === $.column ? "bold" : "");
+        _showAnnotation(S, $) {
+            const C = this.chart,
+                D = this._annotation,
+                I = (z, H) => {
+                    const G = z.find((te) => te.name === H);
+                    return G ? G.position : 0;
+                };
+            if (this.showAnnotation) {
+                const z = C.scales.x(I(C.chartData.columns, $.column)),
+                    H = C.scales.y(I(C.chartData.rows, $.row)),
+                    G = C.scales.r($.value),
+                    te = $.value >= C.chartData.level ? this.colors.above : this.colors.below;
+                this._focused = $, D.hide(), D.show(null, this._getTooltipContent($), z + C.measures.bubbleRadius, H + C.measures.bubbleRadius + C.measures.padding / 2, G, pt.color(te).darker(1));
+            }
         }
-        // if (this._focused == null) {
-        //     // if (this.showTooltip) this._tooltip.show(e, this._getTooltipContent(d));
-        //     if (this.onhover) this.onhover(e, d);
-        //     this.columns.axis.select("line").attr("stroke-width", col => col.name === d.column ? 2 : 1);
-        //     this.columns.text.attr("font-weight", col => col.name === d.column ? "bold" : "");
-        //     dispatch("message", {selection_type: "cell", row: ("" + d.row) , col: ("" + d.column)})
-        //     // Add shadow
-        //     this._bubbles.filter(b => b === d)
-        //     .call(g => {
-        //         // g.select(".bubble").attr("transform", "translate(1,-1.5)");
-        //         g.insert("circle", "circle")
-        //         .attr("class", "shadow")
-        //         .attr("cy", c.measures.bubbleRadius)
-        //         .attr("r", d => d.value ? c.scales.r(d.value) : 0)
-        //         .attr("fill", d => {
-        //             const color = d.value >= c.chartData.level ? this.colors.above : this.colors.below;
-        //             return d3.color(color).darker(1);
-        //         })
-        //     });  // TEMP: remove threshold-based circle coloring
-        // }
-        _handlePointerMove(E) {
-            this.showTooltip && this._tooltip.move(E);
+        _handlePointerEnter(S, $) {
+            const C = this.chart;
+            this.onhover && this.onhover(S, $), this.columns.axis.select("line").attr("stroke-width", (D) => D.name === $.column ? 2 : 1), this._focused == null && (this.showTooltip && this._tooltip.show(S, this._getTooltipContent($)), this.onhover && this.onhover(S, $), this._bubbles.filter((D) => D === $).call((D) => {
+                D.insert("circle", "circle").attr("class", "shadow").attr("cy", C.measures.bubbleRadius).attr("r", (I) => I.value ? C.scales.r(I.value) : 0).attr("fill", (I) => {
+                    const z = I.value >= C.chartData.level ? this.colors.above : this.colors.below;
+                    return pt.color(z).darker(1);
+                }).attr("opacity", 0.5);
+            }));
+        }
+        _handlePointerMove(S) {
+            this.showTooltip && this._tooltip.move(S);
         }
-        _handlePointerLeave(E, $) {
-            this._focused == null && (this.oncancel && this.oncancel(E, $), this.columns.axis.select("line").attr("stroke-width", 1), this.columns.text.attr("font-weight", ""));
+        _handlePointerLeave(S, $) {
+            this.showTooltip && this._tooltip.hide(), this._focused == null && (this.oncancel && this.oncancel(S, $), this.columns.axis.select("line").attr("stroke-width", 1), this._bubbles.filter((C) => C === $).call((C) => {
+                C.select(".bubble").attr("transform", ""), C.select(".shadow").remove();
+            }));
         }
-        //         g.select(".bubble").attr("transform", "");
-        //     });
-        highlightBubbles(E) {
+        highlightBubbles(S) {
             const $ = this.chart.measures.bubbleRadius,
-                C = (z) => this.highlight === I.byRow && ((z.flag & b.rowMin) === b.rowMin || (z.flag & b.rowMax) === b.rowMax),
-                O = (z) => this.highlight === I.matrix && ((z.flag & b.min) === b.min || (z.flag & b.max) === b.max),
-                R = (z) => this.highlight === I.top && (z.flag & b.topGroup) === b.topGroup,
-                L = (z) => this.highlight === I.bottom && (z.flag & b.bottomGroup) === b.bottomGroup,
-                P = this._bubbles.filter((z) => z.value && (C(z) || O(z) || R(z) || L(z)));
-            P.select("circle").attr("stroke", (z) => {
-                const V = z.value >= this.chart.chartData.level ? this.colors.above : this.colors.below;
-                return Yn.color(V).darker(0.75);
-            }), E || P.append("text").attr("text-anchor", "middle").attr("y", (z) => {
-                const V = this.chart.scales.r(z.value);
-                return this.chart.measures.calculateStringWidth(this._formatValue(z.value)) + 5 > V * 2 ? $ + V + 12 : $;
-            }).attr("dy", "0.3em").attr("fill", this.colors.label).attr("font-weight", "bold").text((z) => this._formatValue(z.value));
+                C = (G) => this.highlight === O.byRow && ((G.flag & x.rowMin) === x.rowMin || (G.flag & x.rowMax) === x.rowMax),
+                D = (G) => this.highlight === O.matrix && ((G.flag & x.min) === x.min || (G.flag & x.max) === x.max),
+                I = (G) => this.highlight === O.top && (G.flag & x.topGroup) === x.topGroup,
+                z = (G) => this.highlight === O.bottom && (G.flag & x.bottomGroup) === x.bottomGroup,
+                H = this._bubbles.filter((G) => G.value && (C(G) || D(G) || I(G) || z(G)));
+            H.select("circle").attr("stroke", (G) => {
+                const te = G.value >= this.chart.chartData.level ? this.colors.above : this.colors.below;
+                return pt.color(te).darker(0.75);
+            }), S || H.append("text").attr("text-anchor", "middle").attr("y", (G) => {
+                const te = this.chart.scales.r(G.value);
+                return this.chart.measures.calculateStringWidth(this._formatValue(G.value)) + 5 > te * 2 ? $ + te + 12 : $;
+            }).attr("dy", "0.3em").attr("fill", this.colors.label).attr("font-weight", "bold").text((G) => this._formatValue(G.value));
         }
-        _formatValue(E, $ = !0) {
+        _formatValue(S, $ = !0) {
             const C = this.chart.chartData.numberIsPercentage ? ".1%" : $ ? ".2s" : ",.2f";
-            return Yn.format(C)(E);
+            return pt.format(C)(S);
         }
         _initInfoLayer() {
-            const E = this,
+            const S = this,
                 $ = this.chart.measures.font;
             if (this.showAnnotation) {
-                const O = $.clone().family("system-ui").size("11px").weight("bold");
-                this._annotation = new x(this.matrix.svg, O, "none"), C(this._annotation, O);
+                const D = $.clone().family("system-ui").size("11px").weight("bold");
+                this._annotation = new E(this.matrix.svg, D, "none"), C(this._annotation, D);
             }
-            this.showTooltip && (this._tooltip = new v(this.matrix.svg, $, "white", 0.7, "#aaa"), C(this._tooltip, $));
+            this.showTooltip && (this._tooltip = new w(this.matrix.svg, $, "white", 0.7, "#aaa"), C(this._tooltip, $));
 
-            function C(O, R) {
-                O.getBBox = (L) => E.chart.measures.getBBox(L, void 0, R), O.calcTextWidth = (L) => E.chart.measures.calculateStringWidth(L, void 0, R), O.calcPosition = (L, P) => E._calcTooltipPosition(L, P);
+            function C(D, I) {
+                D.getBBox = (z) => S.chart.measures.getBBox(z, void 0, I), D.calcTextWidth = (z) => S.chart.measures.calculateStringWidth(z, void 0, I), D.calcPosition = (z, H) => S._calcTooltipPosition(z, H);
             }
         }
-        _getTooltipContent(E) {
-            const $ = this.chart.fieldNames;
-            return [
-                `${$.row}: ${E.row}`,
-                `${$.column}: ${E.column}`,
-                `${$.value}: ${this._formatValue(E.value, !1)}`,
-                `${$.detail}: ${E.detail.slice(0, 50)}...`
-            ];
+        _getTooltipContent(S) {
+            if (this.chart.fieldNames, u === "")
+                return [`${S.value} docs`];
+            if (u === "concept")
+                return [`${pt.format(".1%")(S.value)} of concept`];
+            if (u === "slice")
+                return [`${pt.format(".1%")(S.value)} of slice`];
         }
-        _calcTooltipPosition(E, $) {
+        _calcTooltipPosition(S, $) {
             const C = this.matrix.svg.node().getBoundingClientRect(),
-                O = E.x + C.left,
-                R = E.y + C.top,
-                L = 5,
-                P = O + $.width + L > C.right ? E.x - $.width - L : E.x + L,
-                z = R + $.height + L > C.bottom ? E.y - $.height - L : E.y + L;
+                D = S.x + C.left,
+                I = S.y + C.top,
+                z = 5,
+                H = D + $.width + z > C.right ? S.x - $.width - z : S.x + z,
+                G = I + $.height + z > C.bottom ? S.y - $.height - z : S.y + z;
             return {
-                left: P,
-                top: z
+                left: H,
+                top: G
             };
         }
-        _renderGroups(E, $) {
+        _renderGroups(S, $) {
             const C = this.chart;
-            return E.selectAll("g").data(C.chartData.rows).join("g").attr("transform", (O, R) => `translate(0,${C.scales.y(R)})`).call($).on("click", this._rowClick.bind(this)).on("pointerenter", (O, R) => {
-                this._bubbleRects.attr("opacity", (L) => L.name === R.name ? 0.8 : 0.5), this._labelRects.attr("opacity", (L) => L.name === R.name ? 0.8 : 0.5);
-            }).on("pointerleave", (O, R) => {
-                this._bubbleRects.attr("opacity", 0.5), this._labelRects.attr("opacity", 0.5);
-            });
+            return S.selectAll("g").data(C.chartData.rows).join("g").attr("transform", (D, I) => `translate(0,${C.scales.y(I)})`).call($).on("click", this._rowClick.bind(this)).on("pointerenter", (D, I) => {
+                this._bubbleRects.attr("fill", (z) => z.name === I.name ? pt.color(this.colors.row).darker(0.3) : this.colors.row), this._labelRects.attr("fill", (z) => z.name === I.name ? pt.color(this.colors.row).darker(0.3) : this.colors.row);
+            }).on(
+                "pointerleave",
+                // this._labelRects.attr("stroke-width", row => row.name === d.name ? 2 : 0);
+                (D, I) => {
+                    this._bubbleRects.attr("fill", this.colors.row), this._labelRects.attr("fill", this.colors.row);
+                }
+            );
         }
-        _rowClick(E, $) {
-            this._rowFocused !== $ ? (this._bubbleRects.attr("stroke-width", (C) => C.name === $.name ? 2 : 0), this._labelRects.attr("stroke-width", (C) => C.name === $.name ? 2 : 0), this._rowFocused = $, u("message", {
+        _rowClick(S, $) {
+            this._rowFocused !== $ ? (this._bubbleRects.attr("stroke-width", (C) => C.name === $.name ? 2 : 0), this._labelRects.attr("stroke-width", (C) => C.name === $.name ? 2 : 0), this._bubbleRects.attr("fill", (C) => C.name === $.name ? pt.color(this.colors.row).darker(0.3) : this.colors.row), this._labelRects.attr("fill", (C) => C.name === $.name ? pt.color(this.colors.row).darker(0.3) : this.colors.row), this._rowFocused = $, c("message", {
                 selection_type: "row",
                 row: "" + $.name,
                 col: null,
                 sortOrder: $.order
-            }), this.columns._focused != null && (this.columns.axis.select("line").attr("stroke-width", 1), this.columns.text.attr("font-weight", ""), this.columns._focused = null)) : (this._bubbleRects.attr("stroke-width", 0), this._labelRects.attr("stroke-width", 0), this._rowFocused = null, u("message", {
+            }), this.columns._focused != null && (this.columns.axis.select("line").attr("stroke-width", 1), this.columns.text.attr("font-weight", ""), this.columns._focused = null)) : (this._bubbleRects.attr("stroke-width", 0), this._labelRects.attr("stroke-width", 0), this._bubbleRects.attr("fill", this.colors.row), this._labelRects.attr("fill", this.colors.row), this._rowFocused = null, c("message", {
                 selection_type: "row",
                 row: null,
                 col: null,
                 sortOrder: $.order
             }));
         }
-        _renderRect(E, $, C) {
-            const O = this.chart;
-            return E.append("rect").attr("width", C).attr("height", O.measures.bubbleDiameter).attr("x", $).attr("rx", 10).attr("opacity", 0.5).attr("fill", this.colors.row).attr("stroke", Yn.color(this.colors.row).darker(1)).attr("stroke-width", 0);
-        }
-        _click(E, $) {
-            this._sort($), this._labelRects.attr("fill", (C) => C.order === y.ascending ? "white" : this.colors.row), this._bubbleRects.attr("fill", (C) => {
-                if (C.order === y.none)
+        _renderRect(S, $, C) {
+            const D = this.chart;
+            return S.append("rect").attr("width", C).attr("height", D.measures.bubbleDiameter).attr("x", $).attr("rx", 10).attr("opacity", 0.5).attr("fill", this.colors.row).attr("stroke", pt.color(this.colors.row).darker(1)).attr("stroke-width", 0);
+        }
+        _click(S, $) {
+            this._sort($), this._labelRects.attr("fill", (C) => C.order === v.ascending ? "white" : this.colors.row), this._bubbleRects.attr("fill", (C) => {
+                if (C.order === v.none)
                     return this.colors.row;
                 {
-                    const O = this.uid(C.order === y.ascending ? "ascending" : "descending");
-                    return C === $ ? this.url(O) : this.colors.row;
+                    const D = this.uid(C.order === v.ascending ? "ascending" : "descending");
+                    return C === $ ? this.url(D) : this.colors.row;
                 }
             });
         }
-        _sort(E) {
+        _sort(S) {
             if (this.sortOnAxisClick) {
-                let z = function(V) {
-                    V.transition().duration((X, se) => se * R).attr("transform", (X) => {
-                        let se = 0;
-                        for (let ee = 0; ee < O.length; ee++)
-                            if (O[ee].column === X.name) {
-                                X.position = se = ee, $.push(ee);
+                let G = function(te) {
+                    te.transition().duration((K, ae) => ae * I).attr("transform", (K) => {
+                        let ae = 0;
+                        for (let U = 0; U < D.length; U++)
+                            if (D[U].column === K.name) {
+                                K.position = ae = U, $.push(U);
                                 break;
                             }
-                        return `translate(${L(se) + P},0)`;
+                        return `translate(${z(ae) + H},0)`;
                     });
                 };
                 const $ = [],
                     C = this.chart.chartData,
-                    O = E.cells.map((V) => V);
-                C.resetRows(E), E.order === y.none ? E.order = y.descending : E.order === y.descending ? E.order = y.ascending : E.order = y.none, E.order === y.ascending ? O.sort((V, X) => V.value - X.value) : E.order === y.descending && O.sort((V, X) => X.value - V.value);
-                const R = this.duration / C.columns.length,
-                    L = this.chart.scales.x,
-                    P = this.chart.measures.bubbleRadius;
-                z(this.columns.axis), z(this.columns.labels), this.relocateAnnotation(), this._bubbles.transition().duration((V, X) => X * R).attr("transform", (V, X) => `translate(${L($[X]) + P},0)`);
+                    D = S.cells.map((te) => te);
+                C.resetRows(S), S.order === v.none ? S.order = v.descending : S.order === v.descending ? S.order = v.ascending : S.order = v.none, S.order === v.ascending ? D.sort((te, K) => te.value - K.value) : S.order === v.descending && D.sort((te, K) => K.value - te.value);
+                const I = this.duration / C.columns.length,
+                    z = this.chart.scales.x,
+                    H = this.chart.measures.bubbleRadius;
+                G(this.columns.axis), G(this.columns.labels), this.relocateAnnotation(), this._bubbles.transition().duration((te, K) => K * I).attr("transform", (te, K) => `translate(${z($[K]) + H},0)`);
             }
         }
     }
-    class I {
+    class O {
         static get matrix() {
             return 0;
         }
         static get byRow() {
             return 1;
         }
         static get top() {
@@ -1323,120 +1308,122 @@
         }
         get maxX() {
             return this._maxX;
         }
         get maxY() {
             return this._maxY;
         }
-        initialize(E) {
-            const $ = E.measures,
-                C = E.chartData;
-            this.x = (O) => O * $.bubbleDiameter, this.y = (O) => O * ($.bubbleDiameter + $.padding), this.r = Yn.scaleLinear().domain([C.min, C.max]).range([$.bubbleRadius * 0.2, $.bubbleRadius - 1.5]), this._maxX = this.x(C.columns.length), this._maxY = this.y(C.rows.length);
+        initialize(S) {
+            const $ = S.measures,
+                C = S.chartData;
+            this.x = (D) => D * $.bubbleDiameter, this.y = (D) => D * ($.bubbleDiameter + $.padding), this.r = pt.scaleLinear().domain([C.min, C.max]).range([$.bubbleRadius * 0.2, $.bubbleRadius - 1.5]), this._maxX = this.x(C.columns.length), this._maxY = this.y(C.rows.length);
         }
     }
-    class D {
-        constructor(E, $) {
-            this._chart = E, this._caption = $, this._g = null, this._label = null, this._below = null, this._above = null, this._width = 0, this._min = 0, this._max = 0, this._defaultValue = 0;
+    class R {
+        constructor(S, $) {
+            this._chart = S, this._caption = $, this._g = null, this._label = null, this._below = null, this._above = null, this._width = 0, this._min = 0, this._max = 0, this._defaultValue = 0;
         }
         get level() {
             return this._chart.chartData.level;
         }
-        set level(E) {
-            this._chart.chartData.level = E;
+        set level(S) {
+            this._chart.chartData.level = S;
         }
         get defaultLevel() {
             return this._chart.chartData.defaultLevel;
         }
         get isPercent() {
             return this._chart.chartData.numberIsPercentage;
         }
         get height() {
             return this._chart.measures.sliderHeight;
         }
         get rowRenderer() {
             return this._chart.renderer.rows;
         }
         render() {
-            const E = this._chart.measures;
-            this._initialize(), this._g = Yn.select(this._chart.partitions.slider).append("svg").attr("width", E.width).attr("height", this.height).append("g"), this._renderLabel(), this._renderColorRects(), this._renderSlider();
+            const S = this._chart.measures;
+            this._initialize(), this._g = pt.select(this._chart.partitions.slider).append("svg").attr("width", S.width).attr("height", this.height).append("g"), this._renderLabel(), this._renderColorRects(), this._renderSlider();
         }
         _initialize() {
-            const E = this._chart.measures,
+            const S = this._chart.measures,
                 $ = this._chart.chartData;
-            this._defaultValue = this.isPercent ? this.defaultLevel * 100 : this._roundUp(this.defaultLevel, 1), this._width = (E.width - E.rowWidth) / 2;
+            this._defaultValue = this.isPercent ? this.defaultLevel * 100 : this._roundUp(this.defaultLevel, 1), this._width = (S.width - S.rowWidth) / 2;
             let C = $.min,
-                O = $.max;
-            this.isPercent && (C = C * 100, O = O * 100 + 1, C = C > 0 ? C - 1 : C), this._min = C, this._max = O;
+                D = $.max;
+            this.isPercent && (C = C * 100, D = D * 100 + 1, C = C > 0 ? C - 1 : C), this._min = C, this._max = D;
         }
         _renderLabel() {
             this._label = this._g.append("text").attr("x", this._width + 12).attr("y", 10).attr("dy", "0.5em").attr("fill", "black"), this._updateLabel(this._defaultValue);
         }
         _renderColorRects() {
             const {
-                a: E,
+                a: S,
                 b: $
-            } = this._getSafeBound(), C = (this._defaultValue - E) / ($ - E) * this._width;
+            } = this._getSafeBound(), C = (this._defaultValue - S) / ($ - S) * this._width;
             this._below = this._g.append("rect").attr("y", 2).attr("rx", 5).attr("width", C).attr("height", this.height - 2).attr("opacity", 0.5).attr("fill", this._chart.renderer.colors.below), this._above = this._g.append("rect").attr("x", C).attr("y", 2).attr("rx", 5).attr("width", this._width - C).attr("height", this.height - 2).attr("opacity", 0.5).attr("fill", this._chart.renderer.colors.above);
         }
         _renderSlider() {
             const {
-                a: E,
+                a: S,
                 b: $
             } = this._getSafeBound(), C = this._g.append("foreignObject").attr("width", this._width + 2).attr("height", this.height);
-            this._slider = C.append("xhtml:input").attr("type", "range").attr("min", E).attr("max", $).style("width", `${this._width - 5}px`).style("height", `${this._height}px`).on("click", (O) => O.stopPropagation()).on("dblclick", (O) => {
-                this._slider.node().value = this._defaultValue, this._change(), O.stopPropagation();
+            this._slider = C.append("xhtml:input").attr("type", "range").attr("min", S).attr("max", $).style("width", `${this._width - 5}px`).style("height", `${this._height}px`).on("click", (D) => D.stopPropagation()).on("dblclick", (D) => {
+                this._slider.node().value = this._defaultValue, this._change(), D.stopPropagation();
             }).on("input", () => this._change()), this._slider.node().value = this._defaultValue;
         }
         _change() {
             const {
-                a: E,
+                a: S,
                 b: $
-            } = this._getSafeBound(), C = +this._slider.node().value, O = C < E ? E : C > $ ? $ : C, R = (O - E) / ($ - E) * this._width;
-            this._below.attr("width", R), this._above.attr("x", R).attr("width", this._width - R), this._updateLabel(C), this.level = this.isPercent ? C / 100 : C;
-            const L = this._chart.renderer.colors;
-            this.rowRenderer.bubbles.selectAll("circle").transition().duration(1e3).ease(Yn.easeBounce).attr("fill", (P) => P.value >= this.level ? L.above : L.below).attr("opacity", 0.5), this.rowRenderer.relocateAnnotation(!1);
+            } = this._getSafeBound(), C = +this._slider.node().value, D = C < S ? S : C > $ ? $ : C, I = (D - S) / ($ - S) * this._width;
+            this._below.attr("width", I), this._above.attr("x", I).attr("width", this._width - I), this._updateLabel(C), this.level = this.isPercent ? C / 100 : C;
+            const z = this._chart.renderer.colors;
+            this.rowRenderer.bubbles.selectAll("circle").transition().duration(1e3).ease(pt.easeBounce).attr("fill", (H) => H.value >= this.level ? z.above : z.below).attr("opacity", 0.5), this.rowRenderer.relocateAnnotation(!1);
         }
         _getSafeBound() {
-            const E = this.isPercent ? this._min : this._roundDown(this._min, 2),
+            const S = this.isPercent ? this._min : this._roundDown(this._min, 2),
                 $ = this.isPercent ? this._max : this._roundUp(this._max, 2);
             return {
-                a: E,
+                a: S,
                 b: $
             };
         }
-        _roundUp(E, $) {
-            const C = E < 0 ? -1 : 1,
-                O = Math.ceil(Math.abs(E)).toString(),
-                R = Math.pow(10, O.length - $);
-            return Math.ceil(+O / R) * R * C;
-        }
-        _roundDown(E, $) {
-            const C = E < 0 ? -1 : 1,
-                O = E < 0 ? 1 : 0,
-                R = Math.floor(Math.abs(E)).toString(),
-                L = Math.pow(10, R.length - $);
-            return (Math.floor(+R / L) + O) * L * C;
-        }
-        _updateLabel(E) {
-            const $ = E.toFixed(0),
-                C = this.isPercent ? `${$}%` : Yn.format(",.2r")($);
+        _roundUp(S, $) {
+            const C = S < 0 ? -1 : 1,
+                D = Math.ceil(Math.abs(S)).toString(),
+                I = Math.pow(10, D.length - $);
+            return Math.ceil(+D / I) * I * C;
+        }
+        _roundDown(S, $) {
+            const C = S < 0 ? -1 : 1,
+                D = S < 0 ? 1 : 0,
+                I = Math.floor(Math.abs(S)).toString(),
+                z = Math.pow(10, I.length - $);
+            return (Math.floor(+I / z) + D) * z * C;
+        }
+        _updateLabel(S) {
+            const $ = S.toFixed(0),
+                C = this.isPercent ? `${$}%` : pt.format(",.2r")($);
             this._label.text(`${this._caption} = ${C}`);
         }
     }
-    return e.$$set = (M) => {
-        "data" in M && n(0, i = M.data), "div" in M && n(1, r = M.div), "numConcepts" in M && n(2, s = M.numConcepts), "numSlices" in M && n(3, o = M.numSlices);
-    }, [i, r, s, o];
+    return e.$$set = (P) => {
+        "data" in P && n(0, i = P.data), "div" in P && n(1, r = P.div), "numConcepts" in P && n(2, s = P.numConcepts), "numSlices" in P && n(3, o = P.numSlices), "sliceCol" in P && n(4, a = P.sliceCol), "normBy" in P && n(5, u = P.normBy);
+    }, [i, r, s, o, a, u];
 }
 class jW extends ks {
     constructor(t) {
         super(), Ss(this, t, UW, LW, Xi, {
             data: 0,
             div: 1,
             numConcepts: 2,
-            numSlices: 3
+            numSlices: 3,
+            sliceCol: 4,
+            normBy: 5
         });
     }
 }
 
 function Ok(e, t, n) {
     const i = e.slice();
     return i[56] = t[n], i[58] = n, i;
@@ -1516,24 +1503,24 @@
         r[o] = jk(zk(e, i, o));
     let s = (
         /*showExpandIcon*/
         e[11] && qk()
     );
     return {
         c() {
-            t = ge("tr");
+            t = he("tr");
             for (let o = 0; o < r.length; o += 1)
                 r[o].c();
-            n = ct(), s && s.c(), fe(t, "class", "svelte-dsaf7t");
+            n = rt(), s && s.c(), fe(t, "class", "svelte-dsaf7t");
         },
         m(o, a) {
-            we(o, t, a);
+            pe(o, t, a);
             for (let u = 0; u < r.length; u += 1)
                 r[u] && r[u].m(t, null);
-            $e(t, n), s && s.m(t, null);
+            Ce(t, n), s && s.m(t, null);
         },
         p(o, a) {
             if (a[0] & /*asStringArray, columns, classNameInput, filterSelections, classNameSelect, filterValues*/
                 75595796) {
                 i = si(
                     /*columns*/
                     o[4]
@@ -1547,15 +1534,15 @@
                     r[u].d(1);
                 r.length = i.length;
             }
             /*showExpandIcon*/
             o[11] ? s || (s = qk(), s.c(), s.m(t, null)) : s && (s.d(1), s = null);
         },
         d(o) {
-            o && xe(t), cl(r, o), s && s.d();
+            o && ge(t), cl(r, o), s && s.d();
         }
     };
 }
 
 function VW(e) {
     let t, n, i = (
             /*col*/
@@ -1577,34 +1564,34 @@
             t,
             /*col*/
             e[59]
         );
     }
     return {
         c() {
-            t = ge("select"), n = ge("option"), r = Si(i);
+            t = he("select"), n = he("option"), r = Si(i);
             for (let f = 0; f < l.length; f += 1)
                 l[f].c();
-            n.__value = void 0, oh(n, n.__value), fe(t, "class", s = yt(
+            n.__value = void 0, oh(n, n.__value), fe(t, "class", s = bt(
                     /*asStringArray*/
                     e[26](
                         /*classNameSelect*/
                         e[15]
                     )
                 ) + " svelte-dsaf7t"), /*filterSelections*/
                 e[2][
                     /*col*/
                     e[59].key
                 ] === void 0 && Sm(c);
         },
         m(f, d) {
-            we(f, t, d), $e(t, n), $e(n, r);
+            pe(f, t, d), Ce(t, n), Ce(n, r);
             for (let h = 0; h < l.length; h += 1)
                 l[h] && l[h].m(t, null);
-            $k(
+            Ck(
                 t,
                 /*filterSelections*/
                 e[2][
                     /*col*/
                     e[59].key
                 ],
                 !0
@@ -1628,32 +1615,32 @@
                     l[h] ? l[h].p(g, d) : (l[h] = Uk(g), l[h].c(), l[h].m(t, null));
                 }
                 for (; h < l.length; h += 1)
                     l[h].d(1);
                 l.length = u.length;
             }
             d[0] & /*classNameSelect*/
-                32768 && s !== (s = yt(
+                32768 && s !== (s = bt(
                     /*asStringArray*/
                     e[26](
                         /*classNameSelect*/
                         e[15]
                     )
                 ) + " svelte-dsaf7t") && fe(t, "class", s), d[0] & /*filterSelections, columns, filterValues*/
-                8388628 && $k(
+                8388628 && Ck(
                     t,
                     /*filterSelections*/
                     e[2][
                         /*col*/
                         e[59].key
                     ]
                 );
         },
         d(f) {
-            f && xe(t), cl(l, f), o = !1, a();
+            f && ge(t), cl(l, f), o = !1, a();
         }
     };
 }
 
 function YW(e) {
     let t, n, i, r, s;
 
@@ -1662,36 +1649,36 @@
             t,
             /*col*/
             e[59]
         );
     }
     return {
         c() {
-            t = ge("input"), fe(t, "class", n = yt(
+            t = he("input"), fe(t, "class", n = bt(
                 /*asStringArray*/
                 e[26](
                     /*classNameInput*/
                     e[16]
                 )
             ) + " svelte-dsaf7t"), fe(t, "placeholder", i = /*col*/
                 e[59].filterPlaceholder);
         },
         m(a, u) {
-            we(a, t, u), oh(
+            pe(a, t, u), oh(
                 t,
                 /*filterSelections*/
                 e[2][
                     /*col*/
                     e[59].key
                 ]
             ), r || (s = ds(t, "input", o), r = !0);
         },
         p(a, u) {
             e = a, u[0] & /*classNameInput*/
-                65536 && n !== (n = yt(
+                65536 && n !== (n = bt(
                     /*asStringArray*/
                     e[26](
                         /*classNameInput*/
                         e[16]
                     )
                 ) + " svelte-dsaf7t") && fe(t, "class", n), u[0] & /*columns, filterValues*/
                 8388624 && i !== (i = /*col*/
@@ -1706,42 +1693,42 @@
                     e[2][
                         /*col*/
                         e[59].key
                     ]
                 );
         },
         d(a) {
-            a && xe(t), r = !1, s();
+            a && ge(t), r = !1, s();
         }
     };
 }
 
 function Uk(e) {
     let t, n = (
             /*option*/
             e[66].name + ""
         ),
         i, r;
     return {
         c() {
-            t = ge("option"), i = Si(n), t.__value = r = /*option*/
+            t = he("option"), i = Si(n), t.__value = r = /*option*/
                 e[66].value, oh(t, t.__value);
         },
         m(s, o) {
-            we(s, t, o), $e(t, i);
+            pe(s, t, o), Ce(t, i);
         },
         p(s, o) {
             o[0] & /*filterValues, columns*/
                 8388624 && n !== (n = /*option*/
                     s[66].name + "") && ho(i, n), o[0] & /*filterValues, columns*/
                 8388624 && r !== (r = /*option*/
                     s[66].value) && (t.__value = r, oh(t, t.__value));
         },
         d(s) {
-            s && xe(t);
+            s && ge(t);
         }
     };
 }
 
 function jk(e) {
     let t, n;
 
@@ -1758,52 +1745,52 @@
             ] !== void 0)
             return VW;
     }
     let r = i(e),
         s = r && r(e);
     return {
         c() {
-            t = ge("th"), s && s.c(), fe(t, "class", n = yt(
+            t = he("th"), s && s.c(), fe(t, "class", n = bt(
                 /*asStringArray*/
                 e[26]([
                     /*col*/
                     e[59].headerFilterClass
                 ])
             ) + " svelte-dsaf7t");
         },
         m(o, a) {
-            we(o, t, a), s && s.m(t, null);
+            pe(o, t, a), s && s.m(t, null);
         },
         p(o, a) {
             r === (r = i(o)) && s ? s.p(o, a) : (s && s.d(1), s = r && r(o), s && (s.c(), s.m(t, null))), a[0] & /*columns, filterValues*/
-                8388624 && n !== (n = yt(
+                8388624 && n !== (n = bt(
                     /*asStringArray*/
                     o[26]([
                         /*col*/
                         o[59].headerFilterClass
                     ])
                 ) + " svelte-dsaf7t") && fe(t, "class", n);
         },
         d(o) {
-            o && xe(t), s && s.d();
+            o && ge(t), s && s.d();
         }
     };
 }
 
 function qk(e) {
     let t;
     return {
         c() {
-            t = ge("th");
+            t = he("th");
         },
         m(n, i) {
-            we(n, t, i);
+            pe(n, t, i);
         },
         d(n) {
-            n && xe(t);
+            n && ge(t);
         }
     };
 }
 
 function XW(e) {
     let t, n;
     return {
@@ -1812,25 +1799,25 @@
         },
         m(i, r) {
             t.m(
                 /*iconSortable*/
                 e[8],
                 i,
                 r
-            ), we(i, n, r);
+            ), pe(i, n, r);
         },
         p(i, r) {
             r[0] & /*iconSortable*/
                 256 && t.p(
                     /*iconSortable*/
                     i[8]
                 );
         },
         d(i) {
-            i && (xe(n), t.d());
+            i && (ge(n), t.d());
         }
     };
 }
 
 function KW(e) {
     let t, n = (
             /*sortOrder*/
@@ -1844,29 +1831,29 @@
         ),
         i;
     return {
         c() {
             t = new f1(!1), i = lf(), t.a = i;
         },
         m(r, s) {
-            t.m(n, r, s), we(r, i, s);
+            t.m(n, r, s), pe(r, i, s);
         },
         p(r, s) {
             s[0] & /*sortOrder, iconAsc, iconDesc*/
                 194 && n !== (n = /*sortOrder*/
                     (r[1] === 1 ? (
                         /*iconAsc*/
                         r[6]
                     ) : (
                         /*iconDesc*/
                         r[7]
                     )) + "") && t.p(n);
         },
         d(r) {
-            r && (xe(i), t.d());
+            r && (ge(i), t.d());
         }
     };
 }
 
 function Wk(e) {
     let t, n = (
             /*col*/
@@ -1909,61 +1896,61 @@
                 e[59],
                 ...h
             )
         );
     }
     return {
         c() {
-            t = ge("th"), i = Si(n), r = ct(), c && c.c(), fe(t, "class", s = yt(
+            t = he("th"), i = Si(n), r = rt(), c && c.c(), fe(t, "class", s = bt(
                 /*asStringArray*/
                 e[26]([
                     /*col*/
                     e[59].sortable ? "isSortable" : "",
                     /*col*/
                     e[59].headerClass
                 ])
             ) + " svelte-dsaf7t"), fe(t, "tabindex", "0");
         },
         m(h, g) {
-            we(h, t, g), $e(t, i), $e(t, r), c && c.m(t, null), o || (a = [
+            pe(h, t, g), Ce(t, i), Ce(t, r), c && c.m(t, null), o || (a = [
                 ds(t, "click", f),
                 ds(t, "keypress", d)
             ], o = !0);
         },
         p(h, g) {
             e = h, g[0] & /*columns*/
                 16 && n !== (n = /*col*/
                     e[59].title + "") && ho(i, n), l === (l = u(e)) && c ? c.p(e, g) : (c && c.d(1), c = l && l(e), c && (c.c(), c.m(t, null))), g[0] & /*columns, filterValues*/
-                8388624 && s !== (s = yt(
+                8388624 && s !== (s = bt(
                     /*asStringArray*/
                     e[26]([
                         /*col*/
                         e[59].sortable ? "isSortable" : "",
                         /*col*/
                         e[59].headerClass
                     ])
                 ) + " svelte-dsaf7t") && fe(t, "class", s);
         },
         d(h) {
-            h && xe(t), c && c.d(), o = !1, wo(a);
+            h && ge(t), c && c.d(), o = !1, wo(a);
         }
     };
 }
 
 function Hk(e) {
     let t;
     return {
         c() {
-            t = ge("th");
+            t = he("th");
         },
         m(n, i) {
-            we(n, t, i);
+            pe(n, t, i);
         },
         d(n) {
-            n && xe(t);
+            n && ge(t);
         }
     };
 }
 
 function JW(e) {
     let t, n, i = si(
             /*columns*/
@@ -1974,24 +1961,24 @@
         r[o] = Wk(Ik(e, i, o));
     let s = (
         /*showExpandIcon*/
         e[11] && Hk()
     );
     return {
         c() {
-            t = ge("tr");
+            t = he("tr");
             for (let o = 0; o < r.length; o += 1)
                 r[o].c();
-            n = ct(), s && s.c();
+            n = rt(), s && s.c();
         },
         m(o, a) {
-            we(o, t, a);
+            pe(o, t, a);
             for (let u = 0; u < r.length; u += 1)
                 r[u] && r[u].m(t, null);
-            $e(t, n), s && s.m(t, null);
+            Ce(t, n), s && s.m(t, null);
         },
         p(o, a) {
             if (a[0] & /*asStringArray, columns, handleClickCol, sortOrder, iconAsc, iconDesc, sortBy, iconSortable*/
                 201327059) {
                 i = si(
                     /*columns*/
                     o[4]
@@ -2005,15 +1992,15 @@
                     r[u].d(1);
                 r.length = i.length;
             }
             /*showExpandIcon*/
             o[11] ? s || (s = Hk(), s.c(), s.m(t, null)) : s && (s.d(1), s = null);
         },
         d(o) {
-            o && xe(t), cl(r, o), s && s.d();
+            o && ge(t), cl(r, o), s && s.d();
         }
     };
 }
 
 function QW(e) {
     let t = (
             /*col*/
@@ -2041,15 +2028,15 @@
         ),
         n;
     return {
         c() {
             n = Si(t);
         },
         m(i, r) {
-            we(i, n, r);
+            pe(i, n, r);
         },
         p(i, r) {
             r[0] & /*columns, c_rows*/
                 24 && t !== (t = /*col*/
                     (i[59].renderValue ? (
                         /*col*/
                         i[59].renderValue(
@@ -2071,15 +2058,15 @@
                             i[61]
                         )
                     )) + "") && ho(n, t);
         },
         i: dt,
         o: dt,
         d(i) {
-            i && xe(n);
+            i && ge(n);
         }
     };
 }
 
 function ZW(e) {
     let t, n = (
             /*col*/
@@ -2107,15 +2094,15 @@
         ),
         i;
     return {
         c() {
             t = new f1(!1), i = lf(), t.a = i;
         },
         m(r, s) {
-            t.m(n, r, s), we(r, i, s);
+            t.m(n, r, s), pe(r, i, s);
         },
         p(r, s) {
             s[0] & /*columns, c_rows*/
                 24 && n !== (n = /*col*/
                     (r[59].renderValue ? (
                         /*col*/
                         r[59].renderValue(
@@ -2137,15 +2124,15 @@
                             r[61]
                         )
                     )) + "") && t.p(n);
         },
         i: dt,
         o: dt,
         d(r) {
-            r && (xe(i), t.d());
+            r && (ge(i), t.d());
         }
     };
 }
 
 function eH(e) {
     let t, n, i;
     const r = [
@@ -2193,34 +2180,34 @@
                         a[59]
                     )
                 }
             ]))), {
                 props: l
             };
     }
-    return s && (t = Ck(s, o(e))), {
+    return s && (t = $k(s, o(e))), {
         c() {
             t && oi(t.$$.fragment), n = lf();
         },
         m(a, u) {
-            t && Bn(t, a, u), we(a, n, u), i = !0;
+            t && Un(t, a, u), pe(a, n, u), i = !0;
         },
         p(a, u) {
             if (u[0] & /*columns*/
                 16 && s !== (s = /*col*/
                     a[59].renderComponent.component || /*col*/
                     a[59].renderComponent)) {
                 if (t) {
-                    mn();
+                    yn();
                     const l = t;
                     Se(l.$$.fragment, 1, 0, () => {
-                        Un(l, 1);
-                    }), yn();
+                        jn(l, 1);
+                    }), bn();
                 }
-                s ? (t = Ck(s, o(a, u)), oi(t.$$.fragment), he(t.$$.fragment, 1), Bn(t, n.parentNode, n)) : t = null;
+                s ? (t = $k(s, o(a, u)), oi(t.$$.fragment), me(t.$$.fragment, 1), Un(t, n.parentNode, n)) : t = null;
             } else if (s) {
                 const l = u[0] & /*columns, c_rows*/
                     24 ? Tk(r, [
                         u[0] & /*columns*/
                         16 && Fk(
                             /*col*/
                             a[59].renderComponent.props || {}
@@ -2240,21 +2227,21 @@
                             )
                         }
                     ]) : {};
                 t.$set(l);
             }
         },
         i(a) {
-            i || (t && he(t.$$.fragment, a), i = !0);
+            i || (t && me(t.$$.fragment, a), i = !0);
         },
         o(a) {
             t && Se(t.$$.fragment, a), i = !1;
         },
         d(a) {
-            a && xe(n), t && Un(t, a);
+            a && ge(n), t && jn(t, a);
         }
     };
 }
 
 function Gk(e) {
     let t, n, i, r, s, o, a;
     const u = [eH, ZW, QW],
@@ -2294,15 +2281,15 @@
                 e[59],
                 ...h
             )
         );
     }
     return {
         c() {
-            t = ge("td"), i.c(), fe(t, "class", r = yt(
+            t = he("td"), i.c(), fe(t, "class", r = bt(
                 /*asStringArray*/
                 e[26]([
                     typeof /*col*/
                     e[59].class == "string" ? (
                         /*col*/
                         e[59].class
                     ) : null,
@@ -2320,26 +2307,26 @@
                     ) : null,
                     /*classNameCell*/
                     e[18]
                 ])
             ) + " svelte-dsaf7t");
         },
         m(h, g) {
-            we(h, t, g), l[n].m(t, null), s = !0, o || (a = [
+            pe(h, t, g), l[n].m(t, null), s = !0, o || (a = [
                 ds(t, "click", f),
                 ds(t, "keypress", d)
             ], o = !0);
         },
         p(h, g) {
             e = h;
             let p = n;
-            n = c(e), n === p ? l[n].p(e, g) : (mn(), Se(l[p], 1, 1, () => {
+            n = c(e), n === p ? l[n].p(e, g) : (yn(), Se(l[p], 1, 1, () => {
                 l[p] = null;
-            }), yn(), i = l[n], i ? i.p(e, g) : (i = l[n] = u[n](e), i.c()), he(i, 1), i.m(t, null)), (!s || g[0] & /*columns, c_rows, classNameCell, filterValues*/
-                8650776 && r !== (r = yt(
+            }), bn(), i = l[n], i ? i.p(e, g) : (i = l[n] = u[n](e), i.c()), me(i, 1), i.m(t, null)), (!s || g[0] & /*columns, c_rows, classNameCell, filterValues*/
+                8650776 && r !== (r = bt(
                     /*asStringArray*/
                     e[26]([
                         typeof /*col*/
                         e[59].class == "string" ? (
                             /*col*/
                             e[59].class
                         ) : null,
@@ -2357,21 +2344,21 @@
                         ) : null,
                         /*classNameCell*/
                         e[18]
                     ])
                 ) + " svelte-dsaf7t")) && fe(t, "class", r);
         },
         i(h) {
-            s || (he(i), s = !0);
+            s || (me(i), s = !0);
         },
         o(h) {
             Se(i), s = !1;
         },
         d(h) {
-            h && xe(t), l[n].d(), o = !1, wo(a);
+            h && ge(t), l[n].d(), o = !1, wo(a);
         }
     };
 }
 
 function Vk(e) {
     let t, n, i = (
             /*row*/
@@ -2404,48 +2391,48 @@
                 e[56],
                 ...l
             )
         );
     }
     return {
         c() {
-            t = ge("td"), n = ge("span"), fe(n, "class", "isClickable svelte-dsaf7t"), fe(n, "tabindex", "0"), fe(n, "role", "button"), fe(t, "class", r = yt(
+            t = he("td"), n = he("span"), fe(n, "class", "isClickable svelte-dsaf7t"), fe(n, "tabindex", "0"), fe(n, "role", "button"), fe(t, "class", r = bt(
                 /*asStringArray*/
                 e[26](
                     /*classNameCellExpand*/
                     e[22]
                 )
             ) + " svelte-dsaf7t");
         },
         m(l, c) {
-            we(l, t, c), $e(t, n), n.innerHTML = i, s || (o = [
+            pe(l, t, c), Ce(t, n), n.innerHTML = i, s || (o = [
                 ds(n, "click", a),
                 ds(n, "keypress", u)
             ], s = !0);
         },
         p(l, c) {
             e = l, c[0] & /*c_rows, iconExpand, iconExpanded*/
                 1544 && i !== (i = /*row*/
                     (e[56].$expanded ? (
                         /*iconExpand*/
                         e[9]
                     ) : (
                         /*iconExpanded*/
                         e[10]
                     )) + "") && (n.innerHTML = i), c[0] & /*classNameCellExpand*/
-                4194304 && r !== (r = yt(
+                4194304 && r !== (r = bt(
                     /*asStringArray*/
                     e[26](
                         /*classNameCellExpand*/
                         e[22]
                     )
                 ) + " svelte-dsaf7t") && fe(t, "class", r);
         },
         d(l) {
-            l && xe(t), s = !1, wo(o);
+            l && ge(t), s = !1, wo(o);
         }
     };
 }
 
 function Yk(e) {
     let t, n, i, r;
     const s = (
@@ -2457,29 +2444,29 @@
             e,
             /*$$scope*/
             e[41],
             Dk
         );
     return {
         c() {
-            t = ge("tr"), n = ge("td"), o && o.c(), fe(
+            t = he("tr"), n = he("td"), o && o.c(), fe(
                 n,
                 "colspan",
                 /*colspan*/
                 e[24]
-            ), fe(t, "class", i = yt(
+            ), fe(t, "class", i = bt(
                 /*asStringArray*/
                 e[26](
                     /*classNameExpandedContent*/
                     e[21]
                 )
             ) + " svelte-dsaf7t");
         },
         m(a, u) {
-            we(a, t, u), $e(t, n), o && o.m(n, null), r = !0;
+            pe(a, t, u), Ce(t, n), o && o.m(n, null), r = !0;
         },
         p(a, u) {
             o && o.p && (!r || u[0] & /*c_rows*/
                 8 | u[1] & /*$$scope*/
                 1024) && u_(
                 o,
                 s,
@@ -2500,30 +2487,30 @@
             ), (!r || u[0] & /*colspan*/
                 16777216) && fe(
                 n,
                 "colspan",
                 /*colspan*/
                 a[24]
             ), (!r || u[0] & /*classNameExpandedContent*/
-                2097152 && i !== (i = yt(
+                2097152 && i !== (i = bt(
                     /*asStringArray*/
                     a[26](
                         /*classNameExpandedContent*/
                         a[21]
                     )
                 ) + " svelte-dsaf7t")) && fe(t, "class", i);
         },
         i(a) {
-            r || (he(o, a), r = !0);
+            r || (me(o, a), r = !0);
         },
         o(a) {
             Se(o, a), r = !1;
         },
         d(a) {
-            a && xe(t), o && o.d(a);
+            a && ge(t), o && o.d(a);
         }
     };
 }
 
 function tH(e) {
     let t, n, i, r, s, o, a, u, l, c = si(
             /*columns*/
@@ -2563,18 +2550,18 @@
     }
     let m = (
         /*row*/
         e[56].$expanded && Yk(e)
     );
     return {
         c() {
-            t = ge("tr");
+            t = he("tr");
             for (let y = 0; y < f.length; y += 1)
                 f[y].c();
-            n = ct(), h && h.c(), s = ct(), m && m.c(), o = ct(), fe(t, "class", i = yt(
+            n = rt(), h && h.c(), s = rt(), m && m.c(), o = rt(), fe(t, "class", i = bt(
                 /*asStringArray*/
                 e[26]([
                     typeof /*classNameRow*/
                     e[17] == "string" ? (
                         /*classNameRow*/
                         e[17]
                     ) : null,
@@ -2595,41 +2582,41 @@
                     e[56].$selected && /*classNameRowSelected*/
                     e[19]
                 ])
             ) + " svelte-dsaf7t"), fe(t, "tabindex", r = /*selectOnClick*/
                 e[5] ? "0" : null);
         },
         m(y, b) {
-            we(y, t, b);
+            pe(y, t, b);
             for (let v = 0; v < f.length; v += 1)
                 f[v] && f[v].m(t, null);
-            $e(t, n), h && h.m(t, null), we(y, s, b), m && m.m(y, b), we(y, o, b), a = !0, u || (l = [
+            Ce(t, n), h && h.m(t, null), pe(y, s, b), m && m.m(y, b), pe(y, o, b), a = !0, u || (l = [
                 ds(t, "click", g),
                 ds(t, "keypress", p)
             ], u = !0);
         },
         p(y, b) {
             if (e = y, b[0] & /*asStringArray, columns, c_rows, classNameCell, handleClickCell*/
                 1141112856) {
                 c = si(
                     /*columns*/
                     e[4]
                 );
                 let v;
                 for (v = 0; v < c.length; v += 1) {
                     const x = Rk(e, c, v);
-                    f[v] ? (f[v].p(x, b), he(f[v], 1)) : (f[v] = Gk(x), f[v].c(), he(f[v], 1), f[v].m(t, n));
+                    f[v] ? (f[v].p(x, b), me(f[v], 1)) : (f[v] = Gk(x), f[v].c(), me(f[v], 1), f[v].m(t, n));
                 }
-                for (mn(), v = c.length; v < f.length; v += 1)
+                for (yn(), v = c.length; v < f.length; v += 1)
                     d(v);
-                yn();
+                bn();
             }
             /*showExpandIcon*/
             e[11] ? h ? h.p(e, b) : (h = Vk(e), h.c(), h.m(t, null)) : h && (h.d(1), h = null), (!a || b[0] & /*classNameRow, c_rows, classNameRowExpanded, classNameRowSelected*/
-                    1703944 && i !== (i = yt(
+                    1703944 && i !== (i = bt(
                         /*asStringArray*/
                         e[26]([
                             typeof /*classNameRow*/
                             e[17] == "string" ? (
                                 /*classNameRow*/
                                 e[17]
                             ) : null,
@@ -2650,33 +2637,33 @@
                             e[56].$selected && /*classNameRowSelected*/
                             e[19]
                         ])
                     ) + " svelte-dsaf7t")) && fe(t, "class", i), (!a || b[0] & /*selectOnClick*/
                     32 && r !== (r = /*selectOnClick*/
                         e[5] ? "0" : null)) && fe(t, "tabindex", r), /*row*/
                 e[56].$expanded ? m ? (m.p(e, b), b[0] & /*c_rows*/
-                    8 && he(m, 1)) : (m = Yk(e), m.c(), he(m, 1), m.m(o.parentNode, o)) : m && (mn(), Se(m, 1, 1, () => {
+                    8 && me(m, 1)) : (m = Yk(e), m.c(), me(m, 1), m.m(o.parentNode, o)) : m && (yn(), Se(m, 1, 1, () => {
                     m = null;
-                }), yn());
+                }), bn());
         },
         i(y) {
             if (!a) {
                 for (let b = 0; b < c.length; b += 1)
-                    he(f[b]);
-                he(m), a = !0;
+                    me(f[b]);
+                me(m), a = !0;
             }
         },
         o(y) {
             f = f.filter(Boolean);
             for (let b = 0; b < f.length; b += 1)
                 Se(f[b]);
             Se(m), a = !1;
         },
         d(y) {
-            y && (xe(t), xe(s), xe(o)), cl(f, y), h && h.d(), m && m.d(y), u = !1, wo(l);
+            y && (ge(t), ge(s), ge(o)), cl(f, y), h && h.d(), m && m.d(y), u = !1, wo(l);
         }
     };
 }
 
 function Xk(e) {
     let t;
     const n = (
@@ -2719,15 +2706,15 @@
                 ),
                 Lk
             ) : r && r.p && (!t || o[0] & /*classNameExpandedContent, colspan, c_rows, classNameRow, classNameRowExpanded, classNameRowSelected, selectOnClick, classNameCellExpand, iconExpand, iconExpanded, showExpandIcon, columns, classNameCell*/
                 25038392 | o[1] & /*$$scope*/
                 1024) && r.p(s, t ? o : [-1, -1, -1]);
         },
         i(s) {
-            t || (he(r, s), t = !0);
+            t || (me(r, s), t = !0);
         },
         o(s) {
             Se(r, s), t = !1;
         },
         d(s) {
             r && r.d(s);
         }
@@ -2759,39 +2746,39 @@
     for (let y = 0; y < g.length; y += 1)
         p[y] = Xk(Ok(e, g, y));
     const m = (y) => Se(p[y], 1, 1, () => {
         p[y] = null;
     });
     return {
         c() {
-            t = ge("table"), n = ge("thead"), c && c.c(), i = ct(), h && h.c(), s = ct(), o = ge("tbody");
+            t = he("table"), n = he("thead"), c && c.c(), i = rt(), h && h.c(), s = rt(), o = he("tbody");
             for (let y = 0; y < p.length; y += 1)
                 p[y].c();
-            fe(n, "class", r = yt(
+            fe(n, "class", r = bt(
                 /*asStringArray*/
                 e[26](
                     /*classNameThead*/
                     e[13]
                 )
-            ) + " svelte-dsaf7t"), fe(o, "class", a = yt(
+            ) + " svelte-dsaf7t"), fe(o, "class", a = bt(
                 /*asStringArray*/
                 e[26](
                     /*classNameTbody*/
                     e[14]
                 )
-            ) + " svelte-dsaf7t"), fe(t, "class", u = yt(
+            ) + " svelte-dsaf7t"), fe(t, "class", u = bt(
                 /*asStringArray*/
                 e[26](
                     /*classNameTable*/
                     e[12]
                 )
             ) + " svelte-dsaf7t");
         },
         m(y, b) {
-            we(y, t, b), $e(t, n), c && c.m(n, null), $e(n, i), h && h.m(n, null), $e(t, s), $e(t, o);
+            pe(y, t, b), Ce(t, n), c && c.m(n, null), Ce(n, i), h && h.m(n, null), Ce(t, s), Ce(t, o);
             for (let v = 0; v < p.length; v += 1)
                 p[v] && p[v].m(o, null);
             l = !0;
         },
         p(y, b) {
             if (
                 /*showFilterHeader*/
@@ -2812,15 +2799,15 @@
                     ) : l_(
                         /*$$scope*/
                         y[41]
                     ),
                     Pk
                 ) : h && h.p && (!l || b[0] & /*showExpandIcon, columns, sortOrder, iconAsc, iconDesc, sortBy, iconSortable*/
                     2515) && h.p(y, l ? b : [-1, -1, -1]), (!l || b[0] & /*classNameThead*/
-                    8192 && r !== (r = yt(
+                    8192 && r !== (r = bt(
                         /*asStringArray*/
                         y[26](
                             /*classNameThead*/
                             y[13]
                         )
                     ) + " svelte-dsaf7t")) && fe(n, "class", r), b[0] & /*asStringArray, classNameExpandedContent, colspan, c_rows, classNameRow, classNameRowExpanded, classNameRowSelected, selectOnClick, handleClickRow, classNameCellExpand, handleClickExpand, iconExpand, iconExpanded, showExpandIcon, columns, classNameCell, handleClickCell*/
                 1971195448 | b[1] & /*$$scope*/
@@ -2829,52 +2816,52 @@
                 g = si(
                     /*c_rows*/
                     y[3]
                 );
                 let v;
                 for (v = 0; v < g.length; v += 1) {
                     const x = Ok(y, g, v);
-                    p[v] ? (p[v].p(x, b), he(p[v], 1)) : (p[v] = Xk(x), p[v].c(), he(p[v], 1), p[v].m(o, null));
+                    p[v] ? (p[v].p(x, b), me(p[v], 1)) : (p[v] = Xk(x), p[v].c(), me(p[v], 1), p[v].m(o, null));
                 }
-                for (mn(), v = g.length; v < p.length; v += 1)
+                for (yn(), v = g.length; v < p.length; v += 1)
                     m(v);
-                yn();
+                bn();
             }
             (!l || b[0] & /*classNameTbody*/
-                16384 && a !== (a = yt(
+                16384 && a !== (a = bt(
                     /*asStringArray*/
                     y[26](
                         /*classNameTbody*/
                         y[14]
                     )
                 ) + " svelte-dsaf7t")) && fe(o, "class", a), (!l || b[0] & /*classNameTable*/
-                4096 && u !== (u = yt(
+                4096 && u !== (u = bt(
                     /*asStringArray*/
                     y[26](
                         /*classNameTable*/
                         y[12]
                     )
                 ) + " svelte-dsaf7t")) && fe(t, "class", u);
         },
         i(y) {
             if (!l) {
-                he(h, y);
+                me(h, y);
                 for (let b = 0; b < g.length; b += 1)
-                    he(p[b]);
+                    me(p[b]);
                 l = !0;
             }
         },
         o(y) {
             Se(h, y), p = p.filter(Boolean);
             for (let b = 0; b < p.length; b += 1)
                 Se(p[b]);
             l = !1;
         },
         d(y) {
-            y && xe(t), c && c.d(), h && h.d(y), cl(p, y);
+            y && ge(t), c && c.d(), h && h.d(y), cl(p, y);
         }
     };
 }
 
 function iH(e, t, n) {
     let i, {
             $$slots: r = {},
@@ -2925,218 +2912,218 @@
         {
             iconAsc: x = "▲"
         } = t,
         {
             iconDesc: w = "▼"
         } = t,
         {
-            iconSortable: S = ""
+            iconSortable: E = ""
         } = t,
         {
             iconExpand: _ = "▼"
         } = t,
         {
             iconExpanded: k = "▲"
         } = t,
         {
             showExpandIcon: A = !1
         } = t,
         {
-            classNameTable: F = ""
+            classNameTable: T = ""
         } = t,
         {
-            classNameThead: T = ""
+            classNameThead: M = ""
         } = t,
         {
-            classNameTbody: I = ""
+            classNameTbody: L = ""
         } = t,
         {
-            classNameSelect: N = ""
+            classNameSelect: F = ""
         } = t,
         {
-            classNameInput: D = ""
+            classNameInput: O = ""
         } = t,
         {
-            classNameRow: M = null
+            classNameRow: N = null
         } = t,
         {
-            classNameCell: E = ""
+            classNameCell: R = ""
         } = t,
         {
-            classNameRowSelected: $ = null
+            classNameRowSelected: P = null
         } = t,
         {
-            classNameRowExpanded: C = null
+            classNameRowExpanded: S = null
         } = t,
         {
-            classNameExpandedContent: O = ""
+            classNameExpandedContent: $ = ""
         } = t,
         {
-            classNameCellExpand: R = ""
+            classNameCellExpand: C = ""
         } = t;
-    const L = d_();
-    let P = () => "";
+    const D = d_();
+    let I = () => "";
     if (!Array.isArray(h))
         throw "'expanded' needs to be an array";
     if (!Array.isArray(g))
         throw "'selection' needs to be an array";
-    p !== null && console.warn("'expandRowKey' is deprecated in favour of 'rowKey'"), $ && !m && console.error("'rowKey' is needed to use 'classNameRowSelected'");
-    let z = o.some((U) => !U.hideFilterHeader && (U.filterOptions !== void 0 || U.searchValue !== void 0)),
-        V = {},
-        X;
-    const se = (U) => [].concat(U).filter((oe) => oe !== null && typeof oe == "string" && oe !== "").join(" "),
-        ee = () => {
-            n(23, V = {}), o.forEach((U) => {
-                typeof U.filterOptions == "function" ? n(23, V[U.key] = U.filterOptions(a), V) : Array.isArray(U.filterOptions) && n(23, V[U.key] = U.filterOptions.map((oe) => ({
-                    name: oe,
-                    value: oe
-                })), V);
+    p !== null && console.warn("'expandRowKey' is deprecated in favour of 'rowKey'"), P && !m && console.error("'rowKey' is needed to use 'classNameRowSelected'");
+    let z = o.some((j) => !j.hideFilterHeader && (j.filterOptions !== void 0 || j.searchValue !== void 0)),
+        H = {},
+        G;
+    const te = (j) => [].concat(j).filter((ue) => ue !== null && typeof ue == "string" && ue !== "").join(" "),
+        K = () => {
+            n(23, H = {}), o.forEach((j) => {
+                typeof j.filterOptions == "function" ? n(23, H[j.key] = j.filterOptions(a), H) : Array.isArray(j.filterOptions) && n(23, H[j.key] = j.filterOptions.map((ue) => ({
+                    name: ue,
+                    value: ue
+                })), H);
             });
         },
-        ue = (U) => U === c ? l[(l.findIndex((oe) => oe === f) + 1) % l.length] : l[0],
-        G = (U, oe) => {
-            oe.sortable && (n(1, f = ue(oe.key)), n(0, c = f ? oe.key : void 0)), L("clickCol", {
-                event: U,
-                col: oe,
-                key: oe.key
+        ae = (j) => j === c ? l[(l.findIndex((ue) => ue === f) + 1) % l.length] : l[0],
+        U = (j, ue) => {
+            ue.sortable && (n(1, f = ae(ue.key)), n(0, c = f ? ue.key : void 0)), D("clickCol", {
+                event: j,
+                col: ue,
+                key: ue.key
             });
         },
-        ae = (U, oe) => {
-            v && (b ? g.includes(oe[m]) ? n(32, g = []) : n(32, g = [oe[m]]) : g.includes(oe[m]) ? n(32, g = g.filter((Xt) => Xt != oe[m])) : n(32, g = [...g, oe[m]].sort())), L("clickRow", {
-                event: U,
-                row: oe
+        ie = (j, ue) => {
+            v && (b ? g.includes(ue[m]) ? n(32, g = []) : n(32, g = [ue[m]]) : g.includes(ue[m]) ? n(32, g = g.filter((Kt) => Kt != ue[m])) : n(32, g = [...g, ue[m]].sort())), D("clickRow", {
+                event: j,
+                row: ue
             });
         },
-        ce = (U, oe) => {
-            oe.$expanded = !oe.$expanded;
-            const Xt = oe[m];
-            y && oe.$expanded ? n(31, h = [Xt]) : y ? n(31, h = []) : oe.$expanded ? n(31, h = [...h, Xt]) : n(31, h = h.filter((Sk) => Sk != Xt)), L("clickExpand", {
-                event: U,
-                row: oe
+        le = (j, ue) => {
+            ue.$expanded = !ue.$expanded;
+            const Kt = ue[m];
+            y && ue.$expanded ? n(31, h = [Kt]) : y ? n(31, h = []) : ue.$expanded ? n(31, h = [...h, Kt]) : n(31, h = h.filter((Sk) => Sk != Kt)), D("clickExpand", {
+                event: j,
+                row: ue
             });
         },
-        H = (U, oe, Xt) => {
-            L("clickCell", {
-                event: U,
-                row: oe,
-                key: Xt
+        Y = (j, ue, Kt) => {
+            D("clickCell", {
+                event: j,
+                row: ue,
+                key: Kt
             });
         };
 
-    function Be(U) {
-        d[U.key] = this.value, n(2, d), n(23, V), n(4, o);
+    function Be(j) {
+        d[j.key] = this.value, n(2, d), n(23, H), n(4, o);
     }
 
-    function Ee(U) {
-        d[U.key] = $W(this), n(2, d), n(23, V), n(4, o);
+    function Ee(j) {
+        d[j.key] = CW(this), n(2, d), n(23, H), n(4, o);
     }
-    const Ve = (U, oe) => G(oe, U),
-        st = (U, oe) => oe.key === "Enter" && G(oe, U),
-        An = (U, oe, Xt) => H(Xt, U, oe.key),
-        No = (U, oe, Xt) => Xt.key === "Enter" && H(Xt, U, oe.key),
-        Ja = (U, oe) => ce(oe, U),
-        bW = (U, oe) => oe.key === "Enter" && ce(oe, U),
-        vW = (U, oe) => ae(oe, U),
-        xW = (U, oe) => oe.key === "Enter" && ae(oe, U);
-    return e.$$set = (U) => {
-        "columns" in U && n(4, o = U.columns), "rows" in U && n(33, a = U.rows), "c_rows" in U && n(3, u = U.c_rows), "sortOrders" in U && n(34, l = U.sortOrders), "sortBy" in U && n(0, c = U.sortBy), "sortOrder" in U && n(1, f = U.sortOrder), "filterSelections" in U && n(2, d = U.filterSelections), "expanded" in U && n(31, h = U.expanded), "selected" in U && n(32, g = U.selected), "expandRowKey" in U && n(35, p = U.expandRowKey), "rowKey" in U && n(36, m = U.rowKey), "expandSingle" in U && n(37, y = U.expandSingle), "selectSingle" in U && n(38, b = U.selectSingle), "selectOnClick" in U && n(5, v = U.selectOnClick), "iconAsc" in U && n(6, x = U.iconAsc), "iconDesc" in U && n(7, w = U.iconDesc), "iconSortable" in U && n(8, S = U.iconSortable), "iconExpand" in U && n(9, _ = U.iconExpand), "iconExpanded" in U && n(10, k = U.iconExpanded), "showExpandIcon" in U && n(11, A = U.showExpandIcon), "classNameTable" in U && n(12, F = U.classNameTable), "classNameThead" in U && n(13, T = U.classNameThead), "classNameTbody" in U && n(14, I = U.classNameTbody), "classNameSelect" in U && n(15, N = U.classNameSelect), "classNameInput" in U && n(16, D = U.classNameInput), "classNameRow" in U && n(17, M = U.classNameRow), "classNameCell" in U && n(18, E = U.classNameCell), "classNameRowSelected" in U && n(19, $ = U.classNameRowSelected), "classNameRowExpanded" in U && n(20, C = U.classNameRowExpanded), "classNameExpandedContent" in U && n(21, O = U.classNameExpandedContent), "classNameCellExpand" in U && n(22, R = U.classNameCellExpand), "$$scope" in U && n(41, s = U.$$scope);
+    const Ve = (j, ue) => U(ue, j),
+        ot = (j, ue) => ue.key === "Enter" && U(ue, j),
+        Cn = (j, ue, Kt) => Y(Kt, j, ue.key),
+        No = (j, ue, Kt) => Kt.key === "Enter" && Y(Kt, j, ue.key),
+        Ja = (j, ue) => le(ue, j),
+        bW = (j, ue) => ue.key === "Enter" && le(ue, j),
+        vW = (j, ue) => ie(ue, j),
+        xW = (j, ue) => ue.key === "Enter" && ie(ue, j);
+    return e.$$set = (j) => {
+        "columns" in j && n(4, o = j.columns), "rows" in j && n(33, a = j.rows), "c_rows" in j && n(3, u = j.c_rows), "sortOrders" in j && n(34, l = j.sortOrders), "sortBy" in j && n(0, c = j.sortBy), "sortOrder" in j && n(1, f = j.sortOrder), "filterSelections" in j && n(2, d = j.filterSelections), "expanded" in j && n(31, h = j.expanded), "selected" in j && n(32, g = j.selected), "expandRowKey" in j && n(35, p = j.expandRowKey), "rowKey" in j && n(36, m = j.rowKey), "expandSingle" in j && n(37, y = j.expandSingle), "selectSingle" in j && n(38, b = j.selectSingle), "selectOnClick" in j && n(5, v = j.selectOnClick), "iconAsc" in j && n(6, x = j.iconAsc), "iconDesc" in j && n(7, w = j.iconDesc), "iconSortable" in j && n(8, E = j.iconSortable), "iconExpand" in j && n(9, _ = j.iconExpand), "iconExpanded" in j && n(10, k = j.iconExpanded), "showExpandIcon" in j && n(11, A = j.showExpandIcon), "classNameTable" in j && n(12, T = j.classNameTable), "classNameThead" in j && n(13, M = j.classNameThead), "classNameTbody" in j && n(14, L = j.classNameTbody), "classNameSelect" in j && n(15, F = j.classNameSelect), "classNameInput" in j && n(16, O = j.classNameInput), "classNameRow" in j && n(17, N = j.classNameRow), "classNameCell" in j && n(18, R = j.classNameCell), "classNameRowSelected" in j && n(19, P = j.classNameRowSelected), "classNameRowExpanded" in j && n(20, S = j.classNameRowExpanded), "classNameExpandedContent" in j && n(21, $ = j.classNameExpandedContent), "classNameCellExpand" in j && n(22, C = j.classNameCellExpand), "$$scope" in j && n(41, s = j.$$scope);
     }, e.$$.update = () => {
         if (e.$$.dirty[0] & /*columns*/
-            16 && (n(40, X = {}), o.forEach((U) => {
-                n(40, X[U.key] = U, X);
+            16 && (n(40, G = {}), o.forEach((j) => {
+                n(40, G[j.key] = j, G);
             })), e.$$.dirty[0] & /*showExpandIcon, columns*/
             2064 && n(24, i = (A ? 1 : 0) + o.length), e.$$.dirty[0] & /*sortBy*/
             1 | e.$$.dirty[1] & /*columnByKey*/
             512) {
-            let U = X[c];
-            U !== void 0 && U.sortable === !0 && typeof U.value == "function" && n(39, P = (oe) => U.value(oe));
+            let j = G[c];
+            j !== void 0 && j.sortable === !0 && typeof j.value == "function" && n(39, I = (ue) => j.value(ue));
         }
         e.$$.dirty[0] & /*filterSelections, sortBy, sortOrder*/
             7 | e.$$.dirty[1] & /*rows, columnByKey, sortFunction, rowKey, expanded, selected*/
-            807 && n(3, u = a.filter((U) => Object.keys(d).every((oe) => {
+            807 && n(3, u = a.filter((j) => Object.keys(d).every((ue) => {
                 var kk;
-                let Xt = null;
-                if (X[oe] === void 0)
+                let Kt = null;
+                if (G[ue] === void 0)
                     return !0;
-                if (!((kk = X[oe]) != null && kk.searchValue))
-                    Xt = !1;
+                if (!((kk = G[ue]) != null && kk.searchValue))
+                    Kt = !1;
                 else {
-                    if (d[oe] === "")
+                    if (d[ue] === "")
                         return !0;
-                    X[oe].searchValue.length === 1 ? Xt = (X[oe].searchValue(U) + "").toLocaleLowerCase().indexOf((d[oe] + "").toLocaleLowerCase()) >= 0 : X[oe].searchValue.length === 2 && (Xt = !!X[oe].searchValue(U, d[oe] + ""));
+                    G[ue].searchValue.length === 1 ? Kt = (G[ue].searchValue(j) + "").toLocaleLowerCase().indexOf((d[ue] + "").toLocaleLowerCase()) >= 0 : G[ue].searchValue.length === 2 && (Kt = !!G[ue].searchValue(j, d[ue] + ""));
                 }
-                return Xt || d[oe] === void 0 || // default to value() if filterValue() not provided in col
-                    d[oe] === (typeof X[oe].filterValue == "function" ? X[oe].filterValue(U) : X[oe].value(U));
-            })).map((U) => Object.assign({}, U, {
+                return Kt || d[ue] === void 0 || // default to value() if filterValue() not provided in col
+                    d[ue] === (typeof G[ue].filterValue == "function" ? G[ue].filterValue(j) : G[ue].value(j));
+            })).map((j) => Object.assign({}, j, {
                 // internal row property for sort order
-                $sortOn: P(U),
+                $sortOn: I(j),
                 // internal row property for expanded rows
-                $expanded: m !== null && h.indexOf(U[m]) >= 0,
-                $selected: m !== null && g.indexOf(U[m]) >= 0
-            })).sort((U, oe) => {
+                $expanded: m !== null && h.indexOf(j[m]) >= 0,
+                $selected: m !== null && g.indexOf(j[m]) >= 0
+            })).sort((j, ue) => {
                 if (c) {
-                    if (U.$sortOn > oe.$sortOn)
+                    if (j.$sortOn > ue.$sortOn)
                         return f;
-                    if (U.$sortOn < oe.$sortOn)
+                    if (j.$sortOn < ue.$sortOn)
                         return -f;
                 } else
                     return 0;
                 return 0;
             })), e.$$.dirty[0] & /*columns*/
             16 | e.$$.dirty[1] & /*rows*/
-            4 && z && o && a && ee();
+            4 && z && o && a && K();
     }, [
         c,
         f,
         d,
         u,
         o,
         v,
         x,
         w,
-        S,
+        E,
         _,
         k,
         A,
-        F,
         T,
-        I,
-        N,
-        D,
         M,
-        E,
-        $,
-        C,
+        L,
+        F,
         O,
+        N,
         R,
-        V,
+        P,
+        S,
+        $,
+        C,
+        H,
         i,
         z,
-        se,
-        G,
-        ae,
-        ce,
-        H,
+        te,
+        U,
+        ie,
+        le,
+        Y,
         h,
         g,
         a,
         l,
         p,
         m,
         y,
         b,
-        P,
-        X,
+        I,
+        G,
         s,
         r,
         Be,
         Ee,
         Ve,
-        st,
-        An,
+        ot,
+        Cn,
         No,
         Ja,
         bW,
         vW,
         xW
     ];
 }
@@ -3306,15 +3293,15 @@
                     operation: s,
                     tree: o
                 }), u;
             }
             return t;
         }(Error)
     ),
-    mt = B9,
+    yt = B9,
     oH = vi,
     nc = {
         add: function(e, t, n) {
             return e[t] = this.value, {
                 newDocument: n
             };
         },
@@ -3416,23 +3403,23 @@
             return o.newDocument = t.value, o;
         if (t.op === "replace")
             return o.newDocument = t.value, o.removed = e, o;
         if (t.op === "move" || t.op === "copy")
             return o.newDocument = km(e, t.from), t.op === "move" && (o.removed = e), o;
         if (t.op === "test") {
             if (o.test = uh(e, t.value), o.test === !1)
-                throw new mt("Test operation failed", "TEST_OPERATION_FAILED", s, t, e);
+                throw new yt("Test operation failed", "TEST_OPERATION_FAILED", s, t, e);
             return o.newDocument = e, o;
         } else {
             if (t.op === "remove")
                 return o.removed = e, o.newDocument = null, o;
             if (t.op === "_get")
                 return t.value = e, o;
             if (n)
-                throw new mt("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", s, t, e);
+                throw new yt("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", s, t, e);
             return o;
         }
     } else {
         i || (e = vi(e));
         var a = t.path || "",
             u = a.split("/"),
             l = e,
@@ -3445,104 +3432,104 @@
             if (h = u[c], h && h.indexOf("~") != -1 && (h = z9(h)), r && (h == "__proto__" || h == "prototype" && c > 0 && u[c - 1] == "constructor"))
                 throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
             if (n && d === void 0 && (l[h] === void 0 ? d = u.slice(0, c).join("/") : c == f - 1 && (d = t.path), d !== void 0 && g(t, 0, e, d)), c++, Array.isArray(l)) {
                 if (h === "-")
                     h = l.length;
                 else {
                     if (n && !R2(h))
-                        throw new mt("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", s, t, e);
+                        throw new yt("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", s, t, e);
                     R2(h) && (h = ~~h);
                 }
                 if (c >= f) {
                     if (n && t.op === "add" && h > l.length)
-                        throw new mt("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", s, t, e);
+                        throw new yt("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", s, t, e);
                     var o = aH[t.op].call(t, l, h, e);
                     if (o.test === !1)
-                        throw new mt("Test operation failed", "TEST_OPERATION_FAILED", s, t, e);
+                        throw new yt("Test operation failed", "TEST_OPERATION_FAILED", s, t, e);
                     return o;
                 }
             } else if (c >= f) {
                 var o = nc[t.op].call(t, l, h, e);
                 if (o.test === !1)
-                    throw new mt("Test operation failed", "TEST_OPERATION_FAILED", s, t, e);
+                    throw new yt("Test operation failed", "TEST_OPERATION_FAILED", s, t, e);
                 return o;
             }
             if (l = l[h], n && c < f && (!l || typeof l != "object"))
-                throw new mt("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", s, t, e);
+                throw new yt("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", s, t, e);
         }
     }
 }
 
 function d1(e, t, n, i, r) {
     if (i === void 0 && (i = !0), r === void 0 && (r = !0), n && !Array.isArray(t))
-        throw new mt("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
+        throw new yt("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
     i || (e = vi(e));
     for (var s = new Array(t.length), o = 0, a = t.length; o < a; o++)
         s[o] = _u(e, t[o], n, !0, r, o), e = s[o].newDocument;
     return s.newDocument = e, s;
 }
 
 function uH(e, t, n) {
     var i = _u(e, t);
     if (i.test === !1)
-        throw new mt("Test operation failed", "TEST_OPERATION_FAILED", n, t, e);
+        throw new yt("Test operation failed", "TEST_OPERATION_FAILED", n, t, e);
     return i.newDocument;
 }
 
 function Am(e, t, n, i) {
     if (typeof e != "object" || e === null || Array.isArray(e))
-        throw new mt("Operation is not an object", "OPERATION_NOT_AN_OBJECT", t, e, n);
+        throw new yt("Operation is not an object", "OPERATION_NOT_AN_OBJECT", t, e, n);
     if (nc[e.op]) {
         if (typeof e.path != "string")
-            throw new mt("Operation `path` property is not a string", "OPERATION_PATH_INVALID", t, e, n);
+            throw new yt("Operation `path` property is not a string", "OPERATION_PATH_INVALID", t, e, n);
         if (e.path.indexOf("/") !== 0 && e.path.length > 0)
-            throw new mt('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", t, e, n);
+            throw new yt('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", t, e, n);
         if ((e.op === "move" || e.op === "copy") && typeof e.from != "string")
-            throw new mt("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", t, e, n);
+            throw new yt("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", t, e, n);
         if ((e.op === "add" || e.op === "replace" || e.op === "test") && e.value === void 0)
-            throw new mt("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", t, e, n);
+            throw new yt("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", t, e, n);
         if ((e.op === "add" || e.op === "replace" || e.op === "test") && L2(e.value))
-            throw new mt("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", t, e, n);
+            throw new yt("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", t, e, n);
         if (n) {
             if (e.op == "add") {
                 var r = e.path.split("/").length,
                     s = i.split("/").length;
                 if (r !== s + 1 && r !== s)
-                    throw new mt("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", t, e, n);
+                    throw new yt("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", t, e, n);
             } else if (e.op === "replace" || e.op === "remove" || e.op === "_get") {
                 if (e.path !== i)
-                    throw new mt("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", t, e, n);
+                    throw new yt("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", t, e, n);
             } else if (e.op === "move" || e.op === "copy") {
                 var o = {
                         op: "_get",
                         path: e.from,
                         value: void 0
                     },
                     a = U9([o], n);
                 if (a && a.name === "OPERATION_PATH_UNRESOLVABLE")
-                    throw new mt("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", t, e, n);
+                    throw new yt("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", t, e, n);
             }
         }
     } else
-        throw new mt("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", t, e, n);
+        throw new yt("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", t, e, n);
 }
 
 function U9(e, t, n) {
     try {
         if (!Array.isArray(e))
-            throw new mt("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
+            throw new yt("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
         if (t)
             d1(vi(t), vi(e), n || !0);
         else {
             n = n || Am;
             for (var i = 0; i < e.length; i++)
                 n(e[i], i, t, void 0);
         }
     } catch (r) {
-        if (r instanceof mt)
+        if (r instanceof yt)
             return r;
         throw r;
     }
 }
 
 function uh(e, t) {
     if (e === t)
@@ -3572,15 +3559,15 @@
                 return !1;
         return !0;
     }
     return e !== e && t !== t;
 }
 const lH = /* @__PURE__ */ Object.freeze( /* @__PURE__ */ Object.defineProperty({
     __proto__: null,
-    JsonPatchError: mt,
+    JsonPatchError: yt,
     _areEquals: uh,
     applyOperation: _u,
     applyPatch: d1,
     applyReducer: uH,
     deepClone: oH,
     getValueByPointer: km,
     validate: U9,
@@ -3746,16 +3733,16 @@
             ).slice(2, -3), r = i === "" ? 1 / 0 : n.maxLength === void 0 ? 80 : n.maxLength, s = n.replacer,
             function o(a, u, l) {
                 var c, f, d, h, g, p, m, y, b, v, x, w;
                 if (a && typeof a.toJSON == "function" && (a = a.toJSON()), x = JSON.stringify(a, s), x === void 0)
                     return x;
                 if (m = r - u.length - l, x.length <= m && (b = x.replace(
                         vH,
-                        function(S, _) {
-                            return _ || S + " ";
+                        function(E, _) {
+                            return _ || E + " ";
                         }
                     ), b.length <= m))
                     return b;
                 if (s != null && (a = JSON.parse(x), s = void 0), typeof a == "object" && a !== null) {
                     if (y = u + i, d = [], f = 0, Array.isArray(a))
                         for (v = "[", c = "]", m = a.length; f < m; f++)
                             d.push(
@@ -3780,19 +3767,19 @@
     };
 const zb = /* @__PURE__ */ j9(xH);
 
 function hi(e, t, n) {
     return e.fields = t || [], e.fname = n, e;
 }
 
-function _t(e) {
+function Et(e) {
     return e == null ? null : e.fname;
 }
 
-function bn(e) {
+function vn(e) {
     return e == null ? null : e.fields;
 }
 
 function q9(e) {
     return e.length === 1 ? wH(e[0]) : _H(e);
 }
 const wH = (e) => function(t) {
@@ -3803,15 +3790,15 @@
         return function(n) {
             for (let i = 0; i < t; ++i)
                 n = n[e[i]];
             return n;
         };
     };
 
-function q(e) {
+function W(e) {
     throw Error(e);
 }
 
 function As(e) {
     const t = [],
         n = e.length;
     let i = null,
@@ -3827,25 +3814,25 @@
         if (u = e[a], u === "\\")
             s += e.substring(o, a++), o = a;
         else if (u === i)
         l(), i = null, r = -1;
     else {
         if (i)
             continue;
-        o === r && u === '"' || o === r && u === "'" ? (o = a + 1, i = u) : u === "." && !r ? a > o ? l() : o = a + 1 : u === "[" ? (a > o && l(), r = o = a + 1) : u === "]" && (r || q("Access path missing open bracket: " + e), r > 0 && l(), r = 0, o = a + 1);
+        o === r && u === '"' || o === r && u === "'" ? (o = a + 1, i = u) : u === "." && !r ? a > o ? l() : o = a + 1 : u === "[" ? (a > o && l(), r = o = a + 1) : u === "]" && (r || W("Access path missing open bracket: " + e), r > 0 && l(), r = 0, o = a + 1);
     }
-    return r && q("Access path missing closing bracket: " + e), i && q("Access path missing closing quote: " + e), a > o && (a++, l()), t;
+    return r && W("Access path missing closing bracket: " + e), i && W("Access path missing closing quote: " + e), a > o && (a++, l()), t;
 }
 
 function Ki(e, t, n) {
     const i = As(e);
     return e = i.length === 1 ? i[0] : e, hi((n && n.get || q9)(i), [e], t || e);
 }
 const Kh = Ki("id"),
-    Sn = hi((e) => e, [], "identity"),
+    kn = hi((e) => e, [], "identity"),
     Wo = hi(() => 0, [], "zero"),
     cf = hi(() => 1, [], "one"),
     Ji = hi(() => !0, [], "true"),
     Ro = hi(() => !1, [], "false");
 
 function EH(e, t, n) {
     const i = [t].concat([].slice.call(n));
@@ -3874,17 +3861,17 @@
             return i >= H9 && n(t || "log", "INFO", arguments), this;
         },
         debug() {
             return i >= G9 && n(t || "log", "DEBUG", arguments), this;
         }
     };
 }
-var W = Array.isArray;
+var V = Array.isArray;
 
-function re(e) {
+function oe(e) {
     return e === Object(e);
 }
 const Jk = (e) => e !== "__proto__";
 
 function ff() {
     for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
         t[n] = arguments[n];
@@ -3902,16 +3889,16 @@
     }, {});
 }
 
 function df(e, t, n, i) {
     if (!Jk(t))
         return;
     let r, s;
-    if (re(n) && !W(n)) {
-        s = re(e[t]) ? e[t] : e[t] = {};
+    if (oe(n) && !V(n)) {
+        s = oe(e[t]) ? e[t] : e[t] = {};
         for (r in n)
             i && (i === !0 || i[r]) ? df(s, r, n[r]) : Jk(r) && (s[r] = n[r]);
     } else
         e[t] = n;
 }
 
 function SH(e, t) {
@@ -3926,81 +3913,81 @@
     return t.forEach(r), e.forEach(r), i;
 }
 
 function Ie(e) {
     return e[e.length - 1];
 }
 
-function dn(e) {
+function hn(e) {
     return e == null || e === "" ? null : +e;
 }
 const V9 = (e) => (t) => e * Math.exp(t),
     Y9 = (e) => (t) => Math.log(e * t),
     X9 = (e) => (t) => Math.sign(t) * Math.log1p(Math.abs(t / e)),
     K9 = (e) => (t) => Math.sign(t) * Math.expm1(Math.abs(t)) * e,
-    $m = (e) => (t) => t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
+    Cm = (e) => (t) => t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
 
 function h1(e, t, n, i) {
     const r = n(e[0]),
         s = n(Ie(e)),
         o = (s - r) * t;
     return [i(r - o), i(s - o)];
 }
 
 function J9(e, t) {
-    return h1(e, t, dn, Sn);
+    return h1(e, t, hn, kn);
 }
 
 function Q9(e, t) {
     var n = Math.sign(e[0]);
     return h1(e, t, Y9(n), V9(n));
 }
 
 function Z9(e, t, n) {
-    return h1(e, t, $m(n), $m(1 / n));
+    return h1(e, t, Cm(n), Cm(1 / n));
 }
 
 function eM(e, t, n) {
     return h1(e, t, X9(n), K9(n));
 }
 
 function g1(e, t, n, i, r) {
     const s = i(e[0]),
         o = i(Ie(e)),
         a = t != null ? i(t) : (s + o) / 2;
     return [r(a + (s - a) * n), r(a + (o - a) * n)];
 }
 
 function w_(e, t, n) {
-    return g1(e, t, n, dn, Sn);
+    return g1(e, t, n, hn, kn);
 }
 
 function __(e, t, n) {
     const i = Math.sign(e[0]);
     return g1(e, t, n, Y9(i), V9(i));
 }
 
-function Cm(e, t, n, i) {
-    return g1(e, t, n, $m(i), $m(1 / i));
+function $m(e, t, n, i) {
+    return g1(e, t, n, Cm(i), Cm(1 / i));
 }
 
 function E_(e, t, n, i) {
     return g1(e, t, n, X9(i), K9(i));
 }
 
 function tM(e) {
     return 1 + ~~(new Date(e).getMonth() / 3);
 }
 
 function nM(e) {
     return 1 + ~~(new Date(e).getUTCMonth() / 3);
 }
 
-function ne(e) {
-    return e != null ? W(e) ? e : [e] : [];
+function re(e) {
+    return e != null ? V(e) ? e : [e] : [];
 }
 
 function iM(e, t, n) {
     let i = e[0],
         r = e[1],
         s;
     return r < i && (s = r, r = i, i = s), s = r - i, s >= n - t ? [t, n] : [i = Math.min(Math.max(i, t), n - s), i + s];
@@ -4008,48 +3995,48 @@
 
 function Me(e) {
     return typeof e == "function";
 }
 const kH = "descending";
 
 function S_(e, t, n) {
-    n = n || {}, t = ne(t) || [];
+    n = n || {}, t = re(t) || [];
     const i = [],
         r = [],
         s = {},
         o = n.comparator || AH;
-    return ne(e).forEach((a, u) => {
-        a != null && (i.push(t[u] === kH ? -1 : 1), r.push(a = Me(a) ? a : Ki(a, null, n)), (bn(a) || []).forEach((l) => s[l] = 1));
+    return re(e).forEach((a, u) => {
+        a != null && (i.push(t[u] === kH ? -1 : 1), r.push(a = Me(a) ? a : Ki(a, null, n)), (vn(a) || []).forEach((l) => s[l] = 1));
     }), r.length === 0 ? null : hi(o(r, i), Object.keys(s));
 }
 const p1 = (e, t) => (e < t || e == null) && t != null ? -1 : (e > t || t == null) && e != null ? 1 : (t = t instanceof Date ? +t : t, (e = e instanceof Date ? +e : e) !== e && t === t ? -1 : t !== t && e === e ? 1 : 0),
-    AH = (e, t) => e.length === 1 ? $H(e[0], t[0]) : CH(e, t, e.length),
-    $H = (e, t) => function(n, i) {
+    AH = (e, t) => e.length === 1 ? CH(e[0], t[0]) : $H(e, t, e.length),
+    CH = (e, t) => function(n, i) {
         return p1(e(n), e(i)) * t;
     },
-    CH = (e, t, n) => (t.push(0), function(i, r) {
+    $H = (e, t, n) => (t.push(0), function(i, r) {
         let s, o = 0,
             a = -1;
         for (; o === 0 && ++a < n;)
             s = e[a], o = p1(s(i), s(r));
         return o * t[a];
     });
 
-function kn(e) {
+function An(e) {
     return Me(e) ? e : () => e;
 }
 
 function k_(e, t) {
     let n;
     return (i) => {
         n && clearTimeout(n), n = setTimeout(() => (t(i), n = null), e);
     };
 }
 
-function Ce(e) {
+function $e(e) {
     for (let t, n, i = 1, r = arguments.length; i < r; ++i) {
         t = arguments[i];
         for (n in t)
             e[n] = t[n];
     }
     return e;
 }
@@ -4097,25 +4084,25 @@
         for (a = u = i; ++i < n;)
             s = t(e[i], i, e), s != null && (r > s && (r = s, a = i), o < s && (o = s, u = i));
     }
     return [a, u];
 }
 const MH = Object.prototype.hasOwnProperty;
 
-function be(e, t) {
+function xe(e, t) {
     return MH.call(e, t);
 }
 const Qg = {};
 
 function hf(e) {
     let t = {},
         n;
 
     function i(s) {
-        return be(t, s) && t[s] !== Qg;
+        return xe(t, s) && t[s] !== Qg;
     }
     const r = {
         size: 0,
         empty: 0,
         object: t,
         has: i,
         get(s) {
@@ -4156,22 +4143,22 @@
         u = Ie(e),
         l;
     u < a && (l = a, a = u, u = l), l = Math.abs(t - a);
     const c = Math.abs(u - t);
     return l < c && l <= o ? i : c <= o ? r : s;
 }
 
-function Q(e, t, n) {
+function Z(e, t, n) {
     const i = e.prototype = Object.create(t.prototype);
     return Object.defineProperty(i, "constructor", {
         value: e,
         writable: !0,
         enumerable: !0,
         configurable: !0
-    }), Ce(i, n);
+    }), $e(i, n);
 }
 
 function ic(e, t, n, i) {
     let r = t[0],
         s = t[t.length - 1],
         o;
     return r > s && (o = r, r = s, s = o), n = n === void 0 || n, i = i === void 0 || i, (n ? r <= e : r < e) && (i ? e <= s : e < s);
@@ -4193,20 +4180,20 @@
     return typeof e == "number";
 }
 
 function aM(e) {
     return Object.prototype.toString.call(e) === "[object RegExp]";
 }
 
-function ie(e) {
+function se(e) {
     return typeof e == "string";
 }
 
 function A_(e, t, n) {
-    e && (e = t ? ne(e).map((a) => a.replace(/\\(.)/g, "$1")) : ne(e));
+    e && (e = t ? re(e).map((a) => a.replace(/\\(.)/g, "$1")) : re(e));
     const i = e && e.length,
         r = n && n.get || q9,
         s = (a) => r(t ? [a] : As(a));
     let o;
     if (!i)
         o = function() {
             return "";
@@ -4242,17 +4229,17 @@
     let t, n, i;
     const r = () => {
             t = {}, n = {}, i = 0;
         },
         s = (o, a) => (++i > e && (n = t, t = {}, i = 1), t[o] = a);
     return r(), {
         clear: r,
-        has: (o) => be(t, o) || be(n, o),
-        get: (o) => be(t, o) ? t[o] : be(n, o) ? s(o, n[o]) : void 0,
-        set: (o, a) => be(t, o) ? t[o] = a : s(o, a)
+        has: (o) => xe(t, o) || xe(n, o),
+        get: (o) => xe(t, o) ? t[o] : xe(n, o) ? s(o, n[o]) : void 0,
+        set: (o, a) => xe(t, o) ? t[o] = a : s(o, a)
     };
 }
 
 function cM(e, t, n, i) {
     const r = t.length,
         s = n.length;
     if (!s)
@@ -4286,28 +4273,28 @@
     return o <= 0 ? s : i === "left" ? md(r, o) + s : i === "center" ? md(r, ~~(o / 2)) + s + md(r, Math.ceil(o / 2)) : s + md(r, o);
 }
 
 function Jh(e) {
     return e && Ie(e) - e[0] || 0;
 }
 
-function Z(e) {
-    return W(e) ? "[" + e.map(Z) + "]" : re(e) || ie(e) ? (
+function ee(e) {
+    return V(e) ? "[" + e.map(ee) + "]" : oe(e) || se(e) ? (
         // Output valid JSON and JS source strings.
         // See http://timelessrepo.com/json-isnt-a-javascript-subset
         JSON.stringify(e).replace("\u2028", "\\u2028").replace("\u2029", "\\u2029")
     ) : e;
 }
 
-function $_(e) {
+function C_(e) {
     return e == null || e === "" ? null : !e || e === "false" || e === "0" ? !1 : !!e;
 }
 const FH = (e) => ze(e) || na(e) ? e : Date.parse(e);
 
-function C_(e, t) {
+function $_(e, t) {
     return t = t || FH, e == null || e === "" ? null : t(e);
 }
 
 function M_(e) {
     return e == null || e === "" ? null : e + "";
 }
 
@@ -4408,29 +4395,29 @@
         f.charCodeAt(g - 1) === jf && --g, f.charCodeAt(g - 1) === jb && --g;
 
         function x() {
             if (b)
                 return Bb;
             if (v)
                 return v = !1, Qk;
-            var S, _ = p,
+            var E, _ = p,
                 k;
             if (f.charCodeAt(_) === Ub) {
                 for (; p++ < g && f.charCodeAt(p) !== Ub || f.charCodeAt(++p) === Ub;)
                 ;
-                return (S = p) >= g ? b = !0 : (k = f.charCodeAt(p++)) === jf ? v = !0 : k === jb && (v = !0, f.charCodeAt(p) === jf && ++p), f.slice(_ + 1, S - 1).replace(/""/g, '"');
+                return (E = p) >= g ? b = !0 : (k = f.charCodeAt(p++)) === jf ? v = !0 : k === jb && (v = !0, f.charCodeAt(p) === jf && ++p), f.slice(_ + 1, E - 1).replace(/""/g, '"');
             }
             for (; p < g;) {
-                if ((k = f.charCodeAt(S = p++)) === jf)
+                if ((k = f.charCodeAt(E = p++)) === jf)
                     v = !0;
                 else if (k === jb)
                     v = !0, f.charCodeAt(p) === jf && ++p;
                 else if (k !== n)
                     continue;
-                return f.slice(_, S);
+                return f.slice(_, E);
             }
             return b = !0, f.slice(_, g);
         }
         for (;
             (y = x()) !== Bb;) {
             for (var w = []; y !== Qk && y !== Bb;)
                 w.push(y), y = x();
@@ -4724,25 +4711,25 @@
     return c(t), r.forEach(n == null ? function(f) {
         i.push(f[0].i);
     } : function(f) {
         n(f[0].g, f[f.length - 1].g) && i.push(f[0].i);
     }), i;
 }
 
-function vn(e, t) {
+function xn(e, t) {
     return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
 }
 
 function Qh(e, t) {
     return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
 }
 
 function fl(e) {
     let t, n, i;
-    e.length !== 2 ? (t = vn, n = (a, u) => vn(e(a), u), i = (a, u) => e(a) - u) : (t = e === vn || e === Qh ? e : WH, n = e, i = e);
+    e.length !== 2 ? (t = xn, n = (a, u) => xn(e(a), u), i = (a, u) => e(a) - u) : (t = e === xn || e === Qh ? e : WH, n = e, i = e);
 
     function r(a, u, l = 0, c = a.length) {
         if (l < c) {
             if (t(u, u) !== 0)
                 return c;
             do {
                 const f = l + c >>> 1;
@@ -4789,15 +4776,15 @@
             n != null && (n = +n) >= n && (yield n);
     else {
         let n = -1;
         for (let i of e)
             (i = t(i, ++n, e)) != null && (i = +i) >= i && (yield i);
     }
 }
-const mM = fl(vn),
+const mM = fl(xn),
     ca = mM.right,
     GH = mM.left;
 fl(pM).center;
 
 function VH(e) {
     return e.length | 0;
 }
@@ -4869,15 +4856,15 @@
     else {
         let r = -1;
         for (let s of e)
             (s = t(s, ++r, e)) != null && (n === void 0 ? s >= s && (n = i = s) : (n > s && (n = s), i < s && (i = s)));
     }
     return [n, i];
 }
-class In {
+class Pn {
     constructor() {
         this._partials = new Float64Array(32), this._n = 0;
     }
     add(t) {
         const n = this._partials;
         let i = 0;
         for (let r = 0; r < this._n && r < 32; r++) {
@@ -5030,31 +5017,31 @@
                     return a;
             }
         })) : (n = e.map(n), i.sort((r, s) => Mm(n[r], n[s]))), EM(e, i);
     }
     return e.sort(SM(n));
 }
 
-function SM(e = vn) {
-    if (e === vn)
+function SM(e = xn) {
+    if (e === xn)
         return Mm;
     if (typeof e != "function")
         throw new TypeError("compare is not a function");
     return (t, n) => {
         const i = e(t, n);
         return i || i === 0 ? i : (e(n, n) === 0) - (e(t, t) === 0);
     };
 }
 
 function Mm(e, t) {
     return (e == null || !(e >= e)) - (t == null || !(t >= t)) || (e < t ? -1 : e > t ? 1 : 0);
 }
 
 function F_(e, t, n) {
-    return (t.length !== 2 ? B2(qd(e, t, n), ([i, r], [s, o]) => vn(r, o) || vn(i, s)) : B2(_M(e, n), ([i, r], [s, o]) => t(r, o) || vn(i, s))).map(([i]) => i);
+    return (t.length !== 2 ? B2(qd(e, t, n), ([i, r], [s, o]) => xn(r, o) || xn(i, s)) : B2(_M(e, n), ([i, r], [s, o]) => t(r, o) || xn(i, s))).map(([i]) => i);
 }
 const eG = Math.sqrt(50),
     tG = Math.sqrt(10),
     nG = Math.sqrt(2);
 
 function Tm(e, t, n) {
     const i = (t - e) / Math.max(0, n),
@@ -5099,15 +5086,15 @@
 function da(e, t, n) {
     t = +t, e = +e, n = +n;
     const i = t < e,
         r = i ? U2(t, e, n) : U2(e, t, n);
     return (i ? -1 : 1) * (r < 0 ? 1 / -r : r);
 }
 
-function xn(e, t) {
+function wn(e, t) {
     let n;
     if (t === void 0)
         for (const i of e)
             i != null && (n < i || n === void 0 && i >= i) && (n = i);
     else {
         let i = -1;
         for (let r of e)
@@ -5182,57 +5169,57 @@
 }
 
 function qf(e, t, n) {
     const i = e[t];
     e[t] = e[n], e[n] = i;
 }
 
-function AM(e, t = vn) {
+function AM(e, t = xn) {
     let n, i = !1;
     if (t.length === 1) {
         let r;
         for (const s of e) {
             const o = t(s);
-            (i ? vn(o, r) > 0 : vn(o, o) === 0) && (n = s, r = o, i = !0);
+            (i ? xn(o, r) > 0 : xn(o, o) === 0) && (n = s, r = o, i = !0);
         }
     } else
         for (const r of e)
             (i ? t(r, n) > 0 : t(r, r) === 0) && (n = r, i = !0);
     return n;
 }
 
 function Sc(e, t, n) {
     if (e = Float64Array.from(HH(e, n)), !(!(i = e.length) || isNaN(t = +t))) {
         if (t <= 0 || i < 2)
             return gs(e);
         if (t >= 1)
-            return xn(e);
+            return wn(e);
         var i, r = (i - 1) * t,
             s = Math.floor(r),
-            o = xn(kM(e, s).subarray(0, s + 1)),
+            o = wn(kM(e, s).subarray(0, s + 1)),
             a = gs(e.subarray(s + 1));
         return o + (a - o) * (r - s);
     }
 }
 
-function $M(e, t, n = pM) {
+function CM(e, t, n = pM) {
     if (!(!(i = e.length) || isNaN(t = +t))) {
         if (t <= 0 || i < 2)
             return +n(e[0], 0, e);
         if (t >= 1)
             return +n(e[i - 1], i - 1, e);
         var i, r = (i - 1) * t,
             s = Math.floor(r),
             o = +n(e[s], s, e),
             a = +n(e[s + 1], s + 1, e);
         return o + (a - o) * (r - s);
     }
 }
 
-function CM(e, t) {
+function $M(e, t) {
     let n = 0,
         i = 0;
     if (t === void 0)
         for (let r of e)
             r != null && (r = +r) >= r && (++n, i += r);
     else {
         let r = -1;
@@ -5280,15 +5267,15 @@
     return n;
 }
 
 function uG(e, t) {
     return [e, t];
 }
 
-function hn(e, t, n) {
+function gn(e, t, n) {
     e = +e, t = +t, n = (r = arguments.length) < 2 ? (t = e, e = 0, 1) : r < 3 ? 1 : +n;
     for (var i = -1, r = Math.max(0, Math.ceil((t - e) / n)) | 0, s = new Array(r); ++i < r;)
         s[i] = e + i * n;
     return s;
 }
 
 function go(e, t) {
@@ -5474,59 +5461,59 @@
             m = f.zero,
             y = f.width,
             b = f.comma,
             v = f.precision,
             x = f.trim,
             w = f.type;
         w === "n" ? (b = !0, w = "g") : nA[w] || (v === void 0 && (v = 12), x = !0, w = "g"), (m || d === "0" && h === "=") && (m = !0, d = "0", h = "=");
-        var S = p === "$" ? n : p === "#" && /[boxX]/.test(w) ? "0" + w.toLowerCase() : "",
+        var E = p === "$" ? n : p === "#" && /[boxX]/.test(w) ? "0" + w.toLowerCase() : "",
             _ = p === "$" ? i : /[%p]/.test(w) ? o : "",
             k = nA[w],
             A = /[defgprs%]/.test(w);
         v = v === void 0 ? 6 : /[gprs]/.test(w) ? Math.max(1, Math.min(21, v)) : Math.max(0, Math.min(20, v));
 
-        function F(T) {
-            var I = S,
-                N = _,
-                D, M, E;
+        function T(M) {
+            var L = E,
+                F = _,
+                O, N, R;
             if (w === "c")
-                N = k(T) + N, T = "";
+                F = k(M) + F, M = "";
             else {
-                T = +T;
-                var $ = T < 0 || 1 / T < 0;
-                if (T = isNaN(T) ? u : k(Math.abs(T), v), x && (T = mG(T)), $ && +T == 0 && g !== "+" && ($ = !1), I = ($ ? g === "(" ? g : a : g === "-" || g === "(" ? "" : g) + I, N = (w === "s" ? sA[8 + TM / 3] : "") + N + ($ && g === "(" ? ")" : ""), A) {
-                    for (D = -1, M = T.length; ++D < M;)
-                        if (E = T.charCodeAt(D), 48 > E || E > 57) {
-                            N = (E === 46 ? r + T.slice(D + 1) : T.slice(D)) + N, T = T.slice(0, D);
+                M = +M;
+                var P = M < 0 || 1 / M < 0;
+                if (M = isNaN(M) ? u : k(Math.abs(M), v), x && (M = mG(M)), P && +M == 0 && g !== "+" && (P = !1), L = (P ? g === "(" ? g : a : g === "-" || g === "(" ? "" : g) + L, F = (w === "s" ? sA[8 + TM / 3] : "") + F + (P && g === "(" ? ")" : ""), A) {
+                    for (O = -1, N = M.length; ++O < N;)
+                        if (R = M.charCodeAt(O), 48 > R || R > 57) {
+                            F = (R === 46 ? r + M.slice(O + 1) : M.slice(O)) + F, M = M.slice(0, O);
                             break;
                         }
                 }
             }
-            b && !m && (T = t(T, 1 / 0));
-            var C = I.length + T.length + N.length,
-                O = C < y ? new Array(y - C + 1).join(d) : "";
-            switch (b && m && (T = t(O + T, O.length ? y - N.length : 1 / 0), O = ""), h) {
+            b && !m && (M = t(M, 1 / 0));
+            var S = L.length + M.length + F.length,
+                $ = S < y ? new Array(y - S + 1).join(d) : "";
+            switch (b && m && (M = t($ + M, $.length ? y - F.length : 1 / 0), $ = ""), h) {
                 case "<":
-                    T = I + T + N + O;
+                    M = L + M + F + $;
                     break;
                 case "=":
-                    T = I + O + T + N;
+                    M = L + $ + M + F;
                     break;
                 case "^":
-                    T = O.slice(0, C = O.length >> 1) + I + T + N + O.slice(C);
+                    M = $.slice(0, S = $.length >> 1) + L + M + F + $.slice(S);
                     break;
                 default:
-                    T = O + I + T + N;
+                    M = $ + L + M + F;
                     break;
             }
-            return s(T);
+            return s(M);
         }
-        return F.toString = function() {
+        return T.toString = function() {
             return f + "";
-        }, F;
+        }, T;
     }
 
     function c(f, d) {
         var h = l((f = Du(f), f.type = "f", f)),
             g = Math.max(-8, Math.min(8, Math.floor(kc(d) / 3))) * 3,
             p = Math.pow(10, -g),
             m = sA[8 + g / 3];
@@ -5560,15 +5547,15 @@
 
 function DM(e, t) {
     return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, kc(t) - kc(e)) + 1;
 }
 const qb = /* @__PURE__ */ new Date(),
     Wb = /* @__PURE__ */ new Date();
 
-function Ot(e, t, n, i) {
+function Dt(e, t, n, i) {
     function r(s) {
         return e(s = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+s)), s;
     }
     return r.floor = (s) => (e(s = /* @__PURE__ */ new Date(+s)), s), r.ceil = (s) => (e(s = new Date(s - 1)), t(s, 1), e(s), s), r.round = (s) => {
         const o = r(s),
             a = r.ceil(s);
         return s - o < a - s ? o : a;
@@ -5577,15 +5564,15 @@
         if (s = r.ceil(s), a = a == null ? 1 : Math.floor(a), !(s < o) || !(a > 0))
             return u;
         let l;
         do
             u.push(l = /* @__PURE__ */ new Date(+s)), t(s, a), e(s);
         while (l < s && s < o);
         return u;
-    }, r.filter = (s) => Ot((o) => {
+    }, r.filter = (s) => Dt((o) => {
         if (o >= o)
             for (; e(o), !s(o);)
                 o.setTime(o - 1);
     }, (o, a) => {
         if (o >= o)
             if (a < 0)
                 for (; ++a <= 0;)
@@ -5593,82 +5580,82 @@
             ;
             else
                 for (; --a >= 0;)
                     for (; t(o, 1), !s(o);)
         ;
     }), n && (r.count = (s, o) => (qb.setTime(+s), Wb.setTime(+o), e(qb), e(Wb), Math.floor(n(qb, Wb))), r.every = (s) => (s = Math.floor(s), !isFinite(s) || !(s > 0) ? null : s > 1 ? r.filter(i ? (o) => i(o) % s === 0 : (o) => r.count(0, o) % s === 0) : r)), r;
 }
-const Ac = Ot(() => {}, (e, t) => {
+const Ac = Dt(() => {}, (e, t) => {
     e.setTime(+e + t);
 }, (e, t) => t - e);
-Ac.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? Ot((t) => {
+Ac.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? Dt((t) => {
     t.setTime(Math.floor(t / e) * e);
 }, (t, n) => {
     t.setTime(+t + n * e);
 }, (t, n) => (n - t) / e) : Ac);
 Ac.range;
 const no = 1e3,
     ji = no * 60,
     io = ji * 60,
     po = io * 24,
     D_ = po * 7,
     oA = po * 30,
     Hb = po * 365,
-    xi = Ot((e) => {
+    xi = Dt((e) => {
         e.setTime(e - e.getMilliseconds());
     }, (e, t) => {
         e.setTime(+e + t * no);
     }, (e, t) => (t - e) / no, (e) => e.getUTCSeconds());
 xi.range;
-const gf = Ot((e) => {
+const gf = Dt((e) => {
     e.setTime(e - e.getMilliseconds() - e.getSeconds() * no);
 }, (e, t) => {
     e.setTime(+e + t * ji);
 }, (e, t) => (t - e) / ji, (e) => e.getMinutes());
 gf.range;
-const pf = Ot((e) => {
+const pf = Dt((e) => {
     e.setUTCSeconds(0, 0);
 }, (e, t) => {
     e.setTime(+e + t * ji);
 }, (e, t) => (t - e) / ji, (e) => e.getUTCMinutes());
 pf.range;
-const mf = Ot((e) => {
+const mf = Dt((e) => {
     e.setTime(e - e.getMilliseconds() - e.getSeconds() * no - e.getMinutes() * ji);
 }, (e, t) => {
     e.setTime(+e + t * io);
 }, (e, t) => (t - e) / io, (e) => e.getHours());
 mf.range;
-const yf = Ot((e) => {
+const yf = Dt((e) => {
     e.setUTCMinutes(0, 0, 0);
 }, (e, t) => {
     e.setTime(+e + t * io);
 }, (e, t) => (t - e) / io, (e) => e.getUTCHours());
 yf.range;
-const Cr = Ot(
+const $r = Dt(
     (e) => e.setHours(0, 0, 0, 0),
     (e, t) => e.setDate(e.getDate() + t),
     (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * ji) / po,
     (e) => e.getDate() - 1
 );
-Cr.range;
-const ra = Ot((e) => {
+$r.range;
+const ra = Dt((e) => {
     e.setUTCHours(0, 0, 0, 0);
 }, (e, t) => {
     e.setUTCDate(e.getUTCDate() + t);
 }, (e, t) => (t - e) / po, (e) => e.getUTCDate() - 1);
 ra.range;
-const m1 = Ot((e) => {
+const m1 = Dt((e) => {
     e.setUTCHours(0, 0, 0, 0);
 }, (e, t) => {
     e.setUTCDate(e.getUTCDate() + t);
 }, (e, t) => (t - e) / po, (e) => Math.floor(e / po));
 m1.range;
 
 function hl(e) {
-    return Ot((t) => {
+    return Dt((t) => {
         t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
     }, (t, n) => {
         t.setDate(t.getDate() + n * 7);
     }, (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * ji) / D_);
 }
 const ha = hl(0),
     ch = hl(1),
@@ -5682,15 +5669,15 @@
 RM.range;
 LM.range;
 Ru.range;
 IM.range;
 PM.range;
 
 function gl(e) {
-    return Ot((t) => {
+    return Dt((t) => {
         t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
     }, (t, n) => {
         t.setUTCDate(t.getUTCDate() + n * 7);
     }, (t, n) => (n - t) / D_);
 }
 const ga = gl(0),
     fh = gl(1),
@@ -5702,43 +5689,43 @@
 ga.range;
 fh.range;
 zM.range;
 BM.range;
 Lu.range;
 UM.range;
 jM.range;
-const Iu = Ot((e) => {
+const Iu = Dt((e) => {
     e.setDate(1), e.setHours(0, 0, 0, 0);
 }, (e, t) => {
     e.setMonth(e.getMonth() + t);
 }, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, (e) => e.getMonth());
 Iu.range;
-const Pu = Ot((e) => {
+const Pu = Dt((e) => {
     e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0);
 }, (e, t) => {
     e.setUTCMonth(e.getUTCMonth() + t);
 }, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, (e) => e.getUTCMonth());
 Pu.range;
-const Qi = Ot((e) => {
+const Qi = Dt((e) => {
     e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
 }, (e, t) => {
     e.setFullYear(e.getFullYear() + t);
 }, (e, t) => t.getFullYear() - e.getFullYear(), (e) => e.getFullYear());
-Qi.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Ot((t) => {
+Qi.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Dt((t) => {
     t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
 }, (t, n) => {
     t.setFullYear(t.getFullYear() + n * e);
 });
 Qi.range;
-const Zi = Ot((e) => {
+const Zi = Dt((e) => {
     e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
 }, (e, t) => {
     e.setUTCFullYear(e.getUTCFullYear() + t);
 }, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), (e) => e.getUTCFullYear());
-Zi.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Ot((t) => {
+Zi.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Dt((t) => {
     t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
 }, (t, n) => {
     t.setUTCFullYear(t.getUTCFullYear() + n * e);
 });
 Zi.range;
 
 function qM(e, t, n, i, r, s) {
@@ -5779,42 +5766,42 @@
         if (h === 0)
             return Ac.every(Math.max(da(l, c, f), 1));
         const [g, p] = o[d / o[h - 1][2] < o[h][2] / d ? h - 1 : h];
         return g.every(p);
     }
     return [a, u];
 }
-const [vG, xG] = qM(Zi, Pu, ga, m1, yf, pf), [wG, _G] = qM(Qi, Iu, ha, Cr, mf, gf), tn = "year", ai = "quarter", wn = "month", Tt = "week", ui = "date", fn = "day", ps = "dayofyear", Ci = "hours", Mi = "minutes", er = "seconds", Nr = "milliseconds", R_ = [tn, ai, wn, Tt, ui, fn, ps, Ci, Mi, er, Nr], Gb = R_.reduce((e, t, n) => (e[t] = 1 + n, e), {});
+const [vG, xG] = qM(Zi, Pu, ga, m1, yf, pf), [wG, _G] = qM(Qi, Iu, ha, $r, mf, gf), nn = "year", ai = "quarter", _n = "month", Ft = "week", ui = "date", dn = "day", ps = "dayofyear", $i = "hours", Mi = "minutes", er = "seconds", Nr = "milliseconds", R_ = [nn, ai, _n, Ft, ui, dn, ps, $i, Mi, er, Nr], Gb = R_.reduce((e, t, n) => (e[t] = 1 + n, e), {});
 
 function L_(e) {
-    const t = ne(e).slice(),
+    const t = re(e).slice(),
         n = {};
-    return t.length || q("Missing time unit."), t.forEach((r) => {
-        be(Gb, r) ? n[r] = 1 : q(`Invalid time unit: ${r}.`);
-    }), (n[Tt] || n[fn] ? 1 : 0) + (n[ai] || n[wn] || n[ui] ? 1 : 0) + (n[ps] ? 1 : 0) > 1 && q(`Incompatible time units: ${e}`), t.sort((r, s) => Gb[r] - Gb[s]), t;
+    return t.length || W("Missing time unit."), t.forEach((r) => {
+        xe(Gb, r) ? n[r] = 1 : W(`Invalid time unit: ${r}.`);
+    }), (n[Ft] || n[dn] ? 1 : 0) + (n[ai] || n[_n] || n[ui] ? 1 : 0) + (n[ps] ? 1 : 0) > 1 && W(`Incompatible time units: ${e}`), t.sort((r, s) => Gb[r] - Gb[s]), t;
 }
 const EG = {
-    [tn]: "%Y ",
+    [nn]: "%Y ",
     [ai]: "Q%q ",
-    [wn]: "%b ",
+    [_n]: "%b ",
     [ui]: "%d ",
-    [Tt]: "W%U ",
-    [fn]: "%a ",
+    [Ft]: "W%U ",
+    [dn]: "%a ",
     [ps]: "%j ",
-    [Ci]: "%H:00",
+    [$i]: "%H:00",
     [Mi]: "00:%M",
     [er]: ":%S",
     [Nr]: ".%L",
-    [`${tn}-${wn}`]: "%Y-%m ",
-    [`${tn}-${wn}-${ui}`]: "%Y-%m-%d ",
-    [`${Ci}-${Mi}`]: "%H:%M"
+    [`${nn}-${_n}`]: "%Y-%m ",
+    [`${nn}-${_n}-${ui}`]: "%Y-%m-%d ",
+    [`${$i}-${Mi}`]: "%H:%M"
 };
 
 function WM(e, t) {
-    const n = Ce({}, EG, t),
+    const n = $e({}, EG, t),
         i = L_(e),
         r = i.length;
     let s = "",
         o = 0,
         a, u;
     for (o = 0; o < r;)
         for (a = i.length; a > o; --a)
@@ -5835,15 +5822,15 @@
 }
 
 function GM(e) {
     return j2(new Date(e));
 }
 
 function VM(e) {
-    return Cr.count(I_(e.getFullYear()) - 1, e);
+    return $r.count(I_(e.getFullYear()) - 1, e);
 }
 
 function j2(e) {
     return ha.count(I_(e.getFullYear()) - 1, e);
 }
 
 function q2(e) {
@@ -5890,18 +5877,18 @@
 
 function JM(e, t, n, i, r) {
     const s = t || 1,
         o = Ie(e),
         a = (y, b, v) => (v = v || y, AG(n[v], i[v], y === o && s, b)),
         u = /* @__PURE__ */ new Date(),
         l = Fr(e),
-        c = l[tn] ? a(tn) : kn(2012),
-        f = l[wn] ? a(wn) : l[ai] ? a(ai) : Wo,
-        d = l[Tt] && l[fn] ? a(fn, 1, Tt + fn) : l[Tt] ? a(Tt, 1) : l[fn] ? a(fn, 1) : l[ui] ? a(ui, 1) : l[ps] ? a(ps, 1) : cf,
-        h = l[Ci] ? a(Ci) : Wo,
+        c = l[nn] ? a(nn) : An(2012),
+        f = l[_n] ? a(_n) : l[ai] ? a(ai) : Wo,
+        d = l[Ft] && l[dn] ? a(dn, 1, Ft + dn) : l[Ft] ? a(Ft, 1) : l[dn] ? a(dn, 1) : l[ui] ? a(ui, 1) : l[ps] ? a(ps, 1) : cf,
+        h = l[$i] ? a($i) : Wo,
         g = l[Mi] ? a(Mi) : Wo,
         p = l[er] ? a(er) : Wo,
         m = l[Nr] ? a(Nr) : Wo;
     return function(y) {
         u.setTime(+y);
         const b = c(u);
         return r(b, f(u), d(u, b), h(u), g(u), p(u), m(u));
@@ -5909,83 +5896,83 @@
 }
 
 function AG(e, t, n, i) {
     const r = n <= 1 ? e : i ? (s, o) => i + n * Math.floor((e(s, o) - i) / n) : (s, o) => n * Math.floor(e(s, o) / n);
     return t ? (s, o) => t(r(s, o), o) : r;
 }
 
-function $c(e, t, n) {
+function Cc(e, t, n) {
     return t + e * 7 - (n + 6) % 7;
 }
-const $G = {
-        [tn]: (e) => e.getFullYear(),
+const CG = {
+        [nn]: (e) => e.getFullYear(),
         [ai]: (e) => Math.floor(e.getMonth() / 3),
-        [wn]: (e) => e.getMonth(),
+        [_n]: (e) => e.getMonth(),
         [ui]: (e) => e.getDate(),
-        [Ci]: (e) => e.getHours(),
+        [$i]: (e) => e.getHours(),
         [Mi]: (e) => e.getMinutes(),
         [er]: (e) => e.getSeconds(),
         [Nr]: (e) => e.getMilliseconds(),
         [ps]: (e) => VM(e),
-        [Tt]: (e) => j2(e),
-        [Tt + fn]: (e, t) => $c(j2(e), e.getDay(), q2(t)),
-        [fn]: (e, t) => $c(1, e.getDay(), q2(t))
+        [Ft]: (e) => j2(e),
+        [Ft + dn]: (e, t) => Cc(j2(e), e.getDay(), q2(t)),
+        [dn]: (e, t) => Cc(1, e.getDay(), q2(t))
     },
-    CG = {
+    $G = {
         [ai]: (e) => 3 * e,
-        [Tt]: (e, t) => $c(e, 0, q2(t))
+        [Ft]: (e, t) => Cc(e, 0, q2(t))
     };
 
 function QM(e, t) {
-    return JM(e, t || 1, $G, CG, SG);
+    return JM(e, t || 1, CG, $G, SG);
 }
 const MG = {
-        [tn]: (e) => e.getUTCFullYear(),
+        [nn]: (e) => e.getUTCFullYear(),
         [ai]: (e) => Math.floor(e.getUTCMonth() / 3),
-        [wn]: (e) => e.getUTCMonth(),
+        [_n]: (e) => e.getUTCMonth(),
         [ui]: (e) => e.getUTCDate(),
-        [Ci]: (e) => e.getUTCHours(),
+        [$i]: (e) => e.getUTCHours(),
         [Mi]: (e) => e.getUTCMinutes(),
         [er]: (e) => e.getUTCSeconds(),
         [Nr]: (e) => e.getUTCMilliseconds(),
         [ps]: (e) => KM(e),
-        [Tt]: (e) => W2(e),
-        [fn]: (e, t) => $c(1, e.getUTCDay(), H2(t)),
-        [Tt + fn]: (e, t) => $c(W2(e), e.getUTCDay(), H2(t))
+        [Ft]: (e) => W2(e),
+        [dn]: (e, t) => Cc(1, e.getUTCDay(), H2(t)),
+        [Ft + dn]: (e, t) => Cc(W2(e), e.getUTCDay(), H2(t))
     },
     TG = {
         [ai]: (e) => 3 * e,
-        [Tt]: (e, t) => $c(e, 0, H2(t))
+        [Ft]: (e, t) => Cc(e, 0, H2(t))
     };
 
 function ZM(e, t) {
     return JM(e, t || 1, MG, TG, kG);
 }
 const FG = {
-        [tn]: Qi,
+        [nn]: Qi,
         [ai]: Iu.every(3),
-        [wn]: Iu,
-        [Tt]: ha,
-        [ui]: Cr,
-        [fn]: Cr,
-        [ps]: Cr,
-        [Ci]: mf,
+        [_n]: Iu,
+        [Ft]: ha,
+        [ui]: $r,
+        [dn]: $r,
+        [ps]: $r,
+        [$i]: mf,
         [Mi]: gf,
         [er]: xi,
         [Nr]: Ac
     },
     NG = {
-        [tn]: Zi,
+        [nn]: Zi,
         [ai]: Pu.every(3),
-        [wn]: Pu,
-        [Tt]: ga,
+        [_n]: Pu,
+        [Ft]: ga,
         [ui]: ra,
-        [fn]: ra,
+        [dn]: ra,
         [ps]: ra,
-        [Ci]: yf,
+        [$i]: yf,
         [Mi]: pf,
         [er]: xi,
         [Nr]: Ac
     };
 
 function bf(e) {
     return FG[e];
@@ -6021,22 +6008,22 @@
 const yd = 1e3,
     bd = yd * 60,
     vd = bd * 60,
     y1 = vd * 24,
     OG = y1 * 7,
     aA = y1 * 30,
     G2 = y1 * 365,
-    oT = [tn, wn, ui, Ci, Mi, er, Nr],
+    oT = [nn, _n, ui, $i, Mi, er, Nr],
     xd = oT.slice(0, -1),
     wd = xd.slice(0, -1),
     _d = wd.slice(0, -1),
     DG = _d.slice(0, -1),
-    RG = [tn, Tt],
-    uA = [tn, wn],
-    aT = [tn],
+    RG = [nn, Ft],
+    uA = [nn, _n],
+    aT = [nn],
     Wf = [
         [xd, 1, yd],
         [xd, 5, 5 * yd],
         [xd, 15, 15 * yd],
         [xd, 30, 30 * yd],
         [wd, 1, bd],
         [wd, 5, 5 * bd],
@@ -6109,32 +6096,32 @@
         h = Gf(o),
         g = Vf(o),
         p = Gf(a),
         m = Vf(a),
         y = Gf(u),
         b = Vf(u),
         v = {
-            a: $,
-            A: C,
-            b: O,
-            B: R,
+            a: P,
+            A: S,
+            b: $,
+            B: C,
             c: null,
             d: gA,
             e: gA,
             f: rV,
             g: gV,
             G: mV,
             H: tV,
             I: nV,
             j: iV,
             L: cT,
             m: sV,
             M: oV,
-            p: L,
-            q: P,
+            p: D,
+            q: I,
             Q: yA,
             s: bA,
             S: aV,
             u: uV,
             U: lV,
             V: cV,
             w: fV,
@@ -6144,52 +6131,52 @@
             y: hV,
             Y: pV,
             Z: yV,
             "%": mA
         },
         x = {
             a: z,
-            A: V,
-            b: X,
-            B: se,
+            A: H,
+            b: G,
+            B: te,
             c: null,
             d: pA,
             e: pA,
             f: wV,
             g: FV,
             G: OV,
             H: bV,
             I: vV,
             j: xV,
             L: dT,
             m: _V,
             M: EV,
-            p: ee,
-            q: ue,
+            p: K,
+            q: ae,
             Q: yA,
             s: bA,
             S: SV,
             u: kV,
             U: AV,
-            V: $V,
-            w: CV,
+            V: CV,
+            w: $V,
             W: MV,
             x: null,
             X: null,
             y: TV,
             Y: NV,
             Z: DV,
             "%": mA
         },
         w = {
-            a: F,
-            A: T,
-            b: I,
-            B: N,
-            c: D,
+            a: T,
+            A: M,
+            b: L,
+            B: F,
+            c: O,
             d: dA,
             e: dA,
             f: JG,
             g: fA,
             G: cA,
             H: hA,
             I: hA,
@@ -6203,187 +6190,187 @@
             s: eV,
             S: XG,
             u: BG,
             U: UG,
             V: jG,
             w: zG,
             W: qG,
-            x: M,
-            X: E,
+            x: N,
+            X: R,
             y: fA,
             Y: cA,
             Z: WG,
             "%": QG
         };
-    v.x = S(n, v), v.X = S(i, v), v.c = S(t, v), x.x = S(n, x), x.X = S(i, x), x.c = S(t, x);
+    v.x = E(n, v), v.X = E(i, v), v.c = E(t, v), x.x = E(n, x), x.X = E(i, x), x.c = E(t, x);
 
-    function S(G, ae) {
-        return function(ce) {
-            var H = [],
+    function E(U, ie) {
+        return function(le) {
+            var Y = [],
                 Be = -1,
                 Ee = 0,
-                Ve = G.length,
-                st, An, No;
-            for (ce instanceof Date || (ce = /* @__PURE__ */ new Date(+ce)); ++Be < Ve;)
-                G.charCodeAt(Be) === 37 && (H.push(G.slice(Ee, Be)), (An = lA[st = G.charAt(++Be)]) != null ? st = G.charAt(++Be) : An = st === "e" ? " " : "0", (No = ae[st]) && (st = No(ce, An)), H.push(st), Ee = Be + 1);
-            return H.push(G.slice(Ee, Be)), H.join("");
+                Ve = U.length,
+                ot, Cn, No;
+            for (le instanceof Date || (le = /* @__PURE__ */ new Date(+le)); ++Be < Ve;)
+                U.charCodeAt(Be) === 37 && (Y.push(U.slice(Ee, Be)), (Cn = lA[ot = U.charAt(++Be)]) != null ? ot = U.charAt(++Be) : Cn = ot === "e" ? " " : "0", (No = ie[ot]) && (ot = No(le, Cn)), Y.push(ot), Ee = Be + 1);
+            return Y.push(U.slice(Ee, Be)), Y.join("");
         };
     }
 
-    function _(G, ae) {
-        return function(ce) {
-            var H = Hf(1900, void 0, 1),
-                Be = k(H, G, ce += "", 0),
+    function _(U, ie) {
+        return function(le) {
+            var Y = Hf(1900, void 0, 1),
+                Be = k(Y, U, le += "", 0),
                 Ee, Ve;
-            if (Be != ce.length)
+            if (Be != le.length)
                 return null;
-            if ("Q" in H)
-                return new Date(H.Q);
-            if ("s" in H)
-                return new Date(H.s * 1e3 + ("L" in H ? H.L : 0));
-            if (ae && !("Z" in H) && (H.Z = 0), "p" in H && (H.H = H.H % 12 + H.p * 12), H.m === void 0 && (H.m = "q" in H ? H.q : 0), "V" in H) {
-                if (H.V < 1 || H.V > 53)
+            if ("Q" in Y)
+                return new Date(Y.Q);
+            if ("s" in Y)
+                return new Date(Y.s * 1e3 + ("L" in Y ? Y.L : 0));
+            if (ie && !("Z" in Y) && (Y.Z = 0), "p" in Y && (Y.H = Y.H % 12 + Y.p * 12), Y.m === void 0 && (Y.m = "q" in Y ? Y.q : 0), "V" in Y) {
+                if (Y.V < 1 || Y.V > 53)
                     return null;
-                "w" in H || (H.w = 1), "Z" in H ? (Ee = Yb(Hf(H.y, 0, 1)), Ve = Ee.getUTCDay(), Ee = Ve > 4 || Ve === 0 ? fh.ceil(Ee) : fh(Ee), Ee = ra.offset(Ee, (H.V - 1) * 7), H.y = Ee.getUTCFullYear(), H.m = Ee.getUTCMonth(), H.d = Ee.getUTCDate() + (H.w + 6) % 7) : (Ee = Vb(Hf(H.y, 0, 1)), Ve = Ee.getDay(), Ee = Ve > 4 || Ve === 0 ? ch.ceil(Ee) : ch(Ee), Ee = Cr.offset(Ee, (H.V - 1) * 7), H.y = Ee.getFullYear(), H.m = Ee.getMonth(), H.d = Ee.getDate() + (H.w + 6) % 7);
+                "w" in Y || (Y.w = 1), "Z" in Y ? (Ee = Yb(Hf(Y.y, 0, 1)), Ve = Ee.getUTCDay(), Ee = Ve > 4 || Ve === 0 ? fh.ceil(Ee) : fh(Ee), Ee = ra.offset(Ee, (Y.V - 1) * 7), Y.y = Ee.getUTCFullYear(), Y.m = Ee.getUTCMonth(), Y.d = Ee.getUTCDate() + (Y.w + 6) % 7) : (Ee = Vb(Hf(Y.y, 0, 1)), Ve = Ee.getDay(), Ee = Ve > 4 || Ve === 0 ? ch.ceil(Ee) : ch(Ee), Ee = $r.offset(Ee, (Y.V - 1) * 7), Y.y = Ee.getFullYear(), Y.m = Ee.getMonth(), Y.d = Ee.getDate() + (Y.w + 6) % 7);
             } else
-                ("W" in H || "U" in H) && ("w" in H || (H.w = "u" in H ? H.u % 7 : "W" in H ? 1 : 0), Ve = "Z" in H ? Yb(Hf(H.y, 0, 1)).getUTCDay() : Vb(Hf(H.y, 0, 1)).getDay(), H.m = 0, H.d = "W" in H ? (H.w + 6) % 7 + H.W * 7 - (Ve + 5) % 7 : H.w + H.U * 7 - (Ve + 6) % 7);
-            return "Z" in H ? (H.H += H.Z / 100 | 0, H.M += H.Z % 100, Yb(H)) : Vb(H);
+                ("W" in Y || "U" in Y) && ("w" in Y || (Y.w = "u" in Y ? Y.u % 7 : "W" in Y ? 1 : 0), Ve = "Z" in Y ? Yb(Hf(Y.y, 0, 1)).getUTCDay() : Vb(Hf(Y.y, 0, 1)).getDay(), Y.m = 0, Y.d = "W" in Y ? (Y.w + 6) % 7 + Y.W * 7 - (Ve + 5) % 7 : Y.w + Y.U * 7 - (Ve + 6) % 7);
+            return "Z" in Y ? (Y.H += Y.Z / 100 | 0, Y.M += Y.Z % 100, Yb(Y)) : Vb(Y);
         };
     }
 
-    function k(G, ae, ce, H) {
-        for (var Be = 0, Ee = ae.length, Ve = ce.length, st, An; Be < Ee;) {
-            if (H >= Ve)
+    function k(U, ie, le, Y) {
+        for (var Be = 0, Ee = ie.length, Ve = le.length, ot, Cn; Be < Ee;) {
+            if (Y >= Ve)
                 return -1;
-            if (st = ae.charCodeAt(Be++), st === 37) {
-                if (st = ae.charAt(Be++), An = w[st in lA ? ae.charAt(Be++) : st], !An || (H = An(G, ce, H)) < 0)
+            if (ot = ie.charCodeAt(Be++), ot === 37) {
+                if (ot = ie.charAt(Be++), Cn = w[ot in lA ? ie.charAt(Be++) : ot], !Cn || (Y = Cn(U, le, Y)) < 0)
                     return -1;
-            } else if (st != ce.charCodeAt(H++))
+            } else if (ot != le.charCodeAt(Y++))
                 return -1;
         }
-        return H;
+        return Y;
     }
 
-    function A(G, ae, ce) {
-        var H = l.exec(ae.slice(ce));
-        return H ? (G.p = c.get(H[0].toLowerCase()), ce + H[0].length) : -1;
+    function A(U, ie, le) {
+        var Y = l.exec(ie.slice(le));
+        return Y ? (U.p = c.get(Y[0].toLowerCase()), le + Y[0].length) : -1;
     }
 
-    function F(G, ae, ce) {
-        var H = h.exec(ae.slice(ce));
-        return H ? (G.w = g.get(H[0].toLowerCase()), ce + H[0].length) : -1;
+    function T(U, ie, le) {
+        var Y = h.exec(ie.slice(le));
+        return Y ? (U.w = g.get(Y[0].toLowerCase()), le + Y[0].length) : -1;
     }
 
-    function T(G, ae, ce) {
-        var H = f.exec(ae.slice(ce));
-        return H ? (G.w = d.get(H[0].toLowerCase()), ce + H[0].length) : -1;
+    function M(U, ie, le) {
+        var Y = f.exec(ie.slice(le));
+        return Y ? (U.w = d.get(Y[0].toLowerCase()), le + Y[0].length) : -1;
     }
 
-    function I(G, ae, ce) {
-        var H = y.exec(ae.slice(ce));
-        return H ? (G.m = b.get(H[0].toLowerCase()), ce + H[0].length) : -1;
+    function L(U, ie, le) {
+        var Y = y.exec(ie.slice(le));
+        return Y ? (U.m = b.get(Y[0].toLowerCase()), le + Y[0].length) : -1;
     }
 
-    function N(G, ae, ce) {
-        var H = p.exec(ae.slice(ce));
-        return H ? (G.m = m.get(H[0].toLowerCase()), ce + H[0].length) : -1;
+    function F(U, ie, le) {
+        var Y = p.exec(ie.slice(le));
+        return Y ? (U.m = m.get(Y[0].toLowerCase()), le + Y[0].length) : -1;
     }
 
-    function D(G, ae, ce) {
-        return k(G, t, ae, ce);
+    function O(U, ie, le) {
+        return k(U, t, ie, le);
     }
 
-    function M(G, ae, ce) {
-        return k(G, n, ae, ce);
+    function N(U, ie, le) {
+        return k(U, n, ie, le);
     }
 
-    function E(G, ae, ce) {
-        return k(G, i, ae, ce);
+    function R(U, ie, le) {
+        return k(U, i, ie, le);
     }
 
-    function $(G) {
-        return o[G.getDay()];
+    function P(U) {
+        return o[U.getDay()];
     }
 
-    function C(G) {
-        return s[G.getDay()];
+    function S(U) {
+        return s[U.getDay()];
     }
 
-    function O(G) {
-        return u[G.getMonth()];
+    function $(U) {
+        return u[U.getMonth()];
     }
 
-    function R(G) {
-        return a[G.getMonth()];
+    function C(U) {
+        return a[U.getMonth()];
     }
 
-    function L(G) {
-        return r[+(G.getHours() >= 12)];
+    function D(U) {
+        return r[+(U.getHours() >= 12)];
     }
 
-    function P(G) {
-        return 1 + ~~(G.getMonth() / 3);
+    function I(U) {
+        return 1 + ~~(U.getMonth() / 3);
     }
 
-    function z(G) {
-        return o[G.getUTCDay()];
+    function z(U) {
+        return o[U.getUTCDay()];
     }
 
-    function V(G) {
-        return s[G.getUTCDay()];
+    function H(U) {
+        return s[U.getUTCDay()];
     }
 
-    function X(G) {
-        return u[G.getUTCMonth()];
+    function G(U) {
+        return u[U.getUTCMonth()];
     }
 
-    function se(G) {
-        return a[G.getUTCMonth()];
+    function te(U) {
+        return a[U.getUTCMonth()];
     }
 
-    function ee(G) {
-        return r[+(G.getUTCHours() >= 12)];
+    function K(U) {
+        return r[+(U.getUTCHours() >= 12)];
     }
 
-    function ue(G) {
-        return 1 + ~~(G.getUTCMonth() / 3);
+    function ae(U) {
+        return 1 + ~~(U.getUTCMonth() / 3);
     }
     return {
-        format: function(G) {
-            var ae = S(G += "", v);
-            return ae.toString = function() {
-                return G;
-            }, ae;
+        format: function(U) {
+            var ie = E(U += "", v);
+            return ie.toString = function() {
+                return U;
+            }, ie;
         },
-        parse: function(G) {
-            var ae = _(G += "", !1);
-            return ae.toString = function() {
-                return G;
-            }, ae;
+        parse: function(U) {
+            var ie = _(U += "", !1);
+            return ie.toString = function() {
+                return U;
+            }, ie;
         },
-        utcFormat: function(G) {
-            var ae = S(G += "", x);
-            return ae.toString = function() {
-                return G;
-            }, ae;
+        utcFormat: function(U) {
+            var ie = E(U += "", x);
+            return ie.toString = function() {
+                return U;
+            }, ie;
         },
-        utcParse: function(G) {
-            var ae = _(G += "", !0);
-            return ae.toString = function() {
-                return G;
-            }, ae;
+        utcParse: function(U) {
+            var ie = _(U += "", !0);
+            return ie.toString = function() {
+                return U;
+            }, ie;
         }
     };
 }
 var lA = {
         "-": "",
         _: " ",
         0: "0"
     },
-    Vt = /^\s*\d+/,
+    Yt = /^\s*\d+/,
     LG = /^%/,
     IG = /[\\^$*+?|[\]().{}]/g;
 
 function je(e, t, n) {
     var i = e < 0 ? "-" : "",
         r = (i ? -e : e) + "",
         s = r.length;
@@ -6399,110 +6386,110 @@
 }
 
 function Vf(e) {
     return new Map(e.map((t, n) => [t.toLowerCase(), n]));
 }
 
 function zG(e, t, n) {
-    var i = Vt.exec(t.slice(n, n + 1));
+    var i = Yt.exec(t.slice(n, n + 1));
     return i ? (e.w = +i[0], n + i[0].length) : -1;
 }
 
 function BG(e, t, n) {
-    var i = Vt.exec(t.slice(n, n + 1));
+    var i = Yt.exec(t.slice(n, n + 1));
     return i ? (e.u = +i[0], n + i[0].length) : -1;
 }
 
 function UG(e, t, n) {
-    var i = Vt.exec(t.slice(n, n + 2));
+    var i = Yt.exec(t.slice(n, n + 2));
     return i ? (e.U = +i[0], n + i[0].length) : -1;
 }
 
 function jG(e, t, n) {
-    var i = Vt.exec(t.slice(n, n + 2));
+    var i = Yt.exec(t.slice(n, n + 2));
     return i ? (e.V = +i[0], n + i[0].length) : -1;
 }
 
 function qG(e, t, n) {
-    var i = Vt.exec(t.slice(n, n + 2));
+    var i = Yt.exec(t.slice(n, n + 2));
     return i ? (e.W = +i[0], n + i[0].length) : -1;
 }
 
 function cA(e, t, n) {
-    var i = Vt.exec(t.slice(n, n + 4));
+    var i = Yt.exec(t.slice(n, n + 4));
     return i ? (e.y = +i[0], n + i[0].length) : -1;
 }
 
 function fA(e, t, n) {
-    var i = Vt.exec(t.slice(n, n + 2));
+    var i = Yt.exec(t.slice(n, n + 2));
     return i ? (e.y = +i[0] + (+i[0] > 68 ? 1900 : 2e3), n + i[0].length) : -1;
 }
 
 function WG(e, t, n) {
     var i = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
     return i ? (e.Z = i[1] ? 0 : -(i[2] + (i[3] || "00")), n + i[0].length) : -1;
 }
 
 function HG(e, t, n) {
-    var i = Vt.exec(t.slice(n, n + 1));
+    var i = Yt.exec(t.slice(n, n + 1));
     return i ? (e.q = i[0] * 3 - 3, n + i[0].length) : -1;
 }
 
 function GG(e, t, n) {
-    var i = Vt.exec(t.slice(n, n + 2));
+    var i = Yt.exec(t.slice(n, n + 2));
     return i ? (e.m = i[0] - 1, n + i[0].length) : -1;
 }
 
 function dA(e, t, n) {
-    var i = Vt.exec(t.slice(n, n + 2));
+    var i = Yt.exec(t.slice(n, n + 2));
     return i ? (e.d = +i[0], n + i[0].length) : -1;
 }
 
 function VG(e, t, n) {
-    var i = Vt.exec(t.slice(n, n + 3));
+    var i = Yt.exec(t.slice(n, n + 3));
     return i ? (e.m = 0, e.d = +i[0], n + i[0].length) : -1;
 }
 
 function hA(e, t, n) {
-    var i = Vt.exec(t.slice(n, n + 2));
+    var i = Yt.exec(t.slice(n, n + 2));
     return i ? (e.H = +i[0], n + i[0].length) : -1;
 }
 
 function YG(e, t, n) {
-    var i = Vt.exec(t.slice(n, n + 2));
+    var i = Yt.exec(t.slice(n, n + 2));
     return i ? (e.M = +i[0], n + i[0].length) : -1;
 }
 
 function XG(e, t, n) {
-    var i = Vt.exec(t.slice(n, n + 2));
+    var i = Yt.exec(t.slice(n, n + 2));
     return i ? (e.S = +i[0], n + i[0].length) : -1;
 }
 
 function KG(e, t, n) {
-    var i = Vt.exec(t.slice(n, n + 3));
+    var i = Yt.exec(t.slice(n, n + 3));
     return i ? (e.L = +i[0], n + i[0].length) : -1;
 }
 
 function JG(e, t, n) {
-    var i = Vt.exec(t.slice(n, n + 6));
+    var i = Yt.exec(t.slice(n, n + 6));
     return i ? (e.L = Math.floor(i[0] / 1e3), n + i[0].length) : -1;
 }
 
 function QG(e, t, n) {
     var i = LG.exec(t.slice(n, n + 1));
     return i ? n + i[0].length : -1;
 }
 
 function ZG(e, t, n) {
-    var i = Vt.exec(t.slice(n));
+    var i = Yt.exec(t.slice(n));
     return i ? (e.Q = +i[0], n + i[0].length) : -1;
 }
 
 function eV(e, t, n) {
-    var i = Vt.exec(t.slice(n));
+    var i = Yt.exec(t.slice(n));
     return i ? (e.s = +i[0], n + i[0].length) : -1;
 }
 
 function gA(e, t) {
     return je(e.getDate(), t, 2);
 }
 
@@ -6511,15 +6498,15 @@
 }
 
 function nV(e, t) {
     return je(e.getHours() % 12 || 12, t, 2);
 }
 
 function iV(e, t) {
-    return je(1 + Cr.count(Qi(e), e), t, 3);
+    return je(1 + $r.count(Qi(e), e), t, 3);
 }
 
 function cT(e, t) {
     return je(e.getMilliseconds(), t, 3);
 }
 
 function rV(e, t) {
@@ -6632,19 +6619,19 @@
 }
 
 function hT(e) {
     var t = e.getUTCDay();
     return t >= 4 || t === 0 ? Lu(e) : Lu.ceil(e);
 }
 
-function $V(e, t) {
+function CV(e, t) {
     return e = hT(e), je(Lu.count(Zi(e), e) + (Zi(e).getUTCDay() === 4), t, 2);
 }
 
-function CV(e) {
+function $V(e) {
     return e.getUTCDay();
 }
 
 function MV(e, t) {
     return je(fh.count(Zi(e) - 1, e), t, 2);
 }
 
@@ -6796,41 +6783,41 @@
 }
 
 function Dm(e) {
     return arguments.length ? V2 = bT(e) : V2;
 }
 
 function vA(e, t, n) {
-    n = n || {}, re(n) || q(`Invalid time multi-format specifier: ${n}`);
+    n = n || {}, oe(n) || W(`Invalid time multi-format specifier: ${n}`);
     const i = t(er),
         r = t(Mi),
-        s = t(Ci),
+        s = t($i),
         o = t(ui),
-        a = t(Tt),
-        u = t(wn),
+        a = t(Ft),
+        u = t(_n),
         l = t(ai),
-        c = t(tn),
+        c = t(nn),
         f = e(n[Nr] || ".%L"),
         d = e(n[er] || ":%S"),
         h = e(n[Mi] || "%I:%M"),
-        g = e(n[Ci] || "%I %p"),
-        p = e(n[ui] || n[fn] || "%a %d"),
-        m = e(n[Tt] || "%b %d"),
-        y = e(n[wn] || "%B"),
+        g = e(n[$i] || "%I %p"),
+        p = e(n[ui] || n[dn] || "%a %d"),
+        m = e(n[Ft] || "%b %d"),
+        y = e(n[_n] || "%B"),
         b = e(n[ai] || "%B"),
-        v = e(n[tn] || "%Y");
+        v = e(n[nn] || "%Y");
     return (x) => (i(x) < x ? f : r(x) < x ? d : s(x) < x ? h : o(x) < x ? g : u(x) < x ? a(x) < x ? p : m : c(x) < x ? l(x) < x ? y : b : v)(x);
 }
 
 function vT(e) {
     const t = Ed(e.format),
         n = Ed(e.utcFormat);
     return {
-        timeFormat: (i) => ie(i) ? t(i) : vA(t, bf, i),
-        utcFormat: (i) => ie(i) ? n(i) : vA(n, vf, i),
+        timeFormat: (i) => se(i) ? t(i) : vA(t, bf, i),
+        utcFormat: (i) => se(i) ? n(i) : vA(n, vf, i),
         timeParse: Ed(e.parse),
         utcParse: Ed(e.utcParse)
     };
 }
 let Y2;
 xT();
 
@@ -6846,25 +6833,25 @@
 function wT(e) {
     return vT(lT(e));
 }
 
 function dh(e) {
     return arguments.length ? Y2 = wT(e) : Y2;
 }
-const X2 = (e, t) => Ce({}, e, t);
+const X2 = (e, t) => $e({}, e, t);
 
 function _T(e, t) {
     const n = e ? bT(e) : Dm(),
         i = t ? wT(t) : dh();
     return X2(n, i);
 }
 
 function P_(e, t) {
     const n = arguments.length;
-    return n && n !== 2 && q("defaultLocale expects either zero or two arguments."), n ? X2(Dm(e), dh(t)) : X2(Dm(), dh());
+    return n && n !== 2 && W("defaultLocale expects either zero or two arguments."), n ? X2(Dm(e), dh(t)) : X2(Dm(), dh());
 }
 
 function PV() {
     return yT(), xT(), P_();
 }
 const zV = /^(data:|([A-Za-z]+:)?\/\/)/,
     BV = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i,
@@ -6883,62 +6870,62 @@
 }
 async function qV(e, t) {
     const n = await this.sanitize(e, t),
         i = n.href;
     return n.localFile ? this.file(i) : this.http(i, t);
 }
 async function WV(e, t) {
-    t = Ce({}, this.options, t);
+    t = $e({}, this.options, t);
     const n = this.fileAccess,
         i = {
             href: null
         };
     let r, s, o;
     const a = BV.test(e.replace(UV, ""));
-    (e == null || typeof e != "string" || !a) && q("Sanitize failure, invalid URI: " + Z(e));
+    (e == null || typeof e != "string" || !a) && W("Sanitize failure, invalid URI: " + ee(e));
     const u = zV.test(e);
     return (o = t.baseURL) && !u && (!e.startsWith("/") && !o.endsWith("/") && (e = "/" + e), e = o + e), s = (r = e.startsWith(xA)) || t.mode === "file" || t.mode !== "http" && !u && n, r ? e = e.slice(xA.length) : e.startsWith("//") && (t.defaultProtocol === "file" ? (e = e.slice(2), s = !0) : e = (t.defaultProtocol || "http") + ":" + e), Object.defineProperty(i, "localFile", {
         value: !!s
     }), i.href = e, t.target && (i.target = t.target + ""), t.rel && (i.rel = t.rel + ""), t.context === "image" && t.crossOrigin && (i.crossOrigin = t.crossOrigin + ""), i;
 }
 
 function HV(e) {
     return e ? (t) => new Promise((n, i) => {
         e.readFile(t, (r, s) => {
             r ? i(r) : n(s);
         });
     }) : GV;
 }
 async function GV() {
-    q("No file system access.");
+    W("No file system access.");
 }
 
 function VV(e) {
     return e ? async function(t, n) {
-        const i = Ce({}, this.options.http, n),
+        const i = $e({}, this.options.http, n),
             r = n && n.response,
             s = await e(t, i);
-        return s.ok ? Me(s[r]) ? s[r]() : s.text() : q(s.status + "" + s.statusText);
+        return s.ok ? Me(s[r]) ? s[r]() : s.text() : W(s.status + "" + s.statusText);
     }: YV;
 }
 async function YV() {
-    q("No HTTP fetch method available.");
+    W("No HTTP fetch method available.");
 }
 const XV = (e) => e != null && e === e,
     KV = (e) => e === "true" || e === "false" || e === !0 || e === !1,
     JV = (e) => !Number.isNaN(Date.parse(e)),
     ET = (e) => !Number.isNaN(+e) && !(e instanceof Date),
     QV = (e) => ET(e) && Number.isInteger(+e),
     K2 = {
-        boolean: $_,
-        integer: dn,
-        number: dn,
-        date: C_,
+        boolean: C_,
+        integer: hn,
+        number: hn,
+        date: $_,
         string: M_,
-        unknown: Sn
+        unknown: kn
     },
     ep = [KV, QV, ET, JV],
     ZV = ["boolean", "integer", "number", "date"];
 
 function ST(e, t) {
     if (!e || !e.length)
         return "unknown";
@@ -6957,69 +6944,69 @@
 }
 
 function wA(e) {
     const t = function(n, i) {
         const r = {
             delimiter: e
         };
-        return z_(n, i ? Ce(i, r) : r);
+        return z_(n, i ? $e(i, r) : r);
     };
     return t.responseType = "text", t;
 }
 
 function z_(e, t) {
-    return t.header && (e = t.header.map(Z).join(t.delimiter) + `
+    return t.header && (e = t.header.map(ee).join(t.delimiter) + `
 ` + e), RH(t.delimiter).parse(e + "");
 }
 z_.responseType = "text";
 
 function eY(e) {
     return typeof Buffer == "function" && Me(Buffer.isBuffer) ? Buffer.isBuffer(e) : !1;
 }
 
 function B_(e, t) {
-    const n = t && t.property ? Ki(t.property) : Sn;
-    return re(e) && !eY(e) ? tY(n(e), t) : n(JSON.parse(e));
+    const n = t && t.property ? Ki(t.property) : kn;
+    return oe(e) && !eY(e) ? tY(n(e), t) : n(JSON.parse(e));
 }
 B_.responseType = "json";
 
 function tY(e, t) {
-    return !W(e) && oM(e) && (e = [...e]), t && t.copy ? JSON.parse(JSON.stringify(e)) : e;
+    return !V(e) && oM(e) && (e = [...e]), t && t.copy ? JSON.parse(JSON.stringify(e)) : e;
 }
 const nY = {
     interior: (e, t) => e !== t,
     exterior: (e, t) => e === t
 };
 
 function AT(e, t) {
     let n, i, r, s;
-    return e = B_(e, t), t && t.feature ? (n = zH, r = t.feature) : t && t.mesh ? (n = UH, r = t.mesh, s = nY[t.filter]) : q("Missing TopoJSON feature or mesh parameter."), i = (i = e.objects[r]) ? n(e, i, s) : q("Invalid TopoJSON object: " + r), i && i.features || [i];
+    return e = B_(e, t), t && t.feature ? (n = zH, r = t.feature) : t && t.mesh ? (n = UH, r = t.mesh, s = nY[t.filter]) : W("Missing TopoJSON feature or mesh parameter."), i = (i = e.objects[r]) ? n(e, i, s) : W("Invalid TopoJSON object: " + r), i && i.features || [i];
 }
 AT.responseType = "json";
 const Kp = {
     dsv: z_,
     csv: wA(","),
     tsv: wA("	"),
     json: B_,
     topojson: AT
 };
 
 function U_(e, t) {
-    return arguments.length > 1 ? (Kp[e] = t, this) : be(Kp, e) ? Kp[e] : null;
+    return arguments.length > 1 ? (Kp[e] = t, this) : xe(Kp, e) ? Kp[e] : null;
 }
 
-function $T(e) {
+function CT(e) {
     const t = U_(e);
     return t && t.responseType || "text";
 }
 
-function CT(e, t, n, i) {
+function $T(e, t, n, i) {
     t = t || {};
     const r = U_(t.type || "json");
-    return r || q("Unknown data format type: " + t.type), e = r(e, t), t.parse && iY(e, t.parse, n, i), be(e, "columns") && delete e.columns, e;
+    return r || W("Unknown data format type: " + t.type), e = r(e, t), t.parse && iY(e, t.parse, n, i), xe(e, "columns") && delete e.columns, e;
 }
 
 function iY(e, t, n, i) {
     if (!e.length)
         return;
     const r = dh();
     n = n || r.timeParse, i = i || r.utcParse;
@@ -7043,15 +7030,15 @@
     typeof fetch < "u" && fetch,
     // use built-in fetch API
     null
     // no file system access
 );
 
 function x1(e) {
-    const t = e || Sn,
+    const t = e || kn,
         n = [],
         i = {};
     return n.add = (r) => {
         const s = t(r);
         return i[s] || (i[s] = 1, n.push(r)), n;
     }, n.remove = (r) => {
         const s = t(r);
@@ -7070,48 +7057,48 @@
         e.error(n);
     }
 }
 const MT = Symbol("vega_id");
 let rY = 1;
 
 function w1(e) {
-    return !!(e && me(e));
+    return !!(e && be(e));
 }
 
-function me(e) {
+function be(e) {
     return e[MT];
 }
 
 function TT(e, t) {
     return e[MT] = t, e;
 }
 
 function Ge(e) {
     const t = e === Object(e) ? e : {
         data: e
     };
-    return me(t) ? t : TT(t, rY++);
+    return be(t) ? t : TT(t, rY++);
 }
 
 function j_(e) {
     return _1(e, Ge({}));
 }
 
 function _1(e, t) {
     for (const n in e)
         t[n] = e[n];
     return t;
 }
 
 function FT(e, t) {
-    return TT(t, me(e));
+    return TT(t, be(e));
 }
 
 function pl(e, t) {
-    return e ? t ? (n, i) => e(n, i) || me(t(n)) - me(t(i)) : (n, i) => e(n, i) || me(n) - me(i) : null;
+    return e ? t ? (n, i) => e(n, i) || be(t(n)) - be(t(i)) : (n, i) => e(n, i) || be(n) - be(i) : null;
 }
 
 function NT(e) {
     return e && e.constructor === ml;
 }
 
 function ml() {
@@ -7121,32 +7108,32 @@
         i = [],
         r = [];
     let s = null,
         o = !1;
     return {
         constructor: ml,
         insert(a) {
-            const u = ne(a),
+            const u = re(a),
                 l = u.length;
             for (let c = 0; c < l; ++c)
                 e.push(u[c]);
             return this;
         },
         remove(a) {
             const u = Me(a) ? i : t,
-                l = ne(a),
+                l = re(a),
                 c = l.length;
             for (let f = 0; f < c; ++f)
                 u.push(l[f]);
             return this;
         },
         modify(a, u, l) {
             const c = {
                 field: u,
-                value: kn(l)
+                value: An(l)
             };
             return Me(a) ? (c.filter = a, r.push(c)) : (c.tuple = a, n.push(c)), this;
         },
         encode(a, u) {
             return Me(a) ? r.push({
                 filter: a,
                 field: u
@@ -7162,37 +7149,37 @@
             return o = !0, this;
         },
         pulse(a, u) {
             const l = {},
                 c = {};
             let f, d, h, g, p, m;
             for (f = 0, d = u.length; f < d; ++f)
-                l[me(u[f])] = 1;
+                l[be(u[f])] = 1;
             for (f = 0, d = t.length; f < d; ++f)
-                p = t[f], l[me(p)] = -1;
+                p = t[f], l[be(p)] = -1;
             for (f = 0, d = i.length; f < d; ++f)
                 g = i[f], u.forEach((b) => {
-                    g(b) && (l[me(b)] = -1);
+                    g(b) && (l[be(b)] = -1);
                 });
             for (f = 0, d = e.length; f < d; ++f)
-                p = e[f], m = me(p), l[m] ? l[m] = 1 : a.add.push(Ge(e[f]));
+                p = e[f], m = be(p), l[m] ? l[m] = 1 : a.add.push(Ge(e[f]));
             for (f = 0, d = u.length; f < d; ++f)
-                p = u[f], l[me(p)] < 0 && a.rem.push(p);
+                p = u[f], l[be(p)] < 0 && a.rem.push(p);
 
             function y(b, v, x) {
-                x ? b[v] = x(b) : a.encode = v, o || (c[me(b)] = b);
+                x ? b[v] = x(b) : a.encode = v, o || (c[be(b)] = b);
             }
             for (f = 0, d = n.length; f < d; ++f)
-                h = n[f], p = h.tuple, g = h.field, m = l[me(p)], m > 0 && (y(p, g, h.value), a.modifies(g));
+                h = n[f], p = h.tuple, g = h.field, m = l[be(p)], m > 0 && (y(p, g, h.value), a.modifies(g));
             for (f = 0, d = r.length; f < d; ++f)
                 h = r[f], g = h.filter, u.forEach((b) => {
-                    g(b) && l[me(b)] > 0 && y(b, h.field, h.value);
+                    g(b) && l[be(b)] > 0 && y(b, h.field, h.value);
                 }), a.modifies(h.field);
             if (o)
-                a.mod = t.length || i.length ? u.filter((b) => l[me(b)] > 0) : u.slice();
+                a.mod = t.length || i.length ? u.filter((b) => l[be(b)] > 0) : u.slice();
             else
                 for (m in c)
                     a.mod.push(c[m]);
             return (s || s == null && (t.length || i.length)) && a.clean(!0), a;
         }
     };
 }
@@ -7216,30 +7203,30 @@
      *   even if the value is unchanged.
      * @return {Parameters} - This parameter object.
      */
     set(e, t, n, i) {
         const r = this,
             s = r[e],
             o = r[Qp];
-        return t != null && t >= 0 ? (s[t] !== n || i) && (s[t] = n, o[t + ":" + e] = -1, o[e] = -1) : (s !== n || i) && (r[e] = n, o[e] = W(n) ? 1 + n.length : -1), r;
+        return t != null && t >= 0 ? (s[t] !== n || i) && (s[t] = n, o[t + ":" + e] = -1, o[e] = -1) : (s !== n || i) && (r[e] = n, o[e] = V(n) ? 1 + n.length : -1), r;
     },
     /**
      * Tests if one or more parameters has been modified. If invoked with no
      * arguments, returns true if any parameter value has changed. If the first
      * argument is array, returns trues if any parameter name in the array has
      * changed. Otherwise, tests if the given name and optional array index has
      * changed.
      * @param {string} name - The parameter name to test.
      * @param {number} [index=undefined] - The parameter array index to test.
      * @return {boolean} - Returns true if a queried parameter was modified.
      */
     modified(e, t) {
         const n = this[Qp];
         if (arguments.length) {
-            if (W(e)) {
+            if (V(e)) {
                 for (let i = 0; i < e.length; ++i)
                     if (n[e[i]])
                         return !0;
                 return !1;
             }
         } else {
             for (const i in n)
@@ -7335,18 +7322,18 @@
                 op: h,
                 name: f,
                 index: d
             })) : i.set(f, d, h);
         };
         for (o in e)
             if (a = e[o], o === oY)
-                ne(a).forEach((f) => {
-                    f instanceof et ? f !== this && (f.targets().add(this), s.push(f)) : q("Pulse parameters must be operator instances.");
+                re(a).forEach((f) => {
+                    f instanceof et ? f !== this && (f.targets().add(this), s.push(f)) : W("Pulse parameters must be operator instances.");
                 }), this.source = a;
-            else if (W(a))
+            else if (V(a))
             for (i.set(o, -1, Array(u = a.length)), l = 0; l < u; ++l)
                 c(o, l, a[l]);
         else
             c(o, -1, a);
         return this.marshall().clear(), n && (r.initonly = !0), s;
     },
     /**
@@ -7443,15 +7430,15 @@
 }
 
 function Lo(e, t, n) {
     return new S1(e, t, n);
 }
 S1.prototype = {
     _filter: Ji,
-    _apply: Sn,
+    _apply: kn,
     targets() {
         return this._targets || (this._targets = x1(Kh));
     },
     consume(e) {
         return arguments.length ? (this._consume = !!e, this) : !!this._consume;
     },
     receive(e) {
@@ -7512,37 +7499,37 @@
             } catch (c) {
                 r.error(c);
             } finally {
                 r.run();
             }
         };
     let a;
-    typeof e == "string" && typeof document < "u" ? a = document.querySelectorAll(e) : a = ne(e);
+    typeof e == "string" && typeof document < "u" ? a = document.querySelectorAll(e) : a = re(e);
     const u = a.length;
     for (let l = 0; l < u; ++l)
         a[l].addEventListener(t, o);
     return s;
 }
 
 function gY(e, t) {
     const n = this.locale();
-    return CT(e, t, n.timeParse, n.utcParse);
+    return $T(e, t, n.timeParse, n.utcParse);
 }
 
 function pY(e, t, n) {
     return t = this.parse(t, n), this.pulse(e, this.changeset().insert(t));
 }
 async function mY(e, t) {
     const n = this;
     let i = 0,
         r;
     try {
         r = await n.loader().load(e, {
             context: "dataflow",
-            response: $T(t && t.type)
+            response: CT(t && t.type)
         });
         try {
             r = n.parse(r, t);
         } catch (s) {
             i = -2, n.warn("Data ingestion failed", e, s);
         }
     } catch (s) {
@@ -7573,17 +7560,17 @@
 };
 
 function xY(e, t, n, i, r) {
     return (e instanceof et ? _Y : wY)(this, e, t, n, i, r), this;
 }
 
 function wY(e, t, n, i, r, s) {
-    const o = Ce({}, s, vY);
+    const o = $e({}, s, vY);
     let a, u;
-    Me(n) || (n = kn(n)), i === void 0 ? a = (l) => e.touch(n(l)) : Me(i) ? (u = new et(null, i, r, !1), a = (l) => {
+    Me(n) || (n = An(n)), i === void 0 ? a = (l) => e.touch(n(l)) : Me(i) ? (u = new et(null, i, r, !1), a = (l) => {
         u.evaluate(l);
         const c = n(l),
             f = u.value;
         NT(f) ? e.pulse(c, f, s) : e.update(c, f, o);
     }) : a = (l) => e.update(n(l), i, o), t.apply(a);
 }
 
@@ -7594,15 +7581,15 @@
         const o = s || {},
             a = new et(null, EY(n, i), r, !1);
         a.modified(o.force), a.rank = t.rank, t.targets().add(a), n && (a.skip(!0), a.value = n.value, a.targets().add(n), e.connect(n, [a]));
     }
 }
 
 function EY(e, t) {
-    return t = Me(t) ? t : kn(t), e ? function(n, i) {
+    return t = Me(t) ? t : An(t), e ? function(n, i) {
         const r = t(n, i);
         return e.skip() || (e.skip(r !== this.value).value = r), r;
     } : t;
 }
 
 function SY(e) {
     e.rank = ++this._rank;
@@ -7610,15 +7597,15 @@
 
 function kY(e) {
     const t = [e];
     let n, i, r;
     for (; t.length;)
         if (this.rank(n = t.pop()), i = n._targets)
             for (r = i.length; --r >= 0;)
-                t.push(n = i[r]), n === e && q("Cycle detected in dataflow graph.");
+                t.push(n = i[r]), n === e && W("Cycle detected in dataflow graph.");
 }
 const Rm = {},
     Jr = 1,
     Bo = 2,
     Ys = 4,
     AY = Jr | Bo,
     EA = Jr | Ys,
@@ -7633,19 +7620,19 @@
 }
 
 function Xb(e, t) {
     const n = [];
     return zo(e, t, (i) => n.push(i)), n;
 }
 
-function $A(e, t) {
+function CA(e, t) {
     const n = {};
     return e.visit(t, (i) => {
-        n[me(i)] = 1;
-    }), (i) => n[me(i)] ? null : i;
+        n[be(i)] = 1;
+    }), (i) => n[be(i)] ? null : i;
 }
 
 function tp(e, t) {
     return e ? (n, i) => e(n, i) && t(n, i) : t;
 }
 sa.prototype = {
     /**
@@ -7778,15 +7765,15 @@
      * @return {Pulse} - The reflowed pulse instance.
      */
     reflow(e) {
         if (e)
             return this.fork(Pl).reflow();
         const t = this.add.length,
             n = this.source && this.source.length;
-        return n && n !== t && (this.mod = this.source, t && this.filter(Ys, $A(this, Jr))), this;
+        return n && n !== t && (this.mod = this.source, t && this.filter(Ys, CA(this, Jr))), this;
     },
     /**
      * Get/set metadata to pulse requesting garbage collection
      * to reclaim currently unused resources.
      */
     clean(e) {
         return arguments.length ? (this.cleans = !!e, this) : this.cleans;
@@ -7795,28 +7782,28 @@
      * Marks one or more data field names as modified to assist dependency
      * tracking and incremental processing by transform operators.
      * @param {string|Array<string>} _ - The field(s) to mark as modified.
      * @return {Pulse} - This pulse instance.
      */
     modifies(e) {
         const t = this.fields || (this.fields = {});
-        return W(e) ? e.forEach((n) => t[n] = !0) : t[e] = !0, this;
+        return V(e) ? e.forEach((n) => t[n] = !0) : t[e] = !0, this;
     },
     /**
      * Checks if one or more data fields have been modified during this pulse
      * propagation timestamp.
      * @param {string|Array<string>} _ - The field(s) to check for modified.
      * @param {boolean} nomod - If true, will check the modified flag even if
      *   no mod tuples exist. If false (default), mod tuples must be present.
      * @return {boolean} - Returns true if any of the provided fields has been
      *   marked as modified, false otherwise.
      */
     modified(e, t) {
         const n = this.fields;
-        return (t || this.mod.length) && n ? arguments.length ? W(e) ? e.some((i) => n[i]) : n[e] : !!n : !1;
+        return (t || this.mod.length) && n ? arguments.length ? V(e) ? e.some((i) => n[i]) : n[e] : !!n : !1;
     },
     /**
      * Adds a filter function to one more tuple sets. Filters are applied to
      * backing tuple arrays, to determine the actual set of tuples considered
      * added, removed or modified. They can be used to delay materialization of
      * a tuple set in order to avoid expensive array copies. In addition, the
      * filter functions can serve as value transformers: unlike standard predicate
@@ -7858,15 +7845,15 @@
             i = t;
         if (e & Yf)
             return zo(n.source, n.srcF, i), n;
         e & Jr && zo(n.add, n.addF, i), e & Bo && zo(n.rem, n.remF, i), e & Ys && zo(n.mod, n.modF, i);
         const r = n.source;
         if (e & SA && r) {
             const s = n.add.length + n.mod.length;
-            s === r.length || (s ? zo(r, $A(n, EA), i) : zo(r, n.srcF, i));
+            s === r.length || (s ? zo(r, CA(n, EA), i) : zo(r, n.srcF, i));
         }
         return n;
     }
 };
 
 function q_(e, t, n, i) {
     const r = this;
@@ -7879,15 +7866,15 @@
                 for (const u in o.fields)
                     a[u] = 1;
             }
             o.changed(r.ADD) && (s |= r.ADD), o.changed(r.REM) && (s |= r.REM), o.changed(r.MOD) && (s |= r.MOD);
         }
     this.changes = s;
 }
-Q(q_, sa, {
+Z(q_, sa, {
     /**
      * Creates a new pulse based on the values of this pulse.
      * The dataflow, time stamp and field modification values are copied over.
      * @return {Pulse}
      */
     fork(e) {
         const t = new sa(this.dataflow).init(this, e & this.NO_FIELDS);
@@ -7895,21 +7882,21 @@
     },
     changed(e) {
         return this.changes & e;
     },
     modified(e) {
         const t = this,
             n = t.fields;
-        return n && t.changes & t.MOD ? W(e) ? e.some((i) => n[i]) : n[e] : 0;
+        return n && t.changes & t.MOD ? V(e) ? e.some((i) => n[i]) : n[e] : 0;
     },
     filter() {
-        q("MultiPulse does not support filtering.");
+        W("MultiPulse does not support filtering.");
     },
     materialize() {
-        q("MultiPulse does not support materialization.");
+        W("MultiPulse does not support materialization.");
     },
     visit(e, t) {
         const n = this,
             i = n.pulses,
             r = i.length;
         let s = 0;
         if (e & n.SOURCE)
@@ -7917,15 +7904,15 @@
                 i[s].visit(e, t);
         else
             for (; s < r; ++s)
                 i[s].stamp === n.stamp && i[s].visit(e, t);
         return n;
     }
 });
-async function $Y(e, t, n) {
+async function CY(e, t, n) {
     const i = this,
         r = [];
     if (i._pulse)
         return OT(i);
     if (i._pending && await i._pending, t && await Jp(i, t), !i._touched.length)
         return i.debug("Dataflow invoked, but nothing to do."), i;
     const s = ++i._clock;
@@ -7955,15 +7942,15 @@
                 f(i);
             } catch (d) {
                 i.error(d);
             }
         });
     })), i;
 }
-async function CY(e, t, n) {
+async function $Y(e, t, n) {
     for (; this._running;)
         await this._running;
     const i = () => this._running = null;
     return (this._running = this.evaluate(e, t, n)).then(i, i), this._running;
 }
 
 function MY(e, t, n) {
@@ -7992,15 +7979,15 @@
     const n = e.stamp < this._clock;
     n && (e.stamp = this._clock), (n || t) && (e.qrank = e.rank, this._heap.push(e));
 }
 
 function NY(e, t) {
     const n = e.source,
         i = this._clock;
-    return n && W(n) ? new q_(this, i, n.map((r) => r.pulse), t) : this._input[e.id] || OY(this._pulse, n && n.pulse);
+    return n && V(n) ? new q_(this, i, n.map((r) => r.pulse), t) : this._input[e.id] || OY(this._pulse, n && n.pulse);
 }
 
 function OY(e, t) {
     return t && t.stamp === e.stamp ? t : (e = e.fork(), t && t !== Rm && (e.source = t.source), e);
 }
 const W_ = {
     skip: !1,
@@ -8177,26 +8164,26 @@
     parse: gY,
     preload: yY,
     request: mY,
     // EVENT HANDLING
     events: hY,
     on: xY,
     // PULSE PROPAGATION
-    evaluate: $Y,
+    evaluate: CY,
     run: MY,
-    runAsync: CY,
+    runAsync: $Y,
     runAfter: TY,
     _enqueue: FY,
     _getPulse: NY
 };
 
 function B(e, t) {
     et.call(this, e, null, t);
 }
-Q(B, et, {
+Z(B, et, {
     /**
      * Overrides {@link Operator.evaluate} for transform operators.
      * Internally, this method calls {@link evaluate} to perform processing.
      * If {@link evaluate} returns a falsy value, the input pulse is returned.
      * This method should NOT be overridden, instead overrride {@link evaluate}.
      * @param {Pulse} pulse - the current dataflow pulse.
      * @return the output pulse for this operator (or StopPropagation)
@@ -8225,23 +8212,23 @@
      * @param {Parameters} _ - The operator parameter values.
      * @param {Pulse} pulse - The current dataflow pulse.
      * @return {Pulse} The output pulse (or StopPropagation). A falsy return
      *   value (including undefined) will let the input pulse pass through.
      */
     transform() {}
 });
-const Cc = {};
+const $c = {};
 
 function RT(e) {
     const t = LT(e);
     return t && t.Definition || null;
 }
 
 function LT(e) {
-    return e = e && e.toLowerCase(), be(Cc, e) ? Cc[e] : null;
+    return e = e && e.toLowerCase(), xe($c, e) ? $c[e] : null;
 }
 
 function* IT(e, t) {
     if (t == null)
         for (let n of e)
             n != null && n !== "" && (n = +n) >= n && (yield n);
     else {
@@ -8249,15 +8236,15 @@
         for (let i of e)
             i = t(i, ++n, e), i != null && i !== "" && (i = +i) >= i && (yield i);
     }
 }
 
 function H_(e, t, n) {
     const i = Float64Array.from(IT(e, n));
-    return i.sort(vn), t.map((r) => $M(i, r));
+    return i.sort(xn), t.map((r) => CM(i, r));
 }
 
 function G_(e, t) {
     return H_(e, [0.25, 0.5, 0.75], t);
 }
 
 function V_(e, t) {
@@ -8312,15 +8299,15 @@
         o = t;
     let a, u, l, c;
     for (l = 0, c = Array(o); l < o; ++l) {
         for (a = 0, u = 0; u < s; ++u)
             a += r[~~(tr() * s)];
         c[l] = a / s;
     }
-    return c.sort(vn), [Sc(c, n / 2), Sc(c, 1 - n / 2)];
+    return c.sort(xn), [Sc(c, n / 2), Sc(c, 1 - n / 2)];
 }
 
 function BT(e, t, n, i) {
     i = i || ((d) => d);
     const r = e.length,
         s = new Float64Array(r);
     let o = 0,
@@ -8432,15 +8419,15 @@
         const o = Math.exp(-r * r / 2);
         let a;
         r < 7.07106781186547 ? (a = 0.0352624965998911 * r + 0.700383064443688, a = a * r + 6.37396220353165, a = a * r + 33.912866078383, a = a * r + 112.079291497871, a = a * r + 221.213596169931, a = a * r + 220.206867912376, s = o * a, a = 0.0883883476483184 * r + 1.75566716318264, a = a * r + 16.064177579207, a = a * r + 86.7807322029461, a = a * r + 296.564248779674, a = a * r + 637.333633378831, a = a * r + 793.826512519948, a = a * r + 440.413735824752, s = s / a) : (a = r + 0.65, a = r + 4 / a, a = r + 3 / a, a = r + 2 / a, a = r + 1 / a, s = o / a / 2.506628274631);
     }
     return i > 0 ? 1 - s : s;
 }
 
-function $1(e, t, n) {
+function C1(e, t, n) {
     return e < 0 || e > 1 ? NaN : (t || 0) + (n ?? 1) * qY * WY(2 * e - 1);
 }
 
 function WY(e) {
     let t = -Math.log((1 - e) * (1 + e)),
         n;
     return t < 6.25 ? (t -= 3.125, n = -364441206401782e-35, n = -16850591381820166e-35 + n * t, n = 128584807152564e-32 + n * t, n = 11157877678025181e-33 + n * t, n = -1333171662854621e-31 + n * t, n = 20972767875968562e-33 + n * t, n = 6637638134358324e-30 + n * t, n = -4054566272975207e-29 + n * t, n = -8151934197605472e-29 + n * t, n = 26335093153082323e-28 + n * t, n = -12975133253453532e-27 + n * t, n = -5415412054294628e-26 + n * t, n = 10512122733215323e-25 + n * t, n = -4112633980346984e-24 + n * t, n = -29070369957882005e-24 + n * t, n = 42347877827932404e-23 + n * t, n = -13654692000834679e-22 + n * t, n = -13882523362786469e-21 + n * t, n = 18673420803405714e-20 + n * t, n = -740702534166267e-18 + n * t, n = -0.006033670871430149 + n * t, n = 0.24015818242558962 + n * t, n = 1.6536545626831027 + n * t) : t < 16 ? (t = Math.sqrt(t) - 3.25, n = 22137376921775787e-25, n = 9075656193888539e-23 + n * t, n = -27517406297064545e-23 + n * t, n = 18239629214389228e-24 + n * t, n = 15027403968909828e-22 + n * t, n = -4013867526981546e-21 + n * t, n = 29234449089955446e-22 + n * t, n = 12475304481671779e-21 + n * t, n = -47318229009055734e-21 + n * t, n = 6828485145957318e-20 + n * t, n = 24031110387097894e-21 + n * t, n = -3550375203628475e-19 + n * t, n = 9532893797373805e-19 + n * t, n = -0.0016882755560235047 + n * t, n = 0.002491442096107851 + n * t, n = -0.003751208507569241 + n * t, n = 0.005370914553590064 + n * t, n = 1.0052589676941592 + n * t, n = 3.0838856104922208 + n * t) : Number.isFinite(t) ? (t = Math.sqrt(t) - 5, n = -27109920616438573e-27, n = -2555641816996525e-25 + n * t, n = 15076572693500548e-25 + n * t, n = -3789465440126737e-24 + n * t, n = 761570120807834e-23 + n * t, n = -1496002662714924e-23 + n * t, n = 2914795345090108e-23 + n * t, n = -6771199775845234e-23 + n * t, n = 22900482228026655e-23 + n * t, n = -99298272942317e-20 + n * t, n = 4526062597223154e-21 + n * t, n = -1968177810553167e-20 + n * t, n = 7599527703001776e-20 + n * t, n = -21503011930044477e-20 + n * t, n = -13871931833623122e-20 + n * t, n = 1.0103004648645344 + n * t, n = 4.849906401408584 + n * t) : n = 1 / 0, n * e;
@@ -8454,15 +8441,15 @@
         },
         stdev(s) {
             return arguments.length ? (i = s ?? 1, r) : i;
         },
         sample: () => k1(n, i),
         pdf: (s) => Y_(s, n, i),
         cdf: (s) => A1(s, n, i),
-        icdf: (s) => $1(s, n, i)
+        icdf: (s) => C1(s, n, i)
     };
     return r.mean(e).stdev(t);
 }
 
 function K_(e, t) {
     const n = X_();
     let i = 0;
@@ -8510,15 +8497,15 @@
 }
 
 function Z_(e, t, n) {
     return A1(Math.log(e), t, n);
 }
 
 function eE(e, t, n) {
-    return Math.exp($1(e, t, n));
+    return Math.exp(C1(e, t, n));
 }
 
 function jT(e, t) {
     let n, i;
     const r = {
         mean(s) {
             return arguments.length ? (n = s || 0, r) : n;
@@ -8637,15 +8624,15 @@
 
 function Zh(e, t, n, i) {
     const r = i - e * e,
         s = Math.abs(r) < 1e-24 ? 0 : (n - e * t) / r;
     return [t - s * e, s];
 }
 
-function C1(e, t, n, i) {
+function $1(e, t, n, i) {
     e = e.filter((h) => {
         let g = t(h),
             p = n(h);
         return g != null && (g = +g) >= g && p != null && (p = +p) >= p;
     }), i && e.sort((h, g) => t(h) - t(g));
     const r = e.length,
         s = new Float64Array(r),
@@ -8711,15 +8698,15 @@
         coef: u,
         predict: l,
         rSquared: wf(e, t, n, r, l)
     };
 }
 
 function GT(e, t, n) {
-    const [i, r, s, o] = C1(e, t, n);
+    const [i, r, s, o] = $1(e, t, n);
     let a = 0,
         u = 0,
         l = 0,
         c = 0,
         f = 0,
         d, h, g;
     eg(e, t, n, (b, v) => {
@@ -8751,44 +8738,44 @@
         coef: l,
         predict: c,
         rSquared: wf(e, t, n, a, c)
     };
 }
 
 function aE(e, t, n) {
-    const [i, r, s, o] = C1(e, t, n), a = i.length;
+    const [i, r, s, o] = $1(e, t, n), a = i.length;
     let u = 0,
         l = 0,
         c = 0,
         f = 0,
         d = 0,
         h, g, p, m;
     for (h = 0; h < a;)
         g = i[h], p = r[h++], m = g * g, u += (m - u) / h, l += (m * g - l) / h, c += (m * m - c) / h, f += (g * p - f) / h, d += (m * p - d) / h;
     const y = c - u * u,
         b = u * y - l * l,
         v = (d * u - f * l) / b,
         x = (f * y - d * l) / b,
         w = -v * u,
-        S = (_) => (_ = _ - s, v * _ * _ + x * _ + w + o);
+        E = (_) => (_ = _ - s, v * _ * _ + x * _ + w + o);
     return {
         coef: [w - x * s + v * s * s + o, x - 2 * v * s, v],
-        predict: S,
-        rSquared: wf(e, t, n, o, S)
+        predict: E,
+        rSquared: wf(e, t, n, o, E)
     };
 }
 
 function YT(e, t, n, i) {
     if (i === 0)
         return sE(e, t, n);
     if (i === 1)
         return oE(e, t, n);
     if (i === 2)
         return aE(e, t, n);
-    const [r, s, o, a] = C1(e, t, n), u = r.length, l = [], c = [], f = i + 1;
+    const [r, s, o, a] = $1(e, t, n), u = r.length, l = [], c = [], f = i + 1;
     let d, h, g, p, m;
     for (d = 0; d < f; ++d) {
         for (g = 0, p = 0; g < u; ++g)
             p += Math.pow(r[g], d) * s[g];
         for (l.push(p), m = new Float64Array(f), h = 0; h < f; ++h) {
             for (g = 0, p = 0; g < u; ++g)
                 p += Math.pow(r[g], d + h);
@@ -8839,43 +8826,43 @@
     for (r = t - 1; r >= 0; --r) {
         for (a = 0, s = r + 1; s < t; ++s)
             a += e[s][r] * n[s];
         n[r] = (e[t][r] - a) / e[r][r];
     }
     return n;
 }
-const CA = 2,
+const $A = 2,
     MA = 1e-12;
 
 function XT(e, t, n, i) {
-    const [r, s, o, a] = C1(e, t, n, !0), u = r.length, l = Math.max(2, ~~(i * u)), c = new Float64Array(u), f = new Float64Array(u), d = new Float64Array(u).fill(1);
-    for (let h = -1; ++h <= CA;) {
+    const [r, s, o, a] = $1(e, t, n, !0), u = r.length, l = Math.max(2, ~~(i * u)), c = new Float64Array(u), f = new Float64Array(u), d = new Float64Array(u).fill(1);
+    for (let h = -1; ++h <= $A;) {
         const g = [0, l - 1];
         for (let m = 0; m < u; ++m) {
             const y = r[m],
                 b = g[0],
                 v = g[1],
                 x = y - r[b] > r[v] - y ? b : v;
             let w = 0,
-                S = 0,
+                E = 0,
                 _ = 0,
                 k = 0,
                 A = 0;
-            const F = 1 / Math.abs(r[x] - y || 1);
-            for (let N = b; N <= v; ++N) {
-                const D = r[N],
-                    M = s[N],
-                    E = VY(Math.abs(y - D) * F) * d[N],
-                    $ = D * E;
-                w += E, S += $, _ += M * E, k += M * $, A += D * $;
+            const T = 1 / Math.abs(r[x] - y || 1);
+            for (let F = b; F <= v; ++F) {
+                const O = r[F],
+                    N = s[F],
+                    R = VY(Math.abs(y - O) * T) * d[F],
+                    P = O * R;
+                w += R, E += P, _ += N * R, k += N * P, A += O * P;
             }
-            const [T, I] = Zh(S / w, _ / w, k / w, A / w);
-            c[m] = T + I * y, f[m] = Math.abs(s[m] - c[m]), YY(r, m + 1, g);
+            const [M, L] = Zh(E / w, _ / w, k / w, A / w);
+            c[m] = M + L * y, f[m] = Math.abs(s[m] - c[m]), YY(r, m + 1, g);
         }
-        if (h === CA)
+        if (h === $A)
             break;
         const p = lh(f);
         if (Math.abs(p) < MA)
             break;
         for (let m = 0, y, b; m < u; ++m)
             y = f[m] / (6 * p), d[m] = y >= 1 ? MA : (b = 1 - y * y) * b;
     }
@@ -9141,15 +9128,15 @@
             req: ["exponential"],
             idx: 1
         }
     },
     tg = Object.keys(hh).filter((e) => e !== "__count__");
 
 function tX(e, t) {
-    return (n, i) => Ce({
+    return (n, i) => $e({
         name: e,
         aggregate_param: i,
         out: n || e
     }, eX, t);
 }
 [...tg, "__count__"].forEach((e) => {
     hh[e] = tX(e, hh[e]);
@@ -9195,38 +9182,38 @@
 }
 
 function oX(e) {
     return this._out.forEach((t) => e[t.out] = t.value(this)), e;
 }
 
 function ZT(e, t) {
-    const n = t || Sn,
+    const n = t || kn,
         i = nX(e),
         r = e.slice().sort(QT);
 
     function s(o) {
         this._ops = i, this._out = r, this.cell = o, this.init();
     }
     return s.prototype.init = iX, s.prototype.add = rX, s.prototype.rem = sX, s.prototype.set = oX, s.prototype.get = n, s.fields = e.map((o) => o.out), s;
 }
 
 function uE(e) {
-    this._key = e ? Ki(e) : me, this.reset();
+    this._key = e ? Ki(e) : be, this.reset();
 }
-const sn = uE.prototype;
-sn.reset = function() {
+const on = uE.prototype;
+on.reset = function() {
     this._add = [], this._rem = [], this._ext = null, this._get = null, this._q = null;
 };
-sn.add = function(e) {
+on.add = function(e) {
     this._add.push(e);
 };
-sn.rem = function(e) {
+on.rem = function(e) {
     this._rem.push(e);
 };
-sn.values = function() {
+on.values = function() {
     if (this._get = null, this._rem.length === 0)
         return this._add;
     const e = this._add,
         t = this._rem,
         n = this._key,
         i = e.length,
         r = t.length,
@@ -9235,65 +9222,65 @@
     let a, u, l;
     for (a = 0; a < r; ++a)
         o[n(t[a])] = 1;
     for (a = 0, u = 0; a < i; ++a)
         o[n(l = e[a])] ? o[n(l)] = 0 : s[u++] = l;
     return this._rem = [], this._add = s;
 };
-sn.distinct = function(e) {
+on.distinct = function(e) {
     const t = this.values(),
         n = {};
     let i = t.length,
         r = 0,
         s;
     for (; --i >= 0;)
-        s = e(t[i]) + "", be(n, s) || (n[s] = 1, ++r);
+        s = e(t[i]) + "", xe(n, s) || (n[s] = 1, ++r);
     return r;
 };
-sn.extent = function(e) {
+on.extent = function(e) {
     if (this._get !== e || !this._ext) {
         const t = this.values(),
             n = rM(t, e);
         this._ext = [t[n[0]], t[n[1]]], this._get = e;
     }
     return this._ext;
 };
-sn.argmin = function(e) {
+on.argmin = function(e) {
     return this.extent(e)[0] || {};
 };
-sn.argmax = function(e) {
+on.argmax = function(e) {
     return this.extent(e)[1] || {};
 };
-sn.min = function(e) {
+on.min = function(e) {
     const t = this.extent(e)[0];
     return t != null ? e(t) : void 0;
 };
-sn.max = function(e) {
+on.max = function(e) {
     const t = this.extent(e)[1];
     return t != null ? e(t) : void 0;
 };
-sn.quartile = function(e) {
+on.quartile = function(e) {
     return (this._get !== e || !this._q) && (this._q = G_(this.values(), e), this._get = e), this._q;
 };
-sn.q1 = function(e) {
+on.q1 = function(e) {
     return this.quartile(e)[0];
 };
-sn.q2 = function(e) {
+on.q2 = function(e) {
     return this.quartile(e)[1];
 };
-sn.q3 = function(e) {
+on.q3 = function(e) {
     return this.quartile(e)[2];
 };
-sn.ci = function(e) {
+on.ci = function(e) {
     return (this._get !== e || !this._ci) && (this._ci = zT(this.values(), 1e3, 0.05, e), this._get = e), this._ci;
 };
-sn.ci0 = function(e) {
+on.ci0 = function(e) {
     return this.ci(e)[0];
 };
-sn.ci1 = function(e) {
+on.ci1 = function(e) {
     return this.ci(e)[1];
 };
 
 function pa(e) {
     B.call(this, null, e), this._adds = [], this._mods = [], this._alen = 0, this._mlen = 0, this._drop = !0, this._cross = !1, this._dims = [], this._dnames = [], this._measures = [], this._countOnly = !1, this._counts = null, this._prev = null, this._inputs = null, this._outputs = null;
 }
 pa.Definition = {
@@ -9335,15 +9322,15 @@
         type: "boolean",
         default: !1
     }, {
         name: "key",
         type: "field"
     }]
 };
-Q(pa, B, {
+Z(pa, B, {
     transform(e, t) {
         const n = this,
             i = t.fork(t.NO_SOURCE | t.NO_FIELDS),
             r = e.modified();
         return n.stamp = i.stamp, n.value && (r || t.modified(n._inputs, !0)) ? (n._prev = n.value, n.value = r ? n.init(e) : /* @__PURE__ */ Object.create(null), t.visit(t.SOURCE, (s) => n.add(s))) : (n.value = n.value || n.init(e), t.visit(t.REM, (s) => n.rem(s)), t.visit(t.ADD, (s) => n.add(s))), i.modifies(n._outputs), n._drop = e.drop !== !1, e.cross && n._dims.length > 1 && (n._drop = !1, n.cross()), t.clean() && n._drop && i.clean(!0).runAfter(() => this.clean()), n.changes(i);
     },
     cross() {
@@ -9373,34 +9360,34 @@
     },
     init(e) {
         const t = this._inputs = [],
             n = this._outputs = [],
             i = {};
 
         function r(b) {
-            const v = ne(bn(b)),
+            const v = re(vn(b)),
                 x = v.length;
             let w = 0,
-                S;
+                E;
             for (; w < x; ++w)
-                i[S = v[w]] || (i[S] = 1, t.push(S));
+                i[E = v[w]] || (i[E] = 1, t.push(E));
         }
-        this._dims = ne(e.groupby), this._dnames = this._dims.map((b) => {
-            const v = _t(b);
+        this._dims = re(e.groupby), this._dnames = this._dims.map((b) => {
+            const v = Et(b);
             return r(b), n.push(v), v;
         }), this.cellkey = e.key ? e.key : J2(this._dims), this._countOnly = !0, this._counts = [], this._measures = [];
         const s = e.fields || [null],
             o = e.ops || ["count"],
             a = e.aggregate_params || [null],
             u = e.as || [],
             l = s.length,
             c = {};
         let f, d, h, g, p, m, y;
-        for (l !== o.length && q("Unmatched number of fields and aggregate ops."), y = 0; y < l; ++y) {
-            if (f = s[y], d = o[y], h = a[y] || null, f == null && d !== "count" && q("Null aggregate field specified."), p = _t(f), m = KT(d, p, u[y]), n.push(m), d === "count") {
+        for (l !== o.length && W("Unmatched number of fields and aggregate ops."), y = 0; y < l; ++y) {
+            if (f = s[y], d = o[y], h = a[y] || null, f == null && d !== "count" && W("Null aggregate field specified."), p = Et(f), m = KT(d, p, u[y]), n.push(m), d === "count") {
                 this._counts.push(m);
                 continue;
             }
             g = c[p], g || (r(f), g = c[p] = [], g.field = f, this._measures.push(g)), d !== "count" && (this._countOnly = !1), g.push(JT(d, h, m));
         }
         return this._measures = this._measures.map((b) => ZT(b, b.field)), /* @__PURE__ */ Object.create(null);
     },
@@ -9560,25 +9547,25 @@
         name: "as",
         type: "string",
         array: !0,
         length: 2,
         default: ["bin0", "bin1"]
     }]
 };
-Q(lE, B, {
+Z(lE, B, {
     transform(e, t) {
         const n = e.interval !== !1,
             i = this._bins(e),
             r = i.start,
             s = i.step,
             o = e.as || ["bin0", "bin1"],
             a = o[0],
             u = o[1];
         let l;
-        return e.modified() ? (t = t.reflow(!0), l = t.SOURCE) : l = t.modified(bn(e.field)) ? t.ADD_MOD : t.ADD, t.visit(l, n ? (c) => {
+        return e.modified() ? (t = t.reflow(!0), l = t.SOURCE) : l = t.modified(vn(e.field)) ? t.ADD_MOD : t.ADD, t.visit(l, n ? (c) => {
             const f = i(c);
             c[a] = f, c[u] = f == null ? null : r + s * (1 + (f - r) / s);
         } : (c) => c[a] = i(c)), t.modifies(n ? o : a);
     },
     _bins(e) {
         if (this.value && !e.modified())
             return this.value;
@@ -9586,18 +9573,18 @@
             n = PT(e),
             i = n.step;
         let r = n.start,
             s = r + Math.ceil((n.stop - r) / i) * i,
             o, a;
         (o = e.anchor) != null && (a = o - (r + i * Math.floor((o - r) / i)), r += a, s += a);
         const u = function(l) {
-            let c = dn(t(l));
+            let c = hn(t(l));
             return c == null ? null : c < r ? -1 / 0 : c > s ? 1 / 0 : (c = Math.max(r, Math.min(c, s - i)), r + i * Math.floor(aX + (c - r) / i));
         };
-        return u.start = r, u.stop = n.stop, u.step = i, this.value = hi(u, bn(t), e.name || "bin_" + _t(t));
+        return u.start = r, u.stop = n.stop, u.step = i, this.value = hi(u, vn(t), e.name || "bin_" + Et(t));
     }
 });
 
 function eF(e, t, n) {
     const i = e;
     let r = t || [],
         s = n || [],
@@ -9620,28 +9607,28 @@
         source: !0
     },
     params: [{
         name: "sort",
         type: "compare"
     }]
 };
-Q(cE, B, {
+Z(cE, B, {
     transform(e, t) {
         const n = t.fork(t.ALL),
-            i = eF(me, this.value, n.materialize(n.ADD).add),
+            i = eF(be, this.value, n.materialize(n.ADD).add),
             r = e.sort,
             s = t.changed() || r && (e.modified("sort") || t.modified(r.fields));
         return n.visit(n.REM, i.remove), this.modified(s), this.value = n.source = i.data(pl(r), s), t.source && t.source.root && (this.value.root = t.source.root), n;
     }
 });
 
 function tF(e) {
     et.call(this, null, uX, e);
 }
-Q(tF, et);
+Z(tF, et);
 
 function uX(e) {
     return this.value && !e.modified() ? this.value : S_(e.fields, e.orders);
 }
 
 function fE(e) {
     B.call(this, null, e);
@@ -9685,15 +9672,15 @@
             break;
         case "lower":
             e = e.toLowerCase();
             break;
     }
     return e.match(n);
 }
-Q(fE, B, {
+Z(fE, B, {
     transform(e, t) {
         const n = (f) => (d) => {
                 for (var h = lX(a(d), e.case, s) || [], g, p = 0, m = h.length; p < m; ++p)
                     o.test(g = h[p]) || f(g);
             },
             i = this._parameterCheck(e, t),
             r = this._counts,
@@ -9737,15 +9724,15 @@
         name: "as",
         type: "string",
         array: !0,
         length: 2,
         default: ["a", "b"]
     }]
 };
-Q(dE, B, {
+Z(dE, B, {
     transform(e, t) {
         const n = t.fork(t.NO_SOURCE),
             i = e.as || ["a", "b"],
             r = i[0],
             s = i[1],
             o = !this.value || t.changed(t.ADD_REM) || e.modified("as") || e.modified("filter");
         let a = this.value;
@@ -9768,15 +9755,15 @@
     },
     fX = "distributions",
     FA = "function",
     dX = "field";
 
 function nF(e, t) {
     const n = e[FA];
-    be(TA, n) || q("Unknown distribution function: " + n);
+    xe(TA, n) || W("Unknown distribution function: " + n);
     const i = TA[n]();
     for (const r in e)
         r === dX ? i.data((e.from || t()).map(e[r])) : r === fX ? i[r](e[r].map((s) => nF(s, t))) : typeof i[r] === FA && i[r](e[r]);
     return i;
 }
 
 function hE(e) {
@@ -9886,23 +9873,23 @@
     }, {
         name: "as",
         type: "string",
         array: !0,
         default: ["value", "density"]
     }]
 };
-Q(hE, B, {
+Z(hE, B, {
     transform(e, t) {
         const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
         if (!this.value || t.changed() || e.modified()) {
             const i = nF(e.distribution, gX(t)),
                 r = e.steps || e.minsteps || 25,
                 s = e.steps || e.maxsteps || 200;
             let o = e.method || "pdf";
-            o !== "pdf" && o !== "cdf" && q("Invalid density method: " + o), !e.extent && !i.data && q("Missing density extent parameter."), o = i[o];
+            o !== "pdf" && o !== "cdf" && W("Invalid density method: " + o), !e.extent && !i.data && W("Missing density extent parameter."), o = i[o];
             const a = e.as || ["value", "density"],
                 u = e.extent || hs(i.data()),
                 l = M1(o, u, r, s).map((c) => {
                     const f = {};
                     return f[a[0]] = c[0], f[a[1]] = c[1], Ge(f);
                 });
             this.value && (n.rem = this.value), this.value = n.add = n.source = l;
@@ -9912,15 +9899,15 @@
 });
 
 function gX(e) {
     return () => e.materialize(e.SOURCE).source;
 }
 
 function rF(e, t) {
-    return e ? e.map((n, i) => t[i] || _t(n)) : null;
+    return e ? e.map((n, i) => t[i] || Et(n)) : null;
 }
 
 function gE(e, t, n) {
     const i = [],
         r = (f) => f(u);
     let s, o, a, u, l, c;
     if (t == null)
@@ -9958,20 +9945,20 @@
     }, {
         name: "as",
         type: "string",
         default: sF
     }]
 };
 const pX = (e, t) => Jh(hs(e, t)) / 30;
-Q(pE, B, {
+Z(pE, B, {
     transform(e, t) {
         if (this.value && !(e.modified() || t.changed()))
             return t;
         const n = t.materialize(t.SOURCE).source,
-            i = gE(t.source, e.groupby, Sn),
+            i = gE(t.source, e.groupby, kn),
             r = e.smooth || !1,
             s = e.field,
             o = e.step || pX(n, s),
             a = pl((g, p) => s(g) - s(p)),
             u = e.as || sF,
             l = i.length;
         let c = 1 / 0,
@@ -9991,55 +9978,55 @@
         }, t.reflow(!0).modifies(u);
     }
 });
 
 function oF(e) {
     et.call(this, null, mX, e), this.modified(!0);
 }
-Q(oF, et);
+Z(oF, et);
 
 function mX(e) {
     const t = e.expr;
-    return this.value && !e.modified("expr") ? this.value : hi((n) => t(n, e), bn(t), _t(t));
+    return this.value && !e.modified("expr") ? this.value : hi((n) => t(n, e), vn(t), Et(t));
 }
 
 function mE(e) {
     B.call(this, [void 0, void 0], e);
 }
 mE.Definition = {
     type: "Extent",
     metadata: {},
     params: [{
         name: "field",
         type: "field",
         required: !0
     }]
 };
-Q(mE, B, {
+Z(mE, B, {
     transform(e, t) {
         const n = this.value,
             i = e.field,
             r = t.changed() || t.modified(i.fields) || e.modified("field");
         let s = n[0],
             o = n[1];
         if ((r || s == null) && (s = 1 / 0, o = -1 / 0), t.visit(r ? t.SOURCE : t.ADD, (a) => {
-                const u = dn(i(a));
+                const u = hn(i(a));
                 u != null && (u < s && (s = u), u > o && (o = u));
             }), !Number.isFinite(s) || !Number.isFinite(o)) {
-            let a = _t(i);
+            let a = Et(i);
             a && (a = ` for field "${a}"`), t.dataflow.warn(`Infinite extent${a}: [${s}, ${o}]`), s = o = void 0;
         }
         this.value = [s, o];
     }
 });
 
 function yE(e, t) {
     et.call(this, e), this.parent = t, this.count = 0;
 }
-Q(yE, et, {
+Z(yE, et, {
     /**
      * Routes pulses from this subflow to a target transform.
      * @param {Transform} target - A transform that receives the subflow of tuples.
      */
     connect(e) {
         return this.detachSubflow = e.detachSubflow, this.targets().add(e), e.source = this;
     },
@@ -10086,22 +10073,22 @@
     B.call(this, {}, e), this._keys = hf();
     const t = this._targets = [];
     t.active = 0, t.forEach = (n) => {
         for (let i = 0, r = t.active; i < r; ++i)
             n(t[i], i, t);
     };
 }
-Q(T1, B, {
+Z(T1, B, {
     activate(e) {
         this._targets[this._targets.active++] = e;
     },
     // parent argument provided by PreFacet subclass
     subflow(e, t, n, i) {
         const r = this.value;
-        let s = be(r, e) && r[e],
+        let s = xe(r, e) && r[e],
             o, a;
         return s ? s.value.stamp < n.stamp && (s.init(n), this.activate(s)) : (a = i || (a = this._group[e]) && a.tuple, o = n.dataflow, s = new yE(n.fork(n.NO_SOURCE), this), o.add(s).connect(t(o, e, a)), r[e] = s, this.activate(s)), s;
     },
     clean() {
         const e = this.value;
         let t = 0;
         for (const n in e)
@@ -10129,45 +10116,45 @@
         const n = t.dataflow,
             i = e.key,
             r = e.subflow,
             s = this._keys,
             o = e.modified("key"),
             a = (u) => this.subflow(u, r, t);
         return this._group = e.group || {}, this.initTargets(), t.visit(t.REM, (u) => {
-            const l = me(u),
+            const l = be(u),
                 c = s.get(l);
             c !== void 0 && (s.delete(l), a(c).rem(u));
         }), t.visit(t.ADD, (u) => {
             const l = i(u);
-            s.set(me(u), l), a(l).add(u);
+            s.set(be(u), l), a(l).add(u);
         }), o || t.modified(i.fields) ? t.visit(t.MOD, (u) => {
-            const l = me(u),
+            const l = be(u),
                 c = s.get(l),
                 f = i(u);
             c === f ? a(f).mod(u) : (s.set(l, f), a(c).rem(u), a(f).add(u));
         }) : t.changed(t.MOD) && t.visit(t.MOD, (u) => {
-            a(s.get(me(u))).mod(u);
+            a(s.get(be(u))).mod(u);
         }), o && t.visit(t.REFLOW, (u) => {
-            const l = me(u),
+            const l = be(u),
                 c = s.get(l),
                 f = i(u);
             c !== f && (s.set(l, f), a(c).rem(u), a(f).add(u));
         }), t.clean() ? n.runAfter(() => {
             this.clean(), s.clean();
         }) : s.empty > n.cleanThreshold && n.runAfter(s.clean), t;
     }
 });
 
 function aF(e) {
     et.call(this, null, yX, e);
 }
-Q(aF, et);
+Z(aF, et);
 
 function yX(e) {
-    return this.value && !e.modified() ? this.value : W(e.name) ? ne(e.name).map((t) => Ki(t)) : Ki(e.name, e.as);
+    return this.value && !e.modified() ? this.value : V(e.name) ? re(e.name).map((t) => Ki(t)) : Ki(e.name, e.as);
 }
 
 function bE(e) {
     B.call(this, hf(), e);
 }
 bE.Definition = {
     type: "Filter",
@@ -10176,33 +10163,33 @@
     },
     params: [{
         name: "expr",
         type: "expr",
         required: !0
     }]
 };
-Q(bE, B, {
+Z(bE, B, {
     transform(e, t) {
         const n = t.dataflow,
             i = this.value,
             r = t.fork(),
             s = r.add,
             o = r.rem,
             a = r.mod,
             u = e.expr;
         let l = !0;
         t.visit(t.REM, (f) => {
-            const d = me(f);
+            const d = be(f);
             i.has(d) ? i.delete(d) : o.push(f);
         }), t.visit(t.ADD, (f) => {
-            u(f, e) ? s.push(f) : i.set(me(f), 1);
+            u(f, e) ? s.push(f) : i.set(be(f), 1);
         });
 
         function c(f) {
-            const d = me(f),
+            const d = be(f),
                 h = u(f, e),
                 g = i.get(d);
             h && g ? (i.delete(d), s.push(f)) : !h && !g ? (i.set(d, 1), o.push(f)) : l && h && !g && a.push(f);
         }
         return t.visit(t.MOD, c), e.modified() && (l = !1, t.visit(t.REFLOW, c)), i.empty > n.cleanThreshold && n.runAfter(i.clean), r;
     }
 });
@@ -10225,15 +10212,15 @@
         type: "string"
     }, {
         name: "as",
         type: "string",
         array: !0
     }]
 };
-Q(vE, B, {
+Z(vE, B, {
     transform(e, t) {
         const n = t.fork(t.NO_SOURCE),
             i = e.fields,
             r = rF(i, e.as || []),
             s = e.index || null,
             o = r.length;
         return n.rem = this.value, t.visit(t.SOURCE, (a) => {
@@ -10267,19 +10254,19 @@
         name: "as",
         type: "string",
         array: !0,
         length: 2,
         default: ["key", "value"]
     }]
 };
-Q(xE, B, {
+Z(xE, B, {
     transform(e, t) {
         const n = t.fork(t.NO_SOURCE),
             i = e.fields,
-            r = i.map(_t),
+            r = i.map(Et),
             s = e.as || ["key", "value"],
             o = s[0],
             a = s[1],
             u = i.length;
         return n.rem = this.value, t.visit(t.SOURCE, (l) => {
             for (let c = 0, f; c < u; ++c)
                 f = j_(l), f[o] = r[c], f[a] = i[c](l), n.add.push(f);
@@ -10304,28 +10291,28 @@
         type: "string",
         required: !0
     }, {
         name: "initonly",
         type: "boolean"
     }]
 };
-Q(wE, B, {
+Z(wE, B, {
     transform(e, t) {
         const n = e.expr,
             i = e.as,
             r = e.modified(),
             s = e.initonly ? t.ADD : r ? t.SOURCE : t.modified(n.fields) || t.modified(i) ? t.ADD_MOD : t.ADD;
         return r && (t = t.materialize().reflow(!0)), e.initonly || t.modifies(i), t.visit(s, (o) => o[i] = n(o, e));
     }
 });
 
 function uF(e) {
     B.call(this, [], e);
 }
-Q(uF, B, {
+Z(uF, B, {
     transform(e, t) {
         const n = t.fork(t.ALL),
             i = e.generator;
         let r = this.value,
             s = e.size - r.length,
             o, a, u;
         if (s > 0) {
@@ -10336,17 +10323,17 @@
             a = r.slice(0, -s), n.rem = n.rem.length ? n.materialize(n.REM).rem.concat(a) : a, r = r.slice(-s);
         return n.source = this.value = r, n;
     }
 });
 const np = {
         value: "value",
         median: lh,
-        mean: CM,
+        mean: $M,
         min: gs,
-        max: xn
+        max: wn
     },
     bX = [];
 
 function _E(e) {
     B.call(this, [], e);
 }
 _E.Definition = {
@@ -10380,31 +10367,31 @@
     }]
 };
 
 function vX(e) {
     var t = e.method || np.value,
         n;
     if (np[t] == null)
-        q("Unrecognized imputation method: " + t);
+        W("Unrecognized imputation method: " + t);
     else
         return t === np.value ? (n = e.value !== void 0 ? e.value : 0, () => n) : np[t];
 }
 
 function xX(e) {
     const t = e.field;
     return (n) => n ? t(n) : NaN;
 }
-Q(_E, B, {
+Z(_E, B, {
     transform(e, t) {
         var n = t.fork(t.ALL),
             i = vX(e),
             r = xX(e),
-            s = _t(e.field),
-            o = _t(e.key),
-            a = (e.groupby || []).map(_t),
+            s = Et(e.field),
+            o = Et(e.key),
+            a = (e.groupby || []).map(Et),
             u = wX(t.source, e.groupby, e.key, e.keyvals),
             l = [],
             c = this.value,
             f = u.domain.length,
             d, h, g, p, m, y, b, v, x, w;
         for (m = 0, v = u.length; m < v; ++m)
             for (d = u[m], g = d.values, h = NaN, b = 0; b < f; ++b)
@@ -10459,21 +10446,21 @@
         null: !0,
         array: !0
     }, {
         name: "key",
         type: "field"
     }]
 };
-Q(EE, pa, {
+Z(EE, pa, {
     transform(e, t) {
         const n = this,
             i = e.modified();
         let r;
         return n.value && (i || t.modified(n._inputs, !0)) ? (r = n.value = i ? n.init(e) : {}, t.visit(t.SOURCE, (s) => n.add(s))) : (r = n.value = n.value || this.init(e), t.visit(t.REM, (s) => n.rem(s)), t.visit(t.ADD, (s) => n.add(s))), n.changes(), t.visit(t.SOURCE, (s) => {
-            Ce(s, r[n.cellkey(s)].tuple);
+            $e(s, r[n.cellkey(s)].tuple);
         }), t.reflow(i).modifies(this._outputs);
     },
     changes() {
         const e = this._adds,
             t = this._mods;
         let n, i;
         for (n = 0, i = this._alen; n < i; ++n)
@@ -10536,29 +10523,29 @@
     }, {
         name: "as",
         type: "string",
         array: !0,
         default: ["value", "density"]
     }]
 };
-Q(SE, B, {
+Z(SE, B, {
     transform(e, t) {
         const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
         if (!this.value || t.changed() || e.modified()) {
             const i = t.materialize(t.SOURCE).source,
                 r = gE(i, e.groupby, e.field),
-                s = (e.groupby || []).map(_t),
+                s = (e.groupby || []).map(Et),
                 o = e.bandwidth,
                 a = e.cumulative ? "cdf" : "pdf",
                 u = e.as || ["value", "density"],
                 l = [];
             let c = e.extent,
                 f = e.steps || e.minsteps || 25,
                 d = e.steps || e.maxsteps || 200;
-            a !== "pdf" && a !== "cdf" && q("Invalid density method: " + a), e.resolve === "shared" && (c || (c = hs(i, e.field)), f = d = e.steps || d), r.forEach((h) => {
+            a !== "pdf" && a !== "cdf" && W("Invalid density method: " + a), e.resolve === "shared" && (c || (c = hs(i, e.field)), f = d = e.steps || d), r.forEach((h) => {
                 const g = K_(h, o)[a],
                     p = e.counts ? h.length : 1,
                     m = c || hs(h);
                 M1(g, m, f, d).forEach((y) => {
                     const b = {};
                     for (let v = 0; v < s.length; ++v)
                         b[s[v]] = h.dims[v];
@@ -10569,29 +10556,29 @@
         return n;
     }
 });
 
 function lF(e) {
     et.call(this, null, _X, e);
 }
-Q(lF, et);
+Z(lF, et);
 
 function _X(e) {
     return this.value && !e.modified() ? this.value : A_(e.fields, e.flat);
 }
 
 function cF(e) {
     B.call(this, [], e), this._pending = null;
 }
-Q(cF, B, {
+Z(cF, B, {
     transform(e, t) {
         const n = t.dataflow;
         return this._pending ? Jb(this, t, this._pending) : EX(e) ? t.StopPropagation : e.values ? Jb(this, t, n.parse(e.values, e.format)) : e.async ? {
-            async: n.request(e.url, e.format).then((r) => (this._pending = ne(r.data), (s) => s.touch(this)))
-        } : n.request(e.url, e.format).then((i) => Jb(this, t, ne(i.data)));
+            async: n.request(e.url, e.format).then((r) => (this._pending = re(r.data), (s) => s.touch(this)))
+        } : n.request(e.url, e.format).then((i) => Jb(this, t, re(i.data)));
     }
 });
 
 function EX(e) {
     return e.modified("async") && !(e.modified("values") || e.modified("url") || e.modified("format"));
 }
 
@@ -10635,45 +10622,45 @@
         type: "string",
         array: !0
     }, {
         name: "default",
         default: null
     }]
 };
-Q(kE, B, {
+Z(kE, B, {
     transform(e, t) {
         const n = e.fields,
             i = e.index,
             r = e.values,
             s = e.default == null ? null : e.default,
             o = e.modified(),
             a = n.length;
         let u = o ? t.SOURCE : t.ADD,
             l = t,
             c = e.as,
             f, d, h;
-        return r ? (d = r.length, a > 1 && !c && q('Multi-field lookup requires explicit "as" parameter.'), c && c.length !== a * d && q('The "as" parameter has too few output field names.'), c = c || r.map(_t), f = function(g) {
+        return r ? (d = r.length, a > 1 && !c && W('Multi-field lookup requires explicit "as" parameter.'), c && c.length !== a * d && W('The "as" parameter has too few output field names.'), c = c || r.map(Et), f = function(g) {
             for (var p = 0, m = 0, y, b; p < a; ++p)
                 if (b = i.get(n[p](g)), b == null)
                     for (y = 0; y < d; ++y, ++m)
                         g[c[m]] = s;
                 else
                     for (y = 0; y < d; ++y, ++m)
                         g[c[m]] = r[y](b);
-        }) : (c || q("Missing output field names."), f = function(g) {
+        }) : (c || W("Missing output field names."), f = function(g) {
             for (var p = 0, m; p < a; ++p)
                 m = i.get(n[p](g)), g[c[p]] = m ?? s;
         }), o ? l = t.reflow(!0) : (h = n.some((g) => t.modified(g.fields)), u |= h ? t.MOD : 0), t.visit(u, f), l.modifies(c);
     }
 });
 
 function fF(e) {
     et.call(this, null, SX, e);
 }
-Q(fF, et);
+Z(fF, et);
 
 function SX(e) {
     if (this.value && !e.modified())
         return this.value;
     const t = e.extents,
         n = t.length;
     let i = 1 / 0,
@@ -10683,24 +10670,24 @@
         o = t[s], o[0] < i && (i = o[0]), o[1] > r && (r = o[1]);
     return [i, r];
 }
 
 function dF(e) {
     et.call(this, null, kX, e);
 }
-Q(dF, et);
+Z(dF, et);
 
 function kX(e) {
     return this.value && !e.modified() ? this.value : e.values.reduce((t, n) => t.concat(n), []);
 }
 
 function hF(e) {
     B.call(this, null, e);
 }
-Q(hF, B, {
+Z(hF, B, {
     transform(e, t) {
         return this.modified(e.modified()), this.value = e, t.fork(t.NO_SOURCE | t.NO_FIELDS);
     }
 });
 
 function AE(e) {
     pa.call(this, e);
@@ -10733,75 +10720,75 @@
         type: "number",
         default: 0
     }, {
         name: "key",
         type: "field"
     }]
 };
-Q(AE, pa, {
+Z(AE, pa, {
     _transform: pa.prototype.transform,
     transform(e, t) {
         return this._transform(AX(e, t), t);
     }
 });
 
 function AX(e, t) {
     const n = e.field,
         i = e.value,
         r = (e.op === "count" ? "__count__" : e.op) || "sum",
-        s = bn(n).concat(bn(i)),
-        o = CX(n, e.limit || 0, t);
+        s = vn(n).concat(vn(i)),
+        o = $X(n, e.limit || 0, t);
     return t.changed() && e.set("__pivot__", null, null, !0), {
         key: e.key,
         groupby: e.groupby,
         ops: o.map(() => r),
-        fields: o.map((a) => $X(a, n, i, s)),
+        fields: o.map((a) => CX(a, n, i, s)),
         as: o.map((a) => a + ""),
         modified: e.modified.bind(e)
     };
 }
 
-function $X(e, t, n, i) {
+function CX(e, t, n, i) {
     return hi((r) => t(r) === e ? n(r) : NaN, i, e + "");
 }
 
-function CX(e, t, n) {
+function $X(e, t, n) {
     const i = {},
         r = [];
     return n.visit(n.SOURCE, (s) => {
         const o = e(s);
         i[o] || (i[o] = 1, r.push(o));
     }), r.sort(p1), t ? r.slice(0, t) : r;
 }
 
 function gF(e) {
     T1.call(this, e);
 }
-Q(gF, T1, {
+Z(gF, T1, {
     transform(e, t) {
         const n = e.subflow,
             i = e.field,
-            r = (s) => this.subflow(me(s), n, t, s);
-        return (e.modified("field") || i && t.modified(bn(i))) && q("PreFacet does not support field modification."), this.initTargets(), i ? (t.visit(t.MOD, (s) => {
+            r = (s) => this.subflow(be(s), n, t, s);
+        return (e.modified("field") || i && t.modified(vn(i))) && W("PreFacet does not support field modification."), this.initTargets(), i ? (t.visit(t.MOD, (s) => {
             const o = r(s);
             i(s).forEach((a) => o.mod(a));
         }), t.visit(t.ADD, (s) => {
             const o = r(s);
             i(s).forEach((a) => o.add(Ge(a)));
         }), t.visit(t.REM, (s) => {
             const o = r(s);
             i(s).forEach((a) => o.rem(a));
         })) : (t.visit(t.MOD, (s) => r(s).mod(s)), t.visit(t.ADD, (s) => r(s).add(s)), t.visit(t.REM, (s) => r(s).rem(s))), t.clean() && t.runAfter(() => this.clean()), t;
     }
 });
 
-function $E(e) {
+function CE(e) {
     B.call(this, null, e);
 }
-$E.Definition = {
+CE.Definition = {
     type: "Project",
     metadata: {
         generates: !0,
         changes: !0
     },
     params: [{
         name: "fields",
@@ -10810,52 +10797,52 @@
     }, {
         name: "as",
         type: "string",
         null: !0,
         array: !0
     }]
 };
-Q($E, B, {
+Z(CE, B, {
     transform(e, t) {
         const n = t.fork(t.NO_SOURCE),
             i = e.fields,
             r = rF(e.fields, e.as || []),
             s = i ? (a, u) => MX(a, u, i, r) : _1;
         let o;
         return this.value ? o = this.value : (t = t.addAll(), o = this.value = {}), t.visit(t.REM, (a) => {
-            const u = me(a);
+            const u = be(a);
             n.rem.push(o[u]), o[u] = null;
         }), t.visit(t.ADD, (a) => {
             const u = s(a, Ge({}));
-            o[me(a)] = u, n.add.push(u);
+            o[be(a)] = u, n.add.push(u);
         }), t.visit(t.MOD, (a) => {
-            n.mod.push(s(a, o[me(a)]));
+            n.mod.push(s(a, o[be(a)]));
         }), n;
     }
 });
 
 function MX(e, t, n, i) {
     for (let r = 0, s = n.length; r < s; ++r)
         t[i[r]] = n[r](e);
     return t;
 }
 
 function pF(e) {
     B.call(this, null, e);
 }
-Q(pF, B, {
+Z(pF, B, {
     transform(e, t) {
         return this.value = e.value, e.modified("value") ? t.fork(t.NO_SOURCE | t.NO_FIELDS) : t.StopPropagation;
     }
 });
 
-function CE(e) {
+function $E(e) {
     B.call(this, null, e);
 }
-CE.Definition = {
+$E.Definition = {
     type: "Quantile",
     metadata: {
         generates: !0,
         changes: !0
     },
     params: [{
         name: "groupby",
@@ -10877,26 +10864,26 @@
         name: "as",
         type: "string",
         array: !0,
         default: ["prob", "value"]
     }]
 };
 const TX = 1e-14;
-Q(CE, B, {
+Z($E, B, {
     transform(e, t) {
         const n = t.fork(t.NO_SOURCE | t.NO_FIELDS),
             i = e.as || ["prob", "value"];
         if (this.value && !e.modified() && !t.changed())
             return n.source = this.value, n;
         const r = t.materialize(t.SOURCE).source,
             s = gE(r, e.groupby, e.field),
-            o = (e.groupby || []).map(_t),
+            o = (e.groupby || []).map(Et),
             a = [],
             u = e.step || 0.01,
-            l = e.probs || hn(u / 2, 1 - TX, u),
+            l = e.probs || gn(u / 2, 1 - TX, u),
             c = l.length;
         return s.forEach((f) => {
             const d = H_(f, l);
             for (let h = 0; h < c; ++h) {
                 const g = {};
                 for (let p = 0; p < o.length; ++p)
                     g[o[p]] = f.dims[p];
@@ -10905,25 +10892,25 @@
         }), this.value && (n.rem = this.value), this.value = n.add = n.source = a, n;
     }
 });
 
 function mF(e) {
     B.call(this, null, e);
 }
-Q(mF, B, {
+Z(mF, B, {
     transform(e, t) {
         let n, i;
         return this.value ? i = this.value : (n = t = t.addAll(), i = this.value = {}), e.derive && (n = t.fork(t.NO_SOURCE), t.visit(t.REM, (r) => {
-            const s = me(r);
+            const s = be(r);
             n.rem.push(i[s]), i[s] = null;
         }), t.visit(t.ADD, (r) => {
             const s = j_(r);
-            i[me(r)] = s, n.add.push(s);
+            i[be(r)] = s, n.add.push(s);
         }), t.visit(t.MOD, (r) => {
-            const s = i[me(r)];
+            const s = i[be(r)];
             for (const o in r)
                 s[o] = r[o], n.modifies(o);
             n.mod.push(s);
         })), n;
     }
 });
 
@@ -10935,42 +10922,42 @@
     metadata: {},
     params: [{
         name: "size",
         type: "number",
         default: 1e3
     }]
 };
-Q(ME, B, {
+Z(ME, B, {
     transform(e, t) {
         const n = t.fork(t.NO_SOURCE),
             i = e.modified("size"),
             r = e.size,
-            s = this.value.reduce((c, f) => (c[me(f)] = 1, c), {});
+            s = this.value.reduce((c, f) => (c[be(f)] = 1, c), {});
         let o = this.value,
             a = this.count,
             u = 0;
 
         function l(c) {
             let f, d;
-            o.length < r ? o.push(c) : (d = ~~((a + 1) * tr()), d < o.length && d >= u && (f = o[d], s[me(f)] && n.rem.push(f), o[d] = c)), ++a;
+            o.length < r ? o.push(c) : (d = ~~((a + 1) * tr()), d < o.length && d >= u && (f = o[d], s[be(f)] && n.rem.push(f), o[d] = c)), ++a;
         }
         if (t.rem.length && (t.visit(t.REM, (c) => {
-                const f = me(c);
+                const f = be(c);
                 s[f] && (s[f] = -1, n.rem.push(c)), --a;
-            }), o = o.filter((c) => s[me(c)] !== -1)), (t.rem.length || i) && o.length < r && t.source && (u = a = o.length, t.visit(t.SOURCE, (c) => {
-                s[me(c)] || l(c);
+            }), o = o.filter((c) => s[be(c)] !== -1)), (t.rem.length || i) && o.length < r && t.source && (u = a = o.length, t.visit(t.SOURCE, (c) => {
+                s[be(c)] || l(c);
             }), u = -1), i && o.length > r) {
             const c = o.length - r;
             for (let f = 0; f < c; ++f)
-                s[me(o[f])] = -1, n.rem.push(o[f]);
+                s[be(o[f])] = -1, n.rem.push(o[f]);
             o = o.slice(c);
         }
         return t.mod.length && t.visit(t.MOD, (c) => {
-            s[me(c)] && n.mod.push(c);
-        }), t.add.length && t.visit(t.ADD, l), (t.add.length || u < 0) && (n.add = o.filter((c) => !s[me(c)])), this.count = a, this.value = n.source = o, n;
+            s[be(c)] && n.mod.push(c);
+        }), t.add.length && t.visit(t.ADD, l), (t.add.length || u < 0) && (n.add = o.filter((c) => !s[be(c)])), this.count = a, this.value = n.source = o, n;
     }
 });
 
 function TE(e) {
     B.call(this, null, e);
 }
 TE.Definition = {
@@ -10993,31 +10980,31 @@
         default: 1
     }, {
         name: "as",
         type: "string",
         default: "data"
     }]
 };
-Q(TE, B, {
+Z(TE, B, {
     transform(e, t) {
         if (this.value && !e.modified())
             return;
         const n = t.materialize().fork(t.MOD),
             i = e.as || "data";
-        return n.rem = this.value ? t.rem.concat(this.value) : t.rem, this.value = hn(e.start, e.stop, e.step || 1).map((r) => {
+        return n.rem = this.value ? t.rem.concat(this.value) : t.rem, this.value = gn(e.start, e.stop, e.step || 1).map((r) => {
             const s = {};
             return s[i] = r, Ge(s);
         }), n.add = t.add.concat(this.value), n;
     }
 });
 
 function yF(e) {
     B.call(this, null, e), this.modified(!0);
 }
-Q(yF, B, {
+Z(yF, B, {
     transform(e, t) {
         return this.value = t.source, t.changed() ? t.fork(t.NO_SOURCE | t.NO_FIELDS) : t.StopPropagation;
     }
 });
 
 function FE(e) {
     B.call(this, null, e);
@@ -11062,29 +11049,29 @@
         name: "as",
         type: "string",
         array: !0,
         length: 2,
         default: bF
     }]
 };
-Q(FE, B, {
+Z(FE, B, {
     transform(e, t) {
         const n = e.field,
             i = e.interval !== !1,
             r = e.timezone === "utc",
             s = this._floor(e, t),
             o = (r ? vf : bf)(s.unit).offset,
             a = e.as || bF,
             u = a[0],
             l = a[1],
             c = s.step;
         let f = s.start || 1 / 0,
             d = s.stop || -1 / 0,
             h = t.ADD;
-        return (e.modified() || t.changed(t.REM) || t.modified(bn(n))) && (t = t.reflow(!0), h = t.SOURCE, f = 1 / 0, d = -1 / 0), t.visit(h, (g) => {
+        return (e.modified() || t.changed(t.REM) || t.modified(vn(n))) && (t = t.reflow(!0), h = t.SOURCE, f = 1 / 0, d = -1 / 0), t.visit(h, (g) => {
             const p = n(g);
             let m, y;
             p == null ? (g[u] = null, i && (g[l] = null)) : (g[u] = m = y = s(p), i && (g[l] = y = o(m, c)), m < f && (f = m), y > d && (d = y));
         }), s.start = f, s.stop = d, t.modifies(i ? a : u);
     },
     _floor(e, t) {
         const n = e.timezone === "utc",
@@ -11104,29 +11091,29 @@
         return a.unit = Ie(s), a.units = s, a.step = r, a.start = o.start, a.stop = o.stop, this.value = a;
     }
 });
 
 function vF(e) {
     B.call(this, hf(), e);
 }
-Q(vF, B, {
+Z(vF, B, {
     transform(e, t) {
         const n = t.dataflow,
             i = e.field,
             r = this.value,
             s = (a) => r.set(i(a), a);
         let o = !0;
         return e.modified("field") || t.modified(i.fields) ? (r.clear(), t.visit(t.SOURCE, s)) : t.changed() ? (t.visit(t.REM, (a) => r.delete(i(a))), t.visit(t.ADD, s)) : o = !1, this.modified(o), r.empty > n.cleanThreshold && n.runAfter(r.clean), t.fork();
     }
 });
 
 function xF(e) {
     B.call(this, null, e);
 }
-Q(xF, B, {
+Z(xF, B, {
     transform(e, t) {
         (!this.value || e.modified("field") || e.modified("sort") || t.changed() || e.sort && t.modified(e.sort.fields)) && (this.value = (e.sort ? t.source.slice().sort(pl(e.sort)) : t.source).map(e.field));
     }
 });
 
 function FX(e, t, n, i) {
     const r = gh[e](t, n);
@@ -11187,15 +11174,15 @@
                     e = r;
                 }
                 return (1 + e) / n.length;
             }
         };
     },
     ntile: function(e, t) {
-        t = +t, t > 0 || q("ntile num must be greater than zero.");
+        t = +t, t > 0 || W("ntile num must be greater than zero.");
         const n = gh.cume_dist(),
             i = n.next;
         return {
             init: n.init,
             next: (r) => Math.ceil(t * i(r))
         };
     },
@@ -11223,15 +11210,15 @@
     },
     last_value: function(e) {
         return {
             next: (t) => e(t.data[t.i1 - 1])
         };
     },
     nth_value: function(e, t) {
-        return t = +t, t > 0 || q("nth_value nth must be greater than zero."), {
+        return t = +t, t > 0 || W("nth_value nth must be greater than zero."), {
             next: (n) => {
                 const i = n.i0 + (t - 1);
                 return i < n.i1 ? e(n.data[i]) : null;
             }
         };
     },
     prev_value: function(e) {
@@ -11261,40 +11248,40 @@
         if (e(t[n]) != null)
             return n;
     return -1;
 }
 const OX = Object.keys(gh);
 
 function wF(e) {
-    const t = ne(e.ops),
-        n = ne(e.fields),
-        i = ne(e.params),
-        r = ne(e.aggregate_params),
-        s = ne(e.as),
+    const t = re(e.ops),
+        n = re(e.fields),
+        i = re(e.params),
+        r = re(e.aggregate_params),
+        s = re(e.as),
         o = this.outputs = [],
         a = this.windows = [],
         u = {},
         l = {},
         c = [],
         f = [];
     let d = !0;
 
     function h(g) {
-        ne(bn(g)).forEach((p) => u[p] = 1);
+        re(vn(g)).forEach((p) => u[p] = 1);
     }
     h(e.sort), t.forEach((g, p) => {
         const m = n[p],
             y = i[p],
             b = r[p] || null,
-            v = _t(m),
+            v = Et(m),
             x = KT(g, v, s[p]);
-        if (h(m), o.push(x), be(gh, g))
+        if (h(m), o.push(x), xe(gh, g))
             a.push(FX(g, m, y, x));
         else {
-            if (m == null && g !== "count" && q("Null aggregate field specified."), g === "count") {
+            if (m == null && g !== "count" && W("Null aggregate field specified."), g === "count") {
                 c.push(x);
                 return;
             }
             d = !1;
             let w = l[v];
             w || (w = l[v] = [], w.field = m, f.push(w)), w.push(JT(g, b, x));
         }
@@ -11409,30 +11396,30 @@
         default: [null, 0]
     }, {
         name: "ignorePeers",
         type: "boolean",
         default: !1
     }]
 };
-Q(NE, B, {
+Z(NE, B, {
     transform(e, t) {
         this.stamp = t.stamp;
         const n = e.modified(),
             i = pl(e.sort),
             r = J2(e.groupby),
             s = (a) => this.group(r(a));
         let o = this.state;
         (!o || n) && (o = this.state = new wF(e)), n || t.modified(o.inputs) ? (this.value = {}, t.visit(t.SOURCE, (a) => s(a).add(a))) : (t.visit(t.REM, (a) => s(a).remove(a)), t.visit(t.ADD, (a) => s(a).add(a)));
         for (let a = 0, u = this._mlen; a < u; ++a)
             RX(this._mods[a], o, i, e);
         return this._mlen = 0, this._mods = [], t.reflow(n).modifies(o.outputs);
     },
     group(e) {
         let t = this.value[e];
-        return t || (t = this.value[e] = eF(me), t.stamp = -1), t.stamp < this.stamp && (t.stamp = this.stamp, this._mods[this._mlen++] = t), t;
+        return t || (t = this.value[e] = eF(be), t.stamp = -1), t.stamp < this.stamp && (t.stamp = this.stamp, this._mods[this._mlen++] = t), t;
     }
 });
 
 function RX(e, t, n, i) {
     const r = i.sort,
         s = r && !i.ignorePeers,
         o = i.frame || [null, 0],
@@ -11442,15 +11429,15 @@
         c = {
             i0: 0,
             i1: 0,
             p0: 0,
             p1: 0,
             index: 0,
             data: a,
-            compare: r || kn(-1)
+            compare: r || An(-1)
         };
     t.init();
     for (let f = 0; f < u; ++f)
         LX(c, o, f, u), s && IX(c, l), t.update(c, a[f]);
 }
 
 function LX(e, t, n, i) {
@@ -11491,17 +11478,17 @@
     load: cF,
     lookup: kE,
     multiextent: fF,
     multivalues: dF,
     params: hF,
     pivot: AE,
     prefacet: gF,
-    project: $E,
+    project: CE,
     proxy: pF,
-    quantile: CE,
+    quantile: $E,
     relay: mF,
     sample: ME,
     sequence: TE,
     sieve: yF,
     subflow: yE,
     timeunit: FE,
     tupleindex: vF,
@@ -11513,21 +11500,21 @@
 
 function Ye(e) {
     return function() {
         return e;
     };
 }
 const NA = Math.abs,
-    on = Math.atan2,
+    an = Math.atan2,
     Xs = Math.cos,
     zX = Math.max,
     dc = Math.min,
     Kn = Math.sin,
-    ut = Math.sqrt,
-    un = 1e-12,
+    lt = Math.sqrt,
+    ln = 1e-12,
     ma = Math.PI,
     Lm = ma / 2,
     ng = 2 * ma;
 
 function BX(e) {
     return e > 1 ? 0 : e < -1 ? ma : Math.acos(e);
 }
@@ -11674,45 +11661,45 @@
 
 function YX(e, t, n, i, r, s, o, a) {
     var u = n - e,
         l = i - t,
         c = o - r,
         f = a - s,
         d = f * u - c * l;
-    if (!(d * d < un))
+    if (!(d * d < ln))
         return d = (c * (t - s) - f * (e - r)) / d, [e + d * u, t + d * l];
 }
 
 function ip(e, t, n, i, r, s, o) {
     var a = e - n,
         u = t - i,
-        l = (o ? s : -s) / ut(a * a + u * u),
+        l = (o ? s : -s) / lt(a * a + u * u),
         c = l * u,
         f = -l * a,
         d = e + c,
         h = t + f,
         g = n + c,
         p = i + f,
         m = (d + g) / 2,
         y = (h + p) / 2,
         b = g - d,
         v = p - h,
         x = b * b + v * v,
         w = r - s,
-        S = d * p - g * h,
-        _ = (v < 0 ? -1 : 1) * ut(zX(0, w * w * x - S * S)),
-        k = (S * v - b * _) / x,
-        A = (-S * b - v * _) / x,
-        F = (S * v + b * _) / x,
-        T = (-S * b + v * _) / x,
-        I = k - m,
-        N = A - y,
-        D = F - m,
-        M = T - y;
-    return I * I + N * N > D * D + M * M && (k = F, A = T), {
+        E = d * p - g * h,
+        _ = (v < 0 ? -1 : 1) * lt(zX(0, w * w * x - E * E)),
+        k = (E * v - b * _) / x,
+        A = (-E * b - v * _) / x,
+        T = (E * v + b * _) / x,
+        M = (-E * b + v * _) / x,
+        L = k - m,
+        F = A - y,
+        O = T - m,
+        N = M - y;
+    return L * L + F * F > O * O + N * N && (k = T, A = M), {
         cx: k,
         cy: A,
         x01: -c,
         y01: -f,
         x11: k * (r / w - 1),
         y11: A * (r / w - 1)
     };
@@ -11732,59 +11719,59 @@
     function l() {
         var c, f, d = +e.apply(this, arguments),
             h = +t.apply(this, arguments),
             g = r.apply(this, arguments) - Lm,
             p = s.apply(this, arguments) - Lm,
             m = NA(p - g),
             y = p > g;
-        if (a || (a = c = u()), h < d && (f = h, h = d, d = f), !(h > un))
+        if (a || (a = c = u()), h < d && (f = h, h = d, d = f), !(h > ln))
             a.moveTo(0, 0);
-        else if (m > ng - un)
-            a.moveTo(h * Xs(g), h * Kn(g)), a.arc(0, 0, h, g, p, !y), d > un && (a.moveTo(d * Xs(p), d * Kn(p)), a.arc(0, 0, d, p, g, y));
+        else if (m > ng - ln)
+            a.moveTo(h * Xs(g), h * Kn(g)), a.arc(0, 0, h, g, p, !y), d > ln && (a.moveTo(d * Xs(p), d * Kn(p)), a.arc(0, 0, d, p, g, y));
         else {
             var b = g,
                 v = p,
                 x = g,
                 w = p,
-                S = m,
+                E = m,
                 _ = m,
                 k = o.apply(this, arguments) / 2,
-                A = k > un && (i ? +i.apply(this, arguments) : ut(d * d + h * h)),
-                F = dc(NA(h - d) / 2, +n.apply(this, arguments)),
-                T = F,
-                I = F,
-                N, D;
-            if (A > un) {
-                var M = OA(A / d * Kn(k)),
-                    E = OA(A / h * Kn(k));
-                (S -= M * 2) > un ? (M *= y ? 1 : -1, x += M, w -= M) : (S = 0, x = w = (g + p) / 2), (_ -= E * 2) > un ? (E *= y ? 1 : -1, b += E, v -= E) : (_ = 0, b = v = (g + p) / 2);
-            }
-            var $ = h * Xs(b),
-                C = h * Kn(b),
-                O = d * Xs(w),
-                R = d * Kn(w);
-            if (F > un) {
-                var L = h * Xs(v),
-                    P = h * Kn(v),
+                A = k > ln && (i ? +i.apply(this, arguments) : lt(d * d + h * h)),
+                T = dc(NA(h - d) / 2, +n.apply(this, arguments)),
+                M = T,
+                L = T,
+                F, O;
+            if (A > ln) {
+                var N = OA(A / d * Kn(k)),
+                    R = OA(A / h * Kn(k));
+                (E -= N * 2) > ln ? (N *= y ? 1 : -1, x += N, w -= N) : (E = 0, x = w = (g + p) / 2), (_ -= R * 2) > ln ? (R *= y ? 1 : -1, b += R, v -= R) : (_ = 0, b = v = (g + p) / 2);
+            }
+            var P = h * Xs(b),
+                S = h * Kn(b),
+                $ = d * Xs(w),
+                C = d * Kn(w);
+            if (T > ln) {
+                var D = h * Xs(v),
+                    I = h * Kn(v),
                     z = d * Xs(x),
-                    V = d * Kn(x),
-                    X;
+                    H = d * Kn(x),
+                    G;
                 if (m < ma)
-                    if (X = YX($, C, z, V, L, P, O, R)) {
-                        var se = $ - X[0],
-                            ee = C - X[1],
-                            ue = L - X[0],
-                            G = P - X[1],
-                            ae = 1 / Kn(BX((se * ue + ee * G) / (ut(se * se + ee * ee) * ut(ue * ue + G * G))) / 2),
-                            ce = ut(X[0] * X[0] + X[1] * X[1]);
-                        T = dc(F, (d - ce) / (ae - 1)), I = dc(F, (h - ce) / (ae + 1));
+                    if (G = YX(P, S, z, H, D, I, $, C)) {
+                        var te = P - G[0],
+                            K = S - G[1],
+                            ae = D - G[0],
+                            U = I - G[1],
+                            ie = 1 / Kn(BX((te * ae + K * U) / (lt(te * te + K * K) * lt(ae * ae + U * U))) / 2),
+                            le = lt(G[0] * G[0] + G[1] * G[1]);
+                        M = dc(T, (d - le) / (ie - 1)), L = dc(T, (h - le) / (ie + 1));
                     } else
-                        T = I = 0;
+                        M = L = 0;
             }
-            _ > un ? I > un ? (N = ip(z, V, $, C, h, I, y), D = ip(L, P, O, R, h, I, y), a.moveTo(N.cx + N.x01, N.cy + N.y01), I < F ? a.arc(N.cx, N.cy, I, on(N.y01, N.x01), on(D.y01, D.x01), !y) : (a.arc(N.cx, N.cy, I, on(N.y01, N.x01), on(N.y11, N.x11), !y), a.arc(0, 0, h, on(N.cy + N.y11, N.cx + N.x11), on(D.cy + D.y11, D.cx + D.x11), !y), a.arc(D.cx, D.cy, I, on(D.y11, D.x11), on(D.y01, D.x01), !y))) : (a.moveTo($, C), a.arc(0, 0, h, b, v, !y)) : a.moveTo($, C), !(d > un) || !(S > un) ? a.lineTo(O, R) : T > un ? (N = ip(O, R, L, P, d, -T, y), D = ip($, C, z, V, d, -T, y), a.lineTo(N.cx + N.x01, N.cy + N.y01), T < F ? a.arc(N.cx, N.cy, T, on(N.y01, N.x01), on(D.y01, D.x01), !y) : (a.arc(N.cx, N.cy, T, on(N.y01, N.x01), on(N.y11, N.x11), !y), a.arc(0, 0, d, on(N.cy + N.y11, N.cx + N.x11), on(D.cy + D.y11, D.cx + D.x11), y), a.arc(D.cx, D.cy, T, on(D.y11, D.x11), on(D.y01, D.x01), !y))) : a.arc(0, 0, d, w, x, y);
+            _ > ln ? L > ln ? (F = ip(z, H, P, S, h, L, y), O = ip(D, I, $, C, h, L, y), a.moveTo(F.cx + F.x01, F.cy + F.y01), L < T ? a.arc(F.cx, F.cy, L, an(F.y01, F.x01), an(O.y01, O.x01), !y) : (a.arc(F.cx, F.cy, L, an(F.y01, F.x01), an(F.y11, F.x11), !y), a.arc(0, 0, h, an(F.cy + F.y11, F.cx + F.x11), an(O.cy + O.y11, O.cx + O.x11), !y), a.arc(O.cx, O.cy, L, an(O.y11, O.x11), an(O.y01, O.x01), !y))) : (a.moveTo(P, S), a.arc(0, 0, h, b, v, !y)) : a.moveTo(P, S), !(d > ln) || !(E > ln) ? a.lineTo($, C) : M > ln ? (F = ip($, C, D, I, d, -M, y), O = ip(P, S, z, H, d, -M, y), a.lineTo(F.cx + F.x01, F.cy + F.y01), M < T ? a.arc(F.cx, F.cy, M, an(F.y01, F.x01), an(O.y01, O.x01), !y) : (a.arc(F.cx, F.cy, M, an(F.y01, F.x01), an(F.y11, F.x11), !y), a.arc(0, 0, d, an(F.cy + F.y11, F.cx + F.x11), an(O.cy + O.y11, O.cx + O.x11), y), a.arc(O.cx, O.cy, M, an(O.y11, O.x11), an(O.y01, O.x01), !y))) : a.arc(0, 0, d, w, x, y);
         }
         if (a.closePath(), c)
             return a = null, c + "" || null;
     }
     return l.centroid = function() {
         var c = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2,
             f = (+r.apply(this, arguments) + +s.apply(this, arguments)) / 2 - ma / 2;
@@ -11846,25 +11833,25 @@
     return new kF(e);
 }
 
 function AF(e) {
     return e[0];
 }
 
-function $F(e) {
+function CF(e) {
     return e[1];
 }
 
-function CF(e, t) {
+function $F(e, t) {
     var n = Ye(!0),
         i = null,
         r = OE,
         s = null,
         o = O1(a);
-    e = typeof e == "function" ? e : e === void 0 ? AF : Ye(e), t = typeof t == "function" ? t : t === void 0 ? $F : Ye(t);
+    e = typeof e == "function" ? e : e === void 0 ? AF : Ye(e), t = typeof t == "function" ? t : t === void 0 ? CF : Ye(t);
 
     function a(u) {
         var l, c = (u = SF(u)).length,
             f, d = !1,
             h;
         for (i == null && (s = r(h = o())), l = 0; l <= c; ++l)
             !(l < c && n(f = u[l], l, u)) === d && ((d = !d) ? s.lineStart() : s.lineEnd()), d && s.point(+e(f, l, u), +t(f, l, u));
@@ -11887,15 +11874,15 @@
 function MF(e, t, n) {
     var i = null,
         r = Ye(!0),
         s = null,
         o = OE,
         a = null,
         u = O1(l);
-    e = typeof e == "function" ? e : e === void 0 ? AF : Ye(+e), t = typeof t == "function" ? t : Ye(t === void 0 ? 0 : +t), n = typeof n == "function" ? n : n === void 0 ? $F : Ye(+n);
+    e = typeof e == "function" ? e : e === void 0 ? AF : Ye(+e), t = typeof t == "function" ? t : Ye(t === void 0 ? 0 : +t), n = typeof n == "function" ? n : n === void 0 ? CF : Ye(+n);
 
     function l(f) {
         var d, h, g, p = (f = SF(f)).length,
             m, y = !1,
             b, v = new Array(p),
             x = new Array(p);
         for (s == null && (a = o(b = u())), d = 0; d <= p; ++d) {
@@ -11910,15 +11897,15 @@
             y && (v[d] = +e(m, d, f), x[d] = +t(m, d, f), a.point(i ? +i(m, d, f) : v[d], n ? +n(m, d, f) : x[d]));
         }
         if (b)
             return a = null, b + "" || null;
     }
 
     function c() {
-        return CF().defined(r).curve(o).context(s);
+        return $F().defined(r).curve(o).context(s);
     }
     return l.x = function(f) {
         return arguments.length ? (e = typeof f == "function" ? f : Ye(+f), i = null, l) : e;
     }, l.x0 = function(f) {
         return arguments.length ? (e = typeof f == "function" ? f : Ye(+f), l) : e;
     }, l.x1 = function(f) {
         return arguments.length ? (i = f == null ? null : typeof f == "function" ? f : Ye(+f), l) : i;
@@ -11938,123 +11925,123 @@
         return arguments.length ? (r = typeof f == "function" ? f : Ye(!!f), l) : r;
     }, l.curve = function(f) {
         return arguments.length ? (o = f, s != null && (a = o(s)), l) : o;
     }, l.context = function(f) {
         return arguments.length ? (f == null ? s = a = null : a = o(s = f), l) : s;
     }, l;
 }
-const KX = ut(3),
+const KX = lt(3),
     TF = {
         draw(e, t) {
-            const n = ut(t + dc(t / 28, 0.75)) * 0.59436,
+            const n = lt(t + dc(t / 28, 0.75)) * 0.59436,
                 i = n / 2,
                 r = i * KX;
             e.moveTo(0, n), e.lineTo(0, -n), e.moveTo(-r, -i), e.lineTo(r, i), e.moveTo(-r, i), e.lineTo(r, -i);
         }
     },
     D1 = {
         draw(e, t) {
-            const n = ut(t / ma);
+            const n = lt(t / ma);
             e.moveTo(n, 0), e.arc(0, 0, n, 0, ng);
         }
     },
     FF = {
         draw(e, t) {
-            const n = ut(t / 5) / 2;
+            const n = lt(t / 5) / 2;
             e.moveTo(-3 * n, -n), e.lineTo(-n, -n), e.lineTo(-n, -3 * n), e.lineTo(n, -3 * n), e.lineTo(n, -n), e.lineTo(3 * n, -n), e.lineTo(3 * n, n), e.lineTo(n, n), e.lineTo(n, 3 * n), e.lineTo(-n, 3 * n), e.lineTo(-n, n), e.lineTo(-3 * n, n), e.closePath();
         }
     },
-    NF = ut(1 / 3),
+    NF = lt(1 / 3),
     JX = NF * 2,
     OF = {
         draw(e, t) {
-            const n = ut(t / JX),
+            const n = lt(t / JX),
                 i = n * NF;
             e.moveTo(0, -n), e.lineTo(i, 0), e.lineTo(0, n), e.lineTo(-i, 0), e.closePath();
         }
     },
     DF = {
         draw(e, t) {
-            const n = ut(t) * 0.62625;
+            const n = lt(t) * 0.62625;
             e.moveTo(0, -n), e.lineTo(n, 0), e.lineTo(0, n), e.lineTo(-n, 0), e.closePath();
         }
     },
     RF = {
         draw(e, t) {
-            const n = ut(t - dc(t / 7, 2)) * 0.87559;
+            const n = lt(t - dc(t / 7, 2)) * 0.87559;
             e.moveTo(-n, 0), e.lineTo(n, 0), e.moveTo(0, n), e.lineTo(0, -n);
         }
     },
     LF = {
         draw(e, t) {
-            const n = ut(t),
+            const n = lt(t),
                 i = -n / 2;
             e.rect(i, i, n, n);
         }
     },
     IF = {
         draw(e, t) {
-            const n = ut(t) * 0.4431;
+            const n = lt(t) * 0.4431;
             e.moveTo(n, n), e.lineTo(n, -n), e.lineTo(-n, -n), e.lineTo(-n, n), e.closePath();
         }
     },
     QX = 0.8908130915292852,
     PF = Kn(ma / 10) / Kn(7 * ma / 10),
     ZX = Kn(ng / 10) * PF,
     eK = -Xs(ng / 10) * PF,
     zF = {
         draw(e, t) {
-            const n = ut(t * QX),
+            const n = lt(t * QX),
                 i = ZX * n,
                 r = eK * n;
             e.moveTo(0, -n), e.lineTo(i, r);
             for (let s = 1; s < 5; ++s) {
                 const o = ng * s / 5,
                     a = Xs(o),
                     u = Kn(o);
                 e.lineTo(u * n, -a * n), e.lineTo(a * i - u * r, u * i + a * r);
             }
             e.closePath();
         }
     },
-    Qb = ut(3),
+    Qb = lt(3),
     BF = {
         draw(e, t) {
-            const n = -ut(t / (Qb * 3));
+            const n = -lt(t / (Qb * 3));
             e.moveTo(0, n * 2), e.lineTo(-Qb * n, -n), e.lineTo(Qb * n, -n), e.closePath();
         }
     },
-    tK = ut(3),
+    tK = lt(3),
     UF = {
         draw(e, t) {
-            const n = ut(t) * 0.6824,
+            const n = lt(t) * 0.6824,
                 i = n / 2,
                 r = n * tK / 2;
             e.moveTo(0, -n), e.lineTo(r, i), e.lineTo(-r, i), e.closePath();
         }
     },
     Li = -0.5,
-    Ii = ut(3) / 2,
-    tx = 1 / ut(12),
+    Ii = lt(3) / 2,
+    tx = 1 / lt(12),
     nK = (tx / 2 + 1) * 3,
     jF = {
         draw(e, t) {
-            const n = ut(t / nK),
+            const n = lt(t / nK),
                 i = n / 2,
                 r = n * tx,
                 s = i,
                 o = n * tx + n,
                 a = -s,
                 u = o;
             e.moveTo(i, r), e.lineTo(s, o), e.lineTo(a, u), e.lineTo(Li * i - Ii * r, Ii * i + Li * r), e.lineTo(Li * s - Ii * o, Ii * s + Li * o), e.lineTo(Li * a - Ii * u, Ii * a + Li * u), e.lineTo(Li * i + Ii * r, Li * r - Ii * i), e.lineTo(Li * s + Ii * o, Li * o - Ii * s), e.lineTo(Li * a + Ii * u, Li * u - Ii * a), e.closePath();
         }
     },
     qF = {
         draw(e, t) {
-            const n = ut(t - dc(t / 6, 1.7)) * 0.6189;
+            const n = lt(t - dc(t / 6, 1.7)) * 0.6189;
             e.moveTo(-n, -n), e.lineTo(n, n), e.moveTo(-n, n), e.lineTo(n, -n);
         }
     },
     iK = [
         D1,
         FF,
         OF,
@@ -12433,20 +12420,20 @@
 }(0);
 
 function IE(e, t, n) {
     var i = e._x1,
         r = e._y1,
         s = e._x2,
         o = e._y2;
-    if (e._l01_a > un) {
+    if (e._l01_a > ln) {
         var a = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a,
             u = 3 * e._l01_a * (e._l01_a + e._l12_a);
         i = (i * a - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / u, r = (r * a - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / u;
     }
-    if (e._l23_a > un) {
+    if (e._l23_a > ln) {
         var l = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a,
             c = 3 * e._l23_a * (e._l23_a + e._l12_a);
         s = (s * l + e._x1 * e._l23_2a - t * e._l12_2a) / c, o = (o * l + e._y1 * e._l23_2a - n * e._l12_2a) / c;
     }
     e._context.bezierCurveTo(i, r, s, o, e._x2, e._y2);
 }
 
@@ -12924,15 +12911,15 @@
 
     function f() {
         var d = t().length,
             h = r < i,
             g = h ? r : i,
             p = h ? i : r;
         s = (p - g) / Math.max(1, d - u + l * 2), a && (s = Math.floor(s)), g += (p - g - s * (d - u)) * c, o = s * (1 - u), a && (g = Math.round(g), o = Math.round(o));
-        var m = hn(d).map(function(y) {
+        var m = gn(d).map(function(y) {
             return g + s * y;
         });
         return n(h ? m.reverse() : m);
     }
     return e.domain = function(d) {
         return arguments.length ? (t(d), f()) : t();
     }, e.range = function(d) {
@@ -12984,16 +12971,16 @@
 var zu = 0.7,
     Mc = 1 / zu,
     hc = "\\s*([+-]?\\d+)\\s*",
     ph = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
     os = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
     kK = /^#([0-9a-f]{3,8})$/,
     AK = new RegExp(`^rgb\\(${hc},${hc},${hc}\\)$`),
-    $K = new RegExp(`^rgb\\(${os},${os},${os}\\)$`),
-    CK = new RegExp(`^rgba\\(${hc},${hc},${hc},${ph}\\)$`),
+    CK = new RegExp(`^rgb\\(${os},${os},${os}\\)$`),
+    $K = new RegExp(`^rgba\\(${hc},${hc},${hc},${ph}\\)$`),
     MK = new RegExp(`^rgba\\(${os},${os},${os},${ph}\\)$`),
     TK = new RegExp(`^hsl\\(${ph},${os},${os}\\)$`),
     FK = new RegExp(`^hsla\\(${ph},${os},${os},${ph}\\)$`),
     PA = {
         aliceblue: 15792383,
         antiquewhite: 16444375,
         aqua: 65535,
@@ -13173,48 +13160,48 @@
 
 function BA() {
     return this.rgb().formatRgb();
 }
 
 function Bu(e) {
     var t, n;
-    return e = (e + "").trim().toLowerCase(), (t = kK.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? UA(t) : n === 3 ? new zt(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? rp(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? rp(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = AK.exec(e)) ? new zt(t[1], t[2], t[3], 1) : (t = $K.exec(e)) ? new zt(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = CK.exec(e)) ? rp(t[1], t[2], t[3], t[4]) : (t = MK.exec(e)) ? rp(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = TK.exec(e)) ? WA(t[1], t[2] / 100, t[3] / 100, 1) : (t = FK.exec(e)) ? WA(t[1], t[2] / 100, t[3] / 100, t[4]) : PA.hasOwnProperty(e) ? UA(PA[e]) : e === "transparent" ? new zt(NaN, NaN, NaN, 0) : null;
+    return e = (e + "").trim().toLowerCase(), (t = kK.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? UA(t) : n === 3 ? new Bt(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? rp(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? rp(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = AK.exec(e)) ? new Bt(t[1], t[2], t[3], 1) : (t = CK.exec(e)) ? new Bt(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = $K.exec(e)) ? rp(t[1], t[2], t[3], t[4]) : (t = MK.exec(e)) ? rp(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = TK.exec(e)) ? WA(t[1], t[2] / 100, t[3] / 100, 1) : (t = FK.exec(e)) ? WA(t[1], t[2] / 100, t[3] / 100, t[4]) : PA.hasOwnProperty(e) ? UA(PA[e]) : e === "transparent" ? new Bt(NaN, NaN, NaN, 0) : null;
 }
 
 function UA(e) {
-    return new zt(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
+    return new Bt(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
 }
 
 function rp(e, t, n, i) {
-    return i <= 0 && (e = t = n = NaN), new zt(e, t, n, i);
+    return i <= 0 && (e = t = n = NaN), new Bt(e, t, n, i);
 }
 
 function PE(e) {
-    return e instanceof Ra || (e = Bu(e)), e ? (e = e.rgb(), new zt(e.r, e.g, e.b, e.opacity)) : new zt();
+    return e instanceof Ra || (e = Bu(e)), e ? (e = e.rgb(), new Bt(e.r, e.g, e.b, e.opacity)) : new Bt();
 }
 
 function nr(e, t, n, i) {
-    return arguments.length === 1 ? PE(e) : new zt(e, t, n, i ?? 1);
+    return arguments.length === 1 ? PE(e) : new Bt(e, t, n, i ?? 1);
 }
 
-function zt(e, t, n, i) {
+function Bt(e, t, n, i) {
     this.r = +e, this.g = +t, this.b = +n, this.opacity = +i;
 }
-_f(zt, nr, rg(Ra, {
+_f(Bt, nr, rg(Ra, {
     brighter(e) {
-        return e = e == null ? Mc : Math.pow(Mc, e), new zt(this.r * e, this.g * e, this.b * e, this.opacity);
+        return e = e == null ? Mc : Math.pow(Mc, e), new Bt(this.r * e, this.g * e, this.b * e, this.opacity);
     },
     darker(e) {
-        return e = e == null ? zu : Math.pow(zu, e), new zt(this.r * e, this.g * e, this.b * e, this.opacity);
+        return e = e == null ? zu : Math.pow(zu, e), new Bt(this.r * e, this.g * e, this.b * e, this.opacity);
     },
     rgb() {
         return this;
     },
     clamp() {
-        return new zt(Eu(this.r), Eu(this.g), Eu(this.b), Um(this.opacity));
+        return new Bt(Eu(this.r), Eu(this.g), Eu(this.b), Um(this.opacity));
     },
     displayable() {
         return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
     },
     hex: jA,
     // Deprecated! Use color.formatHex.
     formatHex: jA,
@@ -13287,15 +13274,15 @@
     },
     rgb() {
         var e = this.h % 360 + (this.h < 0) * 360,
             t = isNaN(e) || isNaN(this.s) ? 0 : this.s,
             n = this.l,
             i = n + (n < 0.5 ? n : 1 - n) * t,
             r = 2 * n - i;
-        return new zt(
+        return new Bt(
             ev(e >= 240 ? e - 240 : e + 120, r, i),
             ev(e, r, i),
             ev(e < 120 ? e + 240 : e - 120, r, i),
             this.opacity
         );
     },
     clamp() {
@@ -13333,15 +13320,15 @@
     RK = gc * gc * gc;
 
 function lN(e) {
     if (e instanceof as)
         return new as(e.l, e.a, e.b, e.opacity);
     if (e instanceof ro)
         return cN(e);
-    e instanceof zt || (e = PE(e));
+    e instanceof Bt || (e = PE(e));
     var t = rv(e.r),
         n = rv(e.g),
         i = rv(e.b),
         r = tv((0.2225045 * t + 0.7168786 * n + 0.0606169 * i) / sN),
         s, o;
     return t === n && n === i ? s = o = r : (s = tv((0.4360747 * t + 0.3850649 * n + 0.1430804 * i) / rN), o = tv((0.0139322 * t + 0.0971045 * n + 0.7141733 * i) / oN)), new as(116 * r - 16, 500 * (s - r), 200 * (r - o), e.opacity);
 }
@@ -13360,15 +13347,15 @@
     darker(e) {
         return new as(this.l - qm * (e ?? 1), this.a, this.b, this.opacity);
     },
     rgb() {
         var e = (this.l + 16) / 116,
             t = isNaN(this.a) ? e : e + this.a / 500,
             n = isNaN(this.b) ? e : e - this.b / 200;
-        return t = rN * nv(t), e = sN * nv(e), n = oN * nv(n), new zt(
+        return t = rN * nv(t), e = sN * nv(e), n = oN * nv(n), new Bt(
             iv(3.1338561 * t - 1.6168667 * e - 0.4906146 * n),
             iv(-0.9787684 * t + 1.9161415 * e + 0.033454 * n),
             iv(0.0719453 * t - 0.2289914 * e + 1.4052427 * n),
             this.opacity
         );
     }
 }));
@@ -13431,15 +13418,15 @@
     GA = mh * P1,
     VA = mh * zE,
     YA = zE * BE - P1 * fN;
 
 function IK(e) {
     if (e instanceof Su)
         return new Su(e.h, e.s, e.l, e.opacity);
-    e instanceof zt || (e = PE(e));
+    e instanceof Bt || (e = PE(e));
     var t = e.r / 255,
         n = e.g / 255,
         i = e.b / 255,
         r = (YA * i + GA * t - VA * n) / (YA + GA - VA),
         s = i - r,
         o = (mh * (n - r) - BE * s) / P1,
         a = Math.sqrt(o * o + s * s) / (mh * r * (1 - r)),
@@ -13463,15 +13450,15 @@
     },
     rgb() {
         var e = isNaN(this.h) ? 0 : (this.h + 120) * nN,
             t = +this.l,
             n = isNaN(this.s) ? 0 : this.s * t * (1 - t),
             i = Math.cos(e),
             r = Math.sin(e);
-        return new zt(
+        return new Bt(
             255 * (t + n * (fN * i + zE * r)),
             255 * (t + n * (BE * i + P1 * r)),
             255 * (t + n * (mh * i)),
             this.opacity
         );
     }
 }));
@@ -13522,31 +13509,31 @@
 
 function B1(e, t) {
     var n = t - e;
     return n ? pN(e, n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n) : z1(isNaN(e) ? t : e);
 }
 
 function zK(e) {
-    return (e = +e) == 1 ? Bt : function(t, n) {
+    return (e = +e) == 1 ? Ut : function(t, n) {
         return n - t ? PK(t, n, e) : z1(isNaN(t) ? n : t);
     };
 }
 
-function Bt(e, t) {
+function Ut(e, t) {
     var n = t - e;
     return n ? pN(e, n) : z1(isNaN(e) ? t : e);
 }
 const ba = function e(t) {
     var n = zK(t);
 
     function i(r, s) {
         var o = n((r = nr(r)).r, (s = nr(s)).r),
             a = n(r.g, s.g),
             u = n(r.b, s.b),
-            l = Bt(r.opacity, s.opacity);
+            l = Ut(r.opacity, s.opacity);
         return function(c) {
             return r.r = o(c), r.g = a(c), r.b = u(c), r.opacity = l(c), r + "";
         };
     }
     return i.gamma = e, i;
 }(1);
 
@@ -13609,15 +13596,15 @@
     var n = /* @__PURE__ */ new Date();
     return e = +e, t = +t,
         function(i) {
             return n.setTime(e * (1 - i) + t * i), n;
         };
 }
 
-function Qt(e, t) {
+function Zt(e, t) {
     return e = +e, t = +t,
         function(n) {
             return e * (1 - n) + t * n;
         };
 }
 
 function wN(e, t) {
@@ -13653,27 +13640,27 @@
         i, r, s, o = -1,
         a = [],
         u = [];
     for (e = e + "", t = t + "";
         (i = nx.exec(e)) && (r = sv.exec(t));)
         (s = r.index) > n && (s = t.slice(n, s), a[o] ? a[o] += s : a[++o] = s), (i = i[0]) === (r = r[0]) ? a[o] ? a[o] += r : a[++o] = r : (a[++o] = null, u.push({
             i: o,
-            x: Qt(i, r)
+            x: Zt(i, r)
         })), n = sv.lastIndex;
     return n < t.length && (s = t.slice(n), a[o] ? a[o] += s : a[++o] = s), a.length < 2 ? u[0] ? qK(u[0].x) : jK(t) : (t = u.length, function(l) {
         for (var c = 0, f; c < t; ++c)
             a[(f = u[c]).i] = f.x(l);
         return a.join("");
     });
 }
 
 function La(e, t) {
     var n = typeof t,
         i;
-    return t == null || n === "boolean" ? z1(t) : (n === "number" ? Qt : n === "string" ? (i = Bu(t)) ? (t = i, ba) : jE : t instanceof Bu ? ba : t instanceof Date ? xN : bN(t) ? UE : Array.isArray(t) ? vN : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? wN : Qt)(e, t);
+    return t == null || n === "boolean" ? z1(t) : (n === "number" ? Zt : n === "string" ? (i = Bu(t)) ? (t = i, ba) : jE : t instanceof Bu ? ba : t instanceof Date ? xN : bN(t) ? UE : Array.isArray(t) ? vN : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? wN : Zt)(e, t);
 }
 
 function WK(e) {
     var t = e.length;
     return function(n) {
         return e[Math.max(0, Math.min(t - 1, Math.floor(n * t)))];
     };
@@ -13731,46 +13718,46 @@
     }
 
     function s(l, c, f, d, h, g) {
         if (l !== f || c !== d) {
             var p = h.push("translate(", null, t, null, n);
             g.push({
                 i: p - 4,
-                x: Qt(l, f)
+                x: Zt(l, f)
             }, {
                 i: p - 2,
-                x: Qt(c, d)
+                x: Zt(c, d)
             });
         } else
             (f || d) && h.push("translate(" + f + t + d + n);
     }
 
     function o(l, c, f, d) {
         l !== c ? (l - c > 180 ? c += 360 : c - l > 180 && (l += 360), d.push({
             i: f.push(r(f) + "rotate(", null, i) - 2,
-            x: Qt(l, c)
+            x: Zt(l, c)
         })) : c && f.push(r(f) + "rotate(" + c + i);
     }
 
     function a(l, c, f, d) {
         l !== c ? d.push({
             i: f.push(r(f) + "skewX(", null, i) - 2,
-            x: Qt(l, c)
+            x: Zt(l, c)
         }) : c && f.push(r(f) + "skewX(" + c + i);
     }
 
     function u(l, c, f, d, h, g) {
         if (l !== f || c !== d) {
             var p = h.push(r(h) + "scale(", null, ",", null, ")");
             g.push({
                 i: p - 4,
-                x: Qt(l, f)
+                x: Zt(l, f)
             }, {
                 i: p - 2,
-                x: Qt(c, d)
+                x: Zt(c, d)
             });
         } else
             (f !== 1 || d !== 1) && h.push(r(h) + "scale(" + f + "," + d + ")");
     }
     return function(l, c) {
         var f = [],
             d = [];
@@ -13818,22 +13805,22 @@
                 ];
             };
         else {
             var b = Math.sqrt(p),
                 v = (d * d - l * l + i * p) / (2 * l * n * b),
                 x = (d * d - l * l - i * p) / (2 * d * n * b),
                 w = Math.log(Math.sqrt(v * v + 1) - v),
-                S = Math.log(Math.sqrt(x * x + 1) - x);
-            y = (S - w) / t, m = function(_) {
+                E = Math.log(Math.sqrt(x * x + 1) - x);
+            y = (E - w) / t, m = function(_) {
                 var k = _ * y,
                     A = KA(w),
-                    F = l / (n * b) * (A * KK(t * k + w) - XK(w));
+                    T = l / (n * b) * (A * KK(t * k + w) - XK(w));
                 return [
-                    a + F * h,
-                    u + F * g,
+                    a + T * h,
+                    u + T * g,
                     l * A / KA(t * k + w)
                 ];
             };
         }
         return m.duration = y * 1e3 * t / Math.SQRT2, m;
     }
     return r.rho = function(s) {
@@ -13843,67 +13830,67 @@
         return e(o, a, u);
     }, r;
 }(Math.SQRT2, 2, 4);
 
 function AN(e) {
     return function(t, n) {
         var i = e((t = jm(t)).h, (n = jm(n)).h),
-            r = Bt(t.s, n.s),
-            s = Bt(t.l, n.l),
-            o = Bt(t.opacity, n.opacity);
+            r = Ut(t.s, n.s),
+            s = Ut(t.l, n.l),
+            o = Ut(t.opacity, n.opacity);
         return function(a) {
             return t.h = i(a), t.s = r(a), t.l = s(a), t.opacity = o(a), t + "";
         };
     };
 }
-const $N = AN(B1);
-var QK = AN(Bt);
+const CN = AN(B1);
+var QK = AN(Ut);
 
-function CN(e, t) {
-    var n = Bt((e = Wm(e)).l, (t = Wm(t)).l),
-        i = Bt(e.a, t.a),
-        r = Bt(e.b, t.b),
-        s = Bt(e.opacity, t.opacity);
+function $N(e, t) {
+    var n = Ut((e = Wm(e)).l, (t = Wm(t)).l),
+        i = Ut(e.a, t.a),
+        r = Ut(e.b, t.b),
+        s = Ut(e.opacity, t.opacity);
     return function(o) {
         return e.l = n(o), e.a = i(o), e.b = r(o), e.opacity = s(o), e + "";
     };
 }
 
 function MN(e) {
     return function(t, n) {
         var i = e((t = Hm(t)).h, (n = Hm(n)).h),
-            r = Bt(t.c, n.c),
-            s = Bt(t.l, n.l),
-            o = Bt(t.opacity, n.opacity);
+            r = Ut(t.c, n.c),
+            s = Ut(t.l, n.l),
+            o = Ut(t.opacity, n.opacity);
         return function(a) {
             return t.h = i(a), t.c = r(a), t.l = s(a), t.opacity = o(a), t + "";
         };
     };
 }
 const TN = MN(B1);
-var ZK = MN(Bt);
+var ZK = MN(Ut);
 
 function FN(e) {
     return function t(n) {
         n = +n;
 
         function i(r, s) {
             var o = e((r = ms(r)).h, (s = ms(s)).h),
-                a = Bt(r.s, s.s),
-                u = Bt(r.l, s.l),
-                l = Bt(r.opacity, s.opacity);
+                a = Ut(r.s, s.s),
+                u = Ut(r.l, s.l),
+                l = Ut(r.opacity, s.opacity);
             return function(c) {
                 return r.h = o(c), r.s = a(c), r.l = u(Math.pow(c, n)), r.opacity = l(c), r + "";
             };
         }
         return i.gamma = t, i;
     }(1);
 }
 const eJ = FN(B1);
-var U1 = FN(Bt);
+var U1 = FN(Ut);
 
 function Sf(e, t) {
     t === void 0 && (t = e, e = La);
     for (var n = 0, i = t.length - 1, r = t[0], s = new Array(i < 0 ? 0 : i); n < i;)
         s[n] = e(r, r = t[++n]);
     return function(o) {
         var a = Math.max(0, Math.min(i - 1, Math.floor(o *= i)));
@@ -13924,19 +13911,19 @@
     interpolateBasisClosed: gN,
     interpolateCubehelix: eJ,
     interpolateCubehelixLong: U1,
     interpolateDate: xN,
     interpolateDiscrete: WK,
     interpolateHcl: TN,
     interpolateHclLong: ZK,
-    interpolateHsl: $N,
+    interpolateHsl: CN,
     interpolateHslLong: QK,
     interpolateHue: HK,
-    interpolateLab: CN,
-    interpolateNumber: Qt,
+    interpolateLab: $N,
+    interpolateNumber: Zt,
     interpolateNumberArray: UE,
     interpolateObject: wN,
     interpolateRgb: ba,
     interpolateRgbBasis: yN,
     interpolateRgbBasisClosed: BK,
     interpolateRound: Ef,
     interpolateString: jE,
@@ -14018,15 +14005,15 @@
         return o !== ni && (o = iJ(e[0], e[d - 1])), a = d > 2 ? sJ : rJ, u = l = null, f;
     }
 
     function f(d) {
         return d == null || isNaN(d = +d) ? s : (u || (u = a(e.map(i), t, n)))(i(o(d)));
     }
     return f.invert = function(d) {
-            return o(r((l || (l = a(t, e.map(i), Qt)))(d)));
+            return o(r((l || (l = a(t, e.map(i), Zt)))(d)));
         }, f.domain = function(d) {
             return arguments.length ? (e = Array.from(d, rx), c()) : e.slice();
         }, f.range = function(d) {
             return arguments.length ? (t = Array.from(d), c()) : t.slice();
         }, f.rangeRound = function(d) {
             return t = Array.from(d), n = Ef, c();
         }, f.clamp = function(d) {
@@ -14157,26 +14144,26 @@
     return e === 10 ? uJ : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
 }
 
 function cJ(e) {
     return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
 }
 
-function e$(e) {
+function eC(e) {
     return (t, n) => -e(-t, n);
 }
 
 function WE(e) {
     const t = e(QA, ZA),
         n = t.domain;
     let i = 10,
         r, s;
 
     function o() {
-        return r = cJ(i), s = lJ(i), n()[0] < 0 ? (r = e$(r), s = e$(s), e(oJ, aJ)) : e(QA, ZA), t;
+        return r = cJ(i), s = lJ(i), n()[0] < 0 ? (r = eC(r), s = eC(s), e(oJ, aJ)) : e(QA, ZA), t;
     }
     return t.base = function(a) {
         return arguments.length ? (i = +a, o()) : i;
     }, t.domain = function(a) {
         return arguments.length ? (n(a), o()) : n();
     }, t.ticks = (a) => {
         const u = n();
@@ -14225,42 +14212,42 @@
 }
 
 function HE() {
     const e = WE(j1()).domain([1, 10]);
     return e.copy = () => sg(e, HE()).base(e.base()), Lr.apply(e, arguments), e;
 }
 
-function t$(e) {
+function tC(e) {
     return function(t) {
         return Math.sign(t) * Math.log1p(Math.abs(t / e));
     };
 }
 
-function n$(e) {
+function nC(e) {
     return function(t) {
         return Math.sign(t) * Math.expm1(Math.abs(t)) * e;
     };
 }
 
 function GE(e) {
     var t = 1,
-        n = e(t$(t), n$(t));
+        n = e(tC(t), nC(t));
     return n.constant = function(i) {
-        return arguments.length ? e(t$(t = +i), n$(t)) : t;
+        return arguments.length ? e(tC(t = +i), nC(t)) : t;
     }, yl(n);
 }
 
 function VE() {
     var e = GE(j1());
     return e.copy = function() {
         return sg(e, VE()).constant(e.constant());
     }, Lr.apply(e, arguments);
 }
 
-function i$(e) {
+function iC(e) {
     return function(t) {
         return t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
     };
 }
 
 function fJ(e) {
     return e < 0 ? -Math.sqrt(-e) : Math.sqrt(e);
@@ -14271,15 +14258,15 @@
 }
 
 function YE(e) {
     var t = e(ni, ni),
         n = 1;
 
     function i() {
-        return n === 1 ? e(ni, ni) : n === 0.5 ? e(fJ, dJ) : e(i$(n), i$(1 / n));
+        return n === 1 ? e(ni, ni) : n === 0.5 ? e(fJ, dJ) : e(iC(n), iC(1 / n));
     }
     return t.exponent = function(r) {
         return arguments.length ? (n = +r, i()) : n;
     }, yl(t);
 }
 
 function W1() {
@@ -14299,15 +14286,15 @@
         n = [],
         i;
 
     function r() {
         var o = 0,
             a = Math.max(1, t.length);
         for (n = new Array(a - 1); ++o < a;)
-            n[o - 1] = $M(e, o / a);
+            n[o - 1] = CM(e, o / a);
         return s;
     }
 
     function s(o) {
         return o == null || isNaN(o = +o) ? i : t[ca(n, o)];
     }
     return s.invertExtent = function(o) {
@@ -14318,15 +14305,15 @@
         ];
     }, s.domain = function(o) {
         if (!arguments.length)
             return e.slice();
         e = [];
         for (let a of o)
             a != null && !isNaN(a = +a) && e.push(a);
-        return e.sort(vn), r();
+        return e.sort(xn), r();
     }, s.range = function(o) {
         return arguments.length ? (t = Array.from(o), r()) : t.slice();
     }, s.unknown = function(o) {
         return arguments.length ? (i = o, s) : i;
     }, s.quantiles = function() {
         return n.slice();
     }, s.copy = function() {
@@ -14407,36 +14394,36 @@
         p = l("%I:%M"),
         m = l("%I %p"),
         y = l("%a %d"),
         b = l("%b %d"),
         v = l("%B"),
         x = l("%Y");
 
-    function w(S) {
-        return (u(S) < S ? h : a(S) < S ? g : o(S) < S ? p : s(S) < S ? m : i(S) < S ? r(S) < S ? y : b : n(S) < S ? v : x)(S);
+    function w(E) {
+        return (u(E) < E ? h : a(E) < E ? g : o(E) < E ? p : s(E) < E ? m : i(E) < E ? r(E) < E ? y : b : n(E) < E ? v : x)(E);
     }
-    return c.invert = function(S) {
-        return new Date(f(S));
-    }, c.domain = function(S) {
-        return arguments.length ? d(Array.from(S, pJ)) : d().map(gJ);
-    }, c.ticks = function(S) {
+    return c.invert = function(E) {
+        return new Date(f(E));
+    }, c.domain = function(E) {
+        return arguments.length ? d(Array.from(E, pJ)) : d().map(gJ);
+    }, c.ticks = function(E) {
         var _ = d();
-        return e(_[0], _[_.length - 1], S ?? 10);
-    }, c.tickFormat = function(S, _) {
+        return e(_[0], _[_.length - 1], E ?? 10);
+    }, c.tickFormat = function(E, _) {
         return _ == null ? w : l(_);
-    }, c.nice = function(S) {
+    }, c.nice = function(E) {
         var _ = d();
-        return (!S || typeof S.range != "function") && (S = t(_[0], _[_.length - 1], S ?? 10)), S ? d(DN(_, S)) : c;
+        return (!E || typeof E.range != "function") && (E = t(_[0], _[_.length - 1], E ?? 10)), E ? d(DN(_, E)) : c;
     }, c.copy = function() {
         return sg(c, JE(e, t, n, i, r, s, o, a, u, l));
     }, c;
 }
 
 function LN() {
-    return Lr.apply(JE(wG, _G, Qi, Iu, ha, Cr, mf, gf, xi, b1).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
+    return Lr.apply(JE(wG, _G, Qi, Iu, ha, $r, mf, gf, xi, b1).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
 }
 
 function IN() {
     return Lr.apply(JE(vG, xG, Zi, Pu, ga, ra, yf, pf, xi, xf).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
 }
 
 function H1() {
@@ -14590,15 +14577,15 @@
     Fc = "quantile",
     X1 = "quantize",
     K1 = "threshold",
     rS = "ordinal",
     ox = "point",
     BN = "band",
     sS = "bin-ordinal",
-    Dt = "continuous",
+    Rt = "continuous",
     ug = "discrete",
     lg = "discretizing",
     ur = "interpolating",
     oS = "temporal";
 
 function vJ(e) {
     return function(t) {
@@ -14637,15 +14624,15 @@
     function c() {
         const f = t().length,
             d = i[1] < i[0],
             h = i[1 - d],
             g = iS(f, a, u);
         let p = i[d - 0];
         r = (h - p) / (g || 1), o && (r = Math.floor(r)), p += (h - p - r * (f - a)) * l, s = r * (1 - a), o && (p = Math.round(p), s = Math.round(s));
-        const m = hn(f).map((y) => p + r * y);
+        const m = gn(f).map((y) => p + r * y);
         return n(d ? m.reverse() : m);
     }
     return e.domain = function(f) {
         return arguments.length ? (t(f), c()) : t();
     }, e.range = function(f) {
         return arguments.length ? (i = [+f[0], +f[1]], c()) : i.slice();
     }, e.rangeRound = function(f) {
@@ -14692,15 +14679,15 @@
 
 function wJ() {
     return UN(aS().paddingInner(1));
 }
 var _J = Array.prototype.map;
 
 function EJ(e) {
-    return _J.call(e, dn);
+    return _J.call(e, hn);
 }
 const SJ = Array.prototype.slice;
 
 function jN() {
     let e = [],
         t = [];
 
@@ -14729,39 +14716,39 @@
 }
 
 function AJ(e, t, n) {
     const i = function() {
         const s = t();
         return s.invertRange || (s.invertRange = s.invert ? vJ(s) : s.invertExtent ? xJ(s) : void 0), s.type = e, WN(s);
     };
-    return i.metadata = Fr(ne(n)), i;
+    return i.metadata = Fr(re(n)), i;
 }
 
 function qe(e, t, n) {
     return arguments.length > 1 ? (Gm.set(e, AJ(e, t, n)), this) : HN(e) ? Gm.get(e) : void 0;
 }
 qe(bJ, qE);
-qe(Tc, q1, Dt);
-qe(mo, HE, [Dt, mo]);
-qe(og, W1, Dt);
-qe(ag, hJ, Dt);
-qe(Y1, VE, Dt);
-qe(Uu, LN, [Dt, oS]);
-qe(ju, IN, [Dt, oS]);
-qe(us, QE, [Dt, ur]);
-qe(`${us}-${Tc}`, QE, [Dt, ur]);
-qe(`${us}-${mo}`, PN, [Dt, ur, mo]);
-qe(`${us}-${og}`, ZE, [Dt, ur]);
-qe(`${us}-${ag}`, mJ, [Dt, ur]);
-qe(`${us}-${Y1}`, zN, [Dt, ur]);
-qe(`${kf}-${Tc}`, eS, [Dt, ur]);
-qe(`${kf}-${mo}`, tS, [Dt, ur, mo]);
-qe(`${kf}-${og}`, V1, [Dt, ur]);
-qe(`${kf}-${ag}`, yJ, [Dt, ur]);
-qe(`${kf}-${Y1}`, nS, [Dt, ur]);
+qe(Tc, q1, Rt);
+qe(mo, HE, [Rt, mo]);
+qe(og, W1, Rt);
+qe(ag, hJ, Rt);
+qe(Y1, VE, Rt);
+qe(Uu, LN, [Rt, oS]);
+qe(ju, IN, [Rt, oS]);
+qe(us, QE, [Rt, ur]);
+qe(`${us}-${Tc}`, QE, [Rt, ur]);
+qe(`${us}-${mo}`, PN, [Rt, ur, mo]);
+qe(`${us}-${og}`, ZE, [Rt, ur]);
+qe(`${us}-${ag}`, mJ, [Rt, ur]);
+qe(`${us}-${Y1}`, zN, [Rt, ur]);
+qe(`${kf}-${Tc}`, eS, [Rt, ur]);
+qe(`${kf}-${mo}`, tS, [Rt, ur, mo]);
+qe(`${kf}-${og}`, V1, [Rt, ur]);
+qe(`${kf}-${ag}`, yJ, [Rt, ur]);
+qe(`${kf}-${Y1}`, nS, [Rt, ur]);
 qe(Fc, XE, [lg, Fc]);
 qe(X1, RN, lg);
 qe(K1, KE, lg);
 qe(sS, jN, [ug, lg]);
 qe(rS, ig, ug);
 qe(BN, aS, ug);
 qe(ox, wJ, ug);
@@ -14772,41 +14759,41 @@
 
 function bl(e, t) {
     const n = Gm.get(e);
     return n && n.metadata[t];
 }
 
 function uS(e) {
-    return bl(e, Dt);
+    return bl(e, Rt);
 }
 
 function Nc(e) {
     return bl(e, ug);
 }
 
 function ax(e) {
     return bl(e, lg);
 }
 
 function GN(e) {
     return bl(e, mo);
 }
 
-function $J(e) {
+function CJ(e) {
     return bl(e, oS);
 }
 
 function VN(e) {
     return bl(e, ur);
 }
 
 function YN(e) {
     return bl(e, Fc);
 }
-const CJ = ["clamp", "base", "constant", "exponent"];
+const $J = ["clamp", "base", "constant", "exponent"];
 
 function XN(e, t) {
     const n = t[0],
         i = Ie(t) - n;
     return function(r) {
         return e(n + r * i);
     };
@@ -14823,15 +14810,15 @@
         n[r] = e(++r / i);
     return n;
 }
 
 function JN(e, t, n) {
     const i = n - t;
     let r, s, o;
-    return !i || !Number.isFinite(i) ? kn(0.5) : (r = (s = e.type).indexOf("-"), s = r < 0 ? s : s.slice(r + 1), o = qe(s)().domain([t, n]).range([0, 1]), CJ.forEach((a) => e[a] ? o[a](e[a]()) : 0), o);
+    return !i || !Number.isFinite(i) ? An(0.5) : (r = (s = e.type).indexOf("-"), s = r < 0 ? s : s.slice(r + 1), o = qe(s)().domain([t, n]).range([0, 1]), $J.forEach((a) => e[a] ? o[a](e[a]()) : 0), o);
 }
 
 function lS(e, t) {
     const n = tJ[MJ(e)];
     return t != null && n && n.gamma ? n.gamma(t) : n;
 }
 
@@ -14918,31 +14905,31 @@
     return n;
 }
 
 function ZN(e, t) {
     for (const n in e)
         cS(n, t(e[n]));
 }
-const r$ = {};
+const rC = {};
 ZN(FJ, QN);
 ZN(TJ, (e) => J1(QN(e)));
 
 function cS(e, t) {
-    return e = e && e.toLowerCase(), arguments.length > 1 ? (r$[e] = t, this) : r$[e];
+    return e = e && e.toLowerCase(), arguments.length > 1 ? (rC[e] = t, this) : rC[e];
 }
 const Zp = "symbol",
     NJ = "discrete",
     OJ = "gradient",
-    DJ = (e) => W(e) ? e.map((t) => String(t)) : String(e),
+    DJ = (e) => V(e) ? e.map((t) => String(t)) : String(e),
     RJ = (e, t) => e[1] - t[1],
     LJ = (e, t) => t[1] - e[1];
 
 function fS(e, t, n) {
     let i;
-    return ze(t) && (e.bins && (t = Math.max(t, e.bins.length)), n != null && (t = Math.min(t, Math.floor(Jh(e.domain()) / n || 1) + 1))), re(t) && (i = t.step, t = t.interval), ie(t) && (t = e.type === Uu ? bf(t) : e.type == ju ? vf(t) : q("Only time and utc scales accept interval strings."), i && (t = t.every(i))), t;
+    return ze(t) && (e.bins && (t = Math.max(t, e.bins.length)), n != null && (t = Math.min(t, Math.floor(Jh(e.domain()) / n || 1) + 1))), oe(t) && (i = t.step, t = t.interval), se(t) && (t = e.type === Uu ? bf(t) : e.type == ju ? vf(t) : W("Only time and utc scales accept interval strings."), i && (t = t.every(i))), t;
 }
 
 function eO(e, t, n) {
     let i = e.range(),
         r = i[0],
         s = Ie(i),
         o = RJ;
@@ -15029,23 +15016,23 @@
 const BJ = (e) => ux[e.type] || e.bins;
 
 function sO(e, t, n, i, r, s, o) {
     const a = iO[t.type] && s !== Uu && s !== ju ? IJ(e, t, r) : tO(e, t, n, r, s, o);
     return i === Zp && BJ(t) ? UJ(a) : i === NJ ? jJ(a) : qJ(a);
 }
 const UJ = (e) => (t, n, i) => {
-        const r = s$(i[n + 1], s$(i.max, 1 / 0)),
-            s = o$(t, e),
-            o = o$(r, e);
+        const r = sC(i[n + 1], sC(i.max, 1 / 0)),
+            s = oC(t, e),
+            o = oC(r, e);
         return s && o ? s + " – " + o : o ? "< " + o : "≥ " + s;
     },
-    s$ = (e, t) => e ?? t,
+    sC = (e, t) => e ?? t,
     jJ = (e) => (t, n) => n ? e(t) : null,
     qJ = (e) => (t) => e(t),
-    o$ = (e, t) => Number.isFinite(e) ? t(e) : null;
+    oC = (e, t) => Number.isFinite(e) ? t(e) : null;
 
 function WJ(e) {
     const t = e.domain(),
         n = t.length - 1;
     let i = +t[0],
         r = +Ie(t),
         s = r - i;
@@ -15054,15 +15041,15 @@
         i -= o, r += o, s = r - i;
     }
     return (o) => (o - i) / s;
 }
 
 function HJ(e, t, n, i) {
     const r = i || t.type;
-    return ie(n) && $J(r) && (n = n.replace(/%a/g, "%A").replace(/%b/g, "%B")), !n && r === Uu ? e.timeFormat("%A, %d %B %Y, %X") : !n && r === ju ? e.utcFormat("%A, %d %B %Y, %X UTC") : sO(e, t, 5, null, n, i, !0);
+    return se(n) && CJ(r) && (n = n.replace(/%a/g, "%A").replace(/%b/g, "%B")), !n && r === Uu ? e.timeFormat("%A, %d %B %Y, %X") : !n && r === ju ? e.utcFormat("%A, %d %B %Y, %X UTC") : sO(e, t, 5, null, n, i, !0);
 }
 
 function oO(e, t, n) {
     n = n || {};
     const i = Math.max(3, n.maxlen || 7),
         r = HJ(e, t, n.format, n.formatType);
     if (ax(t.type)) {
@@ -15115,15 +15102,15 @@
             return n.push({
                 offset: r,
                 color: s
             }), i;
         }
     };
 }
-const a$ = {
+const aC = {
     basis: {
         curve: oK
     },
     "basis-closed": {
         curve: aK
     },
     "basis-open": {
@@ -15185,15 +15172,15 @@
     },
     "step-before": {
         curve: wK
     }
 };
 
 function gS(e, t, n) {
-    var i = be(a$, e) && a$[e],
+    var i = xe(aC, e) && aC[e],
         r = null;
     return i && (r = i.curve || i[t || "vertical"], i.tension && n != null && (r = r[i.tension](n))), r;
 }
 const VJ = {
         m: 2,
         l: 2,
         h: 1,
@@ -15265,33 +15252,33 @@
     p > 1 && (p = Math.sqrt(p), n *= p, i *= p);
     const m = d / n,
         y = f / n,
         b = -f / i,
         v = d / i,
         x = m * a + y * u,
         w = b * a + v * u,
-        S = m * e + y * t,
+        E = m * e + y * t,
         _ = b * e + v * t;
-    let A = 1 / ((S - x) * (S - x) + (_ - w) * (_ - w)) - 0.25;
+    let A = 1 / ((E - x) * (E - x) + (_ - w) * (_ - w)) - 0.25;
     A < 0 && (A = 0);
-    let F = Math.sqrt(A);
-    s == r && (F = -F);
-    const T = 0.5 * (x + S) - F * (_ - w),
-        I = 0.5 * (w + _) + F * (S - x),
-        N = Math.atan2(w - I, x - T);
-    let M = Math.atan2(_ - I, S - T) - N;
-    M < 0 && s === 1 ? M += es : M > 0 && s === 0 && (M -= es);
-    const E = Math.ceil(Math.abs(M / (du + 1e-3))),
-        $ = [];
-    for (let C = 0; C < E; ++C) {
-        const O = N + C * M / E,
-            R = N + (C + 1) * M / E;
-        $[C] = [T, I, O, R, n, i, f, d];
+    let T = Math.sqrt(A);
+    s == r && (T = -T);
+    const M = 0.5 * (x + E) - T * (_ - w),
+        L = 0.5 * (w + _) + T * (E - x),
+        F = Math.atan2(w - L, x - M);
+    let N = Math.atan2(_ - L, E - M) - F;
+    N < 0 && s === 1 ? N += es : N > 0 && s === 0 && (N -= es);
+    const R = Math.ceil(Math.abs(N / (du + 1e-3))),
+        P = [];
+    for (let S = 0; S < R; ++S) {
+        const $ = F + S * N / R,
+            C = F + (S + 1) * N / R;
+        P[S] = [M, L, $, C, n, i, f, d];
     }
-    return ov[l] = $;
+    return ov[l] = P;
 }
 
 function tQ(e) {
     const t = cO.call(e);
     if (av[t])
         return av[t];
     var n = e[0],
@@ -15310,20 +15297,20 @@
         p = Math.sin(r),
         m = Math.cos(s),
         y = Math.sin(s),
         b = 0.5 * (s - r),
         v = Math.sin(b * 0.5),
         x = 8 / 3 * v * v / Math.sin(b),
         w = n + g - x * p,
-        S = i + p + x * g,
+        E = i + p + x * g,
         _ = n + m,
         k = i + y,
         A = _ + x * y,
-        F = k - x * m;
-    return av[t] = [c * w + f * S, d * w + h * S, c * A + f * F, d * A + h * F, c * _ + f * k, d * _ + h * k];
+        T = k - x * m;
+    return av[t] = [c * w + f * E, d * w + h * E, c * A + f * T, d * A + h * T, c * _ + f * k, d * _ + h * k];
 }
 const Pi = ["l", 0, 0, 0, 0, 0, 0, 0];
 
 function nQ(e, t, n) {
     const i = Pi[0] = e[0];
     if (i === "a" || i === "A")
         Pi[1] = t * e[1], Pi[2] = n * e[2], Pi[3] = e[3], Pi[4] = e[4], Pi[5] = e[5], Pi[6] = t * e[6], Pi[7] = n * e[7];
@@ -15404,29 +15391,29 @@
             case "t":
                 d = u + o[1], h = l + o[2], a[0].match(/[QqTt]/) === null ? (c = u, f = l) : a[0] === "t" ? (c = 2 * u - g, f = 2 * l - p) : a[0] === "q" && (c = 2 * u - c, f = 2 * l - f), g = c, p = f, e.quadraticCurveTo(c + n, f + i, d + n, h + i), u = d, l = h, c = u + o[1], f = l + o[2];
                 break;
             case "T":
                 d = o[1], h = o[2], c = 2 * u - c, f = 2 * l - f, e.quadraticCurveTo(c + n, f + i, d + n, h + i), u = d, l = h;
                 break;
             case "a":
-                u$(e, u + n, l + i, [o[1], o[2], o[3], o[4], o[5], o[6] + u + n, o[7] + l + i]), u += o[6], l += o[7];
+                uC(e, u + n, l + i, [o[1], o[2], o[3], o[4], o[5], o[6] + u + n, o[7] + l + i]), u += o[6], l += o[7];
                 break;
             case "A":
-                u$(e, u + n, l + i, [o[1], o[2], o[3], o[4], o[5], o[6] + n, o[7] + i]), u = o[6], l = o[7];
+                uC(e, u + n, l + i, [o[1], o[2], o[3], o[4], o[5], o[6] + n, o[7] + i]), u = o[6], l = o[7];
                 break;
             case "z":
             case "Z":
                 u = m, l = y, e.closePath();
                 break;
         }
         a = o;
     }
 }
 
-function u$(e, t, n, i) {
+function uC(e, t, n, i) {
     const r = eQ(
         i[5],
         // end x
         i[6],
         // end y
         i[0],
         // radius x
@@ -15442,16 +15429,16 @@
         n
     );
     for (let s = 0; s < r.length; ++s) {
         const o = tQ(r[s]);
         e.bezierCurveTo(o[0], o[1], o[2], o[3], o[4], o[5]);
     }
 }
-const l$ = 0.5773502691896257,
-    c$ = {
+const lC = 0.5773502691896257,
+    cC = {
         circle: {
             draw: function(e, t) {
                 const n = Math.sqrt(t) / 2;
                 e.moveTo(n, 0), e.arc(0, 0, n, 0, es);
             }
         },
         cross: {
@@ -15483,24 +15470,24 @@
                 e.moveTo(-i, n), e.lineTo(i, n), e.lineTo(i, -s), e.lineTo(r, -s), e.lineTo(0, -n), e.lineTo(-r, -s), e.lineTo(-i, -s), e.closePath();
             }
         },
         wedge: {
             draw: function(e, t) {
                 var n = Math.sqrt(t) / 2,
                     i = zl * n,
-                    r = i - n * l$,
+                    r = i - n * lC,
                     s = n / 4;
                 e.moveTo(0, -i - r), e.lineTo(-s, i - r), e.lineTo(s, i - r), e.closePath();
             }
         },
         triangle: {
             draw: function(e, t) {
                 var n = Math.sqrt(t) / 2,
                     i = zl * n,
-                    r = i - n * l$;
+                    r = i - n * lC;
                 e.moveTo(0, -i - r), e.lineTo(-n, i - r), e.lineTo(n, i - r), e.closePath();
             }
         },
         "triangle-up": {
             draw: function(e, t) {
                 var n = Math.sqrt(t) / 2,
                     i = zl * n;
@@ -15533,20 +15520,20 @@
                 const n = Math.sqrt(t) / 2;
                 e.moveTo(-n, 0), e.lineTo(n, 0);
             }
         }
     };
 
 function fO(e) {
-    return be(c$, e) ? c$[e] : iQ(e);
+    return xe(cC, e) ? cC[e] : iQ(e);
 }
 var uv = {};
 
 function iQ(e) {
-    if (!be(uv, e)) {
+    if (!xe(uv, e)) {
         const t = Oc(e);
         uv[e] = {
             draw: function(n, i) {
                 yh(n, t, 0, 0, Math.sqrt(i) / 2);
             }
         };
     }
@@ -15594,21 +15581,21 @@
             p = d ?? +t.call(this, c),
             m = +n.call(this, c),
             y = +i.call(this, c),
             b = Math.min(m, y) / 2,
             v = ap(+r.call(this, c), 0, b),
             x = ap(+s.call(this, c), 0, b),
             w = ap(+o.call(this, c), 0, b),
-            S = ap(+a.call(this, c), 0, b);
-        if (u || (u = h = N1()), v <= 0 && x <= 0 && w <= 0 && S <= 0)
+            E = ap(+a.call(this, c), 0, b);
+        if (u || (u = h = N1()), v <= 0 && x <= 0 && w <= 0 && E <= 0)
             u.rect(g, p, m, y);
         else {
             var _ = g + m,
                 k = p + y;
-            u.moveTo(g + v, p), u.lineTo(_ - x, p), u.bezierCurveTo(_ - Do * x, p, _, p + Do * x, _, p + x), u.lineTo(_, k - S), u.bezierCurveTo(_, k - Do * S, _ - Do * S, k, _ - S, k), u.lineTo(g + w, k), u.bezierCurveTo(g + Do * w, k, g, k - Do * w, g, k - w), u.lineTo(g, p + v), u.bezierCurveTo(g, p + Do * v, g + Do * v, p, g + v, p), u.closePath();
+            u.moveTo(g + v, p), u.lineTo(_ - x, p), u.bezierCurveTo(_ - Do * x, p, _, p + Do * x, _, p + x), u.lineTo(_, k - E), u.bezierCurveTo(_, k - Do * E, _ - Do * E, k, _ - E, k), u.lineTo(g + w, k), u.bezierCurveTo(g + Do * w, k, g, k - Do * w, g, k - w), u.lineTo(g, p + v), u.bezierCurveTo(g, p + Do * v, g + Do * v, p, g + v, p), u.closePath();
         }
         if (h)
             return u = null, h + "" || null;
     }
     return l.x = function(c) {
         return arguments.length ? (e = zs(c), l) : e;
     }, l.y = function(c) {
@@ -15690,16 +15677,16 @@
     wQ = (e) => cg(e.cornerRadiusBottomLeft, e.cornerRadius) || 0,
     _Q = (e) => cg(e.size, 64),
     EQ = (e) => e.size || 1,
     Q1 = (e) => e.defined !== !1,
     SQ = (e) => fO(e.shape || "circle"),
     kQ = XX().startAngle(dQ).endAngle(hQ).padAngle(gQ).innerRadius(pQ).outerRadius(mQ).cornerRadius(yQ),
     AQ = MF().x(fg).y1(dg).y0(fQ).defined(Q1),
-    $Q = MF().y(dg).x1(fg).x0(cQ).defined(Q1),
-    CQ = CF().x(fg).y(dg).defined(Q1),
+    CQ = MF().y(dg).x1(fg).x0(cQ).defined(Q1),
+    $Q = $F().x(fg).y(dg).defined(Q1),
     MQ = dO().x(fg).y(dg).width(uQ).height(lQ).cornerRadius(bQ, vQ, xQ, wQ),
     TQ = sK().type(SQ).size(_Q),
     FQ = hO().x(fg).y(dg).defined(Q1).size(EQ);
 
 function pS(e) {
     return e.cornerRadius || e.cornerRadiusTopLeft || e.cornerRadiusTopRight || e.cornerRadiusBottomRight || e.cornerRadiusBottomLeft;
 }
@@ -15707,21 +15694,21 @@
 function NQ(e, t) {
     return kQ.context(e)(t);
 }
 
 function OQ(e, t) {
     const n = t[0],
         i = n.interpolate || "linear";
-    return (n.orient === "horizontal" ? $Q : AQ).curve(gS(i, n.orient, n.tension)).context(e)(t);
+    return (n.orient === "horizontal" ? CQ : AQ).curve(gS(i, n.orient, n.tension)).context(e)(t);
 }
 
 function DQ(e, t) {
     const n = t[0],
         i = n.interpolate || "linear";
-    return CQ.curve(gS(i, n.orient, n.tension)).context(e)(t);
+    return $Q.curve(gS(i, n.orient, n.tension)).context(e)(t);
 }
 
 function Af(e, t, n, i) {
     return MQ.context(e)(t, n, i);
 }
 
 function RQ(e, t) {
@@ -15827,50 +15814,50 @@
 function Z1(e) {
     this.mark = e, this.bounds = this.bounds || new $t();
 }
 
 function ey(e) {
     Z1.call(this, e), this.items = this.items || [];
 }
-Q(ey, Z1);
+Z(ey, Z1);
 
 function yS(e) {
     this._pending = 0, this._loader = e || v1();
 }
 
-function f$(e) {
+function fC(e) {
     e._pending += 1;
 }
 
 function Jf(e) {
     e._pending -= 1;
 }
 yS.prototype = {
     pending() {
         return this._pending;
     },
     sanitizeURL(e) {
         const t = this;
-        return f$(t), t._loader.sanitize(e, {
+        return fC(t), t._loader.sanitize(e, {
             context: "href"
         }).then((n) => (Jf(t), n)).catch(() => (Jf(t), null));
     },
     loadImage(e) {
         const t = this,
             n = EK();
-        return f$(t), t._loader.sanitize(e, {
+        return fC(t), t._loader.sanitize(e, {
             context: "image"
         }).then((i) => {
             const r = i.href;
             if (!r || !n)
                 throw {
                     url: r
                 };
             const s = new n(),
-                o = be(i, "crossOrigin") ? i.crossOrigin : "anonymous";
+                o = xe(i, "crossOrigin") ? i.crossOrigin : "anonymous";
             return o != null && (s.crossOrigin = o), s.onload = () => Jf(t), s.onerror = () => Jf(t), s.src = r, s;
         }).catch((i) => (Jf(t), {
             complete: !1,
             width: 0,
             height: 0,
             src: i && i.url || ""
         }));
@@ -15899,16 +15886,16 @@
 function PQ(e, t) {
     return e.strokeJoin && e.strokeJoin !== "miter" ? 0 : t;
 }
 const zQ = es - 1e-8;
 let ty, em, tm, vu, lx, nm, cx, fx;
 const Ho = (e, t) => ty.add(e, t),
     im = (e, t) => Ho(em = e, tm = t),
-    d$ = (e) => Ho(e, ty.y1),
-    h$ = (e) => Ho(ty.x1, e),
+    dC = (e) => Ho(e, ty.y1),
+    hC = (e) => Ho(ty.x1, e),
     hu = (e, t) => lx * e + cx * t,
     gu = (e, t) => nm * e + fx * t,
     lv = (e, t) => Ho(hu(e, t), gu(e, t)),
     cv = (e, t) => im(hu(e, t), gu(e, t));
 
 function hg(e, t) {
     return ty = e, t ? (vu = t * va, lx = fx = Math.cos(vu), nm = Math.sin(vu), cx = -nm) : (lx = fx = 1, vu = nm = cx = 0), BQ;
@@ -15922,24 +15909,24 @@
         vu ? (lv(e + n, t), lv(e + n, t + i), lv(e, t + i), cv(e, t)) : (Ho(e + n, t + i), im(e, t));
     },
     quadraticCurveTo(e, t, n, i) {
         const r = hu(e, t),
             s = gu(e, t),
             o = hu(n, i),
             a = gu(n, i);
-        g$(em, r, o, d$), g$(tm, s, a, h$), im(o, a);
+        gC(em, r, o, dC), gC(tm, s, a, hC), im(o, a);
     },
     bezierCurveTo(e, t, n, i, r, s) {
         const o = hu(e, t),
             a = gu(e, t),
             u = hu(n, i),
             l = gu(n, i),
             c = hu(r, s),
             f = gu(r, s);
-        p$(em, o, u, c, d$), p$(tm, a, l, f, h$), im(c, f);
+        pC(em, o, u, c, dC), pC(tm, a, l, f, hC), im(c, f);
     },
     arc(e, t, n, i, r, s) {
         if (i += vu, r += vu, em = n * Math.cos(r) + e, tm = n * Math.sin(r) + t, Math.abs(r - i) > zQ)
             Ho(e - n, t - n), Ho(e + n, t + n);
         else {
             const o = (l) => Ho(n * Math.cos(l) + e, n * Math.sin(l) + t);
             let a, u;
@@ -15950,30 +15937,30 @@
                 else
                     for (a = i - i % du + du, u = 0; u < 4 && a < r; ++u, a = a + du)
                         o(a);
         }
     }
 };
 
-function g$(e, t, n, i) {
+function gC(e, t, n, i) {
     const r = (e - t) / (e + n - 2 * t);
     0 < r && r < 1 && i(e + (t - e) * r);
 }
 
-function p$(e, t, n, i, r) {
+function pC(e, t, n, i, r) {
     const s = i - e + 3 * t - 3 * n,
         o = e + n - 2 * t,
         a = e - t;
     let u = 0,
         l = 0,
         c;
-    Math.abs(s) > ZJ ? (c = o * o + a * s, c >= 0 && (c = Math.sqrt(c), u = (-o + c) / s, l = (-o - c) / s)) : u = 0.5 * a / o, 0 < u && u < 1 && r(m$(u, e, t, n, i)), 0 < l && l < 1 && r(m$(l, e, t, n, i));
+    Math.abs(s) > ZJ ? (c = o * o + a * s, c >= 0 && (c = Math.sqrt(c), u = (-o + c) / s, l = (-o - c) / s)) : u = 0.5 * a / o, 0 < u && u < 1 && r(mC(u, e, t, n, i)), 0 < l && l < 1 && r(mC(l, e, t, n, i));
 }
 
-function m$(e, t, n, i, r) {
+function mC(e, t, n, i, r) {
     const s = 1 - e,
         o = s * s,
         a = e * e;
     return o * s * t + 3 * o * e * n + 3 * s * a * i + a * e * r;
 }
 var aa = (aa = oa(1, 1)) ? aa.getContext("2d") : null;
 const dx = new $t();
@@ -16047,15 +16034,15 @@
     e.globalCompositeOperation = t.blend || "source-over";
 }
 
 function hr(e, t) {
     return e ?? t;
 }
 
-function y$(e, t) {
+function yC(e, t) {
     const n = t.length;
     for (let i = 0; i < n; ++i)
         e.addColorStop(t[i].offset, t[i].color);
     return e;
 }
 
 function UQ(e, t, n) {
@@ -16070,18 +16057,18 @@
             u = hr(t.x2, 1),
             l = hr(t.y2, 0);
         if (o === u || a === l || i === r)
             s = e.createLinearGradient(n.x1 + o * i, n.y1 + a * r, n.x1 + u * i, n.y1 + l * r);
         else {
             const c = oa(Math.ceil(i), Math.ceil(r)),
                 f = c.getContext("2d");
-            return f.scale(i, r), f.fillStyle = y$(f.createLinearGradient(o, a, u, l), t.stops), f.fillRect(0, 0, i, r), e.createPattern(c, "no-repeat");
+            return f.scale(i, r), f.fillStyle = yC(f.createLinearGradient(o, a, u, l), t.stops), f.fillRect(0, 0, i, r), e.createPattern(c, "no-repeat");
         }
     }
-    return y$(s, t.stops);
+    return yC(s, t.stops);
 }
 
 function bO(e, t, n) {
     return hS(n) ? UQ(e, n, t.bounds) : n;
 }
 
 function Ym(e, t, n) {
@@ -16411,56 +16398,56 @@
         width: 0,
         height: 0
     }, t.loadImage(e.url).then((i) => {
         e.image = i, e.image.url = e.url;
     })), n;
 }
 
-function $S(e, t) {
+function CS(e, t) {
     return e.width != null ? e.width : !t || !t.width ? 0 : e.aspect !== !1 && e.height ? e.height * t.width / t.height : t.width;
 }
 
-function CS(e, t) {
+function $S(e, t) {
     return e.height != null ? e.height : !t || !t.height ? 0 : e.aspect !== !1 && e.width ? e.width * t.height / t.width : t.height;
 }
 
 function iy(e, t) {
     return e === "center" ? t / 2 : e === "right" ? t : 0;
 }
 
 function ry(e, t) {
     return e === "middle" ? t / 2 : e === "bottom" ? t : 0;
 }
 
 function dZ(e, t, n) {
     const i = AS(t, n),
-        r = $S(t, i),
-        s = CS(t, i),
+        r = CS(t, i),
+        s = $S(t, i),
         o = (t.x || 0) - iy(t.align, r),
         a = (t.y || 0) - ry(t.baseline, s),
         u = !i.src && i.toDataURL ? i.toDataURL() : i.src || "";
     e("href", u, vh["xmlns:xlink"], "xlink:href"), e("transform", ku(o, a)), e("width", r), e("height", s), e("preserveAspectRatio", t.aspect === !1 ? "none" : "xMidYMid");
 }
 
 function hZ(e, t) {
     const n = t.image,
-        i = $S(t, n),
-        r = CS(t, n),
+        i = CS(t, n),
+        r = $S(t, n),
         s = (t.x || 0) - iy(t.align, i),
         o = (t.y || 0) - ry(t.baseline, r);
     return e.set(s, o, s + i, o + r);
 }
 
 function gZ(e, t, n) {
     Or(t, (i) => {
         if (n && !n.intersects(i.bounds))
             return;
         const r = AS(i, this);
-        let s = $S(i, r),
-            o = CS(i, r);
+        let s = CS(i, r),
+            o = $S(i, r);
         if (s === 0 || o === 0)
             return;
         let a = (i.x || 0) - iy(i.align, s),
             u = (i.y || 0) - ry(i.baseline, o),
             l, c, f, d;
         i.aspect !== !1 && (c = r.width / r.height, f = i.width / i.height, c === c && f === f && c !== f && (f < c ? (d = s / c, u += (o - d) / 2, o = d) : (d = o * c, a += (s - d) / 2, s = d))), (r.complete || r.toDataURL) && (Dc(e, i), e.globalAlpha = (l = i.opacity) != null ? l : 1, e.imageSmoothingEnabled = i.smooth !== !1, e.drawImage(r, a, u, s, o));
     });
@@ -16519,25 +16506,25 @@
 }
 
 function wZ(e, t) {
     var n, i;
     return _o(e.set(n = t.x || 0, i = t.y || 0, n + t.width || 0, i + t.height || 0), t);
 }
 
-function b$(e, t) {
+function bC(e, t) {
     e.beginPath(), Af(e, t);
 }
 var _Z = {
     type: "rect",
     tag: "path",
     nested: !1,
     attr: xZ,
     bound: wZ,
-    draw: wS(b$),
-    pick: _S(b$),
+    draw: wS(bC),
+    pick: _S(bC),
     isect: mO
 };
 
 function EZ(e, t) {
     e("transform", xO(t)), e("x2", t.x2 != null ? t.x2 - (t.x || 0) : 0), e("y2", t.y2 != null ? t.y2 - (t.y || 0) : 0);
 }
 
@@ -16559,90 +16546,90 @@
         }
     });
 }
 
 function AZ(e, t, n, i) {
     return e.isPointInStroke ? SO(e, t, 1) && e.isPointInStroke(n, i) : !1;
 }
-var $Z = {
+var CZ = {
         type: "rule",
         tag: "line",
         nested: !1,
         attr: EZ,
         bound: SZ,
         draw: kZ,
         pick: ny(AZ),
         isect: yO
     },
-    CZ = SS("shape", RQ),
+    $Z = SS("shape", RQ),
     MZ = SS("symbol", LQ, vS);
-const v$ = lM();
+const vC = lM();
 var ki = {
-    height: $s,
+    height: Cs,
     measureWidth: MS,
     estimateWidth: Km,
     width: Km,
     canvas: kO
 };
 kO(!0);
 
 function kO(e) {
     ki.width = e && aa ? MS : Km;
 }
 
 function Km(e, t) {
-    return AO(wa(e, t), $s(e));
+    return AO(wa(e, t), Cs(e));
 }
 
 function AO(e, t) {
     return ~~(0.8 * e.length * t);
 }
 
 function MS(e, t) {
-    return $s(e) <= 0 || !(t = wa(e, t)) ? 0 : $O(t, sy(e));
+    return Cs(e) <= 0 || !(t = wa(e, t)) ? 0 : CO(t, sy(e));
 }
 
-function $O(e, t) {
+function CO(e, t) {
     const n = `(${t}) ${e}`;
-    let i = v$.get(n);
-    return i === void 0 && (aa.font = t, i = aa.measureText(e).width, v$.set(n, i)), i;
+    let i = vC.get(n);
+    return i === void 0 && (aa.font = t, i = aa.measureText(e).width, vC.set(n, i)), i;
 }
 
-function $s(e) {
+function Cs(e) {
     return e.fontSize != null ? +e.fontSize || 0 : 11;
 }
 
 function xa(e) {
-    return e.lineHeight != null ? e.lineHeight : $s(e) + 2;
+    return e.lineHeight != null ? e.lineHeight : Cs(e) + 2;
 }
 
 function TZ(e) {
-    return W(e) ? e.length > 1 ? e : e[0] : e;
+    return V(e) ? e.length > 1 ? e : e[0] : e;
 }
 
 function pg(e) {
-    return TZ(e.lineBreak && e.text && !W(e.text) ? e.text.split(e.lineBreak) : e.text);
+    return TZ(e.lineBreak && e.text && !V(e.text) ? e.text.split(e.lineBreak) : e.text);
 }
 
 function TS(e) {
     const t = pg(e);
-    return (W(t) ? t.length - 1 : 0) * xa(e);
+    return (V(t) ? t.length - 1 : 0) * xa(e);
 }
 
 function wa(e, t) {
     const n = t == null ? "" : (t + "").trim();
     return e.limit > 0 && n.length ? NZ(e, n) : n;
 }
 
 function FZ(e) {
     if (ki.width === MS) {
         const t = sy(e);
-        return (n) => $O(n, t);
+        return (n) => CO(n, t);
     } else if (ki.width === Km) {
-        const t = $s(e);
+        const t = Cs(e);
         return (n) => AO(n, t);
     } else
         return (t) => ki.width(e, t);
 }
 
 function NZ(e, t) {
     var n = +e.limit,
@@ -16667,20 +16654,20 @@
 
 function mg(e, t) {
     var n = e.font;
     return (t && n ? String(n).replace(/"/g, "'") : n) || "sans-serif";
 }
 
 function sy(e, t) {
-    return (e.fontStyle ? e.fontStyle + " " : "") + (e.fontVariant ? e.fontVariant + " " : "") + (e.fontWeight ? e.fontWeight + " " : "") + $s(e) + "px " + mg(e, t);
+    return (e.fontStyle ? e.fontStyle + " " : "") + (e.fontVariant ? e.fontVariant + " " : "") + (e.fontWeight ? e.fontWeight + " " : "") + Cs(e) + "px " + mg(e, t);
 }
 
 function FS(e) {
     var t = e.baseline,
-        n = $s(e);
+        n = Cs(e);
     return Math.round(t === "top" ? 0.79 * n : t === "middle" ? 0.3 * n : t === "bottom" ? -0.21 * n : t === "line-top" ? 0.29 * n + 0.5 * xa(e) : t === "line-bottom" ? 0.29 * n - 0.5 * xa(e) : 0);
 }
 const OZ = {
         left: "start",
         center: "middle",
         right: "end"
     },
@@ -16711,28 +16698,28 @@
         s = oy(t),
         o = s.x1,
         a = s.y1,
         u = t.dx || 0,
         l = (t.dy || 0) + FS(t) - Math.round(0.8 * i),
         c = pg(t),
         f;
-    if (W(c) ? (i += xa(t) * (c.length - 1), f = c.reduce((d, h) => Math.max(d, ki.width(t, h)), 0)) : f = ki.width(t, c), r === "center" ? u -= f / 2 : r === "right" && (u -= f), e.set(u += o, l += a, u + f, l + i), t.angle && !n)
+    if (V(c) ? (i += xa(t) * (c.length - 1), f = c.reduce((d, h) => Math.max(d, ki.width(t, h)), 0)) : f = ki.width(t, c), r === "center" ? u -= f / 2 : r === "right" && (u -= f), e.set(u += o, l += a, u + f, l + i), t.angle && !n)
         e.rotate(t.angle * va, o, a);
     else if (n === 2)
         return e.rotatedPoints(t.angle * va, o, a);
     return e;
 }
 
 function RZ(e, t, n) {
     Or(t, (i) => {
         var r = i.opacity == null ? 1 : i.opacity,
             s, o, a, u, l, c, f;
         if (!(n && !n.intersects(i.bounds) || // bounds check
                 r === 0 || i.fontSize <= 0 || i.text == null || i.text.length === 0)) {
-            if (e.font = sy(i), e.textAlign = i.align || "left", s = oy(i), o = s.x1, a = s.y1, i.angle && (e.save(), e.translate(o, a), e.rotate(i.angle * va), o = a = 0), o += i.dx || 0, a += (i.dy || 0) + FS(i), c = pg(i), Dc(e, i), W(c))
+            if (e.font = sy(i), e.textAlign = i.align || "left", s = oy(i), o = s.x1, a = s.y1, i.angle && (e.save(), e.translate(o, a), e.rotate(i.angle * va), o = a = 0), o += i.dx || 0, a += (i.dy || 0) + FS(i), c = pg(i), Dc(e, i), V(c))
                 for (l = xa(i), u = 0; u < c.length; ++u)
                     f = wa(i, c[u]), i.fill && Ym(e, i, r) && e.fillText(f, o, a), i.stroke && Rc(e, i, r) && e.strokeText(f, o, a), a += l;
             else
                 f = wa(i, c), i.fill && Ym(e, i, r) && e.fillText(f, o, a), i.stroke && Rc(e, i, r) && e.strokeText(f, o, a);
             i.angle && e.restore();
         }
     });
@@ -16774,38 +16761,38 @@
         arc: YQ,
         area: QQ,
         group: fZ,
         image: pZ,
         line: mZ,
         path: vZ,
         rect: _Z,
-        rule: $Z,
-        shape: CZ,
+        rule: CZ,
+        shape: $Z,
         symbol: MZ,
         text: PZ,
         trail: zZ
     };
 
 function hx(e, t, n) {
     var i = Ti[e.mark.marktype],
         r = t || i.bound;
     return i.nested && (e = e.mark), r(e.bounds || (e.bounds = new $t()), e, n);
 }
-var x$ = {
+var xC = {
     mark: null
 };
 
-function CO(e, t, n) {
+function $O(e, t, n) {
     var i = Ti[e.marktype],
         r = i.bound,
         s = e.items,
         o = s && s.length,
         a, u, l, c;
     if (i.nested)
-        return o ? l = s[0] : (x$.mark = e, l = x$), c = hx(l, r, n), t = t && t.union(c) || c, t;
+        return o ? l = s[0] : (xC.mark = e, l = xC), c = hx(l, r, n), t = t && t.union(c) || c, t;
     if (t = t || e.bounds && e.bounds.clear() || new $t(), o)
         for (a = 0, u = s.length; a < u; ++a)
             t.union(hx(s[a], r, n));
     return e.bounds = t;
 }
 const BZ = [
     "marktype",
@@ -16907,15 +16894,15 @@
 function FO(e) {
     var t = e.marktype,
         n = e.items,
         i, r, s;
     if (n)
         for (r = 0, s = n.length; r < s; ++r)
             i = t ? "mark" : "group", n[r][i] = e, n[r].zindex && (n[r][i].zdirty = !0), (t || i) === "group" && FO(n[r]);
-    return t && CO(e), e;
+    return t && $O(e), e;
 }
 
 function OS(e) {
     arguments.length ? this.root = TO(e) : (this.root = NO({
         marktype: "group",
         name: "root",
         role: "frame"
@@ -16954,15 +16941,15 @@
 function DS(e, t) {
     t = t.toLowerCase();
     for (var n = e.childNodes, i = 0, r = n.length; i < r; ++i)
         if (n[i].tagName.toLowerCase() === t)
             return n[i];
 }
 
-function Mt(e, t, n, i) {
+function Tt(e, t, n, i) {
     var r = e.childNodes[t],
         s;
     return (!r || r.tagName.toLowerCase() !== n.toLowerCase()) && (s = r || null, r = Go(e.ownerDocument, n, i), e.insertBefore(r, s)), r;
 }
 
 function Bi(e, t) {
     for (var n = e.childNodes, i = n.length; i > t;)
@@ -17319,43 +17306,43 @@
     bx = Qm;
 
 function Ea(e, t) {
     _a.call(this, e, t), this._down = null, this._touch = null, this._first = !0, this._events = {};
 }
 const JZ = (e) => e === Zm || e === e0 || e === t0 ? [Zm, e0, t0] : [e];
 
-function w$(e, t) {
+function wC(e, t) {
     JZ(t).forEach((n) => QZ(e, n));
 }
 
 function QZ(e, t) {
     const n = e.canvas();
     n && !e._events[t] && (e._events[t] = 1, n.addEventListener(t, e[t] ? (i) => e[t](i) : (i) => e.fire(t, i)));
 }
 
 function Sd(e, t, n) {
     t.forEach((i) => e.fire(i, n));
 }
 
-function _$(e, t, n) {
+function _C(e, t, n) {
     return function(i) {
         const r = this._active,
             s = this.pickEvent(i);
         s === r ? Sd(this, e, i) : ((!r || !r.exit) && Sd(this, n, i), this._active = s, Sd(this, t, i), Sd(this, e, i));
     };
 }
 
-function E$(e) {
+function EC(e) {
     return function(t) {
         Sd(this, e, t), this._active = null;
     };
 }
-Q(Ea, _a, {
+Z(Ea, _a, {
     initialize(e, t, n) {
-        return this._canvas = e && DS(e, "canvas"), [Qm, px, gx, Jm, Hd, sm].forEach((i) => w$(this, i)), _a.prototype.initialize.call(this, e, t, n);
+        return this._canvas = e && DS(e, "canvas"), [Qm, px, gx, Jm, Hd, sm].forEach((i) => wC(this, i)), _a.prototype.initialize.call(this, e, t, n);
     },
     // return the backing canvas instance
     canvas() {
         return this._canvas;
     },
     // retrieve the current canvas context
     context() {
@@ -17363,18 +17350,18 @@
     },
     // supported events
     events: KZ,
     // to keep old versions of firefox happy
     DOMMouseScroll(e) {
         this.fire(zO, e);
     },
-    pointermove: _$([Jm, IO], [LO, PO], [Hd, mx]),
-    dragover: _$([RO], [DO], [sm]),
-    pointerout: E$([Hd, mx]),
-    dragleave: E$([sm]),
+    pointermove: _C([Jm, IO], [LO, PO], [Hd, mx]),
+    dragover: _C([RO], [DO], [sm]),
+    pointerout: EC([Hd, mx]),
+    dragleave: EC([sm]),
     pointerdown(e) {
         this._down = this._active, this.fire(gx, e);
     },
     mousedown(e) {
         this._down = this._active, this.fire(px, e);
     },
     click(e) {
@@ -17397,15 +17384,15 @@
             for (let s = 0, o = r.length; s < o; ++s)
                 r[s].handler.call(this._obj, t, i);
     },
     // add an event handler
     on(e, t) {
         const n = this.eventName(e),
             i = this._handlers;
-        return this._handlerIndex(i[n], e, t) < 0 && (w$(this, e), (i[n] || (i[n] = [])).push({
+        return this._handlerIndex(i[n], e, t) < 0 && (wC(this, e), (i[n] || (i[n] = [])).push({
             type: e,
             handler: t
         })), this;
     },
     // remove an event handler
     off(e, t) {
         const n = this.eventName(e),
@@ -17440,30 +17427,30 @@
         a[l] = s[l];
     return o && u !== 1 && (e.style.width = t + "px", e.style.height = n + "px"), a.pixelRatio = u, a.setTransform(u, 0, 0, u, u * i[0], u * i[1]), e;
 }
 
 function wh(e) {
     Ri.call(this, e), this._options = {}, this._redraw = !1, this._dirty = new $t(), this._tempb = new $t();
 }
-const S$ = Ri.prototype,
+const SC = Ri.prototype,
     tee = (e, t, n) => new $t().set(0, 0, t, n).translate(-e[0], -e[1]);
 
 function nee(e, t, n) {
     return t.expand(1).round(), e.pixelRatio % 1 && t.scale(e.pixelRatio).round().scale(1 / e.pixelRatio), t.translate(-(n[0] % 1), -(n[1] % 1)), e.beginPath(), e.rect(t.x1, t.y1, t.width(), t.height()), e.clip(), t;
 }
-Q(wh, Ri, {
+Z(wh, Ri, {
     initialize(e, t, n, i, r, s) {
-        return this._options = s || {}, this._canvas = this._options.externalContext ? null : oa(1, 1, this._options.type), e && this._canvas && (Bi(e, 0).appendChild(this._canvas), this._canvas.setAttribute("class", "marks")), S$.initialize.call(this, e, t, n, i, r);
+        return this._options = s || {}, this._canvas = this._options.externalContext ? null : oa(1, 1, this._options.type), e && this._canvas && (Bi(e, 0).appendChild(this._canvas), this._canvas.setAttribute("class", "marks")), SC.initialize.call(this, e, t, n, i, r);
     },
     resize(e, t, n, i) {
-        if (S$.resize.call(this, e, t, n, i), this._canvas)
+        if (SC.resize.call(this, e, t, n, i), this._canvas)
             eee(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
         else {
             const r = this._options.externalContext;
-            r || q("CanvasRenderer is missing a valid canvas or context"), r.scale(this._scale, this._scale), r.translate(this._origin[0], this._origin[1]);
+            r || W("CanvasRenderer is missing a valid canvas or context"), r.scale(this._scale, this._scale), r.translate(this._origin[0], this._origin[1]);
         }
         return this._redraw = !0, this;
     },
     canvas() {
         return this._canvas;
     },
     context() {
@@ -17509,15 +17496,15 @@
         n.handleTooltip(i, r, i.type !== xh);
     });
 }
 const vx = (e, t) => (n) => {
     let i = n.target.__data__;
     i = Array.isArray(i) ? i[0] : i, n.vegaType = n.type, t.call(e._obj, n, i);
 };
-Q(RS, _a, {
+Z(RS, _a, {
     initialize(e, t, n) {
         let i = this._svg;
         return i && (i.removeEventListener(bx, this._hrefHandler), i.removeEventListener(yx, this._tooltipHandler), i.removeEventListener(xh, this._tooltipHandler)), this._svg = i = e && DS(e, "svg"), i && (i.addEventListener(bx, this._hrefHandler), i.addEventListener(yx, this._tooltipHandler), i.addEventListener(xh, this._tooltipHandler)), _a.prototype.initialize.call(this, e, t, n);
     },
     canvas() {
         return this._svg;
     },
@@ -17551,53 +17538,53 @@
     zS = "graphics-symbol",
     jO = (e, t, n) => ({
         [IS]: e,
         [PS]: t,
         [LS]: n || void 0
     }),
     iee = Fr(["axis-domain", "axis-grid", "axis-label", "axis-tick", "axis-title", "legend-band", "legend-entry", "legend-gradient", "legend-label", "legend-title", "legend-symbol", "title"]),
-    k$ = {
+    kC = {
         axis: {
             desc: "axis",
             caption: oee
         },
         legend: {
             desc: "legend",
             caption: aee
         },
         "title-text": {
             desc: "title",
-            caption: (e) => `Title text '${$$(e)}'`
+            caption: (e) => `Title text '${CC(e)}'`
         },
         "title-subtitle": {
             desc: "subtitle",
-            caption: (e) => `Subtitle text '${$$(e)}'`
+            caption: (e) => `Subtitle text '${CC(e)}'`
         }
     },
-    A$ = {
+    AC = {
         ariaRole: IS,
         ariaRoleDescription: PS,
         description: LS
     };
 
 function qO(e, t) {
     const n = t.aria === !1;
     if (e(BO, n || void 0), n || t.description == null)
-        for (const i in A$)
-            e(A$[i], void 0);
+        for (const i in AC)
+            e(AC[i], void 0);
     else {
         const i = t.mark.marktype;
         e(LS, t.description), e(IS, t.ariaRole || (i === "group" ? UO : zS)), e(PS, t.ariaRoleDescription || `${i} mark`);
     }
 }
 
 function WO(e) {
     return e.aria === !1 ? {
         [BO]: !0
-    } : iee[e.role] ? null : k$[e.role] ? see(e, k$[e.role]) : ree(e);
+    } : iee[e.role] ? null : kC[e.role] ? see(e, kC[e.role]) : ree(e);
 }
 
 function ree(e) {
     const t = e.marktype,
         n = t === "group" || t === "text" || e.items.some((i) => i.description != null && i.aria !== !1);
     return jO(n ? UO : zS, `${t} mark container`, e.description);
 }
@@ -17608,16 +17595,16 @@
             i = t.caption || (() => "");
         return jO(t.role || zS, t.desc, n.description || i(n));
     } catch {
         return null;
     }
 }
 
-function $$(e) {
-    return ne(e.text).join(" ");
+function CC(e) {
+    return re(e.text).join(" ");
 }
 
 function oee(e) {
     const t = e.datum,
         n = e.orient,
         i = t.title ? HO(e) : null,
         r = e.context,
@@ -17637,15 +17624,15 @@
         a = o.scales[r[s[0]]].value,
         u = o.dataflow.locale();
     return lee(i) + (n ? ` titled '${n}'` : "") + ` for ${uee(s)} with ${oO(u, a, e)}`;
 }
 
 function HO(e) {
     try {
-        return ne(Ie(e.items).items[0].text).join(" ");
+        return re(Ie(e.items).items[0].text).join(" ");
     } catch {
         return null;
     }
 }
 
 function uee(e) {
     return e = e.map((t) => t + (t === "fill" || t === "stroke" ? " color" : "")), e.length < 2 ? e[0] : e.slice(0, -1).join(", ") + " and " + Ie(e);
@@ -17720,35 +17707,35 @@
         blend: "mix-blend-mode"
     },
     XO = {
         fill: "none",
         "stroke-miterlimit": 10
     },
     Qf = 0,
-    C$ = "http://www.w3.org/2000/xmlns/",
-    Ct = vh.xmlns;
+    $C = "http://www.w3.org/2000/xmlns/",
+    Mt = vh.xmlns;
 
 function uy(e) {
     Ri.call(this, e), this._dirtyID = 0, this._dirty = [], this._svg = null, this._root = null, this._defs = null;
 }
 const fv = Ri.prototype;
-Q(uy, Ri, {
+Z(uy, Ri, {
     /**
      * Initialize a new SVGRenderer instance.
      * @param {DOMElement} el - The containing DOM element for the display.
      * @param {number} width - The coordinate width of the display, in pixels.
      * @param {number} height - The coordinate height of the display, in pixels.
      * @param {Array<number>} origin - The origin of the display, in pixels.
      *   The coordinate system will be translated to this point.
      * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
      *   the width and height to determine the final pixel size.
      * @return {SVGRenderer} - This renderer instance.
      */
     initialize(e, t, n, i, r) {
-        return this._defs = {}, this._clearDefs(), e && (this._svg = Mt(e, 0, "svg", Ct), this._svg.setAttributeNS(C$, "xmlns", Ct), this._svg.setAttributeNS(C$, "xmlns:xlink", vh["xmlns:xlink"]), this._svg.setAttribute("version", vh.version), this._svg.setAttribute("class", "marks"), Bi(e, 1), this._root = Mt(this._svg, Qf, "g", Ct), Vo(this._root, XO), Bi(this._svg, Qf + 1)), this.background(this._bgcolor), fv.initialize.call(this, e, t, n, i, r);
+        return this._defs = {}, this._clearDefs(), e && (this._svg = Tt(e, 0, "svg", Mt), this._svg.setAttributeNS($C, "xmlns", Mt), this._svg.setAttributeNS($C, "xmlns:xlink", vh["xmlns:xlink"]), this._svg.setAttribute("version", vh.version), this._svg.setAttribute("class", "marks"), Bi(e, 1), this._root = Tt(this._svg, Qf, "g", Mt), Vo(this._root, XO), Bi(this._svg, Qf + 1)), this.background(this._bgcolor), fv.initialize.call(this, e, t, n, i, r);
     },
     /**
      * Get / set the background color.
      */
     background(e) {
         return arguments.length && this._svg && this._svg.style.setProperty("background-color", e), fv.background.apply(this, arguments);
     },
@@ -17782,15 +17769,15 @@
      */
     svg() {
         const e = this._svg,
             t = this._bgcolor;
         if (!e)
             return null;
         let n;
-        t && (e.removeAttribute("style"), n = Mt(e, Qf, "rect", Ct), Vo(n, {
+        t && (e.removeAttribute("style"), n = Tt(e, Qf, "rect", Mt), Vo(n, {
             width: this._width,
             height: this._height,
             fill: t
         }));
         const i = VO(e);
         return t && (e.removeChild(n), this._svg.style.setProperty("background-color", t)), i;
     },
@@ -17826,22 +17813,22 @@
         this._dirtyAll = !0;
         const e = this._dirty;
         if (!e.length || !this._dirtyID)
             return !0;
         const t = ++this._dirtyID;
         let n, i, r, s, o, a, u;
         for (o = 0, a = e.length; o < a; ++o)
-            if (n = e[o], i = n.mark, i.marktype !== r && (r = i.marktype, s = Ti[r]), i.zdirty && i.dirty !== t && (this._dirtyAll = !1, M$(n, t), i.items.forEach((l) => {
+            if (n = e[o], i = n.mark, i.marktype !== r && (r = i.marktype, s = Ti[r]), i.zdirty && i.dirty !== t && (this._dirtyAll = !1, MC(n, t), i.items.forEach((l) => {
                     l.dirty = t;
                 })), !i.zdirty) {
                 if (n.exit) {
                     s.nested && i.items.length ? (u = i.items[0], u._svg && this._update(s, u._svg, u)) : n._svg && (u = n._svg.parentNode, u && u.removeChild(n._svg)), n._svg = null;
                     continue;
                 }
-                n = s.nested ? i.items[0] : n, n._update !== t && (!n._svg || !n._svg.ownerSVGElement ? (this._dirtyAll = !1, M$(n, t)) : this._update(s, n._svg, n), n._update = t);
+                n = s.nested ? i.items[0] : n, n._update !== t && (!n._svg || !n._svg.ownerSVGElement ? (this._dirtyAll = !1, MC(n, t)) : this._update(s, n._svg, n), n._update = t);
             }
         return !this._dirtyAll;
     },
     // -- Construct & maintain scenegraph to SVG mapping ---
     /**
      * Render a set of mark items.
      * @param {SVGElement} el - The parent element in the SVG tree.
@@ -17854,55 +17841,55 @@
         if (!this.isDirty(t))
             return t._svg;
         const r = this._svg,
             s = t.marktype,
             o = Ti[s],
             a = t.interactive === !1 ? "none" : null,
             u = o.tag === "g",
-            l = T$(t, e, n, "g", r);
+            l = TC(t, e, n, "g", r);
         if (s !== "group" && i != null && !i.includes(s))
             return Bi(l, 0), t._svg;
         l.setAttribute("class", OO(t));
         const c = WO(t);
         for (const g in c)
-            Mn(l, g, c[g]);
-        u || Mn(l, "pointer-events", a), Mn(l, "clip-path", t.clip ? mS(this, t, t.group) : null);
+            Tn(l, g, c[g]);
+        u || Tn(l, "pointer-events", a), Tn(l, "clip-path", t.clip ? mS(this, t, t.group) : null);
         let f = null,
             d = 0;
         const h = (g) => {
             const p = this.isDirty(g),
-                m = T$(g, l, f, o.tag, r);
+                m = TC(g, l, f, o.tag, r);
             p && (this._update(o, m, g), u && hee(this, m, g, i)), f = m, ++d;
         };
         return o.nested ? t.items.length && h(t.items[0]) : Or(t, h), Bi(l, d), l;
     },
     /**
      * Update the attributes of an SVG element for a mark item.
      * @param {object} mdef - The mark definition object
      * @param {SVGElement} el - The SVG element.
      * @param {Item} item - The mark item.
      */
     _update(e, t, n) {
-        so = t, cn = t.__values__, qO(Gd, n), e.attr(Gd, n, this);
+        so = t, fn = t.__values__, qO(Gd, n), e.attr(Gd, n, this);
         const i = pee[e.type];
         i && i.call(this, e, t, n), so && this.style(so, n);
     },
     /**
      * Update the presentation attributes of an SVG element for a mark item.
      * @param {SVGElement} el - The SVG element.
      * @param {Item} item - The mark item.
      */
     style(e, t) {
         if (t != null) {
             for (const n in n0) {
                 let i = n === "font" ? mg(t) : t[n];
-                if (i === cn[n])
+                if (i === fn[n])
                     continue;
                 const r = n0[n];
-                i == null ? e.removeAttribute(r) : (hS(i) && (i = uO(i, this._defs.gradient, KO())), e.setAttribute(r, i + "")), cn[n] = i;
+                i == null ? e.removeAttribute(r) : (hS(i) && (i = uO(i, this._defs.gradient, KO())), e.setAttribute(r, i + "")), fn[n] = i;
             }
             for (const n in i0)
                 om(e, i0[n], t[n]);
         }
     },
     /**
      * Render SVG defs, as needed.
@@ -17911,75 +17898,75 @@
      */
     defs() {
         const e = this._svg,
             t = this._defs;
         let n = t.el,
             i = 0;
         for (const r in t.gradient)
-            n || (t.el = n = Mt(e, Qf + 1, "defs", Ct)), i = fee(n, t.gradient[r], i);
+            n || (t.el = n = Tt(e, Qf + 1, "defs", Mt)), i = fee(n, t.gradient[r], i);
         for (const r in t.clipping)
-            n || (t.el = n = Mt(e, Qf + 1, "defs", Ct)), i = dee(n, t.clipping[r], i);
+            n || (t.el = n = Tt(e, Qf + 1, "defs", Mt)), i = dee(n, t.clipping[r], i);
         n && (i === 0 ? (e.removeChild(n), t.el = null) : Bi(n, i));
     },
     /**
      * Clear defs caches.
      */
     _clearDefs() {
         const e = this._defs;
         e.gradient = {}, e.clipping = {};
     }
 });
 
-function M$(e, t) {
+function MC(e, t) {
     for (; e && e.dirty !== t; e = e.mark.group)
         if (e.dirty = t, e.mark && e.mark.dirty !== t)
             e.mark.dirty = t;
         else
             return;
 }
 
 function fee(e, t, n) {
     let i, r, s;
     if (t.gradient === "radial") {
-        let o = Mt(e, n++, "pattern", Ct);
+        let o = Tt(e, n++, "pattern", Mt);
         Vo(o, {
             id: Vm + t.id,
             viewBox: "0,0,1,1",
             width: "100%",
             height: "100%",
             preserveAspectRatio: "xMidYMid slice"
-        }), o = Mt(o, 0, "rect", Ct), Vo(o, {
+        }), o = Tt(o, 0, "rect", Mt), Vo(o, {
             width: 1,
             height: 1,
             fill: `url(${KO()}#${t.id})`
-        }), e = Mt(e, n++, "radialGradient", Ct), Vo(e, {
+        }), e = Tt(e, n++, "radialGradient", Mt), Vo(e, {
             id: t.id,
             fx: t.x1,
             fy: t.y1,
             fr: t.r1,
             cx: t.x2,
             cy: t.y2,
             r: t.r2
         });
     } else
-        e = Mt(e, n++, "linearGradient", Ct), Vo(e, {
+        e = Tt(e, n++, "linearGradient", Mt), Vo(e, {
             id: t.id,
             x1: t.x1,
             x2: t.x2,
             y1: t.y1,
             y2: t.y2
         });
     for (i = 0, r = t.stops.length; i < r; ++i)
-        s = Mt(e, i, "stop", Ct), s.setAttribute("offset", t.stops[i].offset), s.setAttribute("stop-color", t.stops[i].color);
+        s = Tt(e, i, "stop", Mt), s.setAttribute("offset", t.stops[i].offset), s.setAttribute("stop-color", t.stops[i].color);
     return Bi(e, i), n;
 }
 
 function dee(e, t, n) {
     let i;
-    return e = Mt(e, n, "clipPath", Ct), e.setAttribute("id", t.id), t.path ? (i = Mt(e, 0, "path", Ct), i.setAttribute("d", t.path)) : (i = Mt(e, 0, "rect", Ct), Vo(i, {
+    return e = Tt(e, n, "clipPath", Mt), e.setAttribute("id", t.id), t.path ? (i = Tt(e, 0, "path", Mt), i.setAttribute("d", t.path)) : (i = Tt(e, 0, "rect", Mt), Vo(i, {
         x: 0,
         y: 0,
         width: t.width,
         height: t.height
     })), Bi(e, 1), n + 1;
 }
 
@@ -17987,78 +17974,78 @@
     t = t.lastChild.previousSibling;
     let r, s = 0;
     Or(n, (o) => {
         r = e.mark(t, o, r, i), ++s;
     }), Bi(t, 1 + s);
 }
 
-function T$(e, t, n, i, r) {
+function TC(e, t, n, i, r) {
     let s = e._svg,
         o;
-    if (!s && (o = t.ownerDocument, s = Go(o, i, Ct), e._svg = s, e.mark && (s.__data__ = e, s.__values__ = {
+    if (!s && (o = t.ownerDocument, s = Go(o, i, Mt), e._svg = s, e.mark && (s.__data__ = e, s.__values__ = {
             fill: "default"
         }, i === "g"))) {
-        const a = Go(o, "path", Ct);
+        const a = Go(o, "path", Mt);
         s.appendChild(a), a.__data__ = e;
-        const u = Go(o, "g", Ct);
+        const u = Go(o, "g", Mt);
         s.appendChild(u), u.__data__ = e;
-        const l = Go(o, "path", Ct);
+        const l = Go(o, "path", Mt);
         s.appendChild(l), l.__data__ = e, l.__values__ = {
             fill: "default"
         };
     }
     return (s.ownerSVGElement !== r || gee(s, n)) && t.insertBefore(s, n ? n.nextSibling : t.firstChild), s;
 }
 
 function gee(e, t) {
     return e.parentNode && e.parentNode.childNodes.length > 1 && e.previousSibling != t;
 }
 let so = null,
-    cn = null;
+    fn = null;
 const pee = {
     group(e, t, n) {
         const i = so = t.childNodes[2];
-        cn = i.__values__, e.foreground(Gd, n, this), cn = t.__values__, so = t.childNodes[1], e.content(Gd, n, this);
+        fn = i.__values__, e.foreground(Gd, n, this), fn = t.__values__, so = t.childNodes[1], e.content(Gd, n, this);
         const r = so = t.childNodes[0];
         e.background(Gd, n, this);
         const s = n.mark.interactive === !1 ? "none" : null;
-        if (s !== cn.events && (Mn(i, "pointer-events", s), Mn(r, "pointer-events", s), cn.events = s), n.strokeForeground && n.stroke) {
+        if (s !== fn.events && (Tn(i, "pointer-events", s), Tn(r, "pointer-events", s), fn.events = s), n.strokeForeground && n.stroke) {
             const o = n.fill;
-            Mn(i, "display", null), this.style(r, n), Mn(r, "stroke", null), o && (n.fill = null), cn = i.__values__, this.style(i, n), o && (n.fill = o), so = null;
+            Tn(i, "display", null), this.style(r, n), Tn(r, "stroke", null), o && (n.fill = null), fn = i.__values__, this.style(i, n), o && (n.fill = o), so = null;
         } else
-            Mn(i, "display", "none");
+            Tn(i, "display", "none");
     },
     image(e, t, n) {
         n.smooth === !1 ? (om(t, "image-rendering", "optimizeSpeed"), om(t, "image-rendering", "pixelated")) : om(t, "image-rendering", null);
     },
     text(e, t, n) {
         const i = pg(n);
         let r, s, o, a;
-        W(i) ? (s = i.map((u) => wa(n, u)), r = s.join(`
-`), r !== cn.text && (Bi(t, 0), o = t.ownerDocument, a = xa(n), s.forEach((u, l) => {
-            const c = Go(o, "tspan", Ct);
+        V(i) ? (s = i.map((u) => wa(n, u)), r = s.join(`
+`), r !== fn.text && (Bi(t, 0), o = t.ownerDocument, a = xa(n), s.forEach((u, l) => {
+            const c = Go(o, "tspan", Mt);
             c.__data__ = n, c.textContent = u, l && (c.setAttribute("x", 0), c.setAttribute("dy", a)), t.appendChild(c);
-        }), cn.text = r)) : (s = wa(n, i), s !== cn.text && (t.textContent = s, cn.text = s)), Mn(t, "font-family", mg(n)), Mn(t, "font-size", $s(n) + "px"), Mn(t, "font-style", n.fontStyle), Mn(t, "font-variant", n.fontVariant), Mn(t, "font-weight", n.fontWeight);
+        }), fn.text = r)) : (s = wa(n, i), s !== fn.text && (t.textContent = s, fn.text = s)), Tn(t, "font-family", mg(n)), Tn(t, "font-size", Cs(n) + "px"), Tn(t, "font-style", n.fontStyle), Tn(t, "font-variant", n.fontVariant), Tn(t, "font-weight", n.fontWeight);
     }
 };
 
 function Gd(e, t, n) {
-    t !== cn[e] && (n ? mee(so, e, t, n) : Mn(so, e, t), cn[e] = t);
+    t !== fn[e] && (n ? mee(so, e, t, n) : Tn(so, e, t), fn[e] = t);
 }
 
 function om(e, t, n) {
-    n !== cn[t] && (n == null ? e.style.removeProperty(t) : e.style.setProperty(t, n + ""), cn[t] = n);
+    n !== fn[t] && (n == null ? e.style.removeProperty(t) : e.style.setProperty(t, n + ""), fn[t] = n);
 }
 
 function Vo(e, t) {
     for (const n in t)
-        Mn(e, n, t[n]);
+        Tn(e, n, t[n]);
 }
 
-function Mn(e, t, n) {
+function Tn(e, t, n) {
     n != null ? e.setAttribute(t, n) : e.removeAttribute(t);
 }
 
 function mee(e, t, n, i) {
     n != null ? e.setAttributeNS(i, t, n) : e.removeAttributeNS(i, t);
 }
 
@@ -18069,29 +18056,29 @@
 
 function US(e) {
     Ri.call(this, e), this._text = null, this._defs = {
         gradient: {},
         clipping: {}
     };
 }
-Q(US, Ri, {
+Z(US, Ri, {
     /**
      * Returns the rendered SVG text string,
      * or null if rendering has not yet occurred.
      */
     svg() {
         return this._text;
     },
     /**
      * Internal rendering method.
      * @param {object} scene - The root mark of a scenegraph to render.
      */
     _render(e) {
         const t = BS();
-        t.open("svg", Ce({}, vh, {
+        t.open("svg", $e({}, vh, {
             class: "marks",
             width: this._width * this._scale,
             height: this._height * this._scale,
             viewBox: `0 0 ${this._width} ${this._height}`
         }));
         const n = this._bgcolor;
         return n && n !== "transparent" && n !== "none" && t.open("rect", {
@@ -18117,15 +18104,15 @@
         }, WO(t), {
             "pointer-events": i !== "g" && t.interactive === !1 ? "none" : null
         });
         const s = (o) => {
             const a = this.href(o);
             if (a && e.open("a", a), e.open(i, this.attr(t, o, r, i !== "g" ? i : null)), i === "text") {
                 const u = pg(o);
-                if (W(u)) {
+                if (V(u)) {
                     const l = {
                         x: 0,
                         dy: xa(o)
                     };
                     for (let c = 0; c < u.length; ++c)
                         e.open("tspan", c ? l : null).text(wa(o, u[c])).close();
                 } else
@@ -18234,15 +18221,15 @@
     }
 });
 
 function yee(e, t, n, i, r) {
     let s;
     if (t == null || (i === "bgrect" && n.interactive === !1 && (e["pointer-events"] = "none"), i === "bgfore" && (n.interactive === !1 && (e["pointer-events"] = "none"), e.display = "none", t.fill !== null)))
         return e;
-    i === "image" && t.smooth === !1 && (s = ["image-rendering: optimizeSpeed;", "image-rendering: pixelated;"]), i === "text" && (e["font-family"] = mg(t), e["font-size"] = $s(t) + "px", e["font-style"] = t.fontStyle, e["font-variant"] = t.fontVariant, e["font-weight"] = t.fontWeight);
+    i === "image" && t.smooth === !1 && (s = ["image-rendering: optimizeSpeed;", "image-rendering: pixelated;"]), i === "text" && (e["font-family"] = mg(t), e["font-size"] = Cs(t) + "px", e["font-style"] = t.fontStyle, e["font-variant"] = t.fontVariant, e["font-weight"] = t.fontWeight);
     for (const o in n0) {
         let a = t[o];
         const u = n0[o];
         a === "transparent" && (u === "fill" || u === "stroke") || a != null && (hS(a) && (a = uO(a, r.gradient, "")), e[u] = a);
     }
     for (const o in i0) {
         const a = t[o];
@@ -18259,32 +18246,32 @@
 function bee(e) {
     br.svgMarkTypes = e.svgMarkTypes ?? ["text"], br.svgOnTop = e.svgOnTop ?? !0, br.debug = e.debug ?? !1;
 }
 
 function r0(e) {
     Ri.call(this, e), this._svgRenderer = new uy(e), this._canvasRenderer = new wh(e);
 }
-const F$ = Ri.prototype;
-Q(r0, Ri, {
+const FC = Ri.prototype;
+Z(r0, Ri, {
     /**
      * Initialize a new HybridRenderer instance.
      * @param {DOMElement} el - The containing DOM element for the display.
      * @param {number} width - The coordinate width of the display, in pixels.
      * @param {number} height - The coordinate height of the display, in pixels.
      * @param {Array<number>} origin - The origin of the display, in pixels.
      *   The coordinate system will be translated to this point.
      * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
      *   the width and height to determine the final pixel size.
      * @return {HybridRenderer} - This renderer instance.
      */
     initialize(e, t, n, i, r) {
-        this._root_el = Mt(e, 0, "div");
-        const s = Mt(this._root_el, 0, "div"),
-            o = Mt(this._root_el, 1, "div");
-        return this._root_el.style.position = "relative", br.debug || (s.style.height = "100%", o.style.position = "absolute", o.style.top = "0", o.style.left = "0", o.style.height = "100%", o.style.width = "100%"), this._svgEl = br.svgOnTop ? o : s, this._canvasEl = br.svgOnTop ? s : o, this._svgEl.style.pointerEvents = "none", this._canvasRenderer.initialize(this._canvasEl, t, n, i, r), this._svgRenderer.initialize(this._svgEl, t, n, i, r), F$.initialize.call(this, e, t, n, i, r);
+        this._root_el = Tt(e, 0, "div");
+        const s = Tt(this._root_el, 0, "div"),
+            o = Tt(this._root_el, 1, "div");
+        return this._root_el.style.position = "relative", br.debug || (s.style.height = "100%", o.style.position = "absolute", o.style.top = "0", o.style.left = "0", o.style.height = "100%", o.style.width = "100%"), this._svgEl = br.svgOnTop ? o : s, this._canvasEl = br.svgOnTop ? s : o, this._svgEl.style.pointerEvents = "none", this._canvasRenderer.initialize(this._canvasEl, t, n, i, r), this._svgRenderer.initialize(this._svgEl, t, n, i, r), FC.initialize.call(this, e, t, n, i, r);
     },
     /**
      * Flag a mark item as dirty.
      * @param {Item} item - The mark item.
      */
     dirty(e) {
         return br.svgMarkTypes.includes(e.mark.marktype) ? this._svgRenderer.dirty(e) : this._canvasRenderer.dirty(e), this;
@@ -18306,27 +18293,27 @@
      * @param {Array<number>} origin - The new origin of the display, in pixels.
      *   The coordinate system will be translated to this point.
      * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
      *   the width and height to determine the final pixel size.
      * @return {SVGRenderer} - This renderer instance;
      */
     resize(e, t, n, i) {
-        return F$.resize.call(this, e, t, n, i), this._svgRenderer.resize(e, t, n, i), this._canvasRenderer.resize(e, t, n, i), this;
+        return FC.resize.call(this, e, t, n, i), this._svgRenderer.resize(e, t, n, i), this._canvasRenderer.resize(e, t, n, i), this;
     },
     background(e) {
         return br.svgOnTop ? this._canvasRenderer.background(e) : this._svgRenderer.background(e), this;
     }
 });
 
 function jS(e, t) {
     Ea.call(this, e, t);
 }
-Q(jS, Ea, {
+Z(jS, Ea, {
     initialize(e, t, n) {
-        const i = Mt(Mt(e, 0, "div"), br.svgOnTop ? 0 : 1, "div");
+        const i = Tt(Tt(e, 0, "div"), br.svgOnTop ? 0 : 1, "div");
         return Ea.prototype.initialize.call(this, i, t, n);
     }
 });
 const JO = "canvas",
     QO = "hybrid",
     ZO = "png",
     eD = "svg",
@@ -18360,15 +18347,15 @@
     return e = String(e || "").toLowerCase(), arguments.length > 1 ? (qu[e] = t, this) : qu[e];
 }
 
 function nD(e, t, n) {
     const i = [],
         r = new $t().union(t),
         s = e.marktype;
-    return s ? iD(e, r, n, i) : s === "group" ? rD(e, r, n, i) : q("Intersect scene must be mark node or group item.");
+    return s ? iD(e, r, n, i) : s === "group" ? rD(e, r, n, i) : W("Intersect scene must be mark node or group item.");
 }
 
 function iD(e, t, n, i) {
     if (vee(e, t, n)) {
         const r = e.items,
             s = e.marktype,
             o = r.length;
@@ -18419,15 +18406,15 @@
     else
         return;
     e.bounds.intersect(dv);
 }
 const xee = 1e-9;
 
 function qS(e, t, n) {
-    return e === t ? !0 : n === "path" ? aD(e, t) : e instanceof Date && t instanceof Date ? +e == +t : ze(e) && ze(t) ? Math.abs(e - t) <= xee : !e || !t || !re(e) && !re(t) ? e == t : wee(e, t);
+    return e === t ? !0 : n === "path" ? aD(e, t) : e instanceof Date && t instanceof Date ? +e == +t : ze(e) && ze(t) ? Math.abs(e - t) <= xee : !e || !t || !oe(e) && !oe(t) ? e == t : wee(e, t);
 }
 
 function aD(e, t) {
     return qS(Oc(e), Oc(t));
 }
 
 function wee(e, t) {
@@ -18454,17 +18441,17 @@
     Sa = "bottom",
     Eee = "top-left",
     See = "top-right",
     kee = "bottom-left",
     Aee = "bottom-right",
     WS = "start",
     xx = "middle",
-    Tn = "end",
-    $ee = "x",
-    Cee = "y",
+    Fn = "end",
+    Cee = "x",
+    $ee = "y",
     cy = "group",
     HS = "axis",
     GS = "title",
     Mee = "frame",
     Tee = "scope",
     VS = "legend",
     uD = "row-header",
@@ -18485,15 +18472,15 @@
     XS = "flush",
     Xo = "column",
     Ko = "row";
 
 function yD(e) {
     B.call(this, null, e);
 }
-Q(yD, B, {
+Z(yD, B, {
     transform(e, t) {
         const n = t.dataflow,
             i = e.mark,
             r = i.marktype,
             s = Ti[r],
             o = s.bound;
         let a = i.bounds,
@@ -18518,15 +18505,15 @@
         return oD(i), t.modifies("bounds");
     }
 });
 
 function lp(e, t, n) {
     return t(e.bounds.clear(), e, n);
 }
-const N$ = ":vega_identifier:";
+const NC = ":vega_identifier:";
 
 function KS(e) {
     B.call(this, 0, e);
 }
 KS.Definition = {
     type: "Identifier",
     metadata: {
@@ -18534,31 +18521,31 @@
     },
     params: [{
         name: "as",
         type: "string",
         required: !0
     }]
 };
-Q(KS, B, {
+Z(KS, B, {
     transform(e, t) {
         const n = Dee(t.dataflow),
             i = e.as;
         let r = n.value;
         return t.visit(t.ADD, (s) => s[i] = s[i] || ++r), n.set(this.value = r), t;
     }
 });
 
 function Dee(e) {
-    return e._signals[N$] || (e._signals[N$] = e.add(0));
+    return e._signals[NC] || (e._signals[NC] = e.add(0));
 }
 
 function bD(e) {
     B.call(this, null, e);
 }
-Q(bD, B, {
+Z(bD, B, {
     transform(e, t) {
         let n = this.value;
         n || (n = t.dataflow.scenegraph().mark(e.markdef, Ree(e), e.index), n.group.context = e.context, e.context.group || (e.context.group = n.group), n.source = this.source, n.clip = e.clip, n.interactive = e.interactive, this.value = n);
         const i = n.marktype === cy ? ey : Z1;
         return t.visit(t.ADD, (r) => i.call(r, n)), (e.modified("clip") || e.modified("interactive")) && (n.clip = e.clip, n.interactive = !!e.interactive, n.zdirty = !0, t.reflow()), n.items = t.source, t;
     }
 });
@@ -18568,54 +18555,54 @@
         n = e.parent;
     return t && t.size === 1 ? t.get(Object.keys(t.object)[0]) : t && n ? t.lookup(n) : null;
 }
 
 function vD(e) {
     B.call(this, null, e);
 }
-const O$ = {
+const OC = {
         parity: (e) => e.filter((t, n) => n % 2 ? t.opacity = 0 : 1),
         greedy: (e, t) => {
             let n;
             return e.filter((i, r) => !r || !xD(n.bounds, i.bounds, t) ? (n = i, 1) : i.opacity = 0);
         }
     },
     xD = (e, t, n) => n > Math.max(t.x1 - e.x2, e.x1 - t.x2, t.y1 - e.y2, e.y1 - t.y2),
-    D$ = (e, t) => {
+    DC = (e, t) => {
         for (var n = 1, i = e.length, r = e[0].bounds, s; n < i; r = s, ++n)
             if (xD(r, s = e[n].bounds, t))
                 return !0;
     },
     Lee = (e) => {
         const t = e.bounds;
         return t.width() > 1 && t.height() > 1;
     },
     Iee = (e, t, n) => {
         var i = e.range(),
             r = new $t();
         return t === Lc || t === Sa ? r.set(i[0], -1 / 0, i[1], 1 / 0) : r.set(-1 / 0, i[0], 1 / 0, i[1]), r.expand(n || 1), (s) => r.encloses(s.bounds);
     },
-    R$ = (e) => (e.forEach((t) => t.opacity = 1), e),
-    L$ = (e, t) => e.reflow(t.modified()).modifies("opacity");
-Q(vD, B, {
+    RC = (e) => (e.forEach((t) => t.opacity = 1), e),
+    LC = (e, t) => e.reflow(t.modified()).modifies("opacity");
+Z(vD, B, {
     transform(e, t) {
-        const n = O$[e.method] || O$.parity,
+        const n = OC[e.method] || OC.parity,
             i = e.separation || 0;
         let r = t.materialize(t.SOURCE).source,
             s, o;
         if (!r || !r.length)
             return;
         if (!e.method)
-            return e.modified("method") && (R$(r), t = L$(t, e)), t;
+            return e.modified("method") && (RC(r), t = LC(t, e)), t;
         if (r = r.filter(Lee), !r.length)
             return;
-        if (e.sort && (r = r.slice().sort(e.sort)), s = R$(r), t = L$(t, e), s.length >= 3 && D$(s, i)) {
+        if (e.sort && (r = r.slice().sort(e.sort)), s = RC(r), t = LC(t, e), s.length >= 3 && DC(s, i)) {
             do
                 s = n(s, i);
-            while (s.length >= 3 && D$(s, i));
+            while (s.length >= 3 && DC(s, i));
             s.length < 3 && !Ie(r).opacity && (s.length > 1 && (Ie(s).opacity = 0), Ie(r).opacity = 1);
         }
         e.boundScale && e.boundTolerance >= 0 && (o = Iee(e.boundScale, e.boundOrient, +e.boundTolerance), r.forEach((u) => {
             o(u) || (u.opacity = 0);
         }));
         const a = s[0].mark.bounds.clear();
         return r.forEach((u) => {
@@ -18623,24 +18610,24 @@
         }), t;
     }
 });
 
 function wD(e) {
     B.call(this, null, e);
 }
-Q(wD, B, {
+Z(wD, B, {
     transform(e, t) {
         const n = t.dataflow;
         if (t.visit(t.ALL, (i) => n.dirty(i)), t.fields && t.fields.zindex) {
             const i = t.source && t.source[0];
             i && (i.mark.zdirty = !0);
         }
     }
 });
-const ln = new $t();
+const cn = new $t();
 
 function sc(e, t, n) {
     return e[t] === n ? 0 : (e[t] = n, 1);
 }
 
 function Pee(e) {
     var t = e.items[0].orient;
@@ -18673,15 +18660,15 @@
         g = s.title && r.items[u[2]].items[0],
         p = r.titlePadding,
         m = r.bounds,
         y = g && TS(g),
         b = 0,
         v = 0,
         x, w;
-    switch (ln.clear().union(m), m.clear(), (x = u[0]) > -1 && m.union(r.items[x].bounds), (x = u[1]) > -1 && m.union(r.items[x].bounds), a) {
+    switch (cn.clear().union(m), m.clear(), (x = u[0]) > -1 && m.union(r.items[x].bounds), (x = u[1]) > -1 && m.union(r.items[x].bounds), a) {
         case Lc:
             b = f || 0, v = -c, w = Math.max(d, Math.min(h, -m.y1)), m.add(0, -w).add(l, 0), g && cp(e, g, w, p, y, 0, -1, m);
             break;
         case _r:
             b = -c, v = f || 0, w = Math.max(d, Math.min(h, -m.x1)), m.add(-w, 0).add(0, l), g && cp(e, g, w, p, y, 1, -1, m);
             break;
         case Er:
@@ -18689,29 +18676,29 @@
             break;
         case Sa:
             b = f || 0, v = i + c, w = Math.max(d, Math.min(h, m.y2)), m.add(0, 0).add(l, w), g && cp(e, g, w, p, 0, 0, 1, m);
             break;
         default:
             b = r.x, v = r.y;
     }
-    return _o(m.translate(b, v), r), sc(r, "x", b + o) | sc(r, "y", v + o) && (r.bounds = ln, e.dirty(r), r.bounds = m, e.dirty(r)), r.mark.bounds.clear().union(m);
+    return _o(m.translate(b, v), r), sc(r, "x", b + o) | sc(r, "y", v + o) && (r.bounds = cn, e.dirty(r), r.bounds = m, e.dirty(r)), r.mark.bounds.clear().union(m);
 }
 
 function cp(e, t, n, i, r, s, o, a) {
     const u = t.bounds;
     if (t.auto) {
         const l = o * (n + r + i);
         let c = 0,
             f = 0;
         e.dirty(t), s ? c = (t.x || 0) - (t.x = l) : f = (t.y || 0) - (t.y = l), t.mark.bounds.clear().union(u.translate(-c, -f)), e.dirty(t);
     }
     a.union(u);
 }
-const I$ = (e, t) => Math.floor(Math.min(e, t)),
-    P$ = (e, t) => Math.ceil(Math.max(e, t));
+const IC = (e, t) => Math.floor(Math.min(e, t)),
+    PC = (e, t) => Math.ceil(Math.max(e, t));
 
 function Uee(e) {
     var t = e.items,
         n = t.length,
         i = 0,
         r, s;
     const o = {
@@ -18759,161 +18746,161 @@
 }
 
 function qee(e) {
     const t = e.bounds.clone();
     return t.empty() ? t.set(0, 0, 0, 0) : t.translate(-(e.x || 0), -(e.y || 0));
 }
 
-function lt(e, t, n) {
-    const i = re(e) ? e[t] : e;
+function ct(e, t, n) {
+    const i = oe(e) ? e[t] : e;
     return i ?? (n !== void 0 ? n : 0);
 }
 
-function z$(e) {
+function zC(e) {
     return e < 0 ? Math.ceil(-e) : 0;
 }
 
 function _D(e, t, n) {
     var i = !n.nodirty,
         r = n.bounds === XS ? jee : qee,
-        s = ln.set(0, 0, 0, 0),
-        o = lt(n.align, Xo),
-        a = lt(n.align, Ko),
-        u = lt(n.padding, Xo),
-        l = lt(n.padding, Ko),
+        s = cn.set(0, 0, 0, 0),
+        o = ct(n.align, Xo),
+        a = ct(n.align, Ko),
+        u = ct(n.padding, Xo),
+        l = ct(n.padding, Ko),
         c = n.columns || t.length,
         f = c <= 0 ? 1 : Math.ceil(t.length / c),
         d = t.length,
         h = Array(d),
         g = Array(c),
         p = 0,
         m = Array(d),
         y = Array(f),
         b = 0,
         v = Array(d),
         x = Array(d),
         w = Array(d),
-        S, _, k, A, F, T, I, N, D, M, E;
+        E, _, k, A, T, M, L, F, O, N, R;
     for (_ = 0; _ < c; ++_)
         g[_] = 0;
     for (_ = 0; _ < f; ++_)
         y[_] = 0;
     for (_ = 0; _ < d; ++_)
-        T = t[_], F = w[_] = r(T), T.x = T.x || 0, v[_] = 0, T.y = T.y || 0, x[_] = 0, k = _ % c, A = ~~(_ / c), p = Math.max(p, I = Math.ceil(F.x2)), b = Math.max(b, N = Math.ceil(F.y2)), g[k] = Math.max(g[k], I), y[A] = Math.max(y[A], N), h[_] = u + z$(F.x1), m[_] = l + z$(F.y1), i && e.dirty(t[_]);
+        M = t[_], T = w[_] = r(M), M.x = M.x || 0, v[_] = 0, M.y = M.y || 0, x[_] = 0, k = _ % c, A = ~~(_ / c), p = Math.max(p, L = Math.ceil(T.x2)), b = Math.max(b, F = Math.ceil(T.y2)), g[k] = Math.max(g[k], L), y[A] = Math.max(y[A], F), h[_] = u + zC(T.x1), m[_] = l + zC(T.y1), i && e.dirty(t[_]);
     for (_ = 0; _ < d; ++_)
         _ % c === 0 && (h[_] = 0), _ < c && (m[_] = 0);
     if (o === wx)
         for (k = 1; k < c; ++k) {
-            for (E = 0, _ = k; _ < d; _ += c)
-                E < h[_] && (E = h[_]);
+            for (R = 0, _ = k; _ < d; _ += c)
+                R < h[_] && (R = h[_]);
             for (_ = k; _ < d; _ += c)
-                h[_] = E + g[k - 1];
+                h[_] = R + g[k - 1];
         }
     else if (o === up) {
-        for (E = 0, _ = 0; _ < d; ++_)
-            _ % c && E < h[_] && (E = h[_]);
+        for (R = 0, _ = 0; _ < d; ++_)
+            _ % c && R < h[_] && (R = h[_]);
         for (_ = 0; _ < d; ++_)
-            _ % c && (h[_] = E + p);
+            _ % c && (h[_] = R + p);
     } else
         for (o = !1, k = 1; k < c; ++k)
             for (_ = k; _ < d; _ += c)
                 h[_] += g[k - 1];
     if (a === wx)
         for (A = 1; A < f; ++A) {
-            for (E = 0, _ = A * c, S = _ + c; _ < S; ++_)
-                E < m[_] && (E = m[_]);
-            for (_ = A * c; _ < S; ++_)
-                m[_] = E + y[A - 1];
+            for (R = 0, _ = A * c, E = _ + c; _ < E; ++_)
+                R < m[_] && (R = m[_]);
+            for (_ = A * c; _ < E; ++_)
+                m[_] = R + y[A - 1];
         }
     else if (a === up) {
-        for (E = 0, _ = c; _ < d; ++_)
-            E < m[_] && (E = m[_]);
+        for (R = 0, _ = c; _ < d; ++_)
+            R < m[_] && (R = m[_]);
         for (_ = c; _ < d; ++_)
-            m[_] = E + b;
+            m[_] = R + b;
     } else
         for (a = !1, A = 1; A < f; ++A)
-            for (_ = A * c, S = _ + c; _ < S; ++_)
+            for (_ = A * c, E = _ + c; _ < E; ++_)
                 m[_] += y[A - 1];
-    for (D = 0, _ = 0; _ < d; ++_)
-        D = h[_] + (_ % c ? D : 0), v[_] += D - t[_].x;
+    for (O = 0, _ = 0; _ < d; ++_)
+        O = h[_] + (_ % c ? O : 0), v[_] += O - t[_].x;
     for (k = 0; k < c; ++k)
-        for (M = 0, _ = k; _ < d; _ += c)
-            M += m[_], x[_] += M - t[_].y;
-    if (o && lt(n.center, Xo) && f > 1)
+        for (N = 0, _ = k; _ < d; _ += c)
+            N += m[_], x[_] += N - t[_].y;
+    if (o && ct(n.center, Xo) && f > 1)
         for (_ = 0; _ < d; ++_)
-            F = o === up ? p : g[_ % c], D = F - w[_].x2 - t[_].x - v[_], D > 0 && (v[_] += D / 2);
-    if (a && lt(n.center, Ko) && c !== 1)
+            T = o === up ? p : g[_ % c], O = T - w[_].x2 - t[_].x - v[_], O > 0 && (v[_] += O / 2);
+    if (a && ct(n.center, Ko) && c !== 1)
         for (_ = 0; _ < d; ++_)
-            F = a === up ? b : y[~~(_ / c)], M = F - w[_].y2 - t[_].y - x[_], M > 0 && (x[_] += M / 2);
+            T = a === up ? b : y[~~(_ / c)], N = T - w[_].y2 - t[_].y - x[_], N > 0 && (x[_] += N / 2);
     for (_ = 0; _ < d; ++_)
         s.union(w[_].translate(v[_], x[_]));
-    switch (D = lt(n.anchor, $ee), M = lt(n.anchor, Cee), lt(n.anchor, Xo)) {
-        case Tn:
-            D -= s.width();
+    switch (O = ct(n.anchor, Cee), N = ct(n.anchor, $ee), ct(n.anchor, Xo)) {
+        case Fn:
+            O -= s.width();
             break;
         case xx:
-            D -= s.width() / 2;
+            O -= s.width() / 2;
     }
-    switch (lt(n.anchor, Ko)) {
-        case Tn:
-            M -= s.height();
+    switch (ct(n.anchor, Ko)) {
+        case Fn:
+            N -= s.height();
             break;
         case xx:
-            M -= s.height() / 2;
+            N -= s.height() / 2;
     }
-    for (D = Math.round(D), M = Math.round(M), s.clear(), _ = 0; _ < d; ++_)
+    for (O = Math.round(O), N = Math.round(N), s.clear(), _ = 0; _ < d; ++_)
         t[_].mark.bounds.clear();
     for (_ = 0; _ < d; ++_)
-        T = t[_], T.x += v[_] += D, T.y += x[_] += M, s.union(T.mark.bounds.union(T.bounds.translate(v[_], x[_]))), i && e.dirty(T);
+        M = t[_], M.x += v[_] += O, M.y += x[_] += N, s.union(M.mark.bounds.union(M.bounds.translate(v[_], x[_]))), i && e.dirty(M);
     return s;
 }
 
 function Wee(e, t, n) {
     var i = Uee(t),
         r = i.marks,
         s = n.bounds === XS ? Hee : Gee,
         o = n.offset,
         a = n.columns || r.length,
         u = a <= 0 ? 1 : Math.ceil(r.length / a),
         l = u * a,
         c, f, d, h, g, p, m;
     const y = _D(e, r, n);
-    y.empty() && y.set(0, 0, 0, 0), i.rowheaders && (p = lt(n.headerBand, Ko, null), c = fp(e, i.rowheaders, r, a, u, -lt(o, "rowHeader"), I$, 0, s, "x1", 0, a, 1, p)), i.colheaders && (p = lt(n.headerBand, Xo, null), f = fp(e, i.colheaders, r, a, a, -lt(o, "columnHeader"), I$, 1, s, "y1", 0, 1, a, p)), i.rowfooters && (p = lt(n.footerBand, Ko, null), d = fp(e, i.rowfooters, r, a, u, lt(o, "rowFooter"), P$, 0, s, "x2", a - 1, a, 1, p)), i.colfooters && (p = lt(n.footerBand, Xo, null), h = fp(e, i.colfooters, r, a, a, lt(o, "columnFooter"), P$, 1, s, "y2", l - a, 1, a, p)), i.rowtitle && (g = lt(n.titleAnchor, Ko), m = lt(o, "rowTitle"), m = g === Tn ? d + m : c - m, p = lt(n.titleBand, Ko, 0.5), B$(e, i.rowtitle, m, 0, y, p)), i.coltitle && (g = lt(n.titleAnchor, Xo), m = lt(o, "columnTitle"), m = g === Tn ? h + m : f - m, p = lt(n.titleBand, Xo, 0.5), B$(e, i.coltitle, m, 1, y, p));
+    y.empty() && y.set(0, 0, 0, 0), i.rowheaders && (p = ct(n.headerBand, Ko, null), c = fp(e, i.rowheaders, r, a, u, -ct(o, "rowHeader"), IC, 0, s, "x1", 0, a, 1, p)), i.colheaders && (p = ct(n.headerBand, Xo, null), f = fp(e, i.colheaders, r, a, a, -ct(o, "columnHeader"), IC, 1, s, "y1", 0, 1, a, p)), i.rowfooters && (p = ct(n.footerBand, Ko, null), d = fp(e, i.rowfooters, r, a, u, ct(o, "rowFooter"), PC, 0, s, "x2", a - 1, a, 1, p)), i.colfooters && (p = ct(n.footerBand, Xo, null), h = fp(e, i.colfooters, r, a, a, ct(o, "columnFooter"), PC, 1, s, "y2", l - a, 1, a, p)), i.rowtitle && (g = ct(n.titleAnchor, Ko), m = ct(o, "rowTitle"), m = g === Fn ? d + m : c - m, p = ct(n.titleBand, Ko, 0.5), BC(e, i.rowtitle, m, 0, y, p)), i.coltitle && (g = ct(n.titleAnchor, Xo), m = ct(o, "columnTitle"), m = g === Fn ? h + m : f - m, p = ct(n.titleBand, Xo, 0.5), BC(e, i.coltitle, m, 1, y, p));
 }
 
 function Hee(e, t) {
     return t === "x1" ? e.x || 0 : t === "y1" ? e.y || 0 : t === "x2" ? (e.x || 0) + (e.width || 0) : t === "y2" ? (e.y || 0) + (e.height || 0) : void 0;
 }
 
 function Gee(e, t) {
     return e.bounds[t];
 }
 
 function fp(e, t, n, i, r, s, o, a, u, l, c, f, d, h) {
     var g = n.length,
         p = 0,
         m = 0,
-        y, b, v, x, w, S, _, k, A;
+        y, b, v, x, w, E, _, k, A;
     if (!g)
         return p;
     for (y = c; y < g; y += f)
         n[y] && (p = o(p, u(n[y], l)));
     if (!t.length)
         return p;
     for (t.length > r && (e.warn("Grid headers exceed limit: " + r), t = t.slice(0, r)), p += s, b = 0, x = t.length; b < x; ++b)
         e.dirty(t[b]), t[b].mark.bounds.clear();
     for (y = c, b = 0, x = t.length; b < x; ++b, y += f) {
-        for (S = t[b], w = S.mark.bounds, v = y; v >= 0 && (_ = n[v]) == null; v -= d)
+        for (E = t[b], w = E.mark.bounds, v = y; v >= 0 && (_ = n[v]) == null; v -= d)
         ;
-        a ? (k = h == null ? _.x : Math.round(_.bounds.x1 + h * _.bounds.width()), A = p) : (k = p, A = h == null ? _.y : Math.round(_.bounds.y1 + h * _.bounds.height())), w.union(S.bounds.translate(k - (S.x || 0), A - (S.y || 0))), S.x = k, S.y = A, e.dirty(S), m = o(m, w[l]);
+        a ? (k = h == null ? _.x : Math.round(_.bounds.x1 + h * _.bounds.width()), A = p) : (k = p, A = h == null ? _.y : Math.round(_.bounds.y1 + h * _.bounds.height())), w.union(E.bounds.translate(k - (E.x || 0), A - (E.y || 0))), E.x = k, E.y = A, e.dirty(E), m = o(m, w[l]);
     }
     return m;
 }
 
-function B$(e, t, n, i, r, s) {
+function BC(e, t, n, i, r, s) {
     if (t) {
         e.dirty(t);
         var o = n,
             a = n;
         i ? o = Math.round(r.x1 + s * r.width()) : a = Math.round(r.y1 + s * r.height()), t.bounds.translate(o - (t.x || 0), a - (t.y || 0)), t.mark.bounds.clear().union(t.bounds), t.x = o, t.y = a, e.dirty(t);
     }
 }
@@ -18930,43 +18917,43 @@
     }), n > -1 / 0 ? n : t;
 }
 
 function Xee(e, t, n, i, r, s, o) {
     const a = Vee(n, t),
         u = Yee(e, a("offset", 0)),
         l = a("anchor", WS),
-        c = l === Tn ? 1 : l === xx ? 0.5 : 0,
+        c = l === Fn ? 1 : l === xx ? 0.5 : 0,
         f = {
             align: wx,
             bounds: a("bounds", XS),
             columns: a("direction") === "vertical" ? 1 : e.length,
             padding: a("margin", 8),
             center: a("center"),
             nodirty: !0
         };
     switch (t) {
         case _r:
             f.anchor = {
                 x: Math.floor(i.x1) - u,
-                column: Tn,
+                column: Fn,
                 y: c * (o || i.height() + 2 * i.y1),
                 row: l
             };
             break;
         case Er:
             f.anchor = {
                 x: Math.ceil(i.x2) + u,
                 y: c * (o || i.height() + 2 * i.y1),
                 row: l
             };
             break;
         case Lc:
             f.anchor = {
                 y: Math.floor(r.y1) - u,
-                row: Tn,
+                row: Fn,
                 x: c * (s || r.width() + 2 * r.x1),
                 column: l
             };
             break;
         case Sa:
             f.anchor = {
                 y: Math.ceil(r.y2) + u,
@@ -18980,30 +18967,30 @@
                 y: u
             };
             break;
         case See:
             f.anchor = {
                 x: s - u,
                 y: u,
-                column: Tn
+                column: Fn
             };
             break;
         case kee:
             f.anchor = {
                 x: u,
                 y: o - u,
-                row: Tn
+                row: Fn
             };
             break;
         case Aee:
             f.anchor = {
                 x: s - u,
                 y: o - u,
-                column: Tn,
-                row: Tn
+                column: Fn,
+                row: Fn
             };
             break;
     }
     return f;
 }
 
 function Kee(e, t) {
@@ -19044,18 +19031,18 @@
                 s += o.bounds.height() + u;
         }
         switch ((r || s) && Zf(e, n, r, s), o.orient) {
             case _r:
                 c += Bl(t, n, o, a, 1, 1);
                 break;
             case Er:
-                l += Bl(t, n, o, Tn, 0, 0) + u, c += Bl(t, n, o, a, 1, 1);
+                l += Bl(t, n, o, Fn, 0, 0) + u, c += Bl(t, n, o, a, 1, 1);
                 break;
             case Sa:
-                l += Bl(t, n, o, a, 0, 0), c += Bl(t, n, o, Tn, -1, 0, 1) + u;
+                l += Bl(t, n, o, a, 0, 0), c += Bl(t, n, o, Fn, -1, 0, 1) + u;
                 break;
             default:
                 l += Bl(t, n, o, a, 0, 0);
         }
         (l || c) && Zf(e, o, l, c), (l = Math.round(o.bounds.x1 - i)) < 0 && (Zf(e, n, -l, 0), Zf(e, o, -l, 0));
     }
 }
@@ -19064,15 +19051,15 @@
     const a = e.datum.type !== "symbol",
         u = n.datum.vgrad,
         l = a && (s || !u) && !o ? t.items[0] : t,
         c = l.bounds[r ? "y2" : "x2"] - e.padding,
         f = u && s ? c : 0,
         d = u && s ? 0 : c,
         h = r <= 0 ? 0 : TS(n);
-    return Math.round(i === WS ? f : i === Tn ? d - h : 0.5 * (c - h));
+    return Math.round(i === WS ? f : i === Fn ? d - h : 0.5 * (c - h));
 }
 
 function Zf(e, t, n, i) {
     t.x += n, t.y += i, t.bounds.translate(n, i), t.mark.bounds.translate(n, i), e.dirty(t);
 }
 
 function Zee(e) {
@@ -19094,53 +19081,53 @@
         h = a === _r || a === Er ? i : n,
         g = 0,
         p = 0,
         m = 0,
         y = 0,
         b = 0,
         v;
-    if (o !== cy ? a === _r ? (g = r.y2, h = r.y1) : a === Er ? (g = r.y1, h = r.y2) : (g = r.x1, h = r.x2) : a === _r && (g = i, h = 0), v = u === WS ? g : u === Tn ? h : (g + h) / 2, d && d.text) {
+    if (o !== cy ? a === _r ? (g = r.y2, h = r.y1) : a === Er ? (g = r.y1, h = r.y2) : (g = r.x1, h = r.x2) : a === _r && (g = i, h = 0), v = u === WS ? g : u === Fn ? h : (g + h) / 2, d && d.text) {
         switch (a) {
             case Lc:
             case Sa:
                 b = f.bounds.height() + c;
                 break;
             case _r:
                 y = f.bounds.width() + c;
                 break;
             case Er:
                 y = -f.bounds.width() - c;
                 break;
         }
-        ln.clear().union(d.bounds), ln.translate(y - (d.x || 0), b - (d.y || 0)), sc(d, "x", y) | sc(d, "y", b) && (e.dirty(d), d.bounds.clear().union(ln), d.mark.bounds.clear().union(ln), e.dirty(d)), ln.clear().union(d.bounds);
+        cn.clear().union(d.bounds), cn.translate(y - (d.x || 0), b - (d.y || 0)), sc(d, "x", y) | sc(d, "y", b) && (e.dirty(d), d.bounds.clear().union(cn), d.mark.bounds.clear().union(cn), e.dirty(d)), cn.clear().union(d.bounds);
     } else
-        ln.clear();
-    switch (ln.union(f.bounds), a) {
+        cn.clear();
+    switch (cn.union(f.bounds), a) {
         case Lc:
-            p = v, m = r.y1 - ln.height() - l;
+            p = v, m = r.y1 - cn.height() - l;
             break;
         case _r:
-            p = r.x1 - ln.width() - l, m = v;
+            p = r.x1 - cn.width() - l, m = v;
             break;
         case Er:
-            p = r.x2 + ln.width() + l, m = v;
+            p = r.x2 + cn.width() + l, m = v;
             break;
         case Sa:
             p = v, m = r.y2 + l;
             break;
         default:
             p = s.x, m = s.y;
     }
-    return sc(s, "x", p) | sc(s, "y", m) && (ln.translate(p, m), e.dirty(s), s.bounds.clear().union(ln), t.bounds.clear().union(ln), e.dirty(s)), s.bounds;
+    return sc(s, "x", p) | sc(s, "y", m) && (cn.translate(p, m), e.dirty(s), s.bounds.clear().union(cn), t.bounds.clear().union(cn), e.dirty(s)), s.bounds;
 }
 
 function ED(e) {
     B.call(this, null, e);
 }
-Q(ED, B, {
+Z(ED, B, {
     transform(e, t) {
         const n = t.dataflow;
         return e.mark.items.forEach((i) => {
             e.layout && Wee(n, i, e.layout), nte(n, i, e);
         }), tte(e.mark.group) ? t.reflow() : t;
     }
 });
@@ -19240,15 +19227,15 @@
 }, Symbol.toStringTag, {
     value: "Module"
 }));
 
 function SD(e) {
     B.call(this, null, e);
 }
-Q(SD, B, {
+Z(SD, B, {
     transform(e, t) {
         if (this.value && !e.modified())
             return t.StopPropagation;
         var n = t.dataflow.locale(),
             i = t.fork(t.NO_SOURCE | t.NO_FIELDS),
             r = this.value,
             s = e.scale,
@@ -19278,22 +19265,22 @@
     return Ge({});
 }
 
 function ote(e) {
     const t = hf().test((n) => n.exit);
     return t.lookup = (n) => t.get(e(n)), t;
 }
-Q(kD, B, {
+Z(kD, B, {
     transform(e, t) {
         var n = t.dataflow,
             i = t.fork(t.NO_SOURCE | t.NO_FIELDS),
             r = e.item || ste,
-            s = e.key || me,
+            s = e.key || be,
             o = this.value;
-        return W(i.encode) && (i.encode = null), o && (e.modified("key") || t.modified(s)) && q("DataJoin does not support modified key function or fields."), o || (t = t.addAll(), this.value = o = ote(s)), t.visit(t.ADD, (a) => {
+        return V(i.encode) && (i.encode = null), o && (e.modified("key") || t.modified(s)) && W("DataJoin does not support modified key function or fields."), o || (t = t.addAll(), this.value = o = ote(s)), t.visit(t.ADD, (a) => {
             const u = s(a);
             let l = o.get(u);
             l ? l.exit ? (o.empty--, i.add.push(l)) : i.mod.push(l) : (l = r(a), o.set(u, l), i.add.push(l)), l.datum = a, l.exit = !1;
         }), t.visit(t.MOD, (a) => {
             const u = s(a),
                 l = o.get(u);
             l && (l.datum = a, i.mod.push(l));
@@ -19304,21 +19291,21 @@
         }), t.changed(t.ADD_MOD) && i.modifies("datum"), (t.clean() || e.clean && o.empty > n.cleanThreshold) && n.runAfter(o.clean), i;
     }
 });
 
 function AD(e) {
     B.call(this, null, e);
 }
-Q(AD, B, {
+Z(AD, B, {
     transform(e, t) {
         var n = t.fork(t.ADD_REM),
             i = e.mod || !1,
             r = e.encoders,
             s = t.encode;
-        if (W(s))
+        if (V(s))
             if (n.changed() || s.every((f) => r[f]))
                 s = s[0], n.encode = null;
             else
                 return t.StopPropagation;
         var o = s === "enter",
             a = r.update || Ro,
             u = r.enter || Ro,
@@ -19339,33 +19326,33 @@
                 (c(d, e) || i) && n.mod.push(d);
             }), n.mod.length && n.modifies(c.output);
         }
         return n.changed() ? n : t.StopPropagation;
     }
 });
 
-function $D(e) {
+function CD(e) {
     B.call(this, [], e);
 }
-Q($D, B, {
+Z(CD, B, {
     transform(e, t) {
         if (this.value != null && !e.modified())
             return t.StopPropagation;
         var n = t.dataflow.locale(),
             i = t.fork(t.NO_SOURCE | t.NO_FIELDS),
             r = this.value,
             s = e.type || Zp,
             o = e.scale,
             a = +e.limit,
             u = fS(o, e.count == null ? 5 : e.count, e.minstep),
             l = !!e.values || s === Zp,
             c = e.format || sO(n, o, u, s, e.formatSpecifier, e.formatType, l),
             f = e.values || rO(o, u),
             d, h, g, p, m;
-        return r && (i.rem = r), s === Zp ? (a && f.length > a ? (t.dataflow.warn("Symbol legend count exceeds limit, filtering items."), r = f.slice(0, a - 1), m = !0) : r = f, Me(g = e.size) ? (!e.values && o(r[0]) === 0 && (r = r.slice(1)), p = r.reduce((y, b) => Math.max(y, g(b, e)), 0)) : g = kn(p = g || 8), r = r.map((y, b) => Ge({
+        return r && (i.rem = r), s === Zp ? (a && f.length > a ? (t.dataflow.warn("Symbol legend count exceeds limit, filtering items."), r = f.slice(0, a - 1), m = !0) : r = f, Me(g = e.size) ? (!e.values && o(r[0]) === 0 && (r = r.slice(1)), p = r.reduce((y, b) => Math.max(y, g(b, e)), 0)) : g = An(p = g || 8), r = r.map((y, b) => Ge({
             index: b,
             label: c(y, b, r),
             value: y,
             offset: p,
             size: g(y, e)
         })), m && (m = f[r.length], r.push(Ge({
             index: r.length,
@@ -19431,31 +19418,31 @@
         type: "signal"
     }, {
         name: "as",
         type: "string",
         default: "path"
     }]
 };
-Q(JS, B, {
+Z(JS, B, {
     transform(e, t) {
         var n = e.sourceX || ate,
             i = e.sourceY || ute,
             r = e.targetX || lte,
             s = e.targetY || cte,
             o = e.as || "path",
             a = e.orient || "vertical",
             u = e.shape || "line",
-            l = U$.get(u + "-" + a) || U$.get(u);
-        return l || q("LinkPath unsupported type: " + e.shape + (e.orient ? "-" + e.orient : "")), t.visit(t.SOURCE, (c) => {
+            l = UC.get(u + "-" + a) || UC.get(u);
+        return l || W("LinkPath unsupported type: " + e.shape + (e.orient ? "-" + e.orient : "")), t.visit(t.SOURCE, (c) => {
             c[o] = l(n(c), i(c), r(c), s(c));
         }), t.reflow(e.modified()).modifies(o);
     }
 });
-const CD = (e, t, n, i) => "M" + e + "," + t + "L" + n + "," + i,
-    fte = (e, t, n, i) => CD(t * Math.cos(e), t * Math.sin(e), i * Math.cos(n), i * Math.sin(n)),
+const $D = (e, t, n, i) => "M" + e + "," + t + "L" + n + "," + i,
+    fte = (e, t, n, i) => $D(t * Math.cos(e), t * Math.sin(e), i * Math.cos(n), i * Math.sin(n)),
     MD = (e, t, n, i) => {
         var r = n - e,
             s = i - t,
             o = Math.hypot(r, s) / 2,
             a = 180 * Math.atan2(s, r) / Math.PI;
         return "M" + e + "," + t + "A" + o + "," + o + " " + a + " 0 1 " + n + "," + i;
     },
@@ -19490,16 +19477,16 @@
         const r = Math.cos(e),
             s = Math.sin(e),
             o = Math.cos(n),
             a = Math.sin(n),
             u = (t + i) / 2;
         return "M" + t * r + "," + t * s + "C" + u * r + "," + u * s + " " + u * o + "," + u * a + " " + i * o + "," + i * a;
     },
-    U$ = hf({
-        line: CD,
+    UC = hf({
+        line: $D,
         "line-radial": fte,
         arc: MD,
         "arc-radial": dte,
         curve: TD,
         "curve-radial": hte,
         "orthogonal-horizontal": gte,
         "orthogonal-vertical": pte,
@@ -19536,28 +19523,28 @@
         name: "as",
         type: "string",
         array: !0,
         length: 2,
         default: ["startAngle", "endAngle"]
     }]
 };
-Q(QS, B, {
+Z(QS, B, {
     transform(e, t) {
         var n = e.as || ["startAngle", "endAngle"],
             i = n[0],
             r = n[1],
             s = e.field || cf,
             o = e.startAngle || 0,
             a = e.endAngle != null ? e.endAngle : 2 * Math.PI,
             u = t.source,
             l = u.map(s),
             c = l.length,
             f = o,
             d = (a - o) / go(l),
-            h = hn(c),
+            h = gn(c),
             g, p, m;
         for (e.sort && h.sort((y, b) => l[y] - l[b]), g = 0; g < c; ++g)
             m = l[h[g]], p = u[h[g]], p[i] = f, p[r] = f += m * d;
         return this.value = l, t.reflow(e.modified()).modifies(n);
     }
 });
 const xte = 5;
@@ -19571,140 +19558,140 @@
     return uS(e) && e !== us;
 }
 const _te = Fr(["set", "modified", "clear", "type", "scheme", "schemeExtent", "schemeCount", "domain", "domainMin", "domainMid", "domainMax", "domainRaw", "domainImplicit", "nice", "zero", "bins", "range", "rangeStep", "round", "reverse", "interpolate", "interpolateGamma"]);
 
 function ND(e) {
     B.call(this, null, e), this.modified(!0);
 }
-Q(ND, B, {
+Z(ND, B, {
     transform(e, t) {
         var n = t.dataflow,
             i = this.value,
             r = Ete(e);
         (!i || r !== i.type) && (this.value = i = qe(r)());
         for (r in e)
             if (!_te[r]) {
                 if (r === "padding" && FD(i.type))
                     continue;
                 Me(i[r]) ? i[r](e[r]) : n.warn("Unsupported scale property: " + r);
             }
-        return Mte(i, e, Cte(i, e, kte(i, e, n))), t.fork(t.NO_SOURCE | t.NO_FIELDS);
+        return Mte(i, e, $te(i, e, kte(i, e, n))), t.fork(t.NO_SOURCE | t.NO_FIELDS);
     }
 });
 
 function Ete(e) {
     var t = e.type,
         n = "",
         i;
     return t === us ? us + "-" + Tc : (Ste(e) && (i = e.rawDomain ? e.rawDomain.length : e.domain ? e.domain.length + +(e.domainMid != null) : 0, n = i === 2 ? us + "-" : i === 3 ? kf + "-" : ""), (n + t || Tc).toLowerCase());
 }
 
 function Ste(e) {
     const t = e.type;
-    return uS(t) && t !== Uu && t !== ju && (e.scheme || e.range && e.range.length && e.range.every(ie));
+    return uS(t) && t !== Uu && t !== ju && (e.scheme || e.range && e.range.length && e.range.every(se));
 }
 
 function kte(e, t, n) {
     const i = Ate(e, t.domainRaw, n);
     if (i > -1)
         return i;
     var r = t.domain,
         s = e.type,
         o = t.zero || t.zero === void 0 && wte(e),
         a, u;
     if (!r)
         return 0;
-    if (FD(s) && t.padding && r[0] !== Ie(r) && (r = $te(s, r, t.range, t.padding, t.exponent, t.constant)), (o || t.domainMin != null || t.domainMax != null || t.domainMid != null) && (a = (r = r.slice()).length - 1 || 1, o && (r[0] > 0 && (r[0] = 0), r[a] < 0 && (r[a] = 0)), t.domainMin != null && (r[0] = t.domainMin), t.domainMax != null && (r[a] = t.domainMax), t.domainMid != null)) {
+    if (FD(s) && t.padding && r[0] !== Ie(r) && (r = Cte(s, r, t.range, t.padding, t.exponent, t.constant)), (o || t.domainMin != null || t.domainMax != null || t.domainMid != null) && (a = (r = r.slice()).length - 1 || 1, o && (r[0] > 0 && (r[0] = 0), r[a] < 0 && (r[a] = 0)), t.domainMin != null && (r[0] = t.domainMin), t.domainMax != null && (r[a] = t.domainMax), t.domainMid != null)) {
         u = t.domainMid;
         const l = u > r[a] ? a + 1 : u < r[0] ? 0 : a;
         l !== a && n.warn("Scale domainMid exceeds domain min or max.", u), r.splice(l, 0, u);
     }
     return e.domain(OD(s, r, n)), s === rS && e.unknown(t.domainImplicit ? Bm : void 0), t.nice && e.nice && e.nice(t.nice !== !0 && fS(e, t.nice) || null), r.length;
 }
 
 function Ate(e, t, n) {
     return t ? (e.domain(OD(e.type, t, n)), t.length) : -1;
 }
 
-function $te(e, t, n, i, r, s) {
+function Cte(e, t, n, i, r, s) {
     var o = Math.abs(Ie(n) - n[0]),
         a = o / (o - 2 * i),
-        u = e === mo ? __(t, null, a) : e === ag ? Cm(t, null, a, 0.5) : e === og ? Cm(t, null, a, r || 1) : e === Y1 ? E_(t, null, a, s || 1) : w_(t, null, a);
+        u = e === mo ? __(t, null, a) : e === ag ? $m(t, null, a, 0.5) : e === og ? $m(t, null, a, r || 1) : e === Y1 ? E_(t, null, a, s || 1) : w_(t, null, a);
     return t = t.slice(), t[0] = u[0], t[t.length - 1] = u[1], t;
 }
 
 function OD(e, t, n) {
     if (GN(e)) {
         var i = Math.abs(t.reduce((r, s) => r + (s < 0 ? -1 : s > 0 ? 1 : 0), 0));
-        i !== t.length && n.warn("Log scale domain includes zero: " + Z(t));
+        i !== t.length && n.warn("Log scale domain includes zero: " + ee(t));
     }
     return t;
 }
 
-function Cte(e, t, n) {
+function $te(e, t, n) {
     let i = t.bins;
-    if (i && !W(i)) {
+    if (i && !V(i)) {
         const r = e.domain(),
             s = r[0],
             o = Ie(r),
             a = i.step;
         let u = i.start == null ? s : i.start,
             l = i.stop == null ? o : i.stop;
-        a || q("Scale bins parameter missing step property."), u < s && (u = a * Math.ceil(s / a)), l > o && (l = a * Math.floor(o / a)), i = hn(u, l + a / 2, a);
+        a || W("Scale bins parameter missing step property."), u < s && (u = a * Math.ceil(s / a)), l > o && (l = a * Math.floor(o / a)), i = gn(u, l + a / 2, a);
     }
     return i ? e.bins = i : e.bins && delete e.bins, e.type === sS && (i ? !t.domain && !t.domainRaw && (e.domain(i), n = i.length) : e.bins = e.domain()), n;
 }
 
 function Mte(e, t, n) {
     var i = e.type,
         r = t.round || !1,
         s = t.range;
     if (t.rangeStep != null)
         s = Tte(i, t, n);
     else if (t.scheme && (s = Fte(i, t, n), Me(s))) {
         if (e.interpolator)
             return e.interpolator(s);
-        q(`Scale type ${i} does not support interpolating color schemes.`);
+        W(`Scale type ${i} does not support interpolating color schemes.`);
     }
     if (s && VN(i))
         return e.interpolator(J1(_x(s, t.reverse), t.interpolate, t.interpolateGamma));
     s && t.interpolate && e.interpolate ? e.interpolate(lS(t.interpolate, t.interpolateGamma)) : Me(e.round) ? e.round(r) : Me(e.rangeRound) && e.interpolate(r ? Ef : La), s && e.range(_x(s, t.reverse));
 }
 
 function Tte(e, t, n) {
-    e !== BN && e !== ox && q("Only band and point scales support rangeStep.");
+    e !== BN && e !== ox && W("Only band and point scales support rangeStep.");
     var i = (t.paddingOuter != null ? t.paddingOuter : t.padding) || 0,
         r = e === ox ? 1 : (t.paddingInner != null ? t.paddingInner : t.padding) || 0;
     return [0, t.rangeStep * iS(n, r, i)];
 }
 
 function Fte(e, t, n) {
     var i = t.schemeExtent,
         r, s;
-    return W(t.scheme) ? s = J1(t.scheme, t.interpolate, t.interpolateGamma) : (r = t.scheme.toLowerCase(), s = cS(r), s || q(`Unrecognized scheme name: ${t.scheme}`)), n = e === K1 ? n + 1 : e === sS ? n - 1 : e === Fc || e === X1 ? +t.schemeCount || xte : n, VN(e) ? j$(s, i, t.reverse) : Me(s) ? KN(j$(s, i), n) : e === rS ? s : s.slice(0, n);
+    return V(t.scheme) ? s = J1(t.scheme, t.interpolate, t.interpolateGamma) : (r = t.scheme.toLowerCase(), s = cS(r), s || W(`Unrecognized scheme name: ${t.scheme}`)), n = e === K1 ? n + 1 : e === sS ? n - 1 : e === Fc || e === X1 ? +t.schemeCount || xte : n, VN(e) ? jC(s, i, t.reverse) : Me(s) ? KN(jC(s, i), n) : e === rS ? s : s.slice(0, n);
 }
 
-function j$(e, t, n) {
+function jC(e, t, n) {
     return Me(e) && (t || n) ? XN(e, _x(t || [0, 1], n)) : e;
 }
 
 function _x(e, t) {
     return t ? e.slice().reverse() : e;
 }
 
 function DD(e) {
     B.call(this, null, e);
 }
-Q(DD, B, {
+Z(DD, B, {
     transform(e, t) {
         const n = e.modified("sort") || t.changed(t.ADD) || t.modified(e.sort.fields) || t.modified("datum");
         return n && t.source.sort(pl(e.sort)), this.modified(n), t;
     }
 });
-const q$ = "zero",
+const qC = "zero",
     RD = "center",
     LD = "normalize",
     ID = ["y0", "y1"];
 
 function ZS(e) {
     B.call(this, null, e);
 }
@@ -19722,25 +19709,25 @@
         array: !0
     }, {
         name: "sort",
         type: "compare"
     }, {
         name: "offset",
         type: "enum",
-        default: q$,
-        values: [q$, RD, LD]
+        default: qC,
+        values: [qC, RD, LD]
     }, {
         name: "as",
         type: "string",
         array: !0,
         length: 2,
         default: ID
     }]
 };
-Q(ZS, B, {
+Z(ZS, B, {
     transform(e, t) {
         var n = e.as || ID,
             i = n[0],
             r = n[1],
             s = pl(e.sort),
             o = e.field || cf,
             a = e.offset === RD ? Nte : e.offset === LD ? Ote : Dte,
@@ -19783,70 +19770,70 @@
     return r.max = g, r;
 }
 const Lte = /* @__PURE__ */ Object.freeze( /* @__PURE__ */ Object.defineProperty({
     __proto__: null,
     axisticks: SD,
     datajoin: kD,
     encode: AD,
-    legendentries: $D,
+    legendentries: CD,
     linkpath: JS,
     pie: QS,
     scale: ND,
     sortitems: DD,
     stack: ZS
 }, Symbol.toStringTag, {
     value: "Module"
 }));
-var ve = 1e-6,
+var we = 1e-6,
     s0 = 1e-12,
     Ne = Math.PI,
-    xt = Ne / 2,
+    wt = Ne / 2,
     o0 = Ne / 4,
-    jn = Ne * 2,
-    Et = 180 / Ne,
+    qn = Ne * 2,
+    St = 180 / Ne,
     Fe = Ne / 180,
     Le = Math.abs,
-    $f = Math.atan,
+    Cf = Math.atan,
     rr = Math.atan2,
     _e = Math.cos,
     dp = Math.ceil,
     PD = Math.exp,
     Ex = Math.hypot,
     a0 = Math.log,
     hv = Math.pow,
-    ye = Math.sin,
+    ve = Math.sin,
     qi = Math.sign || function(e) {
         return e > 0 ? 1 : e < 0 ? -1 : 0;
     },
-    qn = Math.sqrt,
+    Wn = Math.sqrt,
     e3 = Math.tan;
 
 function zD(e) {
     return e > 1 ? 0 : e < -1 ? Ne : Math.acos(e);
 }
 
 function li(e) {
-    return e > 1 ? xt : e < -1 ? -xt : Math.asin(e);
+    return e > 1 ? wt : e < -1 ? -wt : Math.asin(e);
 }
 
-function Zt() {}
+function en() {}
 
 function u0(e, t) {
-    e && H$.hasOwnProperty(e.type) && H$[e.type](e, t);
+    e && HC.hasOwnProperty(e.type) && HC[e.type](e, t);
 }
-var W$ = {
+var WC = {
         Feature: function(e, t) {
             u0(e.geometry, t);
         },
         FeatureCollection: function(e, t) {
             for (var n = e.features, i = -1, r = n.length; ++i < r;)
                 u0(n[i].geometry, t);
         }
     },
-    H$ = {
+    HC = {
         Sphere: function(e, t) {
             t.sphere();
         },
         Point: function(e, t) {
             e = e.coordinates, t.point(e[0], e[1], e[2]);
         },
         MultiPoint: function(e, t) {
@@ -19857,19 +19844,19 @@
             Sx(e.coordinates, t, 0);
         },
         MultiLineString: function(e, t) {
             for (var n = e.coordinates, i = -1, r = n.length; ++i < r;)
                 Sx(n[i], t, 0);
         },
         Polygon: function(e, t) {
-            G$(e.coordinates, t);
+            GC(e.coordinates, t);
         },
         MultiPolygon: function(e, t) {
             for (var n = e.coordinates, i = -1, r = n.length; ++i < r;)
-                G$(n[i], t);
+                GC(n[i], t);
         },
         GeometryCollection: function(e, t) {
             for (var n = e.geometries, i = -1, r = n.length; ++i < r;)
                 u0(n[i], t);
         }
     };
 
@@ -19878,81 +19865,81 @@
         r = e.length - n,
         s;
     for (t.lineStart(); ++i < r;)
         s = e[i], t.point(s[0], s[1], s[2]);
     t.lineEnd();
 }
 
-function G$(e, t) {
+function GC(e, t) {
     var n = -1,
         i = e.length;
     for (t.polygonStart(); ++n < i;)
         Sx(e[n], t, 1);
     t.polygonEnd();
 }
 
 function ts(e, t) {
-    e && W$.hasOwnProperty(e.type) ? W$[e.type](e, t) : u0(e, t);
+    e && WC.hasOwnProperty(e.type) ? WC[e.type](e, t) : u0(e, t);
 }
-var l0 = new In(),
-    c0 = new In(),
-    BD, UD, kx, Ax, $x, ys = {
-        point: Zt,
-        lineStart: Zt,
-        lineEnd: Zt,
+var l0 = new Pn(),
+    c0 = new Pn(),
+    BD, UD, kx, Ax, Cx, ys = {
+        point: en,
+        lineStart: en,
+        lineEnd: en,
         polygonStart: function() {
-            l0 = new In(), ys.lineStart = Ite, ys.lineEnd = Pte;
+            l0 = new Pn(), ys.lineStart = Ite, ys.lineEnd = Pte;
         },
         polygonEnd: function() {
             var e = +l0;
-            c0.add(e < 0 ? jn + e : e), this.lineStart = this.lineEnd = this.point = Zt;
+            c0.add(e < 0 ? qn + e : e), this.lineStart = this.lineEnd = this.point = en;
         },
         sphere: function() {
-            c0.add(jn);
+            c0.add(qn);
         }
     };
 
 function Ite() {
     ys.point = zte;
 }
 
 function Pte() {
     jD(BD, UD);
 }
 
 function zte(e, t) {
-    ys.point = jD, BD = e, UD = t, e *= Fe, t *= Fe, kx = e, Ax = _e(t = t / 2 + o0), $x = ye(t);
+    ys.point = jD, BD = e, UD = t, e *= Fe, t *= Fe, kx = e, Ax = _e(t = t / 2 + o0), Cx = ve(t);
 }
 
 function jD(e, t) {
     e *= Fe, t *= Fe, t = t / 2 + o0;
     var n = e - kx,
         i = n >= 0 ? 1 : -1,
         r = i * n,
         s = _e(t),
-        o = ye(t),
-        a = $x * o,
+        o = ve(t),
+        a = Cx * o,
         u = Ax * s + a * _e(r),
-        l = a * i * ye(r);
-    l0.add(rr(l, u)), kx = e, Ax = s, $x = o;
+        l = a * i * ve(r);
+    l0.add(rr(l, u)), kx = e, Ax = s, Cx = o;
 }
 
 function Bte(e) {
-    return c0 = new In(), ts(e, ys), c0 * 2;
+    return c0 = new Pn(), ts(e, ys), c0 * 2;
 }
 
 function f0(e) {
     return [rr(e[1], e[0]), li(e[2])];
 }
 
 function Wu(e) {
     var t = e[0],
         n = e[1],
         i = _e(n);
-    return [i * _e(t), i * ye(t), ye(n)];
+    return [i * _e(t), i * ve(t), ve(n)];
 }
 
 function hp(e, t) {
     return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];
 }
 
 function Ic(e, t) {
@@ -19964,59 +19951,59 @@
 }
 
 function gp(e, t) {
     return [e[0] * t, e[1] * t, e[2] * t];
 }
 
 function d0(e) {
-    var t = qn(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
+    var t = Wn(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
     e[0] /= t, e[1] /= t, e[2] /= t;
 }
-var gt, Qn, pt, yi, cu, qD, WD, pc, Vd, Uo, yo, Js = {
-    point: Cx,
-    lineStart: V$,
-    lineEnd: Y$,
+var gt, Qn, mt, yi, cu, qD, WD, pc, Vd, Uo, yo, Js = {
+    point: $x,
+    lineStart: VC,
+    lineEnd: YC,
     polygonStart: function() {
-        Js.point = GD, Js.lineStart = Ute, Js.lineEnd = jte, Vd = new In(), ys.polygonStart();
+        Js.point = GD, Js.lineStart = Ute, Js.lineEnd = jte, Vd = new Pn(), ys.polygonStart();
     },
     polygonEnd: function() {
-        ys.polygonEnd(), Js.point = Cx, Js.lineStart = V$, Js.lineEnd = Y$, l0 < 0 ? (gt = -(pt = 180), Qn = -(yi = 90)) : Vd > ve ? yi = 90 : Vd < -ve && (Qn = -90), yo[0] = gt, yo[1] = pt;
+        ys.polygonEnd(), Js.point = $x, Js.lineStart = VC, Js.lineEnd = YC, l0 < 0 ? (gt = -(mt = 180), Qn = -(yi = 90)) : Vd > we ? yi = 90 : Vd < -we && (Qn = -90), yo[0] = gt, yo[1] = mt;
     },
     sphere: function() {
-        gt = -(pt = 180), Qn = -(yi = 90);
+        gt = -(mt = 180), Qn = -(yi = 90);
     }
 };
 
-function Cx(e, t) {
-    Uo.push(yo = [gt = e, pt = e]), t < Qn && (Qn = t), t > yi && (yi = t);
+function $x(e, t) {
+    Uo.push(yo = [gt = e, mt = e]), t < Qn && (Qn = t), t > yi && (yi = t);
 }
 
 function HD(e, t) {
     var n = Wu([e * Fe, t * Fe]);
     if (pc) {
         var i = Ic(pc, n),
             r = [i[1], -i[0], 0],
             s = Ic(r, i);
         d0(s), s = f0(s);
         var o = e - cu,
             a = o > 0 ? 1 : -1,
-            u = s[0] * Et * a,
+            u = s[0] * St * a,
             l, c = Le(o) > 180;
-        c ^ (a * cu < u && u < a * e) ? (l = s[1] * Et, l > yi && (yi = l)) : (u = (u + 360) % 360 - 180, c ^ (a * cu < u && u < a * e) ? (l = -s[1] * Et, l < Qn && (Qn = l)) : (t < Qn && (Qn = t), t > yi && (yi = t))), c ? e < cu ? mi(gt, e) > mi(gt, pt) && (pt = e) : mi(e, pt) > mi(gt, pt) && (gt = e) : pt >= gt ? (e < gt && (gt = e), e > pt && (pt = e)) : e > cu ? mi(gt, e) > mi(gt, pt) && (pt = e) : mi(e, pt) > mi(gt, pt) && (gt = e);
+        c ^ (a * cu < u && u < a * e) ? (l = s[1] * St, l > yi && (yi = l)) : (u = (u + 360) % 360 - 180, c ^ (a * cu < u && u < a * e) ? (l = -s[1] * St, l < Qn && (Qn = l)) : (t < Qn && (Qn = t), t > yi && (yi = t))), c ? e < cu ? mi(gt, e) > mi(gt, mt) && (mt = e) : mi(e, mt) > mi(gt, mt) && (gt = e) : mt >= gt ? (e < gt && (gt = e), e > mt && (mt = e)) : e > cu ? mi(gt, e) > mi(gt, mt) && (mt = e) : mi(e, mt) > mi(gt, mt) && (gt = e);
     } else
-        Uo.push(yo = [gt = e, pt = e]);
+        Uo.push(yo = [gt = e, mt = e]);
     t < Qn && (Qn = t), t > yi && (yi = t), pc = n, cu = e;
 }
 
-function V$() {
+function VC() {
     Js.point = HD;
 }
 
-function Y$() {
-    yo[0] = gt, yo[1] = pt, Js.point = Cx, pc = null;
+function YC() {
+    yo[0] = gt, yo[1] = mt, Js.point = $x, pc = null;
 }
 
 function GD(e, t) {
     if (pc) {
         var n = e - cu;
         Vd.add(Le(n) > 180 ? n + (n > 0 ? 360 : -360) : n);
     } else
@@ -20025,240 +20012,240 @@
 }
 
 function Ute() {
     ys.lineStart();
 }
 
 function jte() {
-    GD(qD, WD), ys.lineEnd(), Le(Vd) > ve && (gt = -(pt = 180)), yo[0] = gt, yo[1] = pt, pc = null;
+    GD(qD, WD), ys.lineEnd(), Le(Vd) > we && (gt = -(mt = 180)), yo[0] = gt, yo[1] = mt, pc = null;
 }
 
 function mi(e, t) {
     return (t -= e) < 0 ? t + 360 : t;
 }
 
 function qte(e, t) {
     return e[0] - t[0];
 }
 
-function X$(e, t) {
+function XC(e, t) {
     return e[0] <= e[1] ? e[0] <= t && t <= e[1] : t < e[0] || e[1] < t;
 }
 
 function Wte(e) {
     var t, n, i, r, s, o, a;
-    if (yi = pt = -(gt = Qn = 1 / 0), Uo = [], ts(e, Js), n = Uo.length) {
+    if (yi = mt = -(gt = Qn = 1 / 0), Uo = [], ts(e, Js), n = Uo.length) {
         for (Uo.sort(qte), t = 1, i = Uo[0], s = [i]; t < n; ++t)
-            r = Uo[t], X$(i, r[0]) || X$(i, r[1]) ? (mi(i[0], r[1]) > mi(i[0], i[1]) && (i[1] = r[1]), mi(r[0], i[1]) > mi(i[0], i[1]) && (i[0] = r[0])) : s.push(i = r);
+            r = Uo[t], XC(i, r[0]) || XC(i, r[1]) ? (mi(i[0], r[1]) > mi(i[0], i[1]) && (i[1] = r[1]), mi(r[0], i[1]) > mi(i[0], i[1]) && (i[0] = r[0])) : s.push(i = r);
         for (o = -1 / 0, n = s.length - 1, t = 0, i = s[n]; t <= n; i = r, ++t)
-            r = s[t], (a = mi(i[1], r[0])) > o && (o = a, gt = r[0], pt = i[1]);
+            r = s[t], (a = mi(i[1], r[0])) > o && (o = a, gt = r[0], mt = i[1]);
     }
     return Uo = yo = null, gt === 1 / 0 || Qn === 1 / 0 ? [
         [NaN, NaN],
         [NaN, NaN]
     ] : [
         [gt, Qn],
-        [pt, yi]
+        [mt, yi]
     ];
 }
-var kd, h0, g0, p0, m0, y0, b0, v0, Mx, Tx, Fx, VD, YD, Fn, Nn, On, Sr = {
-    sphere: Zt,
+var kd, h0, g0, p0, m0, y0, b0, v0, Mx, Tx, Fx, VD, YD, Nn, On, Dn, Sr = {
+    sphere: en,
     point: t3,
-    lineStart: K$,
-    lineEnd: J$,
+    lineStart: KC,
+    lineEnd: JC,
     polygonStart: function() {
         Sr.lineStart = Vte, Sr.lineEnd = Yte;
     },
     polygonEnd: function() {
-        Sr.lineStart = K$, Sr.lineEnd = J$;
+        Sr.lineStart = KC, Sr.lineEnd = JC;
     }
 };
 
 function t3(e, t) {
     e *= Fe, t *= Fe;
     var n = _e(t);
-    yg(n * _e(e), n * ye(e), ye(t));
+    yg(n * _e(e), n * ve(e), ve(t));
 }
 
 function yg(e, t, n) {
     ++kd, g0 += (e - g0) / kd, p0 += (t - p0) / kd, m0 += (n - m0) / kd;
 }
 
-function K$() {
+function KC() {
     Sr.point = Hte;
 }
 
 function Hte(e, t) {
     e *= Fe, t *= Fe;
     var n = _e(t);
-    Fn = n * _e(e), Nn = n * ye(e), On = ye(t), Sr.point = Gte, yg(Fn, Nn, On);
+    Nn = n * _e(e), On = n * ve(e), Dn = ve(t), Sr.point = Gte, yg(Nn, On, Dn);
 }
 
 function Gte(e, t) {
     e *= Fe, t *= Fe;
     var n = _e(t),
         i = n * _e(e),
-        r = n * ye(e),
-        s = ye(t),
-        o = rr(qn((o = Nn * s - On * r) * o + (o = On * i - Fn * s) * o + (o = Fn * r - Nn * i) * o), Fn * i + Nn * r + On * s);
-    h0 += o, y0 += o * (Fn + (Fn = i)), b0 += o * (Nn + (Nn = r)), v0 += o * (On + (On = s)), yg(Fn, Nn, On);
+        r = n * ve(e),
+        s = ve(t),
+        o = rr(Wn((o = On * s - Dn * r) * o + (o = Dn * i - Nn * s) * o + (o = Nn * r - On * i) * o), Nn * i + On * r + Dn * s);
+    h0 += o, y0 += o * (Nn + (Nn = i)), b0 += o * (On + (On = r)), v0 += o * (Dn + (Dn = s)), yg(Nn, On, Dn);
 }
 
-function J$() {
+function JC() {
     Sr.point = t3;
 }
 
 function Vte() {
     Sr.point = Xte;
 }
 
 function Yte() {
     XD(VD, YD), Sr.point = t3;
 }
 
 function Xte(e, t) {
     VD = e, YD = t, e *= Fe, t *= Fe, Sr.point = XD;
     var n = _e(t);
-    Fn = n * _e(e), Nn = n * ye(e), On = ye(t), yg(Fn, Nn, On);
+    Nn = n * _e(e), On = n * ve(e), Dn = ve(t), yg(Nn, On, Dn);
 }
 
 function XD(e, t) {
     e *= Fe, t *= Fe;
     var n = _e(t),
         i = n * _e(e),
-        r = n * ye(e),
-        s = ye(t),
-        o = Nn * s - On * r,
-        a = On * i - Fn * s,
-        u = Fn * r - Nn * i,
+        r = n * ve(e),
+        s = ve(t),
+        o = On * s - Dn * r,
+        a = Dn * i - Nn * s,
+        u = Nn * r - On * i,
         l = Ex(o, a, u),
         c = li(l),
         f = l && -c / l;
-    Mx.add(f * o), Tx.add(f * a), Fx.add(f * u), h0 += c, y0 += c * (Fn + (Fn = i)), b0 += c * (Nn + (Nn = r)), v0 += c * (On + (On = s)), yg(Fn, Nn, On);
+    Mx.add(f * o), Tx.add(f * a), Fx.add(f * u), h0 += c, y0 += c * (Nn + (Nn = i)), b0 += c * (On + (On = r)), v0 += c * (Dn + (Dn = s)), yg(Nn, On, Dn);
 }
 
 function Kte(e) {
-    kd = h0 = g0 = p0 = m0 = y0 = b0 = v0 = 0, Mx = new In(), Tx = new In(), Fx = new In(), ts(e, Sr);
+    kd = h0 = g0 = p0 = m0 = y0 = b0 = v0 = 0, Mx = new Pn(), Tx = new Pn(), Fx = new Pn(), ts(e, Sr);
     var t = +Mx,
         n = +Tx,
         i = +Fx,
         r = Ex(t, n, i);
-    return r < s0 && (t = y0, n = b0, i = v0, h0 < ve && (t = g0, n = p0, i = m0), r = Ex(t, n, i), r < s0) ? [NaN, NaN] : [rr(n, t) * Et, li(i / r) * Et];
+    return r < s0 && (t = y0, n = b0, i = v0, h0 < we && (t = g0, n = p0, i = m0), r = Ex(t, n, i), r < s0) ? [NaN, NaN] : [rr(n, t) * St, li(i / r) * St];
 }
 
 function Nx(e, t) {
     function n(i, r) {
         return i = e(i, r), t(i[0], i[1]);
     }
     return e.invert && t.invert && (n.invert = function(i, r) {
         return i = t.invert(i, r), i && e.invert(i[0], i[1]);
     }), n;
 }
 
 function Ox(e, t) {
-    return Le(e) > Ne && (e -= Math.round(e / jn) * jn), [e, t];
+    return Le(e) > Ne && (e -= Math.round(e / qn) * qn), [e, t];
 }
 Ox.invert = Ox;
 
 function KD(e, t, n) {
-    return (e %= jn) ? t || n ? Nx(Z$(e), eC(t, n)) : Z$(e) : t || n ? eC(t, n) : Ox;
+    return (e %= qn) ? t || n ? Nx(ZC(e), e$(t, n)) : ZC(e) : t || n ? e$(t, n) : Ox;
 }
 
-function Q$(e) {
+function QC(e) {
     return function(t, n) {
-        return t += e, Le(t) > Ne && (t -= Math.round(t / jn) * jn), [t, n];
+        return t += e, Le(t) > Ne && (t -= Math.round(t / qn) * qn), [t, n];
     };
 }
 
-function Z$(e) {
-    var t = Q$(e);
-    return t.invert = Q$(-e), t;
+function ZC(e) {
+    var t = QC(e);
+    return t.invert = QC(-e), t;
 }
 
-function eC(e, t) {
+function e$(e, t) {
     var n = _e(e),
-        i = ye(e),
+        i = ve(e),
         r = _e(t),
-        s = ye(t);
+        s = ve(t);
 
     function o(a, u) {
         var l = _e(u),
             c = _e(a) * l,
-            f = ye(a) * l,
-            d = ye(u),
+            f = ve(a) * l,
+            d = ve(u),
             h = d * n + c * i;
         return [
             rr(f * r - h * s, c * n - d * i),
             li(h * r + f * s)
         ];
     }
     return o.invert = function(a, u) {
         var l = _e(u),
             c = _e(a) * l,
-            f = ye(a) * l,
-            d = ye(u),
+            f = ve(a) * l,
+            d = ve(u),
             h = d * r - f * s;
         return [
             rr(f * r + d * s, c * n + h * i),
             li(h * n - c * i)
         ];
     }, o;
 }
 
 function Jte(e) {
     e = KD(e[0] * Fe, e[1] * Fe, e.length > 2 ? e[2] * Fe : 0);
 
     function t(n) {
-        return n = e(n[0] * Fe, n[1] * Fe), n[0] *= Et, n[1] *= Et, n;
+        return n = e(n[0] * Fe, n[1] * Fe), n[0] *= St, n[1] *= St, n;
     }
     return t.invert = function(n) {
-        return n = e.invert(n[0] * Fe, n[1] * Fe), n[0] *= Et, n[1] *= Et, n;
+        return n = e.invert(n[0] * Fe, n[1] * Fe), n[0] *= St, n[1] *= St, n;
     }, t;
 }
 
 function Qte(e, t, n, i, r, s) {
     if (n) {
         var o = _e(t),
-            a = ye(t),
+            a = ve(t),
             u = i * n;
-        r == null ? (r = t + i * jn, s = t - u / 2) : (r = tC(o, r), s = tC(o, s), (i > 0 ? r < s : r > s) && (r += i * jn));
+        r == null ? (r = t + i * qn, s = t - u / 2) : (r = t$(o, r), s = t$(o, s), (i > 0 ? r < s : r > s) && (r += i * qn));
         for (var l, c = r; i > 0 ? c > s : c < s; c -= u)
-            l = f0([o, -a * _e(c), -a * ye(c)]), e.point(l[0], l[1]);
+            l = f0([o, -a * _e(c), -a * ve(c)]), e.point(l[0], l[1]);
     }
 }
 
-function tC(e, t) {
+function t$(e, t) {
     t = Wu(t), t[0] -= e, d0(t);
     var n = zD(-t[1]);
-    return ((-t[2] < 0 ? -n : n) + jn - ve) % jn;
+    return ((-t[2] < 0 ? -n : n) + qn - we) % qn;
 }
 
 function JD() {
     var e = [],
         t;
     return {
         point: function(n, i, r) {
             t.push([n, i, r]);
         },
         lineStart: function() {
             e.push(t = []);
         },
-        lineEnd: Zt,
+        lineEnd: en,
         rejoin: function() {
             e.length > 1 && e.push(e.pop().concat(e.shift()));
         },
         result: function() {
             var n = e;
             return e = [], t = null, n;
         }
     };
 }
 
 function am(e, t) {
-    return Le(e[0] - t[0]) < ve && Le(e[1] - t[1]) < ve;
+    return Le(e[0] - t[0]) < we && Le(e[1] - t[1]) < we;
 }
 
 function pp(e, t, n, i) {
     this.x = e, this.z = t, this.o = n, this.e = i, this.v = !1, this.n = this.p = null;
 }
 
 function QD(e, t, n, i, r) {
@@ -20273,20 +20260,20 @@
                 if (am(m, y)) {
                     if (!m[2] && !y[2]) {
                         for (r.lineStart(), a = 0; a < p; ++a)
                             r.point((m = g[a])[0], m[1]);
                         r.lineEnd();
                         return;
                     }
-                    y[0] += 2 * ve;
+                    y[0] += 2 * we;
                 }
                 s.push(b = new pp(m, g, null, !0)), o.push(b.o = new pp(m, null, b, !1)), s.push(b = new pp(y, g, null, !1)), o.push(b.o = new pp(y, null, b, !0));
             }
         }), !!s.length) {
-        for (o.sort(t), nC(s), nC(o), a = 0, u = o.length; a < u; ++a)
+        for (o.sort(t), n$(s), n$(o), a = 0, u = o.length; a < u; ++a)
             o[a].e = n = !n;
         for (var l = s[0], c, f;;) {
             for (var d = l, h = !0; d.v;)
                 if ((d = d.n) === l)
                     return;
             c = d.z, r.lineStart();
             do {
@@ -20308,58 +20295,58 @@
                 d = d.o, c = d.z, h = !h;
             } while (!d.v);
             r.lineEnd();
         }
     }
 }
 
-function nC(e) {
+function n$(e) {
     if (t = e.length) {
         for (var t, n = 0, i = e[0], r; ++n < t;)
             i.n = r = e[n], r.p = i, i = r;
         i.n = r = e[0], r.p = i;
     }
 }
 
 function pv(e) {
-    return Le(e[0]) <= Ne ? e[0] : qi(e[0]) * ((Le(e[0]) + Ne) % jn - Ne);
+    return Le(e[0]) <= Ne ? e[0] : qi(e[0]) * ((Le(e[0]) + Ne) % qn - Ne);
 }
 
 function Zte(e, t) {
     var n = pv(t),
         i = t[1],
-        r = ye(i),
-        s = [ye(n), -_e(n), 0],
+        r = ve(i),
+        s = [ve(n), -_e(n), 0],
         o = 0,
         a = 0,
-        u = new In();
-    r === 1 ? i = xt + ve : r === -1 && (i = -xt - ve);
+        u = new Pn();
+    r === 1 ? i = wt + we : r === -1 && (i = -wt - we);
     for (var l = 0, c = e.length; l < c; ++l)
         if (d = (f = e[l]).length)
-            for (var f, d, h = f[d - 1], g = pv(h), p = h[1] / 2 + o0, m = ye(p), y = _e(p), b = 0; b < d; ++b, g = x, m = S, y = _, h = v) {
+            for (var f, d, h = f[d - 1], g = pv(h), p = h[1] / 2 + o0, m = ve(p), y = _e(p), b = 0; b < d; ++b, g = x, m = E, y = _, h = v) {
                 var v = f[b],
                     x = pv(v),
                     w = v[1] / 2 + o0,
-                    S = ye(w),
+                    E = ve(w),
                     _ = _e(w),
                     k = x - g,
                     A = k >= 0 ? 1 : -1,
-                    F = A * k,
-                    T = F > Ne,
-                    I = m * S;
-                if (u.add(rr(I * A * ye(F), y * _ + I * _e(F))), o += T ? k + A * jn : k, T ^ g >= n ^ x >= n) {
-                    var N = Ic(Wu(h), Wu(v));
-                    d0(N);
-                    var D = Ic(s, N);
-                    d0(D);
-                    var M = (T ^ k >= 0 ? -1 : 1) * li(D[2]);
-                    (i > M || i === M && (N[0] || N[1])) && (a += T ^ k >= 0 ? 1 : -1);
+                    T = A * k,
+                    M = T > Ne,
+                    L = m * E;
+                if (u.add(rr(L * A * ve(T), y * _ + L * _e(T))), o += M ? k + A * qn : k, M ^ g >= n ^ x >= n) {
+                    var F = Ic(Wu(h), Wu(v));
+                    d0(F);
+                    var O = Ic(s, F);
+                    d0(O);
+                    var N = (M ^ k >= 0 ? -1 : 1) * li(O[2]);
+                    (i > N || i === N && (F[0] || F[1])) && (a += M ^ k >= 0 ? 1 : -1);
                 }
             }
-    return (o < -ve || o < ve && u < -s0) ^ a & 1;
+    return (o < -we || o < we && u < -s0) ^ a & 1;
 }
 
 function ZD(e, t, n, i) {
     return function(r) {
         var s = t(r),
             o = JD(),
             a = t(o),
@@ -20405,21 +20392,21 @@
             a.lineStart(), f = [];
         }
 
         function v() {
             y(f[0][0], f[0][1]), a.lineEnd();
             var x = a.clean(),
                 w = o.result(),
-                S, _ = w.length,
-                k, A, F;
+                E, _ = w.length,
+                k, A, T;
             if (f.pop(), l.push(f), f = null, !!_) {
                 if (x & 1) {
                     if (A = w[0], (k = A.length - 1) > 0) {
-                        for (u || (r.polygonStart(), u = !0), r.lineStart(), S = 0; S < k; ++S)
-                            r.point((F = A[S])[0], F[1]);
+                        for (u || (r.polygonStart(), u = !0), r.lineStart(), E = 0; E < k; ++E)
+                            r.point((T = A[E])[0], T[1]);
                         r.lineEnd();
                     }
                     return;
                 }
                 _ > 1 && x & 2 && w.push(w.pop().concat(w.shift())), c.push(w.filter(ene));
             }
         }
@@ -20428,69 +20415,69 @@
 }
 
 function ene(e) {
     return e.length > 1;
 }
 
 function tne(e, t) {
-    return ((e = e.x)[0] < 0 ? e[1] - xt - ve : xt - e[1]) - ((t = t.x)[0] < 0 ? t[1] - xt - ve : xt - t[1]);
+    return ((e = e.x)[0] < 0 ? e[1] - wt - we : wt - e[1]) - ((t = t.x)[0] < 0 ? t[1] - wt - we : wt - t[1]);
 }
-const iC = ZD(
+const i$ = ZD(
     function() {
         return !0;
     },
     nne,
     rne,
-    [-Ne, -xt]
+    [-Ne, -wt]
 );
 
 function nne(e) {
     var t = NaN,
         n = NaN,
         i = NaN,
         r;
     return {
         lineStart: function() {
             e.lineStart(), r = 1;
         },
         point: function(s, o) {
             var a = s > 0 ? Ne : -Ne,
                 u = Le(s - t);
-            Le(u - Ne) < ve ? (e.point(t, n = (n + o) / 2 > 0 ? xt : -xt), e.point(i, n), e.lineEnd(), e.lineStart(), e.point(a, n), e.point(s, n), r = 0) : i !== a && u >= Ne && (Le(t - i) < ve && (t -= i * ve), Le(s - a) < ve && (s -= a * ve), n = ine(t, n, s, o), e.point(i, n), e.lineEnd(), e.lineStart(), e.point(a, n), r = 0), e.point(t = s, n = o), i = a;
+            Le(u - Ne) < we ? (e.point(t, n = (n + o) / 2 > 0 ? wt : -wt), e.point(i, n), e.lineEnd(), e.lineStart(), e.point(a, n), e.point(s, n), r = 0) : i !== a && u >= Ne && (Le(t - i) < we && (t -= i * we), Le(s - a) < we && (s -= a * we), n = ine(t, n, s, o), e.point(i, n), e.lineEnd(), e.lineStart(), e.point(a, n), r = 0), e.point(t = s, n = o), i = a;
         },
         lineEnd: function() {
             e.lineEnd(), t = n = NaN;
         },
         clean: function() {
             return 2 - r;
         }
     };
 }
 
 function ine(e, t, n, i) {
-    var r, s, o = ye(e - n);
-    return Le(o) > ve ? $f((ye(t) * (s = _e(i)) * ye(n) - ye(i) * (r = _e(t)) * ye(e)) / (r * s * o)) : (t + i) / 2;
+    var r, s, o = ve(e - n);
+    return Le(o) > we ? Cf((ve(t) * (s = _e(i)) * ve(n) - ve(i) * (r = _e(t)) * ve(e)) / (r * s * o)) : (t + i) / 2;
 }
 
 function rne(e, t, n, i) {
     var r;
     if (e == null)
-        r = n * xt, i.point(-Ne, r), i.point(0, r), i.point(Ne, r), i.point(Ne, 0), i.point(Ne, -r), i.point(0, -r), i.point(-Ne, -r), i.point(-Ne, 0), i.point(-Ne, r);
-    else if (Le(e[0] - t[0]) > ve) {
+        r = n * wt, i.point(-Ne, r), i.point(0, r), i.point(Ne, r), i.point(Ne, 0), i.point(Ne, -r), i.point(0, -r), i.point(-Ne, -r), i.point(-Ne, 0), i.point(-Ne, r);
+    else if (Le(e[0] - t[0]) > we) {
         var s = e[0] < t[0] ? Ne : -Ne;
         r = n * s / 2, i.point(-s, r), i.point(0, r), i.point(s, r);
     } else
         i.point(t[0], t[1]);
 }
 
 function sne(e) {
     var t = _e(e),
         n = 2 * Fe,
         i = t > 0,
-        r = Le(t) > ve;
+        r = Le(t) > we;
 
     function s(c, f, d, h) {
         Qte(h, e, n, d, c, f);
     }
 
     function o(c, f) {
         return _e(c) * _e(f) > t;
@@ -20505,16 +20492,16 @@
             point: function(m, y) {
                 var b = [m, y],
                     v, x = o(m, y),
                     w = i ? x ? 0 : l(m, y) : x ? l(m + (m < 0 ? Ne : -Ne), y) : 0;
                 if (!f && (g = h = x) && c.lineStart(), x !== h && (v = u(f, b), (!v || am(f, v) || am(b, v)) && (b[2] = 1)), x !== h)
                     p = 0, x ? (c.lineStart(), v = u(b, f), c.point(v[0], v[1])) : (v = u(f, b), c.point(v[0], v[1], 2), c.lineEnd()), f = v;
                 else if (r && f && i ^ x) {
-                    var S;
-                    !(w & d) && (S = u(b, f, !0)) && (p = 0, i ? (c.lineStart(), c.point(S[0][0], S[0][1]), c.point(S[1][0], S[1][1]), c.lineEnd()) : (c.point(S[1][0], S[1][1]), c.lineEnd(), c.lineStart(), c.point(S[0][0], S[0][1], 3)));
+                    var E;
+                    !(w & d) && (E = u(b, f, !0)) && (p = 0, i ? (c.lineStart(), c.point(E[0][0], E[0][1]), c.point(E[1][0], E[1][1]), c.lineEnd()) : (c.point(E[1][0], E[1][1]), c.lineEnd(), c.lineStart(), c.point(E[0][0], E[0][1], 3)));
                 }
                 x && (!f || !am(f, b)) && c.point(b[0], b[1]), f = b, h = x, d = w;
             },
             lineEnd: function() {
                 h && c.lineEnd(), f = null;
             },
             // Rejoin first and last segments if there were intersections and the first
@@ -20533,39 +20520,39 @@
             y = hp(m, m),
             b = m[0],
             v = y - b * b;
         if (!v)
             return !d && c;
         var x = t * y / v,
             w = -t * b / v,
-            S = Ic(p, m),
+            E = Ic(p, m),
             _ = gp(p, x),
             k = gp(m, w);
         gv(_, k);
-        var A = S,
-            F = hp(_, A),
-            T = hp(A, A),
-            I = F * F - T * (hp(_, _) - 1);
-        if (!(I < 0)) {
-            var N = qn(I),
-                D = gp(A, (-F - N) / T);
-            if (gv(D, _), D = f0(D), !d)
-                return D;
-            var M = c[0],
-                E = f[0],
-                $ = c[1],
-                C = f[1],
-                O;
-            E < M && (O = M, M = E, E = O);
-            var R = E - M,
-                L = Le(R - Ne) < ve,
-                P = L || R < ve;
-            if (!L && C < $ && (O = $, $ = C, C = O), P ? L ? $ + C > 0 ^ D[1] < (Le(D[0] - M) < ve ? $ : C) : $ <= D[1] && D[1] <= C : R > Ne ^ (M <= D[0] && D[0] <= E)) {
-                var z = gp(A, (-F + N) / T);
-                return gv(z, _), [D, f0(z)];
+        var A = E,
+            T = hp(_, A),
+            M = hp(A, A),
+            L = T * T - M * (hp(_, _) - 1);
+        if (!(L < 0)) {
+            var F = Wn(L),
+                O = gp(A, (-T - F) / M);
+            if (gv(O, _), O = f0(O), !d)
+                return O;
+            var N = c[0],
+                R = f[0],
+                P = c[1],
+                S = f[1],
+                $;
+            R < N && ($ = N, N = R, R = $);
+            var C = R - N,
+                D = Le(C - Ne) < we,
+                I = D || C < we;
+            if (!D && S < P && ($ = P, P = S, S = $), I ? D ? P + S > 0 ^ O[1] < (Le(O[0] - N) < we ? P : S) : P <= O[1] && O[1] <= S : C > Ne ^ (N <= O[0] && O[0] <= R)) {
+                var z = gp(A, (-T + F) / M);
+                return gv(z, _), [O, f0(z)];
             }
         }
     }
 
     function l(c, f) {
         var d = i ? e : Ne - e,
             h = 0;
@@ -20646,95 +20633,95 @@
                 d.point(h === 0 || h === 3 ? e : n, h > 1 ? i : t);
             while ((h = (h + f + 4) % 4) !== g);
         else
             d.point(c[0], c[1]);
     }
 
     function o(l, c) {
-        return Le(l[0] - e) < ve ? c > 0 ? 0 : 3 : Le(l[0] - n) < ve ? c > 0 ? 2 : 1 : Le(l[1] - t) < ve ? c > 0 ? 1 : 0 : c > 0 ? 3 : 2;
+        return Le(l[0] - e) < we ? c > 0 ? 0 : 3 : Le(l[0] - n) < we ? c > 0 ? 2 : 1 : Le(l[1] - t) < we ? c > 0 ? 1 : 0 : c > 0 ? 3 : 2;
     }
 
     function a(l, c) {
         return u(l.x, c.x);
     }
 
     function u(l, c) {
         var f = o(l, 1),
             d = o(c, 1);
         return f !== d ? f - d : f === 0 ? c[1] - l[1] : f === 1 ? l[0] - c[0] : f === 2 ? l[1] - c[1] : c[0] - l[0];
     }
     return function(l) {
         var c = l,
             f = JD(),
-            d, h, g, p, m, y, b, v, x, w, S, _ = {
+            d, h, g, p, m, y, b, v, x, w, E, _ = {
                 point: k,
-                lineStart: I,
-                lineEnd: N,
-                polygonStart: F,
-                polygonEnd: T
+                lineStart: L,
+                lineEnd: F,
+                polygonStart: T,
+                polygonEnd: M
             };
 
-        function k(M, E) {
-            r(M, E) && c.point(M, E);
+        function k(N, R) {
+            r(N, R) && c.point(N, R);
         }
 
         function A() {
-            for (var M = 0, E = 0, $ = h.length; E < $; ++E)
-                for (var C = h[E], O = 1, R = C.length, L = C[0], P, z, V = L[0], X = L[1]; O < R; ++O)
-                    P = V, z = X, L = C[O], V = L[0], X = L[1], z <= i ? X > i && (V - P) * (i - z) > (X - z) * (e - P) && ++M : X <= i && (V - P) * (i - z) < (X - z) * (e - P) && --M;
-            return M;
+            for (var N = 0, R = 0, P = h.length; R < P; ++R)
+                for (var S = h[R], $ = 1, C = S.length, D = S[0], I, z, H = D[0], G = D[1]; $ < C; ++$)
+                    I = H, z = G, D = S[$], H = D[0], G = D[1], z <= i ? G > i && (H - I) * (i - z) > (G - z) * (e - I) && ++N : G <= i && (H - I) * (i - z) < (G - z) * (e - I) && --N;
+            return N;
         }
 
-        function F() {
-            c = f, d = [], h = [], S = !0;
+        function T() {
+            c = f, d = [], h = [], E = !0;
         }
 
-        function T() {
-            var M = A(),
-                E = S && M,
-                $ = (d = MM(d)).length;
-            (E || $) && (l.polygonStart(), E && (l.lineStart(), s(null, null, 1, l), l.lineEnd()), $ && QD(d, a, M, s, l), l.polygonEnd()), c = l, d = h = g = null;
+        function M() {
+            var N = A(),
+                R = E && N,
+                P = (d = MM(d)).length;
+            (R || P) && (l.polygonStart(), R && (l.lineStart(), s(null, null, 1, l), l.lineEnd()), P && QD(d, a, N, s, l), l.polygonEnd()), c = l, d = h = g = null;
         }
 
-        function I() {
-            _.point = D, h && h.push(g = []), w = !0, x = !1, b = v = NaN;
+        function L() {
+            _.point = O, h && h.push(g = []), w = !0, x = !1, b = v = NaN;
         }
 
-        function N() {
-            d && (D(p, m), y && x && f.rejoin(), d.push(f.result())), _.point = k, x && c.lineEnd();
+        function F() {
+            d && (O(p, m), y && x && f.rejoin(), d.push(f.result())), _.point = k, x && c.lineEnd();
         }
 
-        function D(M, E) {
-            var $ = r(M, E);
-            if (h && g.push([M, E]), w)
-                p = M, m = E, y = $, w = !1, $ && (c.lineStart(), c.point(M, E));
-            else if ($ && x)
-                c.point(M, E);
+        function O(N, R) {
+            var P = r(N, R);
+            if (h && g.push([N, R]), w)
+                p = N, m = R, y = P, w = !1, P && (c.lineStart(), c.point(N, R));
+            else if (P && x)
+                c.point(N, R);
             else {
-                var C = [b = Math.max(mp, Math.min(Ad, b)), v = Math.max(mp, Math.min(Ad, v))],
-                    O = [M = Math.max(mp, Math.min(Ad, M)), E = Math.max(mp, Math.min(Ad, E))];
-                one(C, O, e, t, n, i) ? (x || (c.lineStart(), c.point(C[0], C[1])), c.point(O[0], O[1]), $ || c.lineEnd(), S = !1) : $ && (c.lineStart(), c.point(M, E), S = !1);
+                var S = [b = Math.max(mp, Math.min(Ad, b)), v = Math.max(mp, Math.min(Ad, v))],
+                    $ = [N = Math.max(mp, Math.min(Ad, N)), R = Math.max(mp, Math.min(Ad, R))];
+                one(S, $, e, t, n, i) ? (x || (c.lineStart(), c.point(S[0], S[1])), c.point($[0], $[1]), P || c.lineEnd(), E = !1) : P && (c.lineStart(), c.point(N, R), E = !1);
             }
-            b = M, v = E, x = $;
+            b = N, v = R, x = P;
         }
         return _;
     };
 }
 
-function rC(e, t, n) {
-    var i = hn(e, t - ve, n).concat(t);
+function r$(e, t, n) {
+    var i = gn(e, t - we, n).concat(t);
     return function(r) {
         return i.map(function(s) {
             return [r, s];
         });
     };
 }
 
-function sC(e, t, n) {
-    var i = hn(e, t - ve, n).concat(t);
+function s$(e, t, n) {
+    var i = gn(e, t - we, n).concat(t);
     return function(r) {
         return i.map(function(s) {
             return [s, r];
         });
     };
 }
 
@@ -20749,18 +20736,18 @@
         return {
             type: "MultiLineString",
             coordinates: b()
         };
     }
 
     function b() {
-        return hn(dp(i / c) * c, n, c).map(g).concat(hn(dp(a / f) * f, o, f).map(p)).concat(hn(dp(t / u) * u, e, u).filter(function(v) {
-            return Le(v % c) > ve;
-        }).map(d)).concat(hn(dp(s / l) * l, r, l).filter(function(v) {
-            return Le(v % f) > ve;
+        return gn(dp(i / c) * c, n, c).map(g).concat(gn(dp(a / f) * f, o, f).map(p)).concat(gn(dp(t / u) * u, e, u).filter(function(v) {
+            return Le(v % c) > we;
+        }).map(d)).concat(gn(dp(s / l) * l, r, l).filter(function(v) {
+            return Le(v % f) > we;
         }).map(h));
     }
     return y.lines = function() {
         return b().map(function(v) {
             return {
                 type: "LineString",
                 coordinates: v
@@ -20792,39 +20779,39 @@
     }, y.step = function(v) {
         return arguments.length ? y.stepMajor(v).stepMinor(v) : y.stepMinor();
     }, y.stepMajor = function(v) {
         return arguments.length ? (c = +v[0], f = +v[1], y) : [c, f];
     }, y.stepMinor = function(v) {
         return arguments.length ? (u = +v[0], l = +v[1], y) : [u, l];
     }, y.precision = function(v) {
-        return arguments.length ? (m = +v, d = rC(s, r, 90), h = sC(t, e, m), g = rC(a, o, 90), p = sC(i, n, m), y) : m;
+        return arguments.length ? (m = +v, d = r$(s, r, 90), h = s$(t, e, m), g = r$(a, o, 90), p = s$(i, n, m), y) : m;
     }, y.extentMajor([
-        [-180, -90 + ve],
-        [180, 90 - ve]
+        [-180, -90 + we],
+        [180, 90 - we]
     ]).extentMinor([
-        [-180, -80 - ve],
-        [180, 80 + ve]
+        [-180, -80 - we],
+        [180, 80 + we]
     ]);
 }
 const _h = (e) => e;
-var mv = new In(),
-    Dx = new In(),
+var mv = new Pn(),
+    Dx = new Pn(),
     eR, tR, Rx, Lx, to = {
-        point: Zt,
-        lineStart: Zt,
-        lineEnd: Zt,
+        point: en,
+        lineStart: en,
+        lineEnd: en,
         polygonStart: function() {
             to.lineStart = une, to.lineEnd = cne;
         },
         polygonEnd: function() {
-            to.lineStart = to.lineEnd = to.point = Zt, mv.add(Le(Dx)), Dx = new In();
+            to.lineStart = to.lineEnd = to.point = en, mv.add(Le(Dx)), Dx = new Pn();
         },
         result: function() {
             var e = mv / 2;
-            return mv = new In(), e;
+            return mv = new Pn(), e;
         }
     };
 
 function une() {
     to.point = lne;
 }
 
@@ -20841,75 +20828,75 @@
 }
 var Pc = 1 / 0,
     x0 = Pc,
     Eh = -Pc,
     w0 = Eh,
     _0 = {
         point: fne,
-        lineStart: Zt,
-        lineEnd: Zt,
-        polygonStart: Zt,
-        polygonEnd: Zt,
+        lineStart: en,
+        lineEnd: en,
+        polygonStart: en,
+        polygonEnd: en,
         result: function() {
             var e = [
                 [Pc, x0],
                 [Eh, w0]
             ];
             return Eh = w0 = -(x0 = Pc = 1 / 0), e;
         }
     };
 
 function fne(e, t) {
     e < Pc && (Pc = e), e > Eh && (Eh = e), t < x0 && (x0 = t), t > w0 && (w0 = t);
 }
 var Ix = 0,
     Px = 0,
-    $d = 0,
+    Cd = 0,
     E0 = 0,
     S0 = 0,
     oc = 0,
     zx = 0,
     Bx = 0,
-    Cd = 0,
+    $d = 0,
     iR, rR, ns, is, Ui = {
         point: Hu,
-        lineStart: oC,
-        lineEnd: aC,
+        lineStart: o$,
+        lineEnd: a$,
         polygonStart: function() {
             Ui.lineStart = gne, Ui.lineEnd = pne;
         },
         polygonEnd: function() {
-            Ui.point = Hu, Ui.lineStart = oC, Ui.lineEnd = aC;
+            Ui.point = Hu, Ui.lineStart = o$, Ui.lineEnd = a$;
         },
         result: function() {
-            var e = Cd ? [zx / Cd, Bx / Cd] : oc ? [E0 / oc, S0 / oc] : $d ? [Ix / $d, Px / $d] : [NaN, NaN];
-            return Ix = Px = $d = E0 = S0 = oc = zx = Bx = Cd = 0, e;
+            var e = $d ? [zx / $d, Bx / $d] : oc ? [E0 / oc, S0 / oc] : Cd ? [Ix / Cd, Px / Cd] : [NaN, NaN];
+            return Ix = Px = Cd = E0 = S0 = oc = zx = Bx = $d = 0, e;
         }
     };
 
 function Hu(e, t) {
-    Ix += e, Px += t, ++$d;
+    Ix += e, Px += t, ++Cd;
 }
 
-function oC() {
+function o$() {
     Ui.point = dne;
 }
 
 function dne(e, t) {
     Ui.point = hne, Hu(ns = e, is = t);
 }
 
 function hne(e, t) {
     var n = e - ns,
         i = t - is,
-        r = qn(n * n + i * i);
+        r = Wn(n * n + i * i);
     E0 += r * (ns + e) / 2, S0 += r * (is + t) / 2, oc += r, Hu(ns = e, is = t);
 }
 
-function aC() {
+function a$() {
     Ui.point = Hu;
 }
 
 function gne() {
     Ui.point = mne;
 }
 
@@ -20920,16 +20907,16 @@
 function mne(e, t) {
     Ui.point = sR, Hu(iR = ns = e, rR = is = t);
 }
 
 function sR(e, t) {
     var n = e - ns,
         i = t - is,
-        r = qn(n * n + i * i);
-    E0 += r * (ns + e) / 2, S0 += r * (is + t) / 2, oc += r, r = is * e - ns * t, zx += r * (ns + e), Bx += r * (is + t), Cd += r * 3, Hu(ns = e, is = t);
+        r = Wn(n * n + i * i);
+    E0 += r * (ns + e) / 2, S0 += r * (is + t) / 2, oc += r, r = is * e - ns * t, zx += r * (ns + e), Bx += r * (is + t), $d += r * 3, Hu(ns = e, is = t);
 }
 
 function oR(e) {
     this._context = e;
 }
 oR.prototype = {
     _radius: 4.5,
@@ -20955,51 +20942,51 @@
                 break;
             }
             case 1: {
                 this._context.lineTo(e, t);
                 break;
             }
             default: {
-                this._context.moveTo(e + this._radius, t), this._context.arc(e, t, this._radius, 0, jn);
+                this._context.moveTo(e + this._radius, t), this._context.arc(e, t, this._radius, 0, qn);
                 break;
             }
         }
     },
-    result: Zt
+    result: en
 };
-var Ux = new In(),
+var Ux = new Pn(),
     yv, aR, uR, Md, Td, Sh = {
-        point: Zt,
+        point: en,
         lineStart: function() {
             Sh.point = yne;
         },
         lineEnd: function() {
-            yv && lR(aR, uR), Sh.point = Zt;
+            yv && lR(aR, uR), Sh.point = en;
         },
         polygonStart: function() {
             yv = !0;
         },
         polygonEnd: function() {
             yv = null;
         },
         result: function() {
             var e = +Ux;
-            return Ux = new In(), e;
+            return Ux = new Pn(), e;
         }
     };
 
 function yne(e, t) {
     Sh.point = lR, aR = Md = e, uR = Td = t;
 }
 
 function lR(e, t) {
-    Md -= e, Td -= t, Ux.add(qn(Md * Md + Td * Td)), Md = e, Td = t;
+    Md -= e, Td -= t, Ux.add(Wn(Md * Md + Td * Td)), Md = e, Td = t;
 }
-let uC, k0, lC, cC;
-class fC {
+let u$, k0, l$, c$;
+class f$ {
     constructor(t) {
         this._append = t == null ? cR : bne(t), this._radius = 4.5, this._ = "";
     }
     pointRadius(t) {
         return this._radius = +t, this;
     }
     polygonStart() {
@@ -21021,20 +21008,20 @@
                 break;
             }
             case 1: {
                 this._append`L${t},${n}`;
                 break;
             }
             default: {
-                if (this._append`M${t},${n}`, this._radius !== lC || this._append !== k0) {
+                if (this._append`M${t},${n}`, this._radius !== l$ || this._append !== k0) {
                     const i = this._radius,
                         r = this._;
-                    this._ = "", this._append`m0,${i}a${i},${i} 0 1,1 0,${-2 * i}a${i},${i} 0 1,1 0,${2 * i}z`, lC = i, k0 = this._append, cC = this._, this._ = r;
+                    this._ = "", this._append`m0,${i}a${i},${i} 0 1,1 0,${-2 * i}a${i},${i} 0 1,1 0,${2 * i}z`, l$ = i, k0 = this._append, c$ = this._, this._ = r;
                 }
-                this._ += cC;
+                this._ += c$;
                 break;
             }
         }
     }
     result() {
         const t = this._;
         return this._ = "", t.length ? t : null;
@@ -21050,17 +21037,17 @@
 
 function bne(e) {
     const t = Math.floor(e);
     if (!(t >= 0))
         throw new RangeError(`invalid digits: ${e}`);
     if (t > 15)
         return cR;
-    if (t !== uC) {
+    if (t !== u$) {
         const n = 10 ** t;
-        uC = t, k0 = function(r) {
+        u$ = t, k0 = function(r) {
             let s = 1;
             this._ += r[0];
             for (const o = r.length; s < o; ++s)
                 this._ += Math.round(arguments[s] * n) / n + r[s];
         };
     }
     return k0;
@@ -21081,29 +21068,29 @@
     }, o.bounds = function(a) {
         return ts(a, r(_0)), _0.result();
     }, o.centroid = function(a) {
         return ts(a, r(Ui)), Ui.result();
     }, o.projection = function(a) {
         return arguments.length ? (r = a == null ? (e = null, _h) : (e = a).stream, o) : e;
     }, o.context = function(a) {
-        return arguments.length ? (s = a == null ? (t = null, new fC(n)) : new oR(t = a), typeof i != "function" && s.pointRadius(i), o) : t;
+        return arguments.length ? (s = a == null ? (t = null, new f$(n)) : new oR(t = a), typeof i != "function" && s.pointRadius(i), o) : t;
     }, o.pointRadius = function(a) {
         return arguments.length ? (i = typeof a == "function" ? a : (s.pointRadius(+a), +a), o) : i;
     }, o.digits = function(a) {
         if (!arguments.length)
             return n;
         if (a == null)
             n = null;
         else {
             const u = Math.floor(a);
             if (!(u >= 0))
                 throw new RangeError(`invalid digits: ${a}`);
             n = u;
         }
-        return t === null && (s = new fC(n)), o;
+        return t === null && (s = new f$(n)), o;
     }, o.projection(e).digits(n).context(t);
 }
 
 function jx(e) {
     return {
         stream: bg(e)
     };
@@ -21178,18 +21165,18 @@
         var r = +t,
             s = r / (i[1][1] - i[0][1]),
             o = -s * i[0][0],
             a = (r - s * (i[1][1] + i[0][1])) / 2;
         e.scale(150 * s).translate([o, a]);
     }, n);
 }
-var dC = 16,
+var d$ = 16,
     vne = _e(30 * Fe);
 
-function hC(e, t) {
+function h$(e, t) {
     return +t ? wne(e, t) : xne(e);
 }
 
 function xne(e) {
     return bg({
         point: function(t, n) {
             t = e(t, n), this.stream.point(t[0], t[1]);
@@ -21201,25 +21188,25 @@
     function n(i, r, s, o, a, u, l, c, f, d, h, g, p, m) {
         var y = l - i,
             b = c - r,
             v = y * y + b * b;
         if (v > 4 * t && p--) {
             var x = o + d,
                 w = a + h,
-                S = u + g,
-                _ = qn(x * x + w * w + S * S),
-                k = li(S /= _),
-                A = Le(Le(S) - 1) < ve || Le(s - f) < ve ? (s + f) / 2 : rr(w, x),
-                F = e(A, k),
-                T = F[0],
-                I = F[1],
-                N = T - i,
-                D = I - r,
-                M = b * N - y * D;
-            (M * M / v > t || Le((y * N + b * D) / v - 0.5) > 0.3 || o * d + a * h + u * g < vne) && (n(i, r, s, o, a, u, T, I, A, x /= _, w /= _, S, p, m), m.point(T, I), n(T, I, A, x, w, S, l, c, f, d, h, g, p, m));
+                E = u + g,
+                _ = Wn(x * x + w * w + E * E),
+                k = li(E /= _),
+                A = Le(Le(E) - 1) < we || Le(s - f) < we ? (s + f) / 2 : rr(w, x),
+                T = e(A, k),
+                M = T[0],
+                L = T[1],
+                F = M - i,
+                O = L - r,
+                N = b * F - y * O;
+            (N * N / v > t || Le((y * F + b * O) / v - 0.5) > 0.3 || o * d + a * h + u * g < vne) && (n(i, r, s, o, a, u, M, L, A, x /= _, w /= _, E, p, m), m.point(M, L), n(M, L, A, x, w, E, l, c, f, d, h, g, p, m));
         }
     }
     return function(i) {
         var r, s, o, a, u, l, c, f, d, h, g, p, m = {
             point: y,
             lineStart: b,
             lineEnd: x,
@@ -21236,33 +21223,33 @@
         }
 
         function b() {
             f = NaN, m.point = v, i.lineStart();
         }
 
         function v(k, A) {
-            var F = Wu([k, A]),
-                T = e(k, A);
-            n(f, d, c, h, g, p, f = T[0], d = T[1], c = k, h = F[0], g = F[1], p = F[2], dC, i), i.point(f, d);
+            var T = Wu([k, A]),
+                M = e(k, A);
+            n(f, d, c, h, g, p, f = M[0], d = M[1], c = k, h = T[0], g = T[1], p = T[2], d$, i), i.point(f, d);
         }
 
         function x() {
             m.point = y, i.lineEnd();
         }
 
         function w() {
-            b(), m.point = S, m.lineEnd = _;
+            b(), m.point = E, m.lineEnd = _;
         }
 
-        function S(k, A) {
+        function E(k, A) {
             v(r = k, A), s = f, o = d, a = h, u = g, l = p, m.point = v;
         }
 
         function _() {
-            n(f, d, c, h, g, p, s, o, r, a, u, l, dC, i), m.lineEnd = x, x();
+            n(f, d, c, h, g, p, s, o, r, a, u, l, d$, i), m.lineEnd = x, x();
         }
         return m;
     };
 }
 var _ne = bg({
     point: function(e, t) {
         this.stream.point(e * Fe, t * Fe);
@@ -21283,19 +21270,19 @@
         return o *= i, a *= r, [t + e * o, n - e * a];
     }
     return s.invert = function(o, a) {
         return [(o - t) / e * i, (n - a) / e * r];
     }, s;
 }
 
-function gC(e, t, n, i, r, s) {
+function g$(e, t, n, i, r, s) {
     if (!s)
         return Sne(e, t, n, i, r);
     var o = _e(s),
-        a = ye(s),
+        a = ve(s),
         u = o * e,
         l = a * e,
         c = o / e,
         f = a / e,
         d = (a * n - o * t) / e,
         h = (a * t + o * n) / e;
 
@@ -21303,15 +21290,15 @@
         return p *= i, m *= r, [u * p - l * m + t, n - l * p - u * m];
     }
     return g.invert = function(p, m) {
         return [i * (c * p - f * m + d), r * (h - f * p - c * m)];
     }, g;
 }
 
-function Cs(e) {
+function $s(e) {
     return fR(function() {
         return e;
     })();
 }
 
 function fR(e) {
     var t, n = 150,
@@ -21322,112 +21309,112 @@
         a = 0,
         u = 0,
         l = 0,
         c, f = 0,
         d = 1,
         h = 1,
         g = null,
-        p = iC,
+        p = i$,
         m = null,
         y, b, v, x = _h,
         w = 0.5,
-        S, _, k, A, F;
+        E, _, k, A, T;
 
-    function T(M) {
-        return k(M[0] * Fe, M[1] * Fe);
+    function M(N) {
+        return k(N[0] * Fe, N[1] * Fe);
     }
 
-    function I(M) {
-        return M = k.invert(M[0], M[1]), M && [M[0] * Et, M[1] * Et];
+    function L(N) {
+        return N = k.invert(N[0], N[1]), N && [N[0] * St, N[1] * St];
     }
-    T.stream = function(M) {
-        return A && F === M ? A : A = _ne(Ene(c)(p(S(x(F = M)))));
-    }, T.preclip = function(M) {
-        return arguments.length ? (p = M, g = void 0, D()) : p;
-    }, T.postclip = function(M) {
-        return arguments.length ? (x = M, m = y = b = v = null, D()) : x;
-    }, T.clipAngle = function(M) {
-        return arguments.length ? (p = +M ? sne(g = M * Fe) : (g = null, iC), D()) : g * Et;
-    }, T.clipExtent = function(M) {
-        return arguments.length ? (x = M == null ? (m = y = b = v = null, _h) : n3(m = +M[0][0], y = +M[0][1], b = +M[1][0], v = +M[1][1]), D()) : m == null ? null : [
+    M.stream = function(N) {
+        return A && T === N ? A : A = _ne(Ene(c)(p(E(x(T = N)))));
+    }, M.preclip = function(N) {
+        return arguments.length ? (p = N, g = void 0, O()) : p;
+    }, M.postclip = function(N) {
+        return arguments.length ? (x = N, m = y = b = v = null, O()) : x;
+    }, M.clipAngle = function(N) {
+        return arguments.length ? (p = +N ? sne(g = N * Fe) : (g = null, i$), O()) : g * St;
+    }, M.clipExtent = function(N) {
+        return arguments.length ? (x = N == null ? (m = y = b = v = null, _h) : n3(m = +N[0][0], y = +N[0][1], b = +N[1][0], v = +N[1][1]), O()) : m == null ? null : [
             [m, y],
             [b, v]
         ];
-    }, T.scale = function(M) {
-        return arguments.length ? (n = +M, N()) : n;
-    }, T.translate = function(M) {
-        return arguments.length ? (i = +M[0], r = +M[1], N()) : [i, r];
-    }, T.center = function(M) {
-        return arguments.length ? (s = M[0] % 360 * Fe, o = M[1] % 360 * Fe, N()) : [s * Et, o * Et];
-    }, T.rotate = function(M) {
-        return arguments.length ? (a = M[0] % 360 * Fe, u = M[1] % 360 * Fe, l = M.length > 2 ? M[2] % 360 * Fe : 0, N()) : [a * Et, u * Et, l * Et];
-    }, T.angle = function(M) {
-        return arguments.length ? (f = M % 360 * Fe, N()) : f * Et;
-    }, T.reflectX = function(M) {
-        return arguments.length ? (d = M ? -1 : 1, N()) : d < 0;
-    }, T.reflectY = function(M) {
-        return arguments.length ? (h = M ? -1 : 1, N()) : h < 0;
-    }, T.precision = function(M) {
-        return arguments.length ? (S = hC(_, w = M * M), D()) : qn(w);
-    }, T.fitExtent = function(M, E) {
-        return dy(T, M, E);
-    }, T.fitSize = function(M, E) {
-        return r3(T, M, E);
-    }, T.fitWidth = function(M, E) {
-        return s3(T, M, E);
-    }, T.fitHeight = function(M, E) {
-        return o3(T, M, E);
-    };
-
-    function N() {
-        var M = gC(n, 0, 0, d, h, f).apply(null, t(s, o)),
-            E = gC(n, i - M[0], r - M[1], d, h, f);
-        return c = KD(a, u, l), _ = Nx(t, E), k = Nx(c, _), S = hC(_, w), D();
+    }, M.scale = function(N) {
+        return arguments.length ? (n = +N, F()) : n;
+    }, M.translate = function(N) {
+        return arguments.length ? (i = +N[0], r = +N[1], F()) : [i, r];
+    }, M.center = function(N) {
+        return arguments.length ? (s = N[0] % 360 * Fe, o = N[1] % 360 * Fe, F()) : [s * St, o * St];
+    }, M.rotate = function(N) {
+        return arguments.length ? (a = N[0] % 360 * Fe, u = N[1] % 360 * Fe, l = N.length > 2 ? N[2] % 360 * Fe : 0, F()) : [a * St, u * St, l * St];
+    }, M.angle = function(N) {
+        return arguments.length ? (f = N % 360 * Fe, F()) : f * St;
+    }, M.reflectX = function(N) {
+        return arguments.length ? (d = N ? -1 : 1, F()) : d < 0;
+    }, M.reflectY = function(N) {
+        return arguments.length ? (h = N ? -1 : 1, F()) : h < 0;
+    }, M.precision = function(N) {
+        return arguments.length ? (E = h$(_, w = N * N), O()) : Wn(w);
+    }, M.fitExtent = function(N, R) {
+        return dy(M, N, R);
+    }, M.fitSize = function(N, R) {
+        return r3(M, N, R);
+    }, M.fitWidth = function(N, R) {
+        return s3(M, N, R);
+    }, M.fitHeight = function(N, R) {
+        return o3(M, N, R);
+    };
+
+    function F() {
+        var N = g$(n, 0, 0, d, h, f).apply(null, t(s, o)),
+            R = g$(n, i - N[0], r - N[1], d, h, f);
+        return c = KD(a, u, l), _ = Nx(t, R), k = Nx(c, _), E = h$(_, w), O();
     }
 
-    function D() {
-        return A = F = null, T;
+    function O() {
+        return A = T = null, M;
     }
     return function() {
-        return t = e.apply(this, arguments), T.invert = t.invert && I, N();
+        return t = e.apply(this, arguments), M.invert = t.invert && L, F();
     };
 }
 
 function a3(e) {
     var t = 0,
         n = Ne / 3,
         i = fR(e),
         r = i(t, n);
     return r.parallels = function(s) {
-        return arguments.length ? i(t = s[0] * Fe, n = s[1] * Fe) : [t * Et, n * Et];
+        return arguments.length ? i(t = s[0] * Fe, n = s[1] * Fe) : [t * St, n * St];
     }, r;
 }
 
 function kne(e) {
     var t = _e(e);
 
     function n(i, r) {
-        return [i * t, ye(r) / t];
+        return [i * t, ve(r) / t];
     }
     return n.invert = function(i, r) {
         return [i / t, li(r * t)];
     }, n;
 }
 
 function Ane(e, t) {
-    var n = ye(e),
-        i = (n + ye(t)) / 2;
-    if (Le(i) < ve)
+    var n = ve(e),
+        i = (n + ve(t)) / 2;
+    if (Le(i) < we)
         return kne(e);
     var r = 1 + n * (2 * i - n),
-        s = qn(r) / i;
+        s = Wn(r) / i;
 
     function o(a, u) {
-        var l = qn(r - 2 * i * ye(u)) / i;
-        return [l * ye(a *= i), s - l * _e(a)];
+        var l = Wn(r - 2 * i * ve(u)) / i;
+        return [l * ve(a *= i), s - l * _e(a)];
     }
     return o.invert = function(a, u) {
         var l = s - u,
             c = rr(a, Le(l)) * qi(l);
         return l * i < 0 && (c -= Ne * qi(a) * qi(l)), [c / i, li((r - (a * a + l * l) * i * i) / (2 * i))];
     }, o;
 }
@@ -21436,15 +21423,15 @@
     return a3(Ane).scale(155.424).center([0, 33.6442]);
 }
 
 function u3() {
     return kh().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
 }
 
-function $ne(e) {
+function Cne(e) {
     var t = e.length;
     return {
         point: function(n, i) {
             for (var r = -1; ++r < t;)
                 e[r].point(n, i);
         },
         sphere: function() {
@@ -21488,34 +21475,34 @@
     c.invert = function(d) {
         var h = n.scale(),
             g = n.translate(),
             p = (d[0] - g[0]) / h,
             m = (d[1] - g[1]) / h;
         return (m >= 0.12 && m < 0.234 && p >= -0.425 && p < -0.214 ? r : m >= 0.166 && m < 0.234 && p >= -0.214 && p < -0.115 ? o : n).invert(d);
     }, c.stream = function(d) {
-        return e && t === d ? e : e = $ne([n.stream(t = d), r.stream(d), o.stream(d)]);
+        return e && t === d ? e : e = Cne([n.stream(t = d), r.stream(d), o.stream(d)]);
     }, c.precision = function(d) {
         return arguments.length ? (n.precision(d), r.precision(d), o.precision(d), f()) : n.precision();
     }, c.scale = function(d) {
         return arguments.length ? (n.scale(d), r.scale(d * 0.35), o.scale(d), c.translate(n.translate())) : n.scale();
     }, c.translate = function(d) {
         if (!arguments.length)
             return n.translate();
         var h = n.scale(),
             g = +d[0],
             p = +d[1];
         return i = n.translate(d).clipExtent([
             [g - 0.455 * h, p - 0.238 * h],
             [g + 0.455 * h, p + 0.238 * h]
         ]).stream(l), s = r.translate([g - 0.307 * h, p + 0.201 * h]).clipExtent([
-            [g - 0.425 * h + ve, p + 0.12 * h + ve],
-            [g - 0.214 * h - ve, p + 0.234 * h - ve]
+            [g - 0.425 * h + we, p + 0.12 * h + we],
+            [g - 0.214 * h - we, p + 0.234 * h - we]
         ]).stream(l), a = o.translate([g - 0.205 * h, p + 0.212 * h]).clipExtent([
-            [g - 0.214 * h + ve, p + 0.166 * h + ve],
-            [g - 0.115 * h - ve, p + 0.234 * h - ve]
+            [g - 0.214 * h + we, p + 0.166 * h + we],
+            [g - 0.115 * h - we, p + 0.234 * h - we]
         ]).stream(l), f();
     }, c.fitExtent = function(d, h) {
         return dy(c, d, h);
     }, c.fitSize = function(d, h) {
         return r3(c, d, h);
     }, c.fitWidth = function(d, h) {
         return s3(c, d, h);
@@ -21531,66 +21518,66 @@
 
 function hR(e) {
     return function(t, n) {
         var i = _e(t),
             r = _e(n),
             s = e(i * r);
         return s === 1 / 0 ? [2, 0] : [
-            s * r * ye(t),
-            s * ye(n)
+            s * r * ve(t),
+            s * ve(n)
         ];
     };
 }
 
 function vg(e) {
     return function(t, n) {
-        var i = qn(t * t + n * n),
+        var i = Wn(t * t + n * n),
             r = e(i),
-            s = ye(r),
+            s = ve(r),
             o = _e(r);
         return [
             rr(t * s, i * o),
             li(i && n * s / i)
         ];
     };
 }
 var gR = hR(function(e) {
-    return qn(2 / (1 + e));
+    return Wn(2 / (1 + e));
 });
 gR.invert = vg(function(e) {
     return 2 * li(e / 2);
 });
 
 function pR() {
-    return Cs(gR).scale(124.75).clipAngle(180 - 1e-3);
+    return $s(gR).scale(124.75).clipAngle(180 - 1e-3);
 }
 var mR = hR(function(e) {
-    return (e = zD(e)) && e / ye(e);
+    return (e = zD(e)) && e / ve(e);
 });
 mR.invert = vg(function(e) {
     return e;
 });
 
 function yR() {
-    return Cs(mR).scale(79.4188).clipAngle(180 - 1e-3);
+    return $s(mR).scale(79.4188).clipAngle(180 - 1e-3);
 }
 
 function hy(e, t) {
-    return [e, a0(e3((xt + t) / 2))];
+    return [e, a0(e3((wt + t) / 2))];
 }
 hy.invert = function(e, t) {
-    return [e, 2 * $f(PD(t)) - xt];
+    return [e, 2 * Cf(PD(t)) - wt];
 };
 
 function bR() {
-    return vR(hy).scale(961 / jn);
+    return vR(hy).scale(961 / qn);
 }
 
 function vR(e) {
-    var t = Cs(e),
+    var t = $s(e),
         n = t.center,
         i = t.scale,
         r = t.translate,
         s = t.clipExtent,
         o = null,
         a, u, l;
     t.scale = function(f) {
@@ -21620,167 +21607,167 @@
             [u, Math.min(d[1] + f, l)]
         ]);
     }
     return c();
 }
 
 function yp(e) {
-    return e3((xt + e) / 2);
+    return e3((wt + e) / 2);
 }
 
-function Cne(e, t) {
+function $ne(e, t) {
     var n = _e(e),
-        i = e === t ? ye(e) : a0(n / _e(t)) / a0(yp(t) / yp(e)),
+        i = e === t ? ve(e) : a0(n / _e(t)) / a0(yp(t) / yp(e)),
         r = n * hv(yp(e), i) / i;
     if (!i)
         return hy;
 
     function s(o, a) {
-        r > 0 ? a < -xt + ve && (a = -xt + ve) : a > xt - ve && (a = xt - ve);
+        r > 0 ? a < -wt + we && (a = -wt + we) : a > wt - we && (a = wt - we);
         var u = r / hv(yp(a), i);
-        return [u * ye(i * o), r - u * _e(i * o)];
+        return [u * ve(i * o), r - u * _e(i * o)];
     }
     return s.invert = function(o, a) {
         var u = r - a,
-            l = qi(i) * qn(o * o + u * u),
+            l = qi(i) * Wn(o * o + u * u),
             c = rr(o, Le(u)) * qi(u);
-        return u * i < 0 && (c -= Ne * qi(o) * qi(u)), [c / i, 2 * $f(hv(r / l, 1 / i)) - xt];
+        return u * i < 0 && (c -= Ne * qi(o) * qi(u)), [c / i, 2 * Cf(hv(r / l, 1 / i)) - wt];
     }, s;
 }
 
 function xR() {
-    return a3(Cne).scale(109.5).parallels([30, 30]);
+    return a3($ne).scale(109.5).parallels([30, 30]);
 }
 
 function A0(e, t) {
     return [e, t];
 }
 A0.invert = A0;
 
 function wR() {
-    return Cs(A0).scale(152.63);
+    return $s(A0).scale(152.63);
 }
 
 function Mne(e, t) {
     var n = _e(e),
-        i = e === t ? ye(e) : (n - _e(t)) / (t - e),
+        i = e === t ? ve(e) : (n - _e(t)) / (t - e),
         r = n / i + e;
-    if (Le(i) < ve)
+    if (Le(i) < we)
         return A0;
 
     function s(o, a) {
         var u = r - a,
             l = i * o;
-        return [u * ye(l), r - u * _e(l)];
+        return [u * ve(l), r - u * _e(l)];
     }
     return s.invert = function(o, a) {
         var u = r - a,
             l = rr(o, Le(u)) * qi(u);
-        return u * i < 0 && (l -= Ne * qi(o) * qi(u)), [l / i, r - qi(i) * qn(o * o + u * u)];
+        return u * i < 0 && (l -= Ne * qi(o) * qi(u)), [l / i, r - qi(i) * Wn(o * o + u * u)];
     }, s;
 }
 
 function _R() {
     return a3(Mne).scale(131.154).center([0, 13.9389]);
 }
 var Yd = 1.340264,
     Xd = -0.081106,
     Kd = 893e-6,
     Jd = 3796e-6,
-    $0 = qn(3) / 2,
+    C0 = Wn(3) / 2,
     Tne = 12;
 
 function ER(e, t) {
-    var n = li($0 * ye(t)),
+    var n = li(C0 * ve(t)),
         i = n * n,
         r = i * i * i;
     return [
-        e * _e(n) / ($0 * (Yd + 3 * Xd * i + r * (7 * Kd + 9 * Jd * i))),
+        e * _e(n) / (C0 * (Yd + 3 * Xd * i + r * (7 * Kd + 9 * Jd * i))),
         n * (Yd + Xd * i + r * (Kd + Jd * i))
     ];
 }
 ER.invert = function(e, t) {
     for (var n = t, i = n * n, r = i * i * i, s = 0, o, a, u; s < Tne && (a = n * (Yd + Xd * i + r * (Kd + Jd * i)) - t, u = Yd + 3 * Xd * i + r * (7 * Kd + 9 * Jd * i), n -= o = a / u, i = n * n, r = i * i * i, !(Le(o) < s0)); ++s)
     ;
     return [
-        $0 * e * (Yd + 3 * Xd * i + r * (7 * Kd + 9 * Jd * i)) / _e(n),
-        li(ye(n) / $0)
+        C0 * e * (Yd + 3 * Xd * i + r * (7 * Kd + 9 * Jd * i)) / _e(n),
+        li(ve(n) / C0)
     ];
 };
 
 function SR() {
-    return Cs(ER).scale(177.158);
+    return $s(ER).scale(177.158);
 }
 
 function kR(e, t) {
     var n = _e(t),
         i = _e(e) * n;
-    return [n * ye(e) / i, ye(t) / i];
+    return [n * ve(e) / i, ve(t) / i];
 }
-kR.invert = vg($f);
+kR.invert = vg(Cf);
 
 function AR() {
-    return Cs(kR).scale(144.049).clipAngle(60);
+    return $s(kR).scale(144.049).clipAngle(60);
 }
 
 function Fne() {
     var e = 1,
         t = 0,
         n = 0,
         i = 1,
         r = 1,
         s = 0,
         o, a, u = null,
         l, c, f, d = 1,
         h = 1,
         g = bg({
             point: function(x, w) {
-                var S = v([x, w]);
-                this.stream.point(S[0], S[1]);
+                var E = v([x, w]);
+                this.stream.point(E[0], E[1]);
             }
         }),
         p = _h,
         m, y;
 
     function b() {
         return d = e * i, h = e * r, m = y = null, v;
     }
 
     function v(x) {
         var w = x[0] * d,
-            S = x[1] * h;
+            E = x[1] * h;
         if (s) {
-            var _ = S * o - w * a;
-            w = w * o + S * a, S = _;
+            var _ = E * o - w * a;
+            w = w * o + E * a, E = _;
         }
-        return [w + t, S + n];
+        return [w + t, E + n];
     }
     return v.invert = function(x) {
         var w = x[0] - t,
-            S = x[1] - n;
+            E = x[1] - n;
         if (s) {
-            var _ = S * o + w * a;
-            w = w * o - S * a, S = _;
+            var _ = E * o + w * a;
+            w = w * o - E * a, E = _;
         }
-        return [w / d, S / h];
+        return [w / d, E / h];
     }, v.stream = function(x) {
         return m && y === x ? m : m = g(p(y = x));
     }, v.postclip = function(x) {
         return arguments.length ? (p = x, u = l = c = f = null, b()) : p;
     }, v.clipExtent = function(x) {
         return arguments.length ? (p = x == null ? (u = l = c = f = null, _h) : n3(u = +x[0][0], l = +x[0][1], c = +x[1][0], f = +x[1][1]), b()) : u == null ? null : [
             [u, l],
             [c, f]
         ];
     }, v.scale = function(x) {
         return arguments.length ? (e = +x, b()) : e;
     }, v.translate = function(x) {
         return arguments.length ? (t = +x[0], n = +x[1], b()) : [t, n];
     }, v.angle = function(x) {
-        return arguments.length ? (s = x % 360 * Fe, a = ye(s), o = _e(s), b()) : s * Et;
+        return arguments.length ? (s = x % 360 * Fe, a = ve(s), o = _e(s), b()) : s * St;
     }, v.reflectX = function(x) {
         return arguments.length ? (i = x ? -1 : 1, b()) : i < 0;
     }, v.reflectY = function(x) {
         return arguments.length ? (r = x ? -1 : 1, b()) : r < 0;
     }, v.fitExtent = function(x, w) {
         return dy(v, x, w);
     }, v.fitSize = function(x, w) {
@@ -21788,118 +21775,118 @@
     }, v.fitWidth = function(x, w) {
         return s3(v, x, w);
     }, v.fitHeight = function(x, w) {
         return o3(v, x, w);
     }, v;
 }
 
-function $R(e, t) {
+function CR(e, t) {
     var n = t * t,
         i = n * n;
     return [
         e * (0.8707 - 0.131979 * n + i * (-0.013791 + i * (3971e-6 * n - 1529e-6 * i))),
         t * (1.007226 + n * (0.015085 + i * (-0.044475 + 0.028874 * n - 5916e-6 * i)))
     ];
 }
-$R.invert = function(e, t) {
+CR.invert = function(e, t) {
     var n = t,
         i = 25,
         r;
     do {
         var s = n * n,
             o = s * s;
         n -= r = (n * (1.007226 + s * (0.015085 + o * (-0.044475 + 0.028874 * s - 5916e-6 * o))) - t) / (1.007226 + s * (0.015085 * 3 + o * (-0.044475 * 7 + 0.028874 * 9 * s - 5916e-6 * 11 * o)));
-    } while (Le(r) > ve && --i > 0);
+    } while (Le(r) > we && --i > 0);
     return [
         e / (0.8707 + (s = n * n) * (-0.131979 + s * (-0.013791 + s * s * s * (3971e-6 - 1529e-6 * s)))),
         n
     ];
 };
 
 function Nne() {
-    return Cs($R).scale(175.295);
+    return $s(CR).scale(175.295);
 }
 
-function CR(e, t) {
-    return [_e(t) * ye(e), ye(t)];
+function $R(e, t) {
+    return [_e(t) * ve(e), ve(t)];
 }
-CR.invert = vg(li);
+$R.invert = vg(li);
 
 function MR() {
-    return Cs(CR).scale(249.5).clipAngle(90 + ve);
+    return $s($R).scale(249.5).clipAngle(90 + we);
 }
 
 function TR(e, t) {
     var n = _e(t),
         i = 1 + _e(e) * n;
-    return [n * ye(e) / i, ye(t) / i];
+    return [n * ve(e) / i, ve(t) / i];
 }
 TR.invert = vg(function(e) {
-    return 2 * $f(e);
+    return 2 * Cf(e);
 });
 
 function FR() {
-    return Cs(TR).scale(250).clipAngle(142);
+    return $s(TR).scale(250).clipAngle(142);
 }
 
 function NR(e, t) {
-    return [a0(e3((xt + t) / 2)), -e];
+    return [a0(e3((wt + t) / 2)), -e];
 }
 NR.invert = function(e, t) {
-    return [-t, 2 * $f(PD(e)) - xt];
+    return [-t, 2 * Cf(PD(e)) - wt];
 };
 
 function OR() {
     var e = vR(NR),
         t = e.center,
         n = e.rotate;
     return e.center = function(i) {
         return arguments.length ? t([-i[1], i[0]]) : (i = t(), [i[1], -i[0]]);
     }, e.rotate = function(i) {
         return arguments.length ? n([i[0], i[1], i.length > 2 ? i[2] + 90 : 90]) : (i = n(), [i[0], i[1], i[2] - 90]);
     }, n([0, 0, 90]).scale(159.155);
 }
 var One = Math.abs,
     Wx = Math.cos,
-    C0 = Math.sin,
+    $0 = Math.sin,
     Dne = 1e-6,
     DR = Math.PI,
     Hx = DR / 2,
-    pC = Rne(2);
+    p$ = Rne(2);
 
-function mC(e) {
+function m$(e) {
     return e > 1 ? Hx : e < -1 ? -Hx : Math.asin(e);
 }
 
 function Rne(e) {
     return e > 0 ? Math.sqrt(e) : 0;
 }
 
 function Lne(e, t) {
-    var n = e * C0(t),
+    var n = e * $0(t),
         i = 30,
         r;
     do
-        t -= r = (t + C0(t) - n) / (1 + Wx(t));
+        t -= r = (t + $0(t) - n) / (1 + Wx(t));
     while (One(r) > Dne && --i > 0);
     return t / 2;
 }
 
 function Ine(e, t, n) {
     function i(r, s) {
-        return [e * r * Wx(s = Lne(n, s)), t * C0(s)];
+        return [e * r * Wx(s = Lne(n, s)), t * $0(s)];
     }
     return i.invert = function(r, s) {
-        return s = mC(s / t), [r / (e * Wx(s)), mC((2 * s + C0(2 * s)) / n)];
+        return s = m$(s / t), [r / (e * Wx(s)), m$((2 * s + $0(2 * s)) / n)];
     }, i;
 }
-var Pne = Ine(pC / Hx, pC, DR);
+var Pne = Ine(p$ / Hx, p$, DR);
 
 function zne() {
-    return Cs(Pne).scale(169.529);
+    return $s(Pne).scale(169.529);
 }
 const Bne = fy(),
     Gx = [
         // standard properties in d3-geo
         "clipAngle",
         "clipExtent",
         "scale",
@@ -22104,30 +22091,30 @@
         }
         for (h = -1, y = u[g * e] >= l, Bs[y << 2].forEach(v); ++h < e - 1;)
             b = y, y = u[g * e + h + 1] >= l, Bs[y << 2 | b << 3].forEach(v);
         Bs[y << 3].forEach(v);
 
         function v(x) {
             var w = [x[0][0] + h, x[0][1] + g],
-                S = [x[1][0] + h, x[1][1] + g],
+                E = [x[1][0] + h, x[1][1] + g],
                 _ = o(w),
-                k = o(S),
-                A, F;
-            (A = d[_]) ? (F = f[k]) ? (delete d[A.end], delete f[F.start], A === F ? (A.ring.push(S), c(A.ring)) : f[A.start] = d[F.end] = {
+                k = o(E),
+                A, T;
+            (A = d[_]) ? (T = f[k]) ? (delete d[A.end], delete f[T.start], A === T ? (A.ring.push(E), c(A.ring)) : f[A.start] = d[T.end] = {
                 start: A.start,
-                end: F.end,
-                ring: A.ring.concat(F.ring)
-            }) : (delete d[A.end], A.ring.push(S), d[A.end = k] = A) : (A = f[k]) ? (F = d[_]) ? (delete f[A.start], delete d[F.end], A === F ? (A.ring.push(S), c(A.ring)) : f[F.start] = d[A.end] = {
-                start: F.start,
+                end: T.end,
+                ring: A.ring.concat(T.ring)
+            }) : (delete d[A.end], A.ring.push(E), d[A.end = k] = A) : (A = f[k]) ? (T = d[_]) ? (delete f[A.start], delete d[T.end], A === T ? (A.ring.push(E), c(A.ring)) : f[T.start] = d[A.end] = {
+                start: T.start,
                 end: A.end,
-                ring: F.ring.concat(A.ring)
+                ring: T.ring.concat(A.ring)
             }) : (delete f[A.start], A.ring.unshift(w), f[A.start = _] = A) : f[_] = d[k] = {
                 start: _,
                 end: k,
-                ring: [w, S]
+                ring: [w, E]
             };
         }
     }
 
     function o(u) {
         return u[0] * 2 + u[1] * (e + 1) * 4;
     }
@@ -22143,15 +22130,15 @@
         });
     }
     return i.contour = r, i.size = function(u) {
         if (!arguments.length)
             return [e, t];
         var l = Math.floor(u[0]),
             c = Math.floor(u[1]);
-        return l >= 0 && c >= 0 || q("invalid size"), e = l, t = c, i;
+        return l >= 0 && c >= 0 || W("invalid size"), e = l, t = c, i;
     }, i.smooth = function(u) {
         return arguments.length ? (n = u ? a : jne, i) : n === a;
     }, i;
 }
 
 function qne(e) {
     for (var t = 0, n = e.length, i = e[n - 1][1] * e[0][0] - e[n - 1][0] * e[0][1]; ++t < n;)
@@ -22197,15 +22184,15 @@
 function IR(e, t, n) {
     return function(i) {
         var r = hs(i),
             s = n ? Math.min(r[0], 0) : r[0],
             o = r[1],
             a = o - s,
             u = t ? da(s, o, e) : a / (e + 1);
-        return hn(s + u, o, u);
+        return gn(s + u, o, u);
     };
 }
 
 function c3(e) {
     B.call(this, null, e);
 }
 c3.Definition = {
@@ -22252,40 +22239,40 @@
     }, {
         name: "as",
         type: "string",
         null: !0,
         default: "contour"
     }]
 };
-Q(c3, B, {
+Z(c3, B, {
     transform(e, t) {
         if (this.value && !t.changed() && !e.modified())
             return t.StopPropagation;
         var n = t.fork(t.NO_SOURCE | t.NO_FIELDS),
             i = t.materialize(t.SOURCE).source,
-            r = e.field || Sn,
+            r = e.field || kn,
             s = LR().smooth(e.smooth !== !1),
             o = e.thresholds || Xne(i, r, e),
             a = e.as === null ? null : e.as || "contour",
             u = [];
         return i.forEach((l) => {
             const c = r(l),
-                f = s.size([c.width, c.height])(c.values, W(o) ? o : o(c.values));
+                f = s.size([c.width, c.height])(c.values, V(o) ? o : o(c.values));
             Kne(f, c, l, e), f.forEach((d) => {
                 u.push(_1(l, Ge(a != null ? {
                     [a]: d
                 } : d)));
             });
         }), this.value && (n.rem = this.value), this.value = n.source = n.add = u, n;
     }
 });
 
 function Xne(e, t, n) {
     const i = IR(n.levels || 10, n.nice, n.zero !== !1);
-    return n.resolve !== "shared" ? i : i(e.map((r) => xn(t(r).values)));
+    return n.resolve !== "shared" ? i : i(e.map((r) => wn(t(r).values)));
 }
 
 function Kne(e, t, n, i) {
     let r = i.scale || t.scale,
         s = i.translate || t.translate;
     if (Me(r) && (r = r(n, i)), Me(s) && (s = s(n, i)), (r === 1 || r == null) && !s)
         return;
@@ -22313,46 +22300,46 @@
         f[0] = (f[0] - s) * t + i, f[1] = (f[1] - o) * n + r;
     }
     return function(f) {
         return f.coordinates.forEach(u), f;
     };
 }
 
-function yC(e, t, n) {
+function y$(e, t, n) {
     const i = e >= 0 ? e : V_(t, n);
     return Math.round((Math.sqrt(4 * i * i + 1) - 1) / 2);
 }
 
 function bv(e) {
-    return Me(e) ? e : kn(+e);
+    return Me(e) ? e : An(+e);
 }
 
 function zR() {
     var e = (u) => u[0],
         t = (u) => u[1],
         n = cf,
         i = [-1, -1],
         r = 960,
         s = 500,
         o = 2;
 
     function a(u, l) {
-        const c = yC(i[0], u, e) >> o,
-            f = yC(i[1], u, t) >> o,
+        const c = y$(i[0], u, e) >> o,
+            f = y$(i[1], u, t) >> o,
             d = c ? c + 2 : 0,
             h = f ? f + 2 : 0,
             g = 2 * d + (r >> o),
             p = 2 * h + (s >> o),
             m = new Float32Array(g * p),
             y = new Float32Array(g * p);
         let b = m;
         u.forEach((x) => {
             const w = d + (+e(x) >> o),
-                S = h + (+t(x) >> o);
-            w >= 0 && w < g && S >= 0 && S < p && (m[w + S * g] += +n(x));
+                E = h + (+t(x) >> o);
+            w >= 0 && w < g && E >= 0 && E < p && (m[w + E * g] += +n(x));
         }), c > 0 && f > 0 ? (Ul(g, p, m, y, c), jl(g, p, y, m, f), Ul(g, p, m, y, c), jl(g, p, y, m, f), Ul(g, p, m, y, c), jl(g, p, y, m, f)) : c > 0 ? (Ul(g, p, m, y, c), Ul(g, p, y, m, c), Ul(g, p, m, y, c), b = y) : f > 0 && (jl(g, p, m, y, f), jl(g, p, y, m, f), jl(g, p, m, y, f), b = y);
         const v = l ? Math.pow(2, -2 * o) : 1 / go(b);
         for (let x = 0, w = g * p; x < w; ++x)
             b[x] *= v;
         return {
             values: b,
             scale: 1 << o,
@@ -22371,19 +22358,19 @@
     }, a.weight = function(u) {
         return arguments.length ? (n = bv(u), a) : n;
     }, a.size = function(u) {
         if (!arguments.length)
             return [r, s];
         var l = +u[0],
             c = +u[1];
-        return l >= 0 && c >= 0 || q("invalid size"), r = l, s = c, a;
+        return l >= 0 && c >= 0 || W("invalid size"), r = l, s = c, a;
     }, a.cellSize = function(u) {
-        return arguments.length ? ((u = +u) >= 1 || q("invalid cell size"), o = Math.floor(Math.log(u) / Math.LN2), a) : 1 << o;
+        return arguments.length ? ((u = +u) >= 1 || W("invalid cell size"), o = Math.floor(Math.log(u) / Math.LN2), a) : 1 << o;
     }, a.bandwidth = function(u) {
-        return arguments.length ? (u = ne(u), u.length === 1 && (u = [+u[0], +u[0]]), u.length !== 2 && q("invalid bandwidth"), i = u, a) : i;
+        return arguments.length ? (u = re(u), u.length === 1 && (u = [+u[0], +u[0]]), u.length !== 2 && W("invalid bandwidth"), i = u, a) : i;
     }, a;
 }
 
 function Ul(e, t, n, i, r) {
     const s = (r << 1) + 1;
     for (let o = 0; o < t; ++o)
         for (let a = 0, u = 0; a < e + r; ++a)
@@ -22445,22 +22432,22 @@
     }]
 };
 const Jne = ["x", "y", "weight", "size", "cellSize", "bandwidth"];
 
 function BR(e, t) {
     return Jne.forEach((n) => t[n] != null ? e[n](t[n]) : 0), e;
 }
-Q(f3, B, {
+Z(f3, B, {
     transform(e, t) {
         if (this.value && !t.changed() && !e.modified())
             return t.StopPropagation;
         var n = t.fork(t.NO_SOURCE | t.NO_FIELDS),
             i = t.materialize(t.SOURCE).source,
             r = Qne(i, e.groupby),
-            s = (e.groupby || []).map(_t),
+            s = (e.groupby || []).map(Et),
             o = BR(zR(), e),
             a = e.as || "grid",
             u = [];
 
         function l(c, f) {
             for (let d = 0; d < s.length; ++d)
                 c[s[d]] = f[d];
@@ -22530,25 +22517,25 @@
         array: !0
     }, {
         name: "smooth",
         type: "boolean",
         default: !0
     }]
 };
-Q(d3, B, {
+Z(d3, B, {
     transform(e, t) {
         if (this.value && !t.changed() && !e.modified())
             return t.StopPropagation;
         var n = t.fork(t.NO_SOURCE | t.NO_FIELDS),
             i = LR().smooth(e.smooth !== !1),
             r = e.values,
             s = e.thresholds || IR(e.count || 10, e.nice, !!r),
             o = e.size,
             a, u;
-        return r || (r = t.materialize(t.SOURCE).source, a = BR(zR(), e)(r, !0), u = PR(a, a.scale || 1, a.scale || 1, 0, 0), o = [a.width, a.height], r = a.values), s = W(s) ? s : s(r), r = i.size(o)(r, s), u && r.forEach(u), this.value && (n.rem = this.value), this.value = n.source = n.add = (r || []).map(Ge), n;
+        return r || (r = t.materialize(t.SOURCE).source, a = BR(zR(), e)(r, !0), u = PR(a, a.scale || 1, a.scale || 1, 0, 0), o = [a.width, a.height], r = a.values), s = V(s) ? s : s(r), r = i.size(o)(r, s), u && r.forEach(u), this.value && (n.rem = this.value), this.value = n.source = n.add = (r || []).map(Ge), n;
     }
 });
 const Vx = "Feature",
     h3 = "FeatureCollection",
     Zne = "MultiPoint";
 
 function g3(e) {
@@ -22563,25 +22550,25 @@
         array: !0,
         length: 2
     }, {
         name: "geojson",
         type: "field"
     }]
 };
-Q(g3, B, {
+Z(g3, B, {
     transform(e, t) {
         var n = this._features,
             i = this._points,
             r = e.fields,
             s = r && r[0],
             o = r && r[1],
-            a = e.geojson || !r && Sn,
+            a = e.geojson || !r && kn,
             u = t.ADD,
             l;
-        l = e.modified() || t.changed(t.REM) || t.modified(bn(a)) || s && t.modified(bn(s)) || o && t.modified(bn(o)), (!this.value || l) && (u = t.SOURCE, this._features = n = [], this._points = i = []), a && t.visit(u, (c) => n.push(a(c))), s && o && (t.visit(u, (c) => {
+        l = e.modified() || t.changed(t.REM) || t.modified(vn(a)) || s && t.modified(vn(s)) || o && t.modified(vn(o)), (!this.value || l) && (u = t.SOURCE, this._features = n = [], this._points = i = []), a && t.visit(u, (c) => n.push(a(c))), s && o && (t.visit(u, (c) => {
             var f = s(c),
                 d = o(c);
             f != null && d != null && (f = +f) === f && (d = +d) === d && i.push([f, d]);
         }), n = n.concat({
             type: Vx,
             geometry: {
                 type: Zne,
@@ -22614,22 +22601,22 @@
         expr: !0
     }, {
         name: "as",
         type: "string",
         default: "path"
     }]
 };
-Q(p3, B, {
+Z(p3, B, {
     transform(e, t) {
         var n = t.fork(t.ALL),
             i = this.value,
-            r = e.field || Sn,
+            r = e.field || kn,
             s = e.as || "path",
             o = n.SOURCE;
-        !i || e.modified() ? (this.value = i = RR(e.projection), n.materialize().reflow()) : o = r === Sn || t.modified(r.fields) ? n.ADD_MOD : n.ADD;
+        !i || e.modified() ? (this.value = i = RR(e.projection), n.materialize().reflow()) : o = r === kn || t.modified(r.fields) ? n.ADD_MOD : n.ADD;
         const a = eie(i, e.pointRadius);
         return n.visit(o, (u) => u[s] = i(r(u))), i.pointRadius(a), n.modifies(s);
     }
 });
 
 function eie(e, t) {
     const n = e.pointRadius();
@@ -22658,15 +22645,15 @@
         name: "as",
         type: "string",
         array: !0,
         length: 2,
         default: ["x", "y"]
     }]
 };
-Q(m3, B, {
+Z(m3, B, {
     transform(e, t) {
         var n = e.projection,
             i = e.fields[0],
             r = e.fields[1],
             s = e.as || ["x", "y"],
             o = s[0],
             a = s[1],
@@ -22702,15 +22689,15 @@
         expr: !0
     }, {
         name: "as",
         type: "string",
         default: "shape"
     }]
 };
-Q(y3, B, {
+Z(y3, B, {
     transform(e, t) {
         var n = t.fork(t.ALL),
             i = this.value,
             r = e.as || "shape",
             s = n.ADD;
         return (!i || e.modified()) && (this.value = i = tie(RR(e.projection), e.field || Ki("datum"), e.pointRadius), n.materialize().reflow(), s = n.SOURCE), n.visit(s, (o) => o[r] = i), n.modifies(r);
     }
@@ -22783,15 +22770,15 @@
         default: [10, 10]
     }, {
         name: "precision",
         type: "number",
         default: 2.5
     }]
 };
-Q(b3, B, {
+Z(b3, B, {
     transform(e, t) {
         var n = this.value,
             i = this.generator,
             r;
         if (!n.length || e.modified())
             for (const s in e)
                 Me(i[s]) && i[s](e[s]);
@@ -22825,52 +22812,52 @@
         default: "independent"
     }, {
         name: "as",
         type: "string",
         default: "image"
     }]
 };
-Q(v3, B, {
+Z(v3, B, {
     transform(e, t) {
         if (!t.changed() && !e.modified())
             return t.StopPropagation;
         var n = t.materialize(t.SOURCE).source,
             i = e.resolve === "shared",
-            r = e.field || Sn,
+            r = e.field || kn,
             s = iie(e.opacity, e),
             o = nie(e.color, e),
             a = e.as || "image",
             u = {
                 $x: 0,
                 $y: 0,
                 $value: 0,
-                $max: i ? xn(n.map((l) => xn(r(l).values))) : 0
+                $max: i ? wn(n.map((l) => wn(r(l).values))) : 0
             };
         return n.forEach((l) => {
             const c = r(l),
-                f = Ce({}, l, u);
-            i || (f.$max = xn(c.values || [])), l[a] = rie(c, f, o.dep ? o : kn(o(f)), s.dep ? s : kn(s(f)));
+                f = $e({}, l, u);
+            i || (f.$max = wn(c.values || [])), l[a] = rie(c, f, o.dep ? o : An(o(f)), s.dep ? s : An(s(f)));
         }), t.reflow(!0).modifies(a);
     }
 });
 
 function nie(e, t) {
     let n;
-    return Me(e) ? (n = (i) => nr(e(i, t)), n.dep = UR(e)) : n = kn(nr(e || "#888")), n;
+    return Me(e) ? (n = (i) => nr(e(i, t)), n.dep = UR(e)) : n = An(nr(e || "#888")), n;
 }
 
 function iie(e, t) {
     let n;
-    return Me(e) ? (n = (i) => e(i, t), n.dep = UR(e)) : e ? n = kn(e) : (n = (i) => i.$value / i.$max || 0, n.dep = !0), n;
+    return Me(e) ? (n = (i) => e(i, t), n.dep = UR(e)) : e ? n = An(e) : (n = (i) => i.$value / i.$max || 0, n.dep = !0), n;
 }
 
 function UR(e) {
     if (!Me(e))
         return !1;
-    const t = Fr(bn(e));
+    const t = Fr(vn(e));
     return t.$x || t.$y || t.$value || t.$max;
 }
 
 function rie(e, t, n, i) {
     const r = e.width,
         s = e.height,
         o = e.x1 || 0,
@@ -22893,48 +22880,48 @@
     }
     return h.putImageData(g, 0, 0), d;
 }
 
 function jR(e) {
     B.call(this, null, e), this.modified(!0);
 }
-Q(jR, B, {
+Z(jR, B, {
     transform(e, t) {
         let n = this.value;
         return !n || e.modified("type") ? (this.value = n = oie(e.type), Gx.forEach((i) => {
-            e[i] != null && bC(n, i, e[i]);
+            e[i] != null && b$(n, i, e[i]);
         })) : Gx.forEach((i) => {
-            e.modified(i) && bC(n, i, e[i]);
+            e.modified(i) && b$(n, i, e[i]);
         }), e.pointRadius != null && n.path.pointRadius(e.pointRadius), e.fit && sie(n, e), t.fork(t.NO_SOURCE | t.NO_FIELDS);
     }
 });
 
 function sie(e, t) {
     const n = aie(t.fit);
     t.extent ? e.fitExtent(t.extent, n) : t.size && e.fitSize(t.size, n);
 }
 
 function oie(e) {
     const t = l3((e || "mercator").toLowerCase());
-    return t || q("Unrecognized projection type: " + e), t();
+    return t || W("Unrecognized projection type: " + e), t();
 }
 
-function bC(e, t, n) {
+function b$(e, t, n) {
     Me(e[t]) && e[t](n);
 }
 
 function aie(e) {
-    return e = ne(e), e.length === 1 ? e[0] : {
+    return e = re(e), e.length === 1 ? e[0] : {
         type: h3,
         features: e.reduce((t, n) => t.concat(uie(n)), [])
     };
 }
 
 function uie(e) {
-    return e.type === h3 ? e.features : ne(e).filter((t) => t != null).map((t) => t.type === Vx ? t : {
+    return e.type === h3 ? e.features : re(e).filter((t) => t != null).map((t) => t.type === Vx ? t : {
         type: Vx,
         geometry: t
     });
 }
 const lie = /* @__PURE__ */ Object.freeze( /* @__PURE__ */ Object.defineProperty({
     __proto__: null,
     contour: d3,
@@ -23066,36 +23053,36 @@
 function pie(e) {
     return arguments.length ? this.cover(+e[0][0], +e[0][1]).cover(+e[1][0], +e[1][1]) : isNaN(this._x0) ? void 0 : [
         [this._x0, this._y0],
         [this._x1, this._y1]
     ];
 }
 
-function Dn(e, t, n, i, r) {
+function Rn(e, t, n, i, r) {
     this.node = e, this.x0 = t, this.y0 = n, this.x1 = i, this.y1 = r;
 }
 
 function mie(e, t, n) {
     var i, r = this._x0,
         s = this._y0,
         o, a, u, l, c = this._x1,
         f = this._y1,
         d = [],
         h = this._root,
         g, p;
-    for (h && d.push(new Dn(h, r, s, c, f)), n == null ? n = 1 / 0 : (r = e - n, s = t - n, c = e + n, f = t + n, n *= n); g = d.pop();)
+    for (h && d.push(new Rn(h, r, s, c, f)), n == null ? n = 1 / 0 : (r = e - n, s = t - n, c = e + n, f = t + n, n *= n); g = d.pop();)
         if (!(!(h = g.node) || (o = g.x0) > c || (a = g.y0) > f || (u = g.x1) < r || (l = g.y1) < s))
             if (h.length) {
                 var m = (o + u) / 2,
                     y = (a + l) / 2;
                 d.push(
-                    new Dn(h[3], m, y, u, l),
-                    new Dn(h[2], o, y, m, l),
-                    new Dn(h[1], m, a, u, y),
-                    new Dn(h[0], o, a, m, y)
+                    new Rn(h[3], m, y, u, l),
+                    new Rn(h[2], o, y, m, l),
+                    new Rn(h[1], m, a, u, y),
+                    new Rn(h[0], o, a, m, y)
                 ), (p = (t >= y) << 1 | e >= m) && (g = d[d.length - 1], d[d.length - 1] = d[d.length - 1 - p], d[d.length - 1 - p] = g);
             } else {
                 var b = e - +this._x.call(null, h.data),
                     v = t - +this._y.call(null, h.data),
                     x = b * b + v * v;
                 if (x < n) {
                     var w = Math.sqrt(n = x);
@@ -23151,37 +23138,37 @@
     }), e;
 }
 
 function wie(e) {
     var t = [],
         n, i = this._root,
         r, s, o, a, u;
-    for (i && t.push(new Dn(i, this._x0, this._y0, this._x1, this._y1)); n = t.pop();)
+    for (i && t.push(new Rn(i, this._x0, this._y0, this._x1, this._y1)); n = t.pop();)
         if (!e(i = n.node, s = n.x0, o = n.y0, a = n.x1, u = n.y1) && i.length) {
             var l = (s + a) / 2,
                 c = (o + u) / 2;
-            (r = i[3]) && t.push(new Dn(r, l, c, a, u)), (r = i[2]) && t.push(new Dn(r, s, c, l, u)), (r = i[1]) && t.push(new Dn(r, l, o, a, c)), (r = i[0]) && t.push(new Dn(r, s, o, l, c));
+            (r = i[3]) && t.push(new Rn(r, l, c, a, u)), (r = i[2]) && t.push(new Rn(r, s, c, l, u)), (r = i[1]) && t.push(new Rn(r, l, o, a, c)), (r = i[0]) && t.push(new Rn(r, s, o, l, c));
         }
     return this;
 }
 
 function _ie(e) {
     var t = [],
         n = [],
         i;
-    for (this._root && t.push(new Dn(this._root, this._x0, this._y0, this._x1, this._y1)); i = t.pop();) {
+    for (this._root && t.push(new Rn(this._root, this._x0, this._y0, this._x1, this._y1)); i = t.pop();) {
         var r = i.node;
         if (r.length) {
             var s, o = i.x0,
                 a = i.y0,
                 u = i.x1,
                 l = i.y1,
                 c = (o + u) / 2,
                 f = (a + l) / 2;
-            (s = r[0]) && t.push(new Dn(s, o, a, c, f)), (s = r[1]) && t.push(new Dn(s, c, a, u, f)), (s = r[2]) && t.push(new Dn(s, o, f, c, l)), (s = r[3]) && t.push(new Dn(s, c, f, u, l));
+            (s = r[0]) && t.push(new Rn(s, o, a, c, f)), (s = r[1]) && t.push(new Rn(s, c, a, u, f)), (s = r[2]) && t.push(new Rn(s, o, f, c, l)), (s = r[3]) && t.push(new Rn(s, c, f, u, l));
         }
         n.push(i);
     }
     for (; i = n.pop();)
         e(i.node, i.x0, i.y0, i.x1, i.y1);
     return this;
 }
@@ -23207,100 +23194,100 @@
     return e == null ? i : i.addAll(e);
 }
 
 function w3(e, t, n, i, r, s) {
     this._x = e, this._y = t, this._x0 = n, this._y0 = i, this._x1 = r, this._y1 = s, this._root = void 0;
 }
 
-function vC(e) {
+function v$(e) {
     for (var t = {
             data: e.data
         }, n = t; e = e.next;)
         n = n.next = {
             data: e.data
         };
     return t;
 }
-var Hn = x3.prototype = w3.prototype;
-Hn.copy = function() {
+var Gn = x3.prototype = w3.prototype;
+Gn.copy = function() {
     var e = new w3(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
         t = this._root,
         n, i;
     if (!t)
         return e;
     if (!t.length)
-        return e._root = vC(t), e;
+        return e._root = v$(t), e;
     for (n = [{
             source: t,
             target: e._root = new Array(4)
         }]; t = n.pop();)
         for (var r = 0; r < 4; ++r)
             (i = t.source[r]) && (i.length ? n.push({
                 source: i,
                 target: t.target[r] = new Array(4)
-            }) : t.target[r] = vC(i));
+            }) : t.target[r] = v$(i));
     return e;
 };
-Hn.add = fie;
-Hn.addAll = die;
-Hn.cover = hie;
-Hn.data = gie;
-Hn.extent = pie;
-Hn.find = mie;
-Hn.remove = yie;
-Hn.removeAll = bie;
-Hn.root = vie;
-Hn.size = xie;
-Hn.visit = wie;
-Hn.visitAfter = _ie;
-Hn.x = Sie;
-Hn.y = Aie;
+Gn.add = fie;
+Gn.addAll = die;
+Gn.cover = hie;
+Gn.data = gie;
+Gn.extent = pie;
+Gn.find = mie;
+Gn.remove = yie;
+Gn.removeAll = bie;
+Gn.root = vie;
+Gn.size = xie;
+Gn.visit = wie;
+Gn.visitAfter = _ie;
+Gn.x = Sie;
+Gn.y = Aie;
 
-function Ln(e) {
+function In(e) {
     return function() {
         return e;
     };
 }
 
 function Jo(e) {
     return (e() - 0.5) * 1e-6;
 }
 
-function $ie(e) {
+function Cie(e) {
     return e.x + e.vx;
 }
 
-function Cie(e) {
+function $ie(e) {
     return e.y + e.vy;
 }
 
 function Mie(e) {
     var t, n, i, r = 1,
         s = 1;
-    typeof e != "function" && (e = Ln(e == null ? 1 : +e));
+    typeof e != "function" && (e = In(e == null ? 1 : +e));
 
     function o() {
         for (var l, c = t.length, f, d, h, g, p, m, y = 0; y < s; ++y)
-            for (f = x3(t, $ie, Cie).visitAfter(a), l = 0; l < c; ++l)
+            for (f = x3(t, Cie, $ie).visitAfter(a), l = 0; l < c; ++l)
                 d = t[l], p = n[d.index], m = p * p, h = d.x + d.vx, g = d.y + d.vy, f.visit(b);
 
-        function b(v, x, w, S, _) {
+        function b(v, x, w, E, _) {
             var k = v.data,
                 A = v.r,
-                F = p + A;
+                T = p + A;
             if (k) {
                 if (k.index > d.index) {
-                    var T = h - k.x - k.vx,
-                        I = g - k.y - k.vy,
-                        N = T * T + I * I;
-                    N < F * F && (T === 0 && (T = Jo(i), N += T * T), I === 0 && (I = Jo(i), N += I * I), N = (F - (N = Math.sqrt(N))) / N * r, d.vx += (T *= N) * (F = (A *= A) / (m + A)), d.vy += (I *= N) * F, k.vx -= T * (F = 1 - F), k.vy -= I * F);
+                    var M = h - k.x - k.vx,
+                        L = g - k.y - k.vy,
+                        F = M * M + L * L;
+                    F < T * T && (M === 0 && (M = Jo(i), F += M * M), L === 0 && (L = Jo(i), F += L * L), F = (T - (F = Math.sqrt(F))) / F * r, d.vx += (M *= F) * (T = (A *= A) / (m + A)), d.vy += (L *= F) * T, k.vx -= M * (T = 1 - T), k.vy -= L * T);
                 }
                 return;
             }
-            return x > h + F || S < h - F || w > g + F || _ < g - F;
+            return x > h + T || E < h - T || w > g + T || _ < g - T;
         }
     }
 
     function a(l) {
         if (l.data)
             return l.r = n[l.data.index];
         for (var c = l.r = 0; c < 4; ++c)
@@ -23318,54 +23305,54 @@
     return o.initialize = function(l, c) {
         t = l, i = c, u();
     }, o.iterations = function(l) {
         return arguments.length ? (s = +l, o) : s;
     }, o.strength = function(l) {
         return arguments.length ? (r = +l, o) : r;
     }, o.radius = function(l) {
-        return arguments.length ? (e = typeof l == "function" ? l : Ln(+l), u(), o) : e;
+        return arguments.length ? (e = typeof l == "function" ? l : In(+l), u(), o) : e;
     }, o;
 }
 
 function Tie(e) {
     return e.index;
 }
 
-function xC(e, t) {
+function x$(e, t) {
     var n = e.get(t);
     if (!n)
         throw new Error("node not found: " + t);
     return n;
 }
 
 function Fie(e) {
     var t = Tie,
         n = f,
-        i, r = Ln(30),
+        i, r = In(30),
         s, o, a, u, l, c = 1;
     e == null && (e = []);
 
     function f(m) {
         return 1 / Math.min(a[m.source.index], a[m.target.index]);
     }
 
     function d(m) {
         for (var y = 0, b = e.length; y < c; ++y)
-            for (var v = 0, x, w, S, _, k, A, F; v < b; ++v)
-                x = e[v], w = x.source, S = x.target, _ = S.x + S.vx - w.x - w.vx || Jo(l), k = S.y + S.vy - w.y - w.vy || Jo(l), A = Math.sqrt(_ * _ + k * k), A = (A - s[v]) / A * m * i[v], _ *= A, k *= A, S.vx -= _ * (F = u[v]), S.vy -= k * F, w.vx += _ * (F = 1 - F), w.vy += k * F;
+            for (var v = 0, x, w, E, _, k, A, T; v < b; ++v)
+                x = e[v], w = x.source, E = x.target, _ = E.x + E.vx - w.x - w.vx || Jo(l), k = E.y + E.vy - w.y - w.vy || Jo(l), A = Math.sqrt(_ * _ + k * k), A = (A - s[v]) / A * m * i[v], _ *= A, k *= A, E.vx -= _ * (T = u[v]), E.vy -= k * T, w.vx += _ * (T = 1 - T), w.vy += k * T;
     }
 
     function h() {
         if (o) {
             var m, y = o.length,
                 b = e.length,
-                v = new Map(o.map((w, S) => [t(w, S, o), w])),
+                v = new Map(o.map((w, E) => [t(w, E, o), w])),
                 x;
             for (m = 0, a = new Array(y); m < b; ++m)
-                x = e[m], x.index = m, typeof x.source != "object" && (x.source = xC(v, x.source)), typeof x.target != "object" && (x.target = xC(v, x.target)), a[x.source.index] = (a[x.source.index] || 0) + 1, a[x.target.index] = (a[x.target.index] || 0) + 1;
+                x = e[m], x.index = m, typeof x.source != "object" && (x.source = x$(v, x.source)), typeof x.target != "object" && (x.target = x$(v, x.target)), a[x.source.index] = (a[x.source.index] || 0) + 1, a[x.target.index] = (a[x.target.index] || 0) + 1;
             for (m = 0, u = new Array(b); m < b; ++m)
                 x = e[m], u[m] = a[x.source.index] / (a[x.source.index] + a[x.target.index]);
             i = new Array(b), g(), s = new Array(b), p();
         }
     }
 
     function g() {
@@ -23384,17 +23371,17 @@
     }, d.links = function(m) {
         return arguments.length ? (e = m, h(), d) : e;
     }, d.id = function(m) {
         return arguments.length ? (t = m, d) : t;
     }, d.iterations = function(m) {
         return arguments.length ? (c = +m, d) : c;
     }, d.strength = function(m) {
-        return arguments.length ? (n = typeof m == "function" ? m : Ln(+m), g(), d) : n;
+        return arguments.length ? (n = typeof m == "function" ? m : In(+m), g(), d) : n;
     }, d.distance = function(m) {
-        return arguments.length ? (r = typeof m == "function" ? m : Ln(+m), p(), d) : r;
+        return arguments.length ? (r = typeof m == "function" ? m : In(+m), p(), d) : r;
     }, d;
 }
 var Nie = {
     value: () => {}
 };
 
 function _3() {
@@ -23435,18 +23422,18 @@
                     return r;
             return;
         }
         if (t != null && typeof t != "function")
             throw new Error("invalid callback: " + t);
         for (; ++s < o;)
             if (r = (e = i[s]).type)
-                n[r] = wC(n[r], e.name, t);
+                n[r] = w$(n[r], e.name, t);
             else if (t == null)
             for (r in n)
-                n[r] = wC(n[r], e.name, null);
+                n[r] = w$(n[r], e.name, null);
         return this;
     },
     copy: function() {
         var e = {},
             t = this._;
         for (var n in t)
             e[n] = t[n].slice();
@@ -23471,15 +23458,15 @@
 
 function Die(e, t) {
     for (var n = 0, i = e.length, r; n < i; ++n)
         if ((r = e[n]).name === t)
             return r.value;
 }
 
-function wC(e, t, n) {
+function w$(e, t, n) {
     for (var i = 0, r = e.length; i < r; ++i)
         if (e[i].name === t) {
             e[i] = Nie, e = e.slice(0, i).concat(e.slice(i + 1));
             break;
         }
     return n != null && e.push({
         name: t,
@@ -23502,42 +23489,42 @@
     return Gu || (HR(Rie), Gu = Ah.now() + gy);
 }
 
 function Rie() {
     Gu = 0;
 }
 
-function $h() {
+function Ch() {
     this._call = this._time = this._next = null;
 }
-$h.prototype = E3.prototype = {
-    constructor: $h,
+Ch.prototype = E3.prototype = {
+    constructor: Ch,
     restart: function(e, t, n) {
         if (typeof e != "function")
             throw new TypeError("callback is not a function");
         n = (n == null ? py() : +n) + (t == null ? 0 : +t), !this._next && Nd !== this && (Nd ? Nd._next = this : T0 = this, Nd = this), this._call = e, this._time = n, Yx();
     },
     stop: function() {
         this._call && (this._call = null, this._time = 1 / 0, Yx());
     }
 };
 
 function E3(e, t, n) {
-    var i = new $h();
+    var i = new Ch();
     return i.restart(e, t, n), i;
 }
 
 function Lie() {
     py(), ++zc;
     for (var e = T0, t; e;)
         (t = Gu - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
     --zc;
 }
 
-function _C() {
+function _$() {
     Gu = (F0 = Ah.now()) + gy, zc = Fd = 0;
     try {
         Lie();
     } finally {
         zc = 0, Pie(), Gu = 0;
     }
 }
@@ -23554,41 +23541,41 @@
     Nd = e, Yx(i);
 }
 
 function Yx(e) {
     if (!zc) {
         Fd && (Fd = clearTimeout(Fd));
         var t = e - Gu;
-        t > 24 ? (e < 1 / 0 && (Fd = setTimeout(_C, e - Ah.now() - gy)), ed && (ed = clearInterval(ed))) : (ed || (F0 = Ah.now(), ed = setInterval(Iie, WR)), zc = 1, HR(_C));
+        t > 24 ? (e < 1 / 0 && (Fd = setTimeout(_$, e - Ah.now() - gy)), ed && (ed = clearInterval(ed))) : (ed || (F0 = Ah.now(), ed = setInterval(Iie, WR)), zc = 1, HR(_$));
     }
 }
 
-function EC(e, t, n) {
-    var i = new $h();
+function E$(e, t, n) {
+    var i = new Ch();
     return t = t == null ? 0 : +t, i.restart((r) => {
         i.stop(), e(r + t);
     }, t, n), i;
 }
 
 function zie(e, t, n) {
-    var i = new $h(),
+    var i = new Ch(),
         r = t;
     return t == null ? (i.restart(e, t, n), i) : (i._restart = i.restart, i.restart = function(s, o, a) {
         o = +o, a = a == null ? py() : +a, i._restart(function u(l) {
             l += r, i._restart(u, r += o, a), s(l);
         }, o, a);
     }, i.restart(e, t, n), i);
 }
 const Bie = 1664525,
     Uie = 1013904223,
-    SC = 4294967296;
+    S$ = 4294967296;
 
 function jie() {
     let e = 1;
-    return () => (e = (Bie * e + Uie) % SC) / SC;
+    return () => (e = (Bie * e + Uie) % S$) / S$;
 }
 
 function qie(e) {
     return e.x;
 }
 
 function Wie(e) {
@@ -23670,27 +23657,27 @@
         },
         force: function(p, m) {
             return arguments.length > 1 ? (m == null ? a.delete(p) : a.set(p, g(m)), t) : a.get(p);
         },
         find: function(p, m, y) {
             var b = 0,
                 v = e.length,
-                x, w, S, _, k;
+                x, w, E, _, k;
             for (y == null ? y = 1 / 0 : y *= y, b = 0; b < v; ++b)
-                _ = e[b], x = p - _.x, w = m - _.y, S = x * x + w * w, S < y && (k = _, y = S);
+                _ = e[b], x = p - _.x, w = m - _.y, E = x * x + w * w, E < y && (k = _, y = E);
             return k;
         },
         on: function(p, m) {
             return arguments.length > 1 ? (l.on(p, m), t) : l.on(p);
         }
     };
 }
 
 function Yie() {
-    var e, t, n, i, r = Ln(-30),
+    var e, t, n, i, r = In(-30),
         s, o = 1,
         a = 1 / 0,
         u = 0.81;
 
     function l(h) {
         var g, p = e.length,
             m = x3(e, qie, Wie).visitAfter(f);
@@ -23739,28 +23726,28 @@
         do
             h.data !== t && (v = s[h.data.index] * i / x, t.vx += y * v, t.vy += b * v);
         while (h = h.next);
     }
     return l.initialize = function(h, g) {
         e = h, n = g, c();
     }, l.strength = function(h) {
-        return arguments.length ? (r = typeof h == "function" ? h : Ln(+h), c(), l) : r;
+        return arguments.length ? (r = typeof h == "function" ? h : In(+h), c(), l) : r;
     }, l.distanceMin = function(h) {
         return arguments.length ? (o = h * h, l) : Math.sqrt(o);
     }, l.distanceMax = function(h) {
         return arguments.length ? (a = h * h, l) : Math.sqrt(a);
     }, l.theta = function(h) {
         return arguments.length ? (u = h * h, l) : Math.sqrt(u);
     }, l;
 }
 
 function Xie(e) {
-    var t = Ln(0.1),
+    var t = In(0.1),
         n, i, r;
-    typeof e != "function" && (e = Ln(e == null ? 0 : +e));
+    typeof e != "function" && (e = In(e == null ? 0 : +e));
 
     function s(a) {
         for (var u = 0, l = n.length, c; u < l; ++u)
             c = n[u], c.vx += (r[u] - c.x) * i[u] * a;
     }
 
     function o() {
@@ -23769,24 +23756,24 @@
             for (i = new Array(u), r = new Array(u), a = 0; a < u; ++a)
                 i[a] = isNaN(r[a] = +e(n[a], a, n)) ? 0 : +t(n[a], a, n);
         }
     }
     return s.initialize = function(a) {
         n = a, o();
     }, s.strength = function(a) {
-        return arguments.length ? (t = typeof a == "function" ? a : Ln(+a), o(), s) : t;
+        return arguments.length ? (t = typeof a == "function" ? a : In(+a), o(), s) : t;
     }, s.x = function(a) {
-        return arguments.length ? (e = typeof a == "function" ? a : Ln(+a), o(), s) : e;
+        return arguments.length ? (e = typeof a == "function" ? a : In(+a), o(), s) : e;
     }, s;
 }
 
 function Kie(e) {
-    var t = Ln(0.1),
+    var t = In(0.1),
         n, i, r;
-    typeof e != "function" && (e = Ln(e == null ? 0 : +e));
+    typeof e != "function" && (e = In(e == null ? 0 : +e));
 
     function s(a) {
         for (var u = 0, l = n.length, c; u < l; ++u)
             c = n[u], c.vy += (r[u] - c.y) * i[u] * a;
     }
 
     function o() {
@@ -23795,20 +23782,20 @@
             for (i = new Array(u), r = new Array(u), a = 0; a < u; ++a)
                 i[a] = isNaN(r[a] = +e(n[a], a, n)) ? 0 : +t(n[a], a, n);
         }
     }
     return s.initialize = function(a) {
         n = a, o();
     }, s.strength = function(a) {
-        return arguments.length ? (t = typeof a == "function" ? a : Ln(+a), o(), s) : t;
+        return arguments.length ? (t = typeof a == "function" ? a : In(+a), o(), s) : t;
     }, s.y = function(a) {
-        return arguments.length ? (e = typeof a == "function" ? a : Ln(+a), o(), s) : e;
+        return arguments.length ? (e = typeof a == "function" ? a : In(+a), o(), s) : e;
     }, s;
 }
-const kC = {
+const k$ = {
         center: cie,
         collide: Mie,
         nbody: Yie,
         link: Fie,
         x: Xie,
         y: Kie
     },
@@ -23961,15 +23948,15 @@
         name: "as",
         type: "string",
         array: !0,
         modify: !1,
         default: GR
     }]
 };
-Q(S3, B, {
+Z(S3, B, {
     transform(e, t) {
         var n = this.value,
             i = t.changed(t.ADD_REM),
             r = e.modified(Xx),
             s = e.iterations || 300;
         if (n ? (i && (t.modifies("index"), n.nodes(t.source)), (r || t.changed(t.MOD)) && VR(n, e, 0, t)) : (this.value = n = Zie(t.source, e), n.on("tick", Qie(t.dataflow, this)), e.static || (i = !0, n.tick()), t.modifies("index")), r || i || e.modified(Jie) || t.changed() && e.restart) {
             if (n.alpha(Math.max(n.alpha(), e.alpha || 1)).alphaDecay(1 - Math.pow(n.alphaMin(), 1 / s)), e.static)
@@ -24003,36 +23990,36 @@
         i = n.stop,
         r = n.restart;
     let s = !1;
     return n.stopped = () => s, n.restart = () => (s = !1, r()), n.stop = () => (s = !0, i()), VR(n, t, !0).on("end", () => s = !0);
 }
 
 function VR(e, t, n, i) {
-    var r = ne(t.forces),
+    var r = re(t.forces),
         s, o, a, u;
     for (s = 0, o = Xx.length; s < o; ++s)
         a = Xx[s], a !== Od && t.modified(a) && e[a](t[a]);
     for (s = 0, o = r.length; s < o; ++s)
         u = Od + s, a = n || t.modified(Od, s) ? tre(r[s]) : i && ere(r[s], i) ? e.force(u) : null, a && e.force(u, a);
     for (o = e.numForces || 0; s < o; ++s)
         e.force(Od + s, null);
     return e.numForces = r.length, e;
 }
 
 function ere(e, t) {
     var n, i;
     for (n in e)
-        if (Me(i = e[n]) && t.modified(bn(i)))
+        if (Me(i = e[n]) && t.modified(vn(i)))
             return 1;
     return 0;
 }
 
 function tre(e) {
     var t, n;
-    be(kC, e.force) || q("Unrecognized force: " + e.force), t = kC[e.force]();
+    xe(k$, e.force) || W("Unrecognized force: " + e.force), t = k$[e.force]();
     for (n in e)
         Me(t[n]) && nre(t[n], e[n], e);
     return t;
 }
 
 function nre(e, t, n) {
     e(Me(t) ? (i) => t(i, n) : t);
@@ -24225,27 +24212,27 @@
             if (yield e, i = e.children)
                 for (r = 0, s = i.length; r < s; ++r)
                     n.push(i[r]);
     while (n.length);
 }
 
 function k3(e, t) {
-    e instanceof Map ? (e = [void 0, e], t === void 0 && (t = Mre)) : t === void 0 && (t = Cre);
+    e instanceof Map ? (e = [void 0, e], t === void 0 && (t = Mre)) : t === void 0 && (t = $re);
     for (var n = new Bc(e), i, r = [n], s, o, a, u; i = r.pop();)
         if ((o = t(i.data)) && (u = (o = Array.from(o)).length))
             for (i.children = o, a = u - 1; a >= 0; --a)
                 r.push(s = o[a] = new Bc(o[a])), s.parent = i, s.depth = i.depth + 1;
     return n.eachBefore(YR);
 }
 
-function $re() {
+function Cre() {
     return k3(this).eachBefore(Tre);
 }
 
-function Cre(e) {
+function $re(e) {
     return e.children;
 }
 
 function Mre(e) {
     return Array.isArray(e) ? e[1] : null;
 }
 
@@ -24273,15 +24260,15 @@
     sum: bre,
     sort: vre,
     path: xre,
     ancestors: _re,
     descendants: Ere,
     leaves: Sre,
     links: kre,
-    copy: $re,
+    copy: Cre,
     [Symbol.iterator]: Are
 };
 
 function lm(e) {
     return e == null ? null : XR(e);
 }
 
@@ -24298,19 +24285,19 @@
 function ec(e) {
     return function() {
         return e;
     };
 }
 const Fre = 1664525,
     Nre = 1013904223,
-    AC = 4294967296;
+    A$ = 4294967296;
 
 function Ore() {
     let e = 1;
-    return () => (e = (Fre * e + Nre) % AC) / AC;
+    return () => (e = (Fre * e + Nre) % A$) / A$;
 }
 
 function Dre(e) {
     return typeof e == "object" && "length" in e ? e : Array.from(e);
 }
 
 function Rre(e, t) {
@@ -24415,44 +24402,44 @@
         p = r - c,
         m = u - s,
         y = f - s,
         b = i * i + r * r - s * s,
         v = b - o * o - a * a + u * u,
         x = b - l * l - c * c + f * f,
         w = h * g - d * p,
-        S = (g * x - p * v) / (w * 2) - i,
+        E = (g * x - p * v) / (w * 2) - i,
         _ = (p * m - g * y) / w,
         k = (h * v - d * x) / (w * 2) - r,
         A = (d * y - h * m) / w,
-        F = _ * _ + A * A - 1,
-        T = 2 * (s + S * _ + k * A),
-        I = S * S + k * k - s * s,
-        N = -(Math.abs(F) > 1e-6 ? (T + Math.sqrt(T * T - 4 * F * I)) / (2 * F) : I / T);
+        T = _ * _ + A * A - 1,
+        M = 2 * (s + E * _ + k * A),
+        L = E * E + k * k - s * s,
+        F = -(Math.abs(T) > 1e-6 ? (M + Math.sqrt(M * M - 4 * T * L)) / (2 * T) : L / M);
     return {
-        x: i + S + _ * N,
-        y: r + k + A * N,
-        r: N
+        x: i + E + _ * F,
+        y: r + k + A * F,
+        r: F
     };
 }
 
-function $C(e, t, n) {
+function C$(e, t, n) {
     var i = e.x - t.x,
         r, s, o = e.y - t.y,
         a, u, l = i * i + o * o;
     l ? (s = t.r + n.r, s *= s, u = e.r + n.r, u *= u, s > u ? (r = (l + u - s) / (2 * l), a = Math.sqrt(Math.max(0, u / l - r * r)), n.x = e.x - r * i - a * o, n.y = e.y - r * o + a * i) : (r = (l + s - u) / (2 * l), a = Math.sqrt(Math.max(0, s / l - r * r)), n.x = t.x + r * i - a * o, n.y = t.y + r * o + a * i)) : (n.x = t.x + n.r, n.y = t.y);
 }
 
-function CC(e, t) {
+function $$(e, t) {
     var n = e.r + t.r - 1e-6,
         i = t.x - e.x,
         r = t.y - e.y;
     return n > 0 && n * n > i * i + r * r;
 }
 
-function MC(e) {
+function M$(e) {
     var t = e._,
         n = e.next._,
         i = t.r + n.r,
         r = (t.x * n.r + n.x * t.r) / i,
         s = (t.y * n.r + n.y * t.r) / i;
     return r * r + s * s;
 }
@@ -24465,36 +24452,36 @@
     if (!(s = (e = Dre(e)).length))
         return 0;
     var n, i, r, s, o, a, u, l, c, f, d;
     if (n = e[0], n.x = 0, n.y = 0, !(s > 1))
         return n.r;
     if (i = e[1], n.x = -i.r, i.x = n.r, i.y = 0, !(s > 2))
         return n.r + i.r;
-    $C(i, n, r = e[2]), n = new vp(n), i = new vp(i), r = new vp(r), n.next = r.previous = i, i.next = n.previous = r, r.next = i.previous = n;
+    C$(i, n, r = e[2]), n = new vp(n), i = new vp(i), r = new vp(r), n.next = r.previous = i, i.next = n.previous = r, r.next = i.previous = n;
     e:
         for (u = 3; u < s; ++u) {
-            $C(n._, i._, r = e[u]), r = new vp(r), l = i.next, c = n.previous, f = i._.r, d = n._.r;
+            C$(n._, i._, r = e[u]), r = new vp(r), l = i.next, c = n.previous, f = i._.r, d = n._.r;
             do
                 if (f <= d) {
-                    if (CC(l._, r._)) {
+                    if ($$(l._, r._)) {
                         i = l, n.next = i, i.previous = n, --u;
                         continue e;
                     }
                     f += l._.r, l = l.next;
                 } else {
-                    if (CC(c._, r._)) {
+                    if ($$(c._, r._)) {
                         n = c, n.next = i, i.previous = n, --u;
                         continue e;
                     }
                     d += c._.r, c = c.previous;
                 }
             while (l !== c.next);
-            for (r.previous = n, r.next = i, n.next = i.previous = i = r, o = MC(n);
+            for (r.previous = n, r.next = i, n.next = i.previous = i = r, o = M$(n);
                 (r = r.next) !== i;)
-                (a = MC(r)) < o && (n = r, o = a);
+                (a = M$(r)) < o && (n = r, o = a);
             i = n.next;
         }
     for (n = [i._], r = i;
         (r = r.next) !== i;)
         n.push(r._);
     for (r = Lre(n, t), u = 0; u < s; ++u)
         n = e[u], n.x -= r.x, n.y -= r.y;
@@ -24509,26 +24496,26 @@
     var e = null,
         t = 1,
         n = 1,
         i = pu;
 
     function r(s) {
         const o = Ore();
-        return s.x = t / 2, s.y = n / 2, e ? s.eachBefore(TC(e)).eachAfter(xv(i, 0.5, o)).eachBefore(FC(1)) : s.eachBefore(TC(Ure)).eachAfter(xv(pu, 1, o)).eachAfter(xv(i, s.r / Math.min(t, n), o)).eachBefore(FC(Math.min(t, n) / (2 * s.r))), s;
+        return s.x = t / 2, s.y = n / 2, e ? s.eachBefore(T$(e)).eachAfter(xv(i, 0.5, o)).eachBefore(F$(1)) : s.eachBefore(T$(Ure)).eachAfter(xv(pu, 1, o)).eachAfter(xv(i, s.r / Math.min(t, n), o)).eachBefore(F$(Math.min(t, n) / (2 * s.r))), s;
     }
     return r.radius = function(s) {
         return arguments.length ? (e = lm(s), r) : e;
     }, r.size = function(s) {
         return arguments.length ? (t = +s[0], n = +s[1], r) : [t, n];
     }, r.padding = function(s) {
         return arguments.length ? (i = typeof s == "function" ? s : ec(+s), r) : i;
     }, r;
 }
 
-function TC(e) {
+function T$(e) {
     return function(t) {
         t.children || (t.r = Math.max(0, +e(t) || 0));
     };
 }
 
 function xv(e, t, n) {
     return function(i) {
@@ -24543,15 +24530,15 @@
                 for (s = 0; s < o; ++s)
                     r[s].r -= a;
             i.r = u + a;
         }
     };
 }
 
-function FC(e) {
+function F$(e) {
     return function(t) {
         var n = t.parent;
         t.r *= e, n && (t.x = n.x + e * t.x, t.y = n.y + e * t.y);
     };
 }
 
 function QR(e) {
@@ -24591,50 +24578,50 @@
     }, r.padding = function(o) {
         return arguments.length ? (n = +o, r) : n;
     }, r;
 }
 var Wre = {
         depth: -1
     },
-    NC = {},
+    N$ = {},
     wv = {};
 
 function Hre(e) {
     return e.id;
 }
 
 function Gre(e) {
     return e.parentId;
 }
 
-function OC() {
+function O$() {
     var e = Hre,
         t = Gre,
         n;
 
     function i(r) {
         var s = Array.from(r),
             o = e,
             a = t,
             u, l, c, f, d, h, g, p, m = /* @__PURE__ */ new Map();
         if (n != null) {
             const y = s.map((x, w) => Vre(n(x, w, r))),
-                b = y.map(DC),
+                b = y.map(D$),
                 v = new Set(y).add("");
             for (const x of b)
-                v.has(x) || (v.add(x), y.push(x), b.push(DC(x)), s.push(wv));
+                v.has(x) || (v.add(x), y.push(x), b.push(D$(x)), s.push(wv));
             o = (x, w) => y[w], a = (x, w) => b[w];
         }
         for (c = 0, u = s.length; c < u; ++c)
-            l = s[c], h = s[c] = new Bc(l), (g = o(l, c, r)) != null && (g += "") && (p = h.id = g, m.set(p, m.has(p) ? NC : h)), (g = a(l, c, r)) != null && (g += "") && (h.parent = g);
+            l = s[c], h = s[c] = new Bc(l), (g = o(l, c, r)) != null && (g += "") && (p = h.id = g, m.set(p, m.has(p) ? N$ : h)), (g = a(l, c, r)) != null && (g += "") && (h.parent = g);
         for (c = 0; c < u; ++c)
             if (h = s[c], g = h.parent) {
                 if (d = m.get(g), !d)
                     throw new Error("missing: " + g);
-                if (d === NC)
+                if (d === N$)
                     throw new Error("ambiguous: " + g);
                 d.children ? d.children.push(h) : d.children = [h], h.parent = d;
             } else {
                 if (f)
                     throw new Error("multiple roots");
                 f = h;
             }
@@ -24663,15 +24650,15 @@
 
 function Vre(e) {
     e = `${e}`;
     let t = e.length;
     return Kx(e, t - 1) && !Kx(e, t - 2) && (e = e.slice(0, -1)), e[0] === "/" ? e : `/${e}`;
 }
 
-function DC(e) {
+function D$(e) {
     let t = e.length;
     if (t < 2)
         return "";
     for (; --t > 1 && !Kx(e, t);)
     ;
     return e.slice(0, t);
 }
@@ -24797,21 +24784,21 @@
 function my(e, t, n, i, r) {
     for (var s = e.children, o, a = -1, u = s.length, l = e.value && (r - n) / e.value; ++a < u;)
         o = s[a], o.x0 = t, o.x1 = i, o.y0 = n, o.y1 = n += o.value * l;
 }
 var ZR = (1 + Math.sqrt(5)) / 2;
 
 function eL(e, t, n, i, r, s) {
-    for (var o = [], a = t.children, u, l, c = 0, f = 0, d = a.length, h, g, p = t.value, m, y, b, v, x, w, S; c < d;) {
+    for (var o = [], a = t.children, u, l, c = 0, f = 0, d = a.length, h, g, p = t.value, m, y, b, v, x, w, E; c < d;) {
         h = r - n, g = s - i;
         do
             m = a[f++].value;
         while (!m && f < d);
-        for (y = b = m, w = Math.max(g / h, h / g) / (p * e), S = m * m * w, x = Math.max(b / S, S / y); f < d; ++f) {
-            if (m += l = a[f].value, l < y && (y = l), l > b && (b = l), S = m * m * w, v = Math.max(b / S, S / y), v > x) {
+        for (y = b = m, w = Math.max(g / h, h / g) / (p * e), E = m * m * w, x = Math.max(b / E, E / y); f < d; ++f) {
+            if (m += l = a[f].value, l < y && (y = l), l > b && (b = l), E = m * m * w, v = Math.max(b / E, E / y), v > x) {
                 m -= l;
                 break;
             }
             x = v;
         }
         o.push(u = {
             value: m,
@@ -24887,27 +24874,27 @@
 
     function c(f, d, h, g, p, m, y) {
         if (f >= d - 1) {
             var b = s[f];
             b.x0 = g, b.y0 = p, b.x1 = m, b.y1 = y;
             return;
         }
-        for (var v = l[f], x = h / 2 + v, w = f + 1, S = d - 1; w < S;) {
-            var _ = w + S >>> 1;
-            l[_] < x ? w = _ + 1 : S = _;
+        for (var v = l[f], x = h / 2 + v, w = f + 1, E = d - 1; w < E;) {
+            var _ = w + E >>> 1;
+            l[_] < x ? w = _ + 1 : E = _;
         }
         x - l[w - 1] < l[w] - x && f + 1 < w && --w;
         var k = l[w] - v,
             A = h - k;
         if (m - g > y - p) {
-            var F = h ? (g * A + m * k) / h : m;
-            c(f, w, k, g, p, F, y), c(w, d, A, F, p, m, y);
+            var T = h ? (g * A + m * k) / h : m;
+            c(f, w, k, g, p, T, y), c(w, d, A, T, p, m, y);
         } else {
-            var T = h ? (p * A + y * k) / h : y;
-            c(f, w, k, g, p, m, T), c(w, d, A, g, T, m, y);
+            var M = h ? (p * A + y * k) / h : y;
+            c(f, w, k, g, p, m, M), c(w, d, A, g, M, m, y);
         }
     }
 }
 
 function nse(e, t, n, i, r) {
     (e.depth & 1 ? my : xg)(e, t, n, i, r);
 }
@@ -24950,28 +24937,28 @@
         array: !0
     }, {
         name: "generate",
         type: "boolean"
     }]
 };
 const rse = (e) => e.values;
-Q(A3, B, {
+Z(A3, B, {
     transform(e, t) {
-        t.source || q("Nest transform requires an upstream data source.");
+        t.source || W("Nest transform requires an upstream data source.");
         var n = e.generate,
             i = e.modified(),
             r = t.clone(),
             s = this.value;
         return (!s || i || t.changed()) && (s && s.each((o) => {
             o.children && w1(o.data) && r.rem.push(o.data);
         }), this.value = s = k3({
-            values: ne(e.keys).reduce((o, a) => (o.key(a), o), sse()).entries(r.source)
+            values: re(e.keys).reduce((o, a) => (o.key(a), o), sse()).entries(r.source)
         }, rse), n && s.each((o) => {
             o.children && (o = Ge(o.data), r.add.push(o), r.source.push(o));
-        }), Jx(s, me, me)), r.source.root = s, r;
+        }), Jx(s, be, be)), r.source.root = s, r;
     }
 });
 
 function sse() {
     const e = [],
         t = {
             entries: (r) => i(n(r, 0), 0),
@@ -25008,26 +24995,26 @@
     return t;
 }
 
 function Eo(e) {
     B.call(this, null, e);
 }
 const ose = (e, t) => e.parent === t.parent ? 1 : 2;
-Q(Eo, B, {
+Z(Eo, B, {
     transform(e, t) {
-        (!t.source || !t.source.root) && q(this.constructor.name + " transform requires a backing tree data source.");
+        (!t.source || !t.source.root) && W(this.constructor.name + " transform requires a backing tree data source.");
         const n = this.layout(e.method),
             i = this.fields,
             r = t.source.root,
             s = e.as || i;
         e.field ? r.sum(e.field) : r.count(), e.sort && r.sort(pl(e.sort, (o) => o.data)), ase(n, this.params, e), n.separation && n.separation(e.separation !== !1 ? ose : cf);
         try {
             this.value = n(r);
         } catch (o) {
-            q(o);
+            W(o);
         }
         return r.each((o) => use(o, i, s)), t.reflow(e.modified()).modifies(s).modifies("leaf");
     }
 });
 
 function ase(e, t, n) {
     for (let i, r = 0, s = t.length; r < s; ++r)
@@ -25039,18 +25026,18 @@
         r = t.length - 1;
     for (let s = 0; s < r; ++s)
         i[n[s]] = e[t[s]];
     i[n[r]] = e.children ? e.children.length : 0;
 }
 const Qx = ["x", "y", "r", "depth", "children"];
 
-function $3(e) {
+function C3(e) {
     Eo.call(this, e);
 }
-$3.Definition = {
+C3.Definition = {
     type: "Pack",
     metadata: {
         tree: !0,
         modifies: !0
     },
     params: [{
         name: "field",
@@ -25075,25 +25062,25 @@
         name: "as",
         type: "string",
         array: !0,
         length: Qx.length,
         default: Qx
     }]
 };
-Q($3, Eo, {
+Z(C3, Eo, {
     layout: jre,
     params: ["radius", "size", "padding"],
     fields: Qx
 });
 const Zx = ["x0", "y0", "x1", "y1", "depth", "children"];
 
-function C3(e) {
+function $3(e) {
     Eo.call(this, e);
 }
-C3.Definition = {
+$3.Definition = {
     type: "Partition",
     metadata: {
         tree: !0,
         modifies: !0
     },
     params: [{
         name: "field",
@@ -25118,15 +25105,15 @@
         name: "as",
         type: "string",
         array: !0,
         length: Zx.length,
         default: Zx
     }]
 };
-Q(C3, Eo, {
+Z($3, Eo, {
     layout: qre,
     params: ["size", "round", "padding"],
     fields: Zx
 });
 
 function M3(e) {
     B.call(this, null, e);
@@ -25142,25 +25129,25 @@
         required: !0
     }, {
         name: "parentKey",
         type: "field",
         required: !0
     }]
 };
-Q(M3, B, {
+Z(M3, B, {
     transform(e, t) {
-        t.source || q("Stratify transform requires an upstream data source.");
+        t.source || W("Stratify transform requires an upstream data source.");
         let n = this.value;
         const i = e.modified(),
             r = t.fork(t.ALL).materialize(t.SOURCE),
             s = !n || i || t.changed(t.ADD_REM) || t.modified(e.key.fields) || t.modified(e.parentKey.fields);
-        return r.source = r.source.slice(), s && (n = r.source.length ? Jx(OC().id(e.key).parentId(e.parentKey)(r.source), e.key, Ji) : Jx(OC()([{}]), e.key, e.key)), r.source.root = this.value = n, r;
+        return r.source = r.source.slice(), s && (n = r.source.length ? Jx(O$().id(e.key).parentId(e.parentKey)(r.source), e.key, Ji) : Jx(O$()([{}]), e.key, e.key)), r.source.root = this.value = n, r;
     }
 });
-const RC = {
+const R$ = {
         tidy: Zre,
         cluster: fre
     },
     ew = ["x", "y", "depth", "children"];
 
 function T3(e) {
     Eo.call(this, e);
@@ -25200,23 +25187,23 @@
         name: "as",
         type: "string",
         array: !0,
         length: ew.length,
         default: ew
     }]
 };
-Q(T3, Eo, {
+Z(T3, Eo, {
     /**
      * Tree layout generator. Supports both 'tidy' and 'cluster' layouts.
      */
     layout(e) {
         const t = e || "tidy";
-        if (be(RC, t))
-            return RC[t]();
-        q("Unrecognized Tree layout method: " + t);
+        if (xe(R$, t))
+            return R$[t]();
+        W("Unrecognized Tree layout method: " + t);
     },
     params: ["size", "nodeSize"],
     fields: ew
 });
 
 function F3(e) {
     B.call(this, [], e);
@@ -25226,33 +25213,33 @@
     metadata: {
         tree: !0,
         generates: !0,
         changes: !0
     },
     params: []
 };
-Q(F3, B, {
+Z(F3, B, {
     transform(e, t) {
         const n = this.value,
             i = t.source && t.source.root,
             r = t.fork(t.NO_SOURCE),
             s = {};
-        return i || q("TreeLinks transform requires a tree data source."), t.changed(t.ADD_REM) ? (r.rem = n, t.visit(t.SOURCE, (o) => s[me(o)] = 1), i.each((o) => {
+        return i || W("TreeLinks transform requires a tree data source."), t.changed(t.ADD_REM) ? (r.rem = n, t.visit(t.SOURCE, (o) => s[be(o)] = 1), i.each((o) => {
             const a = o.data,
                 u = o.parent && o.parent.data;
-            u && s[me(a)] && s[me(u)] && r.add.push(Ge({
+            u && s[be(a)] && s[be(u)] && r.add.push(Ge({
                 source: u,
                 target: a
             }));
-        }), this.value = r.add) : t.changed(t.MOD) && (t.visit(t.MOD, (o) => s[me(o)] = 1), n.forEach((o) => {
-            (s[me(o.source)] || s[me(o.target)]) && r.mod.push(o);
+        }), this.value = r.add) : t.changed(t.MOD) && (t.visit(t.MOD, (o) => s[be(o)] = 1), n.forEach((o) => {
+            (s[be(o.source)] || s[be(o.target)]) && r.mod.push(o);
         })), r;
     }
 });
-const LC = {
+const L$ = {
         binary: tse,
         dice: xg,
         slice: my,
         slicedice: nse,
         squarify: tL,
         resquarify: ise
     },
@@ -25323,36 +25310,36 @@
         name: "as",
         type: "string",
         array: !0,
         length: tw.length,
         default: tw
     }]
 };
-Q(N3, Eo, {
+Z(N3, Eo, {
     /**
      * Treemap layout generator. Adds 'method' and 'ratio' parameters
      * to configure the underlying tile method.
      */
     layout() {
         const e = ese();
         return e.ratio = (t) => {
             const n = e.tile();
             n.ratio && e.tile(n.ratio(t));
         }, e.method = (t) => {
-            be(LC, t) ? e.tile(LC[t]) : q("Unrecognized Treemap layout method: " + t);
+            xe(L$, t) ? e.tile(L$[t]) : W("Unrecognized Treemap layout method: " + t);
         }, e;
     },
     params: ["method", "ratio", "size", "round", "padding", "paddingInner", "paddingOuter", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
     fields: tw
 });
 const lse = /* @__PURE__ */ Object.freeze( /* @__PURE__ */ Object.defineProperty({
         __proto__: null,
         nest: A3,
-        pack: $3,
-        partition: C3,
+        pack: C3,
+        partition: $3,
         stratify: M3,
         tree: T3,
         treelinks: F3,
         treemap: N3
     }, Symbol.toStringTag, {
         value: "Module"
     })),
@@ -25372,18 +25359,18 @@
         c = a && oa(s, o).getContext("2d");
     n.forEach((k) => fm(u, k, !1)), fm(l, t, !1), a && fm(c, t, !0);
     const f = kv(u, s, o),
         d = kv(l, s, o),
         h = a && kv(c, s, o),
         g = e.bitmap(),
         p = a && e.bitmap();
-    let m, y, b, v, x, w, S, _;
+    let m, y, b, v, x, w, E, _;
     for (y = 0; y < o; ++y)
         for (m = 0; m < s; ++m)
-            x = y * s + m, w = f[x] & Sv, _ = d[x] & Sv, S = a && h[x] & Sv, (w || S || _) && (b = e(m), v = e(y), !r && (w || _) && g.set(b, v), a && (w || S) && p.set(b, v));
+            x = y * s + m, w = f[x] & Sv, _ = d[x] & Sv, E = a && h[x] & Sv, (w || E || _) && (b = e(m), v = e(y), !r && (w || _) && g.set(b, v), a && (w || E) && p.set(b, v));
     return [g, p];
 }
 
 function kv(e, t, n) {
     return new Uint32Array(e.getImageData(0, 0, t, n).data.buffer);
 }
 
@@ -25405,24 +25392,24 @@
         strokeOpacity: 1,
         stroke: "#000",
         fillOpacity: 0
     } : t;
 }
 const Us = 5,
     $n = 31,
-    Ch = 32,
-    jo = new Uint32Array(Ch + 1),
-    xr = new Uint32Array(Ch + 1);
+    $h = 32,
+    jo = new Uint32Array($h + 1),
+    xr = new Uint32Array($h + 1);
 xr[0] = 0;
 jo[0] = ~xr[0];
-for (let e = 1; e <= Ch; ++e)
+for (let e = 1; e <= $h; ++e)
     xr[e] = xr[e - 1] << 1 | 1, jo[e] = ~xr[e];
 
 function hse(e, t) {
-    const n = new Uint32Array(~~((e * t + Ch) / Ch));
+    const n = new Uint32Array(~~((e * t + $h) / $h));
 
     function i(s, o) {
         n[s] |= o;
     }
 
     function r(s, o) {
         n[s] &= o;
@@ -25541,25 +25528,25 @@
             f = c.length,
             d = l.datum.fontSize,
             h = ki.width(l.datum, l.datum.text);
         let g = n ? d : 0,
             p = !1,
             m = !1,
             y = 0,
-            b, v, x, w, S, _, k, A, F, T, I, N, D, M, E, $, C;
-        for (let O = 0; O < f; ++O) {
-            for (b = c[O].x, x = c[O].y, v = c[O].x2 === void 0 ? b : c[O].x2, w = c[O].y2 === void 0 ? x : c[O].y2, b > v && (C = b, b = v, v = C), x > w && (C = x, x = w, w = C), F = e(b), I = e(v), T = ~~((F + I) / 2), N = e(x), M = e(w), D = ~~((N + M) / 2), k = T; k >= F; --k)
-                for (A = D; A >= N; --A)
-                    $ = u(k, A, g, h, d), $ && ([l.x, l.y, g, p] = $);
-            for (k = T; k <= I; ++k)
-                for (A = D; A <= M; ++A)
-                    $ = u(k, A, g, h, d), $ && ([l.x, l.y, g, p] = $);
-            !p && !n && (E = Math.abs(v - b + w - x), S = (b + v) / 2, _ = (x + w) / 2, E >= y && !N0(S, _, h, d, r, s) && !Qo(e, S, _, d, h, d, o, null) && (y = E, l.x = S, l.y = _, m = !0));
+            b, v, x, w, E, _, k, A, T, M, L, F, O, N, R, P, S;
+        for (let $ = 0; $ < f; ++$) {
+            for (b = c[$].x, x = c[$].y, v = c[$].x2 === void 0 ? b : c[$].x2, w = c[$].y2 === void 0 ? x : c[$].y2, b > v && (S = b, b = v, v = S), x > w && (S = x, x = w, w = S), T = e(b), L = e(v), M = ~~((T + L) / 2), F = e(x), N = e(w), O = ~~((F + N) / 2), k = M; k >= T; --k)
+                for (A = O; A >= F; --A)
+                    P = u(k, A, g, h, d), P && ([l.x, l.y, g, p] = P);
+            for (k = M; k <= L; ++k)
+                for (A = O; A <= N; ++A)
+                    P = u(k, A, g, h, d), P && ([l.x, l.y, g, p] = P);
+            !p && !n && (R = Math.abs(v - b + w - x), E = (b + v) / 2, _ = (x + w) / 2, R >= y && !N0(E, _, h, d, r, s) && !Qo(e, E, _, d, h, d, o, null) && (y = R, l.x = E, l.y = _, m = !0));
         }
-        return p || m ? (S = h / 2, _ = d / 2, o.setRange(e(l.x - S), e(l.y - _), e(l.x + S), e(l.y + _)), l.align = "center", l.baseline = "middle", !0) : !1;
+        return p || m ? (E = h / 2, _ = d / 2, o.setRange(e(l.x - E), e(l.y - _), e(l.x + E), e(l.y + _)), l.align = "center", l.baseline = "middle", !0) : !1;
     };
 }
 const yse = [-1, -1, 1, 1],
     bse = [-1, 1, -1, 1];
 
 function vse(e, t, n, i) {
     const r = e.width,
@@ -25573,27 +25560,27 @@
             d = l.datum.fontSize,
             h = ki.width(l.datum, l.datum.text),
             g = [];
         let p = n ? d : 0,
             m = !1,
             y = !1,
             b = 0,
-            v, x, w, S, _, k, A, F, T, I, N, D;
-        for (let M = 0; M < f; ++M) {
-            for (v = c[M].x, w = c[M].y, x = c[M].x2 === void 0 ? v : c[M].x2, S = c[M].y2 === void 0 ? w : c[M].y2, g.push([e((v + x) / 2), e((w + S) / 2)]); g.length;)
-                if ([A, F] = g.pop(), !(o.get(A, F) || a.get(A, F) || u.get(A, F))) {
-                    u.set(A, F);
-                    for (let E = 0; E < 4; ++E)
-                        _ = A + yse[E], k = F + bse[E], u.outOfBounds(_, k, _, k) || g.push([_, k]);
-                    if (_ = e.invert(A), k = e.invert(F), T = p, I = s, !N0(_, k, h, d, r, s) && !Qo(e, _, k, d, h, T, o, a) && !Qo(e, _, k, d, h, d, o, null)) {
-                        for (; I - T >= 1;)
-                            N = (T + I) / 2, Qo(e, _, k, d, h, N, o, a) ? I = N : T = N;
-                        T > p && (l.x = _, l.y = k, p = T, m = !0);
+            v, x, w, E, _, k, A, T, M, L, F, O;
+        for (let N = 0; N < f; ++N) {
+            for (v = c[N].x, w = c[N].y, x = c[N].x2 === void 0 ? v : c[N].x2, E = c[N].y2 === void 0 ? w : c[N].y2, g.push([e((v + x) / 2), e((w + E) / 2)]); g.length;)
+                if ([A, T] = g.pop(), !(o.get(A, T) || a.get(A, T) || u.get(A, T))) {
+                    u.set(A, T);
+                    for (let R = 0; R < 4; ++R)
+                        _ = A + yse[R], k = T + bse[R], u.outOfBounds(_, k, _, k) || g.push([_, k]);
+                    if (_ = e.invert(A), k = e.invert(T), M = p, L = s, !N0(_, k, h, d, r, s) && !Qo(e, _, k, d, h, M, o, a) && !Qo(e, _, k, d, h, d, o, null)) {
+                        for (; L - M >= 1;)
+                            F = (M + L) / 2, Qo(e, _, k, d, h, F, o, a) ? L = F : M = F;
+                        M > p && (l.x = _, l.y = k, p = M, m = !0);
                     }
-                }! m && !n && (D = Math.abs(x - v + S - w), _ = (v + x) / 2, k = (w + S) / 2, D >= b && !N0(_, k, h, d, r, s) && !Qo(e, _, k, d, h, d, o, null) && (b = D, l.x = _, l.y = k, y = !0));
+                }! m && !n && (O = Math.abs(x - v + E - w), _ = (v + x) / 2, k = (w + E) / 2, O >= b && !N0(_, k, h, d, r, s) && !Qo(e, _, k, d, h, d, o, null) && (b = O, l.x = _, l.y = k, y = !0));
         }
         return m || y ? (_ = h / 2, k = d / 2, o.setRange(e(l.x - _), e(l.y - k), e(l.x + _), e(l.y + k)), l.align = "center", l.baseline = "middle", !0) : !1;
     };
 }
 const xse = ["right", "center", "left"],
     wse = ["bottom", "middle", "top"];
 
@@ -25605,117 +25592,117 @@
         u = i.length;
     return function(l) {
         const c = l.boundary,
             f = l.datum.fontSize;
         if (c[2] < 0 || c[5] < 0 || c[0] > r || c[3] > s)
             return !1;
         let d = l.textWidth ?? 0,
-            h, g, p, m, y, b, v, x, w, S, _, k, A, F, T;
-        for (let I = 0; I < u; ++I) {
-            if (h = (n[I] & 3) - 1, g = (n[I] >>> 2 & 3) - 1, p = h === 0 && g === 0 || i[I] < 0, m = h && g ? Math.SQRT1_2 : 1, y = i[I] < 0 ? -1 : 1, b = c[1 + h] + i[I] * h * m, _ = c[4 + g] + y * f * g / 2 + i[I] * g * m, x = _ - f / 2, w = _ + f / 2, k = e(b), F = e(x), T = e(w), !d)
-                if (IC(k, k, F, T, o, a, b, b, x, w, c, p))
+            h, g, p, m, y, b, v, x, w, E, _, k, A, T, M;
+        for (let L = 0; L < u; ++L) {
+            if (h = (n[L] & 3) - 1, g = (n[L] >>> 2 & 3) - 1, p = h === 0 && g === 0 || i[L] < 0, m = h && g ? Math.SQRT1_2 : 1, y = i[L] < 0 ? -1 : 1, b = c[1 + h] + i[L] * h * m, _ = c[4 + g] + y * f * g / 2 + i[L] * g * m, x = _ - f / 2, w = _ + f / 2, k = e(b), T = e(x), M = e(w), !d)
+                if (I$(k, k, T, M, o, a, b, b, x, w, c, p))
                     d = ki.width(l.datum, l.datum.text);
                 else
                     continue;
-            if (S = b + y * d * h / 2, b = S - d / 2, v = S + d / 2, k = e(b), A = e(v), IC(k, A, F, T, o, a, b, v, x, w, c, p))
-                return l.x = h ? h * y < 0 ? v : b : S, l.y = g ? g * y < 0 ? w : x : _, l.align = xse[h * y + 1], l.baseline = wse[g * y + 1], o.setRange(k, F, A, T), !0;
+            if (E = b + y * d * h / 2, b = E - d / 2, v = E + d / 2, k = e(b), A = e(v), I$(k, A, T, M, o, a, b, v, x, w, c, p))
+                return l.x = h ? h * y < 0 ? v : b : E, l.y = g ? g * y < 0 ? w : x : _, l.align = xse[h * y + 1], l.baseline = wse[g * y + 1], o.setRange(k, T, A, M), !0;
         }
         return !1;
     };
 }
 
-function IC(e, t, n, i, r, s, o, a, u, l, c, f) {
+function I$(e, t, n, i, r, s, o, a, u, l, c, f) {
     return !(r.outOfBounds(e, n, t, i) || (f && s || r).getRange(e, n, t, i));
 }
 const Av = 0,
-    $v = 4,
-    Cv = 8,
+    Cv = 4,
+    $v = 8,
     Mv = 0,
     Tv = 1,
     Fv = 2,
     Ese = {
         "top-left": Av + Mv,
         top: Av + Tv,
         "top-right": Av + Fv,
-        left: $v + Mv,
-        middle: $v + Tv,
-        right: $v + Fv,
-        "bottom-left": Cv + Mv,
-        bottom: Cv + Tv,
-        "bottom-right": Cv + Fv
+        left: Cv + Mv,
+        middle: Cv + Tv,
+        right: Cv + Fv,
+        "bottom-left": $v + Mv,
+        bottom: $v + Tv,
+        "bottom-right": $v + Fv
     },
     Sse = {
         naive: pse,
         "reduced-search": mse,
         floodfill: vse
     };
 
 function kse(e, t, n, i, r, s, o, a, u, l, c) {
     if (!e.length)
         return e;
     const f = Math.max(i.length, r.length),
         d = Ase(i, f),
-        h = $se(r, f),
-        g = Cse(e[0].datum),
+        h = Cse(r, f),
+        g = $se(e[0].datum),
         p = g === "group" && e[0].datum.items[u].marktype,
         m = p === "area",
         y = Mse(g, p, a, u),
         b = l === null || l === 1 / 0,
         v = m && c === "naive";
     let x = -1,
         w = -1;
-    const S = e.map((F) => {
-        const T = b ? ki.width(F, F.text) : void 0;
-        return x = Math.max(x, T), w = Math.max(w, F.fontSize), {
-            datum: F,
+    const E = e.map((T) => {
+        const M = b ? ki.width(T, T.text) : void 0;
+        return x = Math.max(x, M), w = Math.max(w, T.fontSize), {
+            datum: T,
             opacity: 0,
             x: void 0,
             y: void 0,
             align: void 0,
             baseline: void 0,
-            boundary: y(F),
-            textWidth: T
+            boundary: y(T),
+            textWidth: M
         };
     });
     l = l === null || l === 1 / 0 ? Math.max(x, w) + Math.max(...i) : l;
     const _ = gse(t[0], t[1], l);
     let k;
     if (!v) {
-        n && S.sort((I, N) => n(I.datum, N.datum));
-        let F = !1;
-        for (let I = 0; I < h.length && !F; ++I)
-            F = h[I] === 5 || d[I] < 0;
-        const T = (g && o || m) && e.map((I) => I.datum);
-        k = s.length || T ? fse(_, T || [], s, F, m) : cse(_, o && S);
+        n && E.sort((L, F) => n(L.datum, F.datum));
+        let T = !1;
+        for (let L = 0; L < h.length && !T; ++L)
+            T = h[L] === 5 || d[L] < 0;
+        const M = (g && o || m) && e.map((L) => L.datum);
+        k = s.length || M ? fse(_, M || [], s, T, m) : cse(_, o && E);
     }
     const A = m ? Sse[c](_, k, o, u) : _se(_, k, h, d);
-    return S.forEach((F) => F.opacity = +A(F)), S;
+    return E.forEach((T) => T.opacity = +A(T)), E;
 }
 
 function Ase(e, t) {
     const n = new Float64Array(t),
         i = e.length;
     for (let r = 0; r < i; ++r)
         n[r] = e[r] || 0;
     for (let r = i; r < t; ++r)
         n[r] = n[i - 1];
     return n;
 }
 
-function $se(e, t) {
+function Cse(e, t) {
     const n = new Int8Array(t),
         i = e.length;
     for (let r = 0; r < i; ++r)
         n[r] |= Ese[e[r]];
     for (let r = i; r < t; ++r)
         n[r] = n[i - 1];
     return n;
 }
 
-function Cse(e) {
+function $se(e) {
     return e && e.mark && e.mark.marktype;
 }
 
 function Mse(e, t, n, i) {
     const r = (s) => [s.x, s.x, s.x, s.y, s.y, s.y];
     return e ? e === "line" || e === "area" ? (s) => r(s.datum) : t === "line" ? (s) => {
         const o = s.datum.items[i].items;
@@ -25788,26 +25775,26 @@
         name: "as",
         type: "string",
         array: !0,
         length: nw.length,
         default: nw
     }]
 };
-Q(O3, B, {
+Z(O3, B, {
     transform(e, t) {
         function n(s) {
             const o = e[s];
             return Me(o) && t.modified(o.fields);
         }
         const i = e.modified();
         if (!(i || t.changed(t.ADD_REM) || n("sort")))
             return;
-        (!e.size || e.size.length !== 2) && q("Size parameter should be specified as a [width, height] array.");
+        (!e.size || e.size.length !== 2) && W("Size parameter should be specified as a [width, height] array.");
         const r = e.as || nw;
-        return kse(t.materialize(t.SOURCE).source || [], e.size, e.sort, ne(e.offset == null ? 1 : e.offset), ne(e.anchor || nL), e.avoidMarks || [], e.avoidBaseMark !== !1, e.lineAnchor || "end", e.markIndex || 0, e.padding === void 0 ? 0 : e.padding, e.method || "naive").forEach((s) => {
+        return kse(t.materialize(t.SOURCE).source || [], e.size, e.sort, re(e.offset == null ? 1 : e.offset), re(e.anchor || nL), e.avoidMarks || [], e.avoidBaseMark !== !1, e.lineAnchor || "end", e.markIndex || 0, e.padding === void 0 ? 0 : e.padding, e.method || "naive").forEach((s) => {
             const o = s.datum;
             o[r[0]] = s.x, o[r[1]] = s.y, o[r[2]] = s.opacity, o[r[3]] = s.align, o[r[4]] = s.baseline;
         }), t.reflow(i).modifies(r);
     }
 });
 const Tse = /* @__PURE__ */ Object.freeze( /* @__PURE__ */ Object.defineProperty({
     __proto__: null,
@@ -25856,23 +25843,23 @@
         default: 0.3
     }, {
         name: "as",
         type: "string",
         array: !0
     }]
 };
-Q(D3, B, {
+Z(D3, B, {
     transform(e, t) {
         const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
         if (!this.value || t.changed() || e.modified()) {
             const i = t.materialize(t.SOURCE).source,
                 r = iL(i, e.groupby),
-                s = (e.groupby || []).map(_t),
+                s = (e.groupby || []).map(Et),
                 o = s.length,
-                a = e.as || [_t(e.x), _t(e.y)],
+                a = e.as || [Et(e.x), Et(e.y)],
                 u = [];
             r.forEach((l) => {
                 XT(l, e.x, e.y, e.bandwidth || 0.3).forEach((c) => {
                     const f = {};
                     for (let d = 0; d < o; ++d)
                         f[s[d]] = l.dims[d];
                     f[a[0]] = c[0], f[a[1]] = c[1], u.push(Ge(f));
@@ -25933,29 +25920,29 @@
         default: !1
     }, {
         name: "as",
         type: "string",
         array: !0
     }]
 };
-Q(R3, B, {
+Z(R3, B, {
     transform(e, t) {
         const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
         if (!this.value || t.changed() || e.modified()) {
             const i = t.materialize(t.SOURCE).source,
                 r = iL(i, e.groupby),
-                s = (e.groupby || []).map(_t),
+                s = (e.groupby || []).map(Et),
                 o = e.method || "linear",
                 a = e.order == null ? 3 : e.order,
                 u = Fse(o, a),
-                l = e.as || [_t(e.x), _t(e.y)],
+                l = e.as || [Et(e.x), Et(e.y)],
                 c = iw[o],
                 f = [];
             let d = e.extent;
-            be(iw, o) || q("Invalid regression method: " + o), d != null && o === "log" && d[0] <= 0 && (t.dataflow.warn("Ignoring extent with values <= 0 for log regression."), d = null), r.forEach((h) => {
+            xe(iw, o) || W("Invalid regression method: " + o), d != null && o === "log" && d[0] <= 0 && (t.dataflow.warn("Ignoring extent with values <= 0 for log regression."), d = null), r.forEach((h) => {
                 if (h.length <= u) {
                     t.dataflow.warn("Skipping regression with more parameters than data points.");
                     return;
                 }
                 const p = c(h, e.x, e.y, a);
                 if (e.params) {
                     f.push(Ge({
@@ -25982,15 +25969,15 @@
         __proto__: null,
         loess: D3,
         regression: R3
     }, Symbol.toStringTag, {
         value: "Module"
     })),
     ao = 11102230246251565e-32,
-    an = 134217729,
+    un = 134217729,
     Ose = (3 + 8 * ao) * ao;
 
 function Nv(e, t, n, i, r) {
     let s, o, a, u, l = t[0],
         c = i[0],
         f = 0,
         d = 0;
@@ -26016,47 +26003,47 @@
 function wg(e) {
     return new Float64Array(e);
 }
 const Rse = (3 + 16 * ao) * ao,
     Lse = (2 + 12 * ao) * ao,
     Ise = (9 + 64 * ao) * ao * ao,
     ql = wg(4),
-    PC = wg(8),
-    zC = wg(12),
-    BC = wg(16),
-    Cn = wg(4);
+    P$ = wg(8),
+    z$ = wg(12),
+    B$ = wg(16),
+    Mn = wg(4);
 
 function Pse(e, t, n, i, r, s, o) {
-    let a, u, l, c, f, d, h, g, p, m, y, b, v, x, w, S, _, k;
+    let a, u, l, c, f, d, h, g, p, m, y, b, v, x, w, E, _, k;
     const A = e - r,
-        F = n - r,
-        T = t - s,
-        I = i - s;
-    x = A * I, d = an * A, h = d - (d - A), g = A - h, d = an * I, p = d - (d - I), m = I - p, w = g * m - (x - h * p - g * p - h * m), S = T * F, d = an * T, h = d - (d - T), g = T - h, d = an * F, p = d - (d - F), m = F - p, _ = g * m - (S - h * p - g * p - h * m), y = w - _, f = w - y, ql[0] = w - (y + f) + (f - _), b = x + y, f = b - x, v = x - (b - f) + (y - f), y = v - S, f = v - y, ql[1] = v - (y + f) + (f - S), k = b + y, f = k - b, ql[2] = b - (k - f) + (y - f), ql[3] = k;
-    let N = Dse(4, ql),
-        D = Lse * o;
-    if (N >= D || -N >= D || (f = e - A, a = e - (A + f) + (f - r), f = n - F, l = n - (F + f) + (f - r), f = t - T, u = t - (T + f) + (f - s), f = i - I, c = i - (I + f) + (f - s), a === 0 && u === 0 && l === 0 && c === 0) || (D = Ise * o + Ose * Math.abs(N), N += A * c + I * a - (T * l + F * u), N >= D || -N >= D))
-        return N;
-    x = a * I, d = an * a, h = d - (d - a), g = a - h, d = an * I, p = d - (d - I), m = I - p, w = g * m - (x - h * p - g * p - h * m), S = u * F, d = an * u, h = d - (d - u), g = u - h, d = an * F, p = d - (d - F), m = F - p, _ = g * m - (S - h * p - g * p - h * m), y = w - _, f = w - y, Cn[0] = w - (y + f) + (f - _), b = x + y, f = b - x, v = x - (b - f) + (y - f), y = v - S, f = v - y, Cn[1] = v - (y + f) + (f - S), k = b + y, f = k - b, Cn[2] = b - (k - f) + (y - f), Cn[3] = k;
-    const M = Nv(4, ql, 4, Cn, PC);
-    x = A * c, d = an * A, h = d - (d - A), g = A - h, d = an * c, p = d - (d - c), m = c - p, w = g * m - (x - h * p - g * p - h * m), S = T * l, d = an * T, h = d - (d - T), g = T - h, d = an * l, p = d - (d - l), m = l - p, _ = g * m - (S - h * p - g * p - h * m), y = w - _, f = w - y, Cn[0] = w - (y + f) + (f - _), b = x + y, f = b - x, v = x - (b - f) + (y - f), y = v - S, f = v - y, Cn[1] = v - (y + f) + (f - S), k = b + y, f = k - b, Cn[2] = b - (k - f) + (y - f), Cn[3] = k;
-    const E = Nv(M, PC, 4, Cn, zC);
-    x = a * c, d = an * a, h = d - (d - a), g = a - h, d = an * c, p = d - (d - c), m = c - p, w = g * m - (x - h * p - g * p - h * m), S = u * l, d = an * u, h = d - (d - u), g = u - h, d = an * l, p = d - (d - l), m = l - p, _ = g * m - (S - h * p - g * p - h * m), y = w - _, f = w - y, Cn[0] = w - (y + f) + (f - _), b = x + y, f = b - x, v = x - (b - f) + (y - f), y = v - S, f = v - y, Cn[1] = v - (y + f) + (f - S), k = b + y, f = k - b, Cn[2] = b - (k - f) + (y - f), Cn[3] = k;
-    const $ = Nv(E, zC, 4, Cn, BC);
-    return BC[$ - 1];
+        T = n - r,
+        M = t - s,
+        L = i - s;
+    x = A * L, d = un * A, h = d - (d - A), g = A - h, d = un * L, p = d - (d - L), m = L - p, w = g * m - (x - h * p - g * p - h * m), E = M * T, d = un * M, h = d - (d - M), g = M - h, d = un * T, p = d - (d - T), m = T - p, _ = g * m - (E - h * p - g * p - h * m), y = w - _, f = w - y, ql[0] = w - (y + f) + (f - _), b = x + y, f = b - x, v = x - (b - f) + (y - f), y = v - E, f = v - y, ql[1] = v - (y + f) + (f - E), k = b + y, f = k - b, ql[2] = b - (k - f) + (y - f), ql[3] = k;
+    let F = Dse(4, ql),
+        O = Lse * o;
+    if (F >= O || -F >= O || (f = e - A, a = e - (A + f) + (f - r), f = n - T, l = n - (T + f) + (f - r), f = t - M, u = t - (M + f) + (f - s), f = i - L, c = i - (L + f) + (f - s), a === 0 && u === 0 && l === 0 && c === 0) || (O = Ise * o + Ose * Math.abs(F), F += A * c + L * a - (M * l + T * u), F >= O || -F >= O))
+        return F;
+    x = a * L, d = un * a, h = d - (d - a), g = a - h, d = un * L, p = d - (d - L), m = L - p, w = g * m - (x - h * p - g * p - h * m), E = u * T, d = un * u, h = d - (d - u), g = u - h, d = un * T, p = d - (d - T), m = T - p, _ = g * m - (E - h * p - g * p - h * m), y = w - _, f = w - y, Mn[0] = w - (y + f) + (f - _), b = x + y, f = b - x, v = x - (b - f) + (y - f), y = v - E, f = v - y, Mn[1] = v - (y + f) + (f - E), k = b + y, f = k - b, Mn[2] = b - (k - f) + (y - f), Mn[3] = k;
+    const N = Nv(4, ql, 4, Mn, P$);
+    x = A * c, d = un * A, h = d - (d - A), g = A - h, d = un * c, p = d - (d - c), m = c - p, w = g * m - (x - h * p - g * p - h * m), E = M * l, d = un * M, h = d - (d - M), g = M - h, d = un * l, p = d - (d - l), m = l - p, _ = g * m - (E - h * p - g * p - h * m), y = w - _, f = w - y, Mn[0] = w - (y + f) + (f - _), b = x + y, f = b - x, v = x - (b - f) + (y - f), y = v - E, f = v - y, Mn[1] = v - (y + f) + (f - E), k = b + y, f = k - b, Mn[2] = b - (k - f) + (y - f), Mn[3] = k;
+    const R = Nv(N, P$, 4, Mn, z$);
+    x = a * c, d = un * a, h = d - (d - a), g = a - h, d = un * c, p = d - (d - c), m = c - p, w = g * m - (x - h * p - g * p - h * m), E = u * l, d = un * u, h = d - (d - u), g = u - h, d = un * l, p = d - (d - l), m = l - p, _ = g * m - (E - h * p - g * p - h * m), y = w - _, f = w - y, Mn[0] = w - (y + f) + (f - _), b = x + y, f = b - x, v = x - (b - f) + (y - f), y = v - E, f = v - y, Mn[1] = v - (y + f) + (f - E), k = b + y, f = k - b, Mn[2] = b - (k - f) + (y - f), Mn[3] = k;
+    const P = Nv(R, z$, 4, Mn, B$);
+    return B$[P - 1];
 }
 
 function xp(e, t, n, i, r, s) {
     const o = (t - s) * (n - r),
         a = (e - r) * (i - s),
         u = o - a,
         l = Math.abs(o + a);
     return Math.abs(u) >= Rse * l ? u : -Pse(e, t, n, i, r, s, l);
 }
-const UC = Math.pow(2, -52),
+const U$ = Math.pow(2, -52),
     wp = new Uint32Array(512);
 class O0 {
     static from(t, n = qse, i = Wse) {
         const r = t.length,
             s = new Float64Array(r * 2);
         for (let o = 0; o < r; o++) {
             const a = t[o];
@@ -26081,103 +26068,103 @@
             _hullHash: s
         } = this, o = t.length >> 1;
         let a = 1 / 0,
             u = 1 / 0,
             l = -1 / 0,
             c = -1 / 0;
         for (let A = 0; A < o; A++) {
-            const F = t[2 * A],
-                T = t[2 * A + 1];
-            F < a && (a = F), T < u && (u = T), F > l && (l = F), T > c && (c = T), this._ids[A] = A;
+            const T = t[2 * A],
+                M = t[2 * A + 1];
+            T < a && (a = T), M < u && (u = M), T > l && (l = T), M > c && (c = M), this._ids[A] = A;
         }
         const f = (a + l) / 2,
             d = (u + c) / 2;
         let h, g, p;
-        for (let A = 0, F = 1 / 0; A < o; A++) {
-            const T = Ov(f, d, t[2 * A], t[2 * A + 1]);
-            T < F && (h = A, F = T);
+        for (let A = 0, T = 1 / 0; A < o; A++) {
+            const M = Ov(f, d, t[2 * A], t[2 * A + 1]);
+            M < T && (h = A, T = M);
         }
         const m = t[2 * h],
             y = t[2 * h + 1];
-        for (let A = 0, F = 1 / 0; A < o; A++) {
+        for (let A = 0, T = 1 / 0; A < o; A++) {
             if (A === h)
                 continue;
-            const T = Ov(m, y, t[2 * A], t[2 * A + 1]);
-            T < F && T > 0 && (g = A, F = T);
+            const M = Ov(m, y, t[2 * A], t[2 * A + 1]);
+            M < T && M > 0 && (g = A, T = M);
         }
         let b = t[2 * g],
             v = t[2 * g + 1],
             x = 1 / 0;
         for (let A = 0; A < o; A++) {
             if (A === h || A === g)
                 continue;
-            const F = Use(m, y, b, v, t[2 * A], t[2 * A + 1]);
-            F < x && (p = A, x = F);
+            const T = Use(m, y, b, v, t[2 * A], t[2 * A + 1]);
+            T < x && (p = A, x = T);
         }
         let w = t[2 * p],
-            S = t[2 * p + 1];
+            E = t[2 * p + 1];
         if (x === 1 / 0) {
-            for (let T = 0; T < o; T++)
-                this._dists[T] = t[2 * T] - t[0] || t[2 * T + 1] - t[1];
+            for (let M = 0; M < o; M++)
+                this._dists[M] = t[2 * M] - t[0] || t[2 * M + 1] - t[1];
             ac(this._ids, this._dists, 0, o - 1);
             const A = new Uint32Array(o);
-            let F = 0;
-            for (let T = 0, I = -1 / 0; T < o; T++) {
-                const N = this._ids[T],
-                    D = this._dists[N];
-                D > I && (A[F++] = N, I = D);
+            let T = 0;
+            for (let M = 0, L = -1 / 0; M < o; M++) {
+                const F = this._ids[M],
+                    O = this._dists[F];
+                O > L && (A[T++] = F, L = O);
             }
-            this.hull = A.subarray(0, F), this.triangles = new Uint32Array(0), this.halfedges = new Uint32Array(0);
+            this.hull = A.subarray(0, T), this.triangles = new Uint32Array(0), this.halfedges = new Uint32Array(0);
             return;
         }
-        if (xp(m, y, b, v, w, S) < 0) {
+        if (xp(m, y, b, v, w, E) < 0) {
             const A = g,
-                F = b,
-                T = v;
-            g = p, b = w, v = S, p = A, w = F, S = T;
+                T = b,
+                M = v;
+            g = p, b = w, v = E, p = A, w = T, E = M;
         }
-        const _ = jse(m, y, b, v, w, S);
+        const _ = jse(m, y, b, v, w, E);
         this._cx = _.x, this._cy = _.y;
         for (let A = 0; A < o; A++)
             this._dists[A] = Ov(t[2 * A], t[2 * A + 1], _.x, _.y);
         ac(this._ids, this._dists, 0, o - 1), this._hullStart = h;
         let k = 3;
-        i[h] = n[p] = g, i[g] = n[h] = p, i[p] = n[g] = h, r[h] = 0, r[g] = 1, r[p] = 2, s.fill(-1), s[this._hashKey(m, y)] = h, s[this._hashKey(b, v)] = g, s[this._hashKey(w, S)] = p, this.trianglesLen = 0, this._addTriangle(h, g, p, -1, -1, -1);
-        for (let A = 0, F, T; A < this._ids.length; A++) {
-            const I = this._ids[A],
-                N = t[2 * I],
-                D = t[2 * I + 1];
-            if (A > 0 && Math.abs(N - F) <= UC && Math.abs(D - T) <= UC || (F = N, T = D, I === h || I === g || I === p))
+        i[h] = n[p] = g, i[g] = n[h] = p, i[p] = n[g] = h, r[h] = 0, r[g] = 1, r[p] = 2, s.fill(-1), s[this._hashKey(m, y)] = h, s[this._hashKey(b, v)] = g, s[this._hashKey(w, E)] = p, this.trianglesLen = 0, this._addTriangle(h, g, p, -1, -1, -1);
+        for (let A = 0, T, M; A < this._ids.length; A++) {
+            const L = this._ids[A],
+                F = t[2 * L],
+                O = t[2 * L + 1];
+            if (A > 0 && Math.abs(F - T) <= U$ && Math.abs(O - M) <= U$ || (T = F, M = O, L === h || L === g || L === p))
                 continue;
-            let M = 0;
-            for (let R = 0, L = this._hashKey(N, D); R < this._hashSize && (M = s[(L + R) % this._hashSize], !(M !== -1 && M !== i[M])); R++)
+            let N = 0;
+            for (let C = 0, D = this._hashKey(F, O); C < this._hashSize && (N = s[(D + C) % this._hashSize], !(N !== -1 && N !== i[N])); C++)
             ;
-            M = n[M];
-            let E = M,
-                $;
-            for (; $ = i[E], xp(N, D, t[2 * E], t[2 * E + 1], t[2 * $], t[2 * $ + 1]) >= 0;)
-                if (E = $, E === M) {
-                    E = -1;
+            N = n[N];
+            let R = N,
+                P;
+            for (; P = i[R], xp(F, O, t[2 * R], t[2 * R + 1], t[2 * P], t[2 * P + 1]) >= 0;)
+                if (R = P, R === N) {
+                    R = -1;
                     break;
                 }
-            if (E === -1)
+            if (R === -1)
                 continue;
-            let C = this._addTriangle(E, I, i[E], -1, -1, r[E]);
-            r[I] = this._legalize(C + 2), r[E] = C, k++;
-            let O = i[E];
-            for (; $ = i[O], xp(N, D, t[2 * O], t[2 * O + 1], t[2 * $], t[2 * $ + 1]) < 0;)
-                C = this._addTriangle(O, I, $, r[I], -1, r[O]), r[I] = this._legalize(C + 2), i[O] = O, k--, O = $;
-            if (E === M)
-                for (; $ = n[E], xp(N, D, t[2 * $], t[2 * $ + 1], t[2 * E], t[2 * E + 1]) < 0;)
-                    C = this._addTriangle($, I, E, -1, r[E], r[$]), this._legalize(C + 2), r[$] = C, i[E] = E, k--, E = $;
-            this._hullStart = n[I] = E, i[E] = n[O] = I, i[I] = O, s[this._hashKey(N, D)] = I, s[this._hashKey(t[2 * E], t[2 * E + 1])] = E;
+            let S = this._addTriangle(R, L, i[R], -1, -1, r[R]);
+            r[L] = this._legalize(S + 2), r[R] = S, k++;
+            let $ = i[R];
+            for (; P = i[$], xp(F, O, t[2 * $], t[2 * $ + 1], t[2 * P], t[2 * P + 1]) < 0;)
+                S = this._addTriangle($, L, P, r[L], -1, r[$]), r[L] = this._legalize(S + 2), i[$] = $, k--, $ = P;
+            if (R === N)
+                for (; P = n[R], xp(F, O, t[2 * P], t[2 * P + 1], t[2 * R], t[2 * R + 1]) < 0;)
+                    S = this._addTriangle(P, L, R, -1, r[R], r[P]), this._legalize(S + 2), r[P] = S, i[R] = R, k--, R = P;
+            this._hullStart = n[L] = R, i[R] = n[$] = L, i[L] = $, s[this._hashKey(F, O)] = L, s[this._hashKey(t[2 * R], t[2 * R + 1])] = R;
         }
         this.hull = new Uint32Array(k);
-        for (let A = 0, F = this._hullStart; A < k; A++)
-            this.hull[A] = F, F = i[F];
+        for (let A = 0, T = this._hullStart; A < k; A++)
+            this.hull[A] = T, T = i[T];
         this.triangles = this._triangles.subarray(0, this.trianglesLen), this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
     }
     _hashKey(t, n) {
         return Math.floor(zse(t - this._cx, n - this._cy) * this._hashSize) % this._hashSize;
     }
     _legalize(t) {
         const {
@@ -26339,15 +26326,15 @@
 function qse(e) {
     return e[0];
 }
 
 function Wse(e) {
     return e[1];
 }
-const jC = 1e-6;
+const j$ = 1e-6;
 class xu {
     constructor() {
         this._x0 = this._y0 = // start of current subpath
             this._x1 = this._y1 = null, this._ = "";
     }
     moveTo(t, n) {
         this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
@@ -26360,15 +26347,15 @@
     }
     arc(t, n, i) {
         t = +t, n = +n, i = +i;
         const r = t + i,
             s = n;
         if (i < 0)
             throw new Error("negative radius");
-        this._x1 === null ? this._ += `M${r},${s}` : (Math.abs(this._x1 - r) > jC || Math.abs(this._y1 - s) > jC) && (this._ += "L" + r + "," + s), i && (this._ += `A${i},${i},0,1,1,${t - i},${n}A${i},${i},0,1,1,${this._x1 = r},${this._y1 = s}`);
+        this._x1 === null ? this._ += `M${r},${s}` : (Math.abs(this._x1 - r) > j$ || Math.abs(this._y1 - s) > j$) && (this._ += "L" + r + "," + s), i && (this._ += `A${i},${i},0,1,1,${t - i},${n}A${i},${i},0,1,1,${this._x1 = r},${this._y1 = s}`);
     }
     rect(t, n, i, r) {
         this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${+i}v${+r}h${-i}Z`;
     }
     value() {
         return this._ || null;
     }
@@ -26409,40 +26396,40 @@
             vectors: r
         } = this;
         let s, o;
         const a = this.circumcenters = this._circumcenters.subarray(0, i.length / 3 * 2);
         for (let p = 0, m = 0, y = i.length, b, v; p < y; p += 3, m += 2) {
             const x = i[p] * 2,
                 w = i[p + 1] * 2,
-                S = i[p + 2] * 2,
+                E = i[p + 2] * 2,
                 _ = t[x],
                 k = t[x + 1],
                 A = t[w],
-                F = t[w + 1],
-                T = t[S],
-                I = t[S + 1],
-                N = A - _,
-                D = F - k,
-                M = T - _,
-                E = I - k,
-                $ = (N * E - D * M) * 2;
-            if (Math.abs($) < 1e-9) {
+                T = t[w + 1],
+                M = t[E],
+                L = t[E + 1],
+                F = A - _,
+                O = T - k,
+                N = M - _,
+                R = L - k,
+                P = (F * R - O * N) * 2;
+            if (Math.abs(P) < 1e-9) {
                 if (s === void 0) {
                     s = o = 0;
-                    for (const O of n)
-                        s += t[O * 2], o += t[O * 2 + 1];
+                    for (const $ of n)
+                        s += t[$ * 2], o += t[$ * 2 + 1];
                     s /= n.length, o /= n.length;
                 }
-                const C = 1e9 * Math.sign((s - _) * E - (o - k) * M);
-                b = (_ + T) / 2 - C * E, v = (k + I) / 2 + C * M;
+                const S = 1e9 * Math.sign((s - _) * R - (o - k) * N);
+                b = (_ + M) / 2 - S * R, v = (k + L) / 2 + S * N;
             } else {
-                const C = 1 / $,
-                    O = N * N + D * D,
-                    R = M * M + E * E;
-                b = _ + (E * O - D * R) * C, v = k + (N * R - M * O) * C;
+                const S = 1 / P,
+                    $ = F * F + O * O,
+                    C = N * N + R * R;
+                b = _ + (R * $ - O * C) * S, v = k + (F * C - N * $) * S;
             }
             a[m] = b, a[m + 1] = v;
         }
         let u = n[n.length - 1],
             l, c = u * 4,
             f, d = t[2 * u],
             h, g = t[2 * u + 1];
@@ -26966,15 +26953,15 @@
     }, {
         name: "as",
         type: "string",
         default: "path"
     }]
 };
 const Zse = [-1e5, -1e5, 1e5, 1e5];
-Q(I3, B, {
+Z(I3, B, {
     transform(e, t) {
         const n = e.as || "path",
             i = t.source;
         if (!i || !i.length)
             return t;
         let r = e.size;
         r = r ? [0, 0, r[0], r[1]] : (r = e.extent) ? [r[0][0], r[0][1], r[1][0], r[1][1]] : Zse;
@@ -27012,32 +26999,32 @@
 function ioe() {
     var e = [256, 256],
         t, n, i, r, s, o, a, u = rL,
         l = [],
         c = Math.random,
         f = {};
     f.layout = function() {
-        for (var g = d(oa()), p = loe((e[0] >> 5) * e[1]), m = null, y = l.length, b = -1, v = [], x = l.map((S) => ({
-                text: t(S),
-                font: n(S),
-                style: r(S),
-                weight: s(S),
-                rotate: o(S),
-                size: ~~(i(S) + 1e-14),
-                padding: a(S),
+        for (var g = d(oa()), p = loe((e[0] >> 5) * e[1]), m = null, y = l.length, b = -1, v = [], x = l.map((E) => ({
+                text: t(E),
+                font: n(E),
+                style: r(E),
+                weight: s(E),
+                rotate: o(E),
+                size: ~~(i(E) + 1e-14),
+                padding: a(E),
                 xoff: 0,
                 yoff: 0,
                 x1: 0,
                 y1: 0,
                 x0: 0,
                 y0: 0,
                 hasText: !1,
                 sprite: null,
-                datum: S
-            })).sort((S, _) => _.size - S.size); ++b < y;) {
+                datum: E
+            })).sort((E, _) => _.size - E.size); ++b < y;) {
             var w = x[b];
             w.x = e[0] * (c() + 0.5) >> 1, w.y = e[1] * (c() + 0.5) >> 1, roe(g, w, x, b), w.hasText && h(p, w, m) && (v.push(w), m ? ooe(m, w) : m = [{
                 x: w.x + w.x0,
                 y: w.y + w.y0
             }, {
                 x: w.x + w.x1,
                 y: w.y + w.y1
@@ -27054,22 +27041,22 @@
         return m.fillStyle = m.strokeStyle = "red", m.textAlign = "center", {
             context: m,
             ratio: p
         };
     }
 
     function h(g, p, m) {
-        for (var y = p.x, b = p.y, v = Math.sqrt(e[0] * e[0] + e[1] * e[1]), x = u(e), w = c() < 0.5 ? 1 : -1, S = -w, _, k, A;
-            (_ = x(S += w)) && (k = ~~_[0], A = ~~_[1], !(Math.min(Math.abs(k), Math.abs(A)) >= v));)
+        for (var y = p.x, b = p.y, v = Math.sqrt(e[0] * e[0] + e[1] * e[1]), x = u(e), w = c() < 0.5 ? 1 : -1, E = -w, _, k, A;
+            (_ = x(E += w)) && (k = ~~_[0], A = ~~_[1], !(Math.min(Math.abs(k), Math.abs(A)) >= v));)
             if (p.x = y + k, p.y = b + A, !(p.x + p.x0 < 0 || p.y + p.y0 < 0 || p.x + p.x1 > e[0] || p.y + p.y1 > e[1]) && (!m || !soe(p, g, e[0])) && (!m || aoe(p, m))) {
-                for (var F = p.sprite, T = p.width >> 5, I = e[0] >> 5, N = p.x - (T << 4), D = N & 127, M = 32 - D, E = p.y1 - p.y0, $ = (p.y + p.y0) * I + (N >> 5), C, O = 0; O < E; O++) {
-                    C = 0;
-                    for (var R = 0; R <= T; R++)
-                        g[$ + R] |= C << M | (R < T ? (C = F[O * T + R]) >>> D : 0);
-                    $ += I;
+                for (var T = p.sprite, M = p.width >> 5, L = e[0] >> 5, F = p.x - (M << 4), O = F & 127, N = 32 - O, R = p.y1 - p.y0, P = (p.y + p.y0) * L + (F >> 5), S, $ = 0; $ < R; $++) {
+                    S = 0;
+                    for (var C = 0; C <= M; C++)
+                        g[P + C] |= S << N | (C < M ? (S = T[$ * M + C]) >>> O : 0);
+                    P += L;
                 }
                 return p.sprite = null, !0;
             }
         return !1;
     }
     return f.words = function(g) {
         return arguments.length ? (l = g, f) : l;
@@ -27117,32 +27104,32 @@
                 c = Math.max(Math.abs(y + x), Math.abs(y - x)) + 31 >> 5 << 5, d = ~~Math.max(Math.abs(b + v), Math.abs(b - v));
             } else
                 c = c + 31 >> 5 << 5;
             if (d > u && (u = d), o + c >= Rd << 5 && (o = 0, a += u, u = 0), a + d >= dm)
                 break;
             r.translate((o + (c >> 1)) / s, (a + (d >> 1)) / s), t.rotate && r.rotate(t.rotate * Dv), r.fillText(t.text, 0, 0), t.padding && (r.lineWidth = 2 * t.padding, r.strokeText(t.text, 0, 0)), r.restore(), t.width = c, t.height = d, t.xoff = o, t.yoff = a, t.x1 = c >> 1, t.y1 = d >> 1, t.x0 = -t.x1, t.y0 = -t.y1, t.hasText = !0, o += c;
         }
-        for (var w = r.getImageData(0, 0, (Rd << 5) / s, dm / s).data, S = []; --i >= 0;)
+        for (var w = r.getImageData(0, 0, (Rd << 5) / s, dm / s).data, E = []; --i >= 0;)
             if (t = n[i], !!t.hasText) {
                 for (c = t.width, f = c >> 5, d = t.y1 - t.y0, h = 0; h < d * f; h++)
-                    S[h] = 0;
+                    E[h] = 0;
                 if (o = t.xoff, o == null)
                     return;
                 a = t.yoff;
                 var _ = 0,
                     k = -1;
                 for (g = 0; g < d; g++) {
                     for (h = 0; h < c; h++) {
                         var A = f * g + (h >> 5),
-                            F = w[(a + g) * (Rd << 5) + (o + h) << 2] ? 1 << 31 - h % 32 : 0;
-                        S[A] |= F, _ |= F;
+                            T = w[(a + g) * (Rd << 5) + (o + h) << 2] ? 1 << 31 - h % 32 : 0;
+                        E[A] |= T, _ |= T;
                     }
                     _ ? k = g : (t.y0++, d--, g--, a++);
                 }
-                t.y1 = t.y0 + k, t.sprite = S.slice(0, (t.y1 - t.y0) * f);
+                t.y1 = t.y0 + k, t.sprite = E.slice(0, (t.y1 - t.y0) * f);
             }
     }
 }
 
 function soe(e, t, n) {
     n >>= 5;
     for (var i = e.sprite, r = e.width >> 5, s = e.x - (r << 4), o = s & 127, a = 32 - o, u = e.y1 - e.y0, l = (e.y + e.y0) * n + (s >> 5), c, f = 0; f < u; f++) {
@@ -27273,31 +27260,31 @@
         name: "as",
         type: "string",
         array: !0,
         length: 7,
         default: sL
     }]
 };
-Q(P3, B, {
+Z(P3, B, {
     transform(e, t) {
-        e.size && !(e.size[0] && e.size[1]) && q("Wordcloud size dimensions must be non-zero.");
+        e.size && !(e.size[0] && e.size[1]) && W("Wordcloud size dimensions must be non-zero.");
 
         function n(g) {
             const p = e[g];
             return Me(p) && t.modified(p.fields);
         }
         const i = e.modified();
         if (!(i || t.changed(t.ADD_REM) || foe.some(n)))
             return;
         const r = t.materialize(t.SOURCE).source,
             s = this.value,
             o = e.as || sL;
         let a = e.fontSize || 14,
             u;
-        if (Me(a) ? u = e.fontSizeRange : a = kn(a), u) {
+        if (Me(a) ? u = e.fontSizeRange : a = An(a), u) {
             const g = a,
                 p = qe("sqrt")().domain(hs(r, g)).range(u);
             a = (m) => p(g(m));
         }
         r.forEach((g) => {
             g[o[0]] = NaN, g[o[1]] = NaN, g[o[3]] = 0;
         });
@@ -27368,15 +27355,15 @@
 }
 
 function _p(e, t, n) {
     const i = (t < 257 ? hoe : t < 65537 ? goe : Qd)(e);
     return n && i.set(n), i;
 }
 
-function qC(e, t, n) {
+function q$(e, t, n) {
     const i = 1 << t;
     return {
         one: i,
         zero: ~i,
         range: n.slice(),
         bisect: e.bisect,
         index: e.index,
@@ -27394,15 +27381,15 @@
             for (d = c; d < f; ++d)
                 s[u[d]] |= i;
             return o;
         }
     };
 }
 
-function WC() {
+function W$() {
     let e = Qd(0),
         t = [],
         n = 0;
 
     function i(a, u, l) {
         if (!u.length)
             return [];
@@ -27495,15 +27482,15 @@
         content: {
             type: "number",
             array: !0,
             length: 2
         }
     }]
 };
-Q(z3, B, {
+Z(z3, B, {
     transform(e, t) {
         if (this._dims) {
             var n = e.modified("fields") || e.fields.some((i) => t.modified(i.fields));
             return n ? this.reinit(e, t) : this.eval(e, t);
         } else
             return this.init(e, t);
     },
@@ -27512,15 +27499,15 @@
             i = e.query,
             r = this._indices = {},
             s = this._dims = [],
             o = i.length;
         let a = 0,
             u, l;
         for (; a < o; ++a)
-            u = n[a].fname, l = r[u] || (r[u] = WC()), s.push(qC(l, a, i[a]));
+            u = n[a].fname, l = r[u] || (r[u] = W$()), s.push(q$(l, a, i[a]));
         return this.eval(e, t);
     },
     reinit(e, t) {
         const n = t.materialize().fork(),
             i = e.fields,
             r = e.query,
             s = this._indices,
@@ -27529,21 +27516,21 @@
             u = a.curr(),
             l = a.prev(),
             c = a.all(),
             f = n.rem = n.add,
             d = n.mod,
             h = r.length,
             g = {};
-        let p, m, y, b, v, x, w, S, _;
+        let p, m, y, b, v, x, w, E, _;
         if (l.set(u), t.rem.length && (v = this.remove(e, t, n)), t.add.length && a.add(t.add), t.mod.length)
-            for (x = {}, b = t.mod, w = 0, S = b.length; w < S; ++w)
+            for (x = {}, b = t.mod, w = 0, E = b.length; w < E; ++w)
                 x[b[w]._index] = 1;
         for (w = 0; w < h; ++w)
-            _ = i[w], (!o[w] || e.modified("fields", w) || t.modified(_.fields)) && (y = _.fname, (p = g[y]) || (s[y] = m = WC(), g[y] = p = m.insert(_, t.source, 0)), o[w] = qC(m, w, r[w]).onAdd(p, u));
-        for (w = 0, S = a.data().length; w < S; ++w)
+            _ = i[w], (!o[w] || e.modified("fields", w) || t.modified(_.fields)) && (y = _.fname, (p = g[y]) || (s[y] = m = W$(), g[y] = p = m.insert(_, t.source, 0)), o[w] = q$(m, w, r[w]).onAdd(p, u));
+        for (w = 0, E = a.data().length; w < E; ++w)
             v[w] || (l[w] !== u[w] ? f.push(w) : x[w] && u[w] !== c && d.push(w));
         return a.mask = (1 << h) - 1, n;
     },
     eval(e, t) {
         const n = t.materialize().fork(),
             i = this._dims.length;
         let r = 0;
@@ -27692,15 +27679,15 @@
     }, {
         name: "filter",
         type: "object",
         required: !0,
         description: "Per-tuple filter bitmaps from a CrossFilter transform."
     }]
 };
-Q(B3, B, {
+Z(B3, B, {
     transform(e, t) {
         const n = ~(e.ignore || 0),
             i = e.filter,
             r = i.mask;
         if (!(r & n))
             return t.StopPropagation;
         const s = t.fork(t.ALL),
@@ -27729,16 +27716,16 @@
     woe = "Property",
     _oe = "Identifier",
     Eoe = "ArrayExpression",
     Soe = "BinaryExpression",
     oL = "CallExpression",
     koe = "ConditionalExpression",
     Aoe = "LogicalExpression",
-    $oe = "MemberExpression",
-    Coe = "ObjectExpression",
+    Coe = "MemberExpression",
+    $oe = "ObjectExpression",
     Moe = "UnaryExpression";
 
 function Ir(e) {
     this.type = e;
 }
 Ir.prototype.visit = function(e) {
     let t, n, i;
@@ -27756,30 +27743,30 @@
         case Soe:
         case Aoe:
             return [e.left, e.right];
         case oL:
             return [e.callee].concat(e.arguments);
         case koe:
             return [e.test, e.consequent, e.alternate];
-        case $oe:
-            return [e.object, e.property];
         case Coe:
+            return [e.object, e.property];
+        case $oe:
             return e.properties;
         case woe:
             return [e.key, e.value];
         case Moe:
             return [e.argument];
         case _oe:
         case Vu:
         case xoe:
         default:
             return [];
     }
 }
-var Ms, le, j, _n, Xe, yy = 1,
+var Ms, ce, q, En, Xe, yy = 1,
     _g = 2,
     Yu = 3,
     Pa = 4,
     by = 5,
     vl = 6,
     Jn = 7,
     Eg = 8,
@@ -27801,25 +27788,25 @@
     aL = "Identifier",
     Loe = "Literal",
     Ioe = "LogicalExpression",
     Poe = "MemberExpression",
     zoe = "ObjectExpression",
     Boe = "Property",
     Uoe = "UnaryExpression",
-    Ut = "Unexpected token %0",
+    jt = "Unexpected token %0",
     joe = "Unexpected number",
     qoe = "Unexpected string",
     Woe = "Unexpected identifier",
     Hoe = "Unexpected reserved word",
     Goe = "Unexpected end of input",
     sw = "Invalid regular expression",
     Rv = "Invalid regular expression: missing /",
     uL = "Octal literals are not allowed in strict mode.",
     Voe = "Duplicate data property in object literal not allowed in strict mode",
-    en = "ILLEGAL",
+    tn = "ILLEGAL",
     Mh = "Disabled.",
     Yoe = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),
     Xoe = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
 
 function vy(e, t) {
     if (!e)
         throw new Error("ASSERT: " + t);
@@ -27903,222 +27890,222 @@
     interface: 1,
     protected: 1,
     instanceof: 1,
     implements: 1
 };
 
 function lL() {
-    for (; j < _n;) {
-        const e = le.charCodeAt(j);
+    for (; q < En;) {
+        const e = ce.charCodeAt(q);
         if (Koe(e) || Th(e))
-            ++j;
+            ++q;
         else
             break;
     }
 }
 
 function ow(e) {
     var t, n, i, r = 0;
     for (n = e === "u" ? 4 : 2, t = 0; t < n; ++t)
-        j < _n && U3(le[j]) ? (i = le[j++], r = r * 16 + "0123456789abcdef".indexOf(i.toLowerCase())) : Ue({}, Ut, en);
+        q < En && U3(ce[q]) ? (i = ce[q++], r = r * 16 + "0123456789abcdef".indexOf(i.toLowerCase())) : Ue({}, jt, tn);
     return String.fromCharCode(r);
 }
 
 function Qoe() {
     var e, t, n, i;
-    for (e = le[j], t = 0, e === "}" && Ue({}, Ut, en); j < _n && (e = le[j++], !!U3(e));)
+    for (e = ce[q], t = 0, e === "}" && Ue({}, jt, tn); q < En && (e = ce[q++], !!U3(e));)
         t = t * 16 + "0123456789abcdef".indexOf(e.toLowerCase());
-    return (t > 1114111 || e !== "}") && Ue({}, Ut, en), t <= 65535 ? String.fromCharCode(t) : (n = (t - 65536 >> 10) + 55296, i = (t - 65536 & 1023) + 56320, String.fromCharCode(n, i));
+    return (t > 1114111 || e !== "}") && Ue({}, jt, tn), t <= 65535 ? String.fromCharCode(t) : (n = (t - 65536 >> 10) + 55296, i = (t - 65536 & 1023) + 56320, String.fromCharCode(n, i));
 }
 
 function cL() {
     var e, t;
-    for (e = le.charCodeAt(j++), t = String.fromCharCode(e), e === 92 && (le.charCodeAt(j) !== 117 && Ue({}, Ut, en), ++j, e = ow("u"), (!e || e === "\\" || !Sg(e.charCodeAt(0))) && Ue({}, Ut, en), t = e); j < _n && (e = le.charCodeAt(j), !!D0(e));)
-        ++j, t += String.fromCharCode(e), e === 92 && (t = t.substr(0, t.length - 1), le.charCodeAt(j) !== 117 && Ue({}, Ut, en), ++j, e = ow("u"), (!e || e === "\\" || !D0(e.charCodeAt(0))) && Ue({}, Ut, en), t += e);
+    for (e = ce.charCodeAt(q++), t = String.fromCharCode(e), e === 92 && (ce.charCodeAt(q) !== 117 && Ue({}, jt, tn), ++q, e = ow("u"), (!e || e === "\\" || !Sg(e.charCodeAt(0))) && Ue({}, jt, tn), t = e); q < En && (e = ce.charCodeAt(q), !!D0(e));)
+        ++q, t += String.fromCharCode(e), e === 92 && (t = t.substr(0, t.length - 1), ce.charCodeAt(q) !== 117 && Ue({}, jt, tn), ++q, e = ow("u"), (!e || e === "\\" || !D0(e.charCodeAt(0))) && Ue({}, jt, tn), t += e);
     return t;
 }
 
 function Zoe() {
     var e, t;
-    for (e = j++; j < _n;) {
-        if (t = le.charCodeAt(j), t === 92)
-            return j = e, cL();
+    for (e = q++; q < En;) {
+        if (t = ce.charCodeAt(q), t === 92)
+            return q = e, cL();
         if (D0(t))
-            ++j;
+            ++q;
         else
             break;
     }
-    return le.slice(e, j);
+    return ce.slice(e, q);
 }
 
 function eae() {
     var e, t, n;
-    return e = j, t = le.charCodeAt(j) === 92 ? cL() : Zoe(), t.length === 1 ? n = Yu : Joe.hasOwnProperty(t) ? n = Pa : t === "null" ? n = by : t === "true" || t === "false" ? n = yy : n = Yu, {
+    return e = q, t = ce.charCodeAt(q) === 92 ? cL() : Zoe(), t.length === 1 ? n = Yu : Joe.hasOwnProperty(t) ? n = Pa : t === "null" ? n = by : t === "true" || t === "false" ? n = yy : n = Yu, {
         type: n,
         value: t,
         start: e,
-        end: j
+        end: q
     };
 }
 
 function Lv() {
-    var e = j,
-        t = le.charCodeAt(j),
-        n, i = le[j],
+    var e = q,
+        t = ce.charCodeAt(q),
+        n, i = ce[q],
         r, s, o;
     switch (t) {
         case 46:
         case 40:
         case 41:
         case 59:
         case 44:
         case 123:
         case 125:
         case 91:
         case 93:
         case 58:
         case 63:
         case 126:
-            return ++j, {
+            return ++q, {
                 type: Jn,
                 value: String.fromCharCode(t),
                 start: e,
-                end: j
+                end: q
             };
         default:
-            if (n = le.charCodeAt(j + 1), n === 61)
+            if (n = ce.charCodeAt(q + 1), n === 61)
                 switch (t) {
                     case 43:
                     case 45:
                     case 47:
                     case 60:
                     case 62:
                     case 94:
                     case 124:
                     case 37:
                     case 38:
                     case 42:
-                        return j += 2, {
+                        return q += 2, {
                             type: Jn,
                             value: String.fromCharCode(t) + String.fromCharCode(n),
                             start: e,
-                            end: j
+                            end: q
                         };
                     case 33:
                     case 61:
-                        return j += 2, le.charCodeAt(j) === 61 && ++j, {
+                        return q += 2, ce.charCodeAt(q) === 61 && ++q, {
                             type: Jn,
-                            value: le.slice(e, j),
+                            value: ce.slice(e, q),
                             start: e,
-                            end: j
+                            end: q
                         };
                 }
     }
-    if (o = le.substr(j, 4), o === ">>>=")
-        return j += 4, {
+    if (o = ce.substr(q, 4), o === ">>>=")
+        return q += 4, {
             type: Jn,
             value: o,
             start: e,
-            end: j
+            end: q
         };
     if (s = o.substr(0, 3), s === ">>>" || s === "<<=" || s === ">>=")
-        return j += 3, {
+        return q += 3, {
             type: Jn,
             value: s,
             start: e,
-            end: j
+            end: q
         };
     if (r = s.substr(0, 2), i === r[1] && "+-<>&|".indexOf(i) >= 0 || r === "=>")
-        return j += 2, {
+        return q += 2, {
             type: Jn,
             value: r,
             start: e,
-            end: j
+            end: q
         };
-    if (r === "//" && Ue({}, Ut, en), "<>=!+-*%&|^/".indexOf(i) >= 0)
-        return ++j, {
+    if (r === "//" && Ue({}, jt, tn), "<>=!+-*%&|^/".indexOf(i) >= 0)
+        return ++q, {
             type: Jn,
             value: i,
             start: e,
-            end: j
+            end: q
         };
-    Ue({}, Ut, en);
+    Ue({}, jt, tn);
 }
 
 function tae(e) {
     let t = "";
-    for (; j < _n && U3(le[j]);)
-        t += le[j++];
-    return t.length === 0 && Ue({}, Ut, en), Sg(le.charCodeAt(j)) && Ue({}, Ut, en), {
+    for (; q < En && U3(ce[q]);)
+        t += ce[q++];
+    return t.length === 0 && Ue({}, jt, tn), Sg(ce.charCodeAt(q)) && Ue({}, jt, tn), {
         type: vl,
         value: parseInt("0x" + t, 16),
         start: e,
-        end: j
+        end: q
     };
 }
 
 function nae(e) {
-    let t = "0" + le[j++];
-    for (; j < _n && Zd(le[j]);)
-        t += le[j++];
-    return (Sg(le.charCodeAt(j)) || Qs(le.charCodeAt(j))) && Ue({}, Ut, en), {
+    let t = "0" + ce[q++];
+    for (; q < En && Zd(ce[q]);)
+        t += ce[q++];
+    return (Sg(ce.charCodeAt(q)) || Qs(ce.charCodeAt(q))) && Ue({}, jt, tn), {
         type: vl,
         value: parseInt(t, 8),
         octal: !0,
         start: e,
-        end: j
+        end: q
     };
 }
 
-function HC() {
+function H$() {
     var e, t, n;
-    if (n = le[j], vy(Qs(n.charCodeAt(0)) || n === ".", "Numeric literal must start with a decimal digit or a decimal point"), t = j, e = "", n !== ".") {
-        if (e = le[j++], n = le[j], e === "0") {
+    if (n = ce[q], vy(Qs(n.charCodeAt(0)) || n === ".", "Numeric literal must start with a decimal digit or a decimal point"), t = q, e = "", n !== ".") {
+        if (e = ce[q++], n = ce[q], e === "0") {
             if (n === "x" || n === "X")
-                return ++j, tae(t);
+                return ++q, tae(t);
             if (Zd(n))
                 return nae(t);
-            n && Qs(n.charCodeAt(0)) && Ue({}, Ut, en);
+            n && Qs(n.charCodeAt(0)) && Ue({}, jt, tn);
         }
-        for (; Qs(le.charCodeAt(j));)
-            e += le[j++];
-        n = le[j];
+        for (; Qs(ce.charCodeAt(q));)
+            e += ce[q++];
+        n = ce[q];
     }
     if (n === ".") {
-        for (e += le[j++]; Qs(le.charCodeAt(j));)
-            e += le[j++];
-        n = le[j];
+        for (e += ce[q++]; Qs(ce.charCodeAt(q));)
+            e += ce[q++];
+        n = ce[q];
     }
     if (n === "e" || n === "E")
-        if (e += le[j++], n = le[j], (n === "+" || n === "-") && (e += le[j++]), Qs(le.charCodeAt(j)))
-            for (; Qs(le.charCodeAt(j));)
-                e += le[j++];
+        if (e += ce[q++], n = ce[q], (n === "+" || n === "-") && (e += ce[q++]), Qs(ce.charCodeAt(q)))
+            for (; Qs(ce.charCodeAt(q));)
+                e += ce[q++];
         else
-            Ue({}, Ut, en);
-    return Sg(le.charCodeAt(j)) && Ue({}, Ut, en), {
+            Ue({}, jt, tn);
+    return Sg(ce.charCodeAt(q)) && Ue({}, jt, tn), {
         type: vl,
         value: parseFloat(e),
         start: t,
-        end: j
+        end: q
     };
 }
 
 function iae() {
     var e = "",
         t, n, i, r, s = !1;
-    for (t = le[j], vy(t === "'" || t === '"', "String literal must starts with a quote"), n = j, ++j; j < _n;)
-        if (i = le[j++], i === t) {
+    for (t = ce[q], vy(t === "'" || t === '"', "String literal must starts with a quote"), n = q, ++q; q < En;)
+        if (i = ce[q++], i === t) {
             t = "";
             break;
         } else if (i === "\\")
-        if (i = le[j++], !i || !Th(i.charCodeAt(0)))
+        if (i = ce[q++], !i || !Th(i.charCodeAt(0)))
             switch (i) {
                 case "u":
                 case "x":
-                    le[j] === "{" ? (++j, e += Qoe()) : e += ow(i);
+                    ce[q] === "{" ? (++q, e += Qoe()) : e += ow(i);
                     break;
                 case "n":
                     e += `
 `;
                     break;
                 case "r":
                     e += "\r";
@@ -28132,31 +28119,31 @@
                 case "f":
                     e += "\f";
                     break;
                 case "v":
                     e += "\v";
                     break;
                 default:
-                    Zd(i) ? (r = "01234567".indexOf(i), r !== 0 && (s = !0), j < _n && Zd(le[j]) && (s = !0, r = r * 8 + "01234567".indexOf(le[j++]), "0123".indexOf(i) >= 0 && j < _n && Zd(le[j]) && (r = r * 8 + "01234567".indexOf(le[j++]))), e += String.fromCharCode(r)) : e += i;
+                    Zd(i) ? (r = "01234567".indexOf(i), r !== 0 && (s = !0), q < En && Zd(ce[q]) && (s = !0, r = r * 8 + "01234567".indexOf(ce[q++]), "0123".indexOf(i) >= 0 && q < En && Zd(ce[q]) && (r = r * 8 + "01234567".indexOf(ce[q++]))), e += String.fromCharCode(r)) : e += i;
                     break;
             }
     else
-        i === "\r" && le[j] === `
-` && ++j;
+        i === "\r" && ce[q] === `
+` && ++q;
     else {
         if (Th(i.charCodeAt(0)))
             break;
         e += i;
     }
-    return t !== "" && Ue({}, Ut, en), {
+    return t !== "" && Ue({}, jt, tn), {
         type: Eg,
         value: e,
         octal: s,
         start: n,
-        end: j
+        end: q
     };
 }
 
 function rae(e, t) {
     let n = e;
     t.indexOf("u") >= 0 && (n = n.replace(/\\u\{([0-9a-fA-F]+)\}/g, (i, r) => {
         if (parseInt(r, 16) <= 1114111)
@@ -28173,17 +28160,17 @@
     } catch {
         return null;
     }
 }
 
 function sae() {
     var e, t, n, i, r;
-    for (e = le[j], vy(e === "/", "Regular expression literal must start with a slash"), t = le[j++], n = !1, i = !1; j < _n;)
-        if (e = le[j++], t += e, e === "\\")
-            e = le[j++], Th(e.charCodeAt(0)) && Ue({}, Rv), t += e;
+    for (e = ce[q], vy(e === "/", "Regular expression literal must start with a slash"), t = ce[q++], n = !1, i = !1; q < En;)
+        if (e = ce[q++], t += e, e === "\\")
+            e = ce[q++], Th(e.charCodeAt(0)) && Ue({}, Rv), t += e;
         else if (Th(e.charCodeAt(0)))
         Ue({}, Rv);
     else if (n)
         e === "]" && (n = !1);
     else if (e === "/") {
         i = !0;
         break;
@@ -28193,67 +28180,67 @@
         value: r,
         literal: t
     };
 }
 
 function oae() {
     var e, t, n;
-    for (t = "", n = ""; j < _n && (e = le[j], !!D0(e.charCodeAt(0)));)
-        ++j, e === "\\" && j < _n ? Ue({}, Ut, en) : (n += e, t += e);
+    for (t = "", n = ""; q < En && (e = ce[q], !!D0(e.charCodeAt(0)));)
+        ++q, e === "\\" && q < En ? Ue({}, jt, tn) : (n += e, t += e);
     return n.search(/[^gimuy]/g) >= 0 && Ue({}, sw, n), {
         value: n,
         literal: t
     };
 }
 
 function aae() {
     var e, t, n, i;
-    return Xe = null, lL(), e = j, t = sae(), n = oae(), i = rae(t.value, n.value), {
+    return Xe = null, lL(), e = q, t = sae(), n = oae(), i = rae(t.value, n.value), {
         literal: t.literal + n.literal,
         value: i,
         regex: {
             pattern: t.value,
             flags: n.value
         },
         start: e,
-        end: j
+        end: q
     };
 }
 
 function uae(e) {
     return e.type === Yu || e.type === Pa || e.type === yy || e.type === by;
 }
 
 function fL() {
-    if (lL(), j >= _n)
+    if (lL(), q >= En)
         return {
             type: _g,
-            start: j,
-            end: j
+            start: q,
+            end: q
         };
-    const e = le.charCodeAt(j);
-    return Sg(e) ? eae() : e === 40 || e === 41 || e === 59 ? Lv() : e === 39 || e === 34 ? iae() : e === 46 ? Qs(le.charCodeAt(j + 1)) ? HC() : Lv() : Qs(e) ? HC() : Lv();
+    const e = ce.charCodeAt(q);
+    return Sg(e) ? eae() : e === 40 || e === 41 || e === 59 ? Lv() : e === 39 || e === 34 ? iae() : e === 46 ? Qs(ce.charCodeAt(q + 1)) ? H$() : Lv() : Qs(e) ? H$() : Lv();
 }
 
 function ei() {
     const e = Xe;
-    return j = e.end, Xe = fL(), j = e.end, e;
+    return q = e.end, Xe = fL(), q = e.end, e;
 }
 
 function dL() {
-    const e = j;
-    Xe = fL(), j = e;
+    const e = q;
+    Xe = fL(), q = e;
 }
 
 function lae(e) {
     const t = new Ir(Noe);
     return t.elements = e, t;
 }
 
-function GC(e, t, n) {
+function G$(e, t, n) {
     const i = new Ir(e === "||" || e === "&&" ? Ioe : Ooe);
     return i.operator = e, i.left = t, i.right = n, i;
 }
 
 function cae(e, t) {
     const n = new Ir(Doe);
     return n.callee = e, n.arguments = t, n;
@@ -28267,185 +28254,185 @@
 function j3(e) {
     const t = new Ir(aL);
     return t.name = e, t;
 }
 
 function Ld(e) {
     const t = new Ir(Loe);
-    return t.value = e.value, t.raw = le.slice(e.start, e.end), e.regex && (t.raw === "//" && (t.raw = "/(?:)/"), t.regex = e.regex), t;
+    return t.value = e.value, t.raw = ce.slice(e.start, e.end), e.regex && (t.raw === "//" && (t.raw = "/(?:)/"), t.regex = e.regex), t;
 }
 
-function VC(e, t, n) {
+function V$(e, t, n) {
     const i = new Ir(Poe);
     return i.computed = e === "[", i.object = t, i.property = n, i.computed || (n.member = !0), i;
 }
 
 function dae(e) {
     const t = new Ir(zoe);
     return t.properties = e, t;
 }
 
-function YC(e, t, n) {
+function Y$(e, t, n) {
     const i = new Ir(Boe);
     return i.key = t, i.value = n, i.kind = e, i;
 }
 
 function hae(e, t) {
     const n = new Ir(Uoe);
     return n.operator = e, n.argument = t, n.prefix = !0, n;
 }
 
 function Ue(e, t) {
     var n, i = Array.prototype.slice.call(arguments, 2),
         r = t.replace(/%(\d)/g, (s, o) => (vy(o < i.length, "Message reference must be in range"), i[o]));
-    throw n = new Error(r), n.index = j, n.description = r, n;
+    throw n = new Error(r), n.index = q, n.description = r, n;
 }
 
 function xy(e) {
-    e.type === _g && Ue(e, Goe), e.type === vl && Ue(e, joe), e.type === Eg && Ue(e, qoe), e.type === Yu && Ue(e, Woe), e.type === Pa && Ue(e, Hoe), Ue(e, Ut, e.value);
+    e.type === _g && Ue(e, Goe), e.type === vl && Ue(e, joe), e.type === Eg && Ue(e, qoe), e.type === Yu && Ue(e, Woe), e.type === Pa && Ue(e, Hoe), Ue(e, jt, e.value);
 }
 
-function En(e) {
+function Sn(e) {
     const t = ei();
     (t.type !== Jn || t.value !== e) && xy(t);
 }
 
-function ot(e) {
+function at(e) {
     return Xe.type === Jn && Xe.value === e;
 }
 
 function Iv(e) {
     return Xe.type === Pa && Xe.value === e;
 }
 
 function gae() {
     const e = [];
-    for (j = Xe.start, En("["); !ot("]");)
-        ot(",") ? (ei(), e.push(null)) : (e.push(Xu()), ot("]") || En(","));
+    for (q = Xe.start, Sn("["); !at("]");)
+        at(",") ? (ei(), e.push(null)) : (e.push(Xu()), at("]") || Sn(","));
     return ei(), lae(e);
 }
 
-function XC() {
-    j = Xe.start;
+function X$() {
+    q = Xe.start;
     const e = ei();
     return e.type === Eg || e.type === vl ? (e.octal && Ue(e, uL), Ld(e)) : j3(e.value);
 }
 
 function pae() {
     var e, t, n, i;
-    if (j = Xe.start, e = Xe, e.type === Yu)
-        return n = XC(), En(":"), i = Xu(), YC("init", n, i);
+    if (q = Xe.start, e = Xe, e.type === Yu)
+        return n = X$(), Sn(":"), i = Xu(), Y$("init", n, i);
     if (e.type === _g || e.type === Jn)
         xy(e);
     else
-        return t = XC(), En(":"), i = Xu(), YC("init", t, i);
+        return t = X$(), Sn(":"), i = Xu(), Y$("init", t, i);
 }
 
 function mae() {
     var e = [],
         t, n, i, r = {},
         s = String;
-    for (j = Xe.start, En("{"); !ot("}");)
-        t = pae(), t.key.type === aL ? n = t.key.name : n = s(t.key.value), i = "$" + n, Object.prototype.hasOwnProperty.call(r, i) ? Ue({}, Voe) : r[i] = !0, e.push(t), ot("}") || En(",");
-    return En("}"), dae(e);
+    for (q = Xe.start, Sn("{"); !at("}");)
+        t = pae(), t.key.type === aL ? n = t.key.name : n = s(t.key.value), i = "$" + n, Object.prototype.hasOwnProperty.call(r, i) ? Ue({}, Voe) : r[i] = !0, e.push(t), at("}") || Sn(",");
+    return Sn("}"), dae(e);
 }
 
 function yae() {
-    En("(");
+    Sn("(");
     const e = q3();
-    return En(")"), e;
+    return Sn(")"), e;
 }
 const bae = {
     if: 1
 };
 
 function vae() {
     var e, t, n;
-    if (ot("("))
+    if (at("("))
         return yae();
-    if (ot("["))
+    if (at("["))
         return gae();
-    if (ot("{"))
+    if (at("{"))
         return mae();
-    if (e = Xe.type, j = Xe.start, e === Yu || bae[Xe.value])
+    if (e = Xe.type, q = Xe.start, e === Yu || bae[Xe.value])
         n = j3(ei().value);
     else if (e === Eg || e === vl)
         Xe.octal && Ue(Xe, uL), n = Ld(ei());
     else {
         if (e === Pa)
             throw new Error(Mh);
-        e === yy ? (t = ei(), t.value = t.value === "true", n = Ld(t)) : e === by ? (t = ei(), t.value = null, n = Ld(t)) : ot("/") || ot("/=") ? (n = Ld(aae()), dL()) : xy(ei());
+        e === yy ? (t = ei(), t.value = t.value === "true", n = Ld(t)) : e === by ? (t = ei(), t.value = null, n = Ld(t)) : at("/") || at("/=") ? (n = Ld(aae()), dL()) : xy(ei());
     }
     return n;
 }
 
 function xae() {
     const e = [];
-    if (En("("), !ot(")"))
-        for (; j < _n && (e.push(Xu()), !ot(")"));)
-            En(",");
-    return En(")"), e;
+    if (Sn("("), !at(")"))
+        for (; q < En && (e.push(Xu()), !at(")"));)
+            Sn(",");
+    return Sn(")"), e;
 }
 
 function wae() {
-    j = Xe.start;
+    q = Xe.start;
     const e = ei();
     return uae(e) || xy(e), j3(e.value);
 }
 
 function _ae() {
-    return En("."), wae();
+    return Sn("."), wae();
 }
 
 function Eae() {
-    En("[");
+    Sn("[");
     const e = q3();
-    return En("]"), e;
+    return Sn("]"), e;
 }
 
 function Sae() {
     var e, t, n;
     for (e = vae();;)
-        if (ot("."))
-            n = _ae(), e = VC(".", e, n);
-        else if (ot("("))
+        if (at("."))
+            n = _ae(), e = V$(".", e, n);
+        else if (at("("))
         t = xae(), e = cae(e, t);
-    else if (ot("["))
-        n = Eae(), e = VC("[", e, n);
+    else if (at("["))
+        n = Eae(), e = V$("[", e, n);
     else
         break;
     return e;
 }
 
-function KC() {
+function K$() {
     const e = Sae();
-    if (Xe.type === Jn && (ot("++") || ot("--")))
+    if (Xe.type === Jn && (at("++") || at("--")))
         throw new Error(Mh);
     return e;
 }
 
 function hm() {
     var e, t;
     if (Xe.type !== Jn && Xe.type !== Pa)
-        t = KC();
+        t = K$();
     else {
-        if (ot("++") || ot("--"))
+        if (at("++") || at("--"))
             throw new Error(Mh);
-        if (ot("+") || ot("-") || ot("~") || ot("!"))
+        if (at("+") || at("-") || at("~") || at("!"))
             e = ei(), t = hm(), t = hae(e.value, t);
         else {
             if (Iv("delete") || Iv("void") || Iv("typeof"))
                 throw new Error(Mh);
-            t = KC();
+            t = K$();
         }
     }
     return t;
 }
 
-function JC(e) {
+function J$(e) {
     let t = 0;
     if (e.type !== Jn && e.type !== Pa)
         return 0;
     switch (e.value) {
         case "||":
             t = 1;
             break;
@@ -28491,41 +28478,41 @@
             break;
     }
     return t;
 }
 
 function kae() {
     var e, t, n, i, r, s, o, a, u, l;
-    if (e = Xe, u = hm(), i = Xe, r = JC(i), r === 0)
+    if (e = Xe, u = hm(), i = Xe, r = J$(i), r === 0)
         return u;
     for (i.prec = r, ei(), t = [e, Xe], o = hm(), s = [u, i, o];
-        (r = JC(Xe)) > 0;) {
+        (r = J$(Xe)) > 0;) {
         for (; s.length > 2 && r <= s[s.length - 2].prec;)
-            o = s.pop(), a = s.pop().value, u = s.pop(), t.pop(), n = GC(a, u, o), s.push(n);
+            o = s.pop(), a = s.pop().value, u = s.pop(), t.pop(), n = G$(a, u, o), s.push(n);
         i = ei(), i.prec = r, s.push(i), t.push(Xe), n = hm(), s.push(n);
     }
     for (l = s.length - 1, n = s[l], t.pop(); l > 1;)
-        t.pop(), n = GC(s[l - 1].value, s[l - 2], n), l -= 2;
+        t.pop(), n = G$(s[l - 1].value, s[l - 2], n), l -= 2;
     return n;
 }
 
 function Xu() {
     var e, t, n;
-    return e = kae(), ot("?") && (ei(), t = Xu(), En(":"), n = Xu(), e = fae(e, t, n)), e;
+    return e = kae(), at("?") && (ei(), t = Xu(), Sn(":"), n = Xu(), e = fae(e, t, n)), e;
 }
 
 function q3() {
     const e = Xu();
-    if (ot(","))
+    if (at(","))
         throw new Error(Mh);
     return e;
 }
 
 function W3(e) {
-    le = e, j = 0, _n = le.length, Xe = null, dL();
+    ce = e, q = 0, En = ce.length, Xe = null, dL();
     const t = q3();
     if (Xe.type !== _g)
         throw new Error("Unexpect token after expression.");
     return t;
 }
 var hL = {
     NaN: "NaN",
@@ -28573,15 +28560,15 @@
         pow: "Math.pow",
         random: "Math.random",
         round: "Math.round",
         sin: "Math.sin",
         sqrt: "Math.sqrt",
         tan: "Math.tan",
         clamp: function(o) {
-            o.length < 3 && q("Missing arguments to clamp function."), o.length > 3 && q("Too many arguments to clamp function.");
+            o.length < 3 && W("Missing arguments to clamp function."), o.length > 3 && W("Too many arguments to clamp function.");
             const a = o.map(e);
             return "Math.max(" + a[1] + ", Math.min(" + a[2] + "," + a[0] + "))";
         },
         // DATE functions
         now: "Date.now",
         utc: "Date.UTC",
         datetime: i,
@@ -28614,15 +28601,15 @@
         split: n("split", r),
         trim: n("trim", r, 0),
         // REGEXP functions
         regexp: s,
         test: n("test", s),
         // Control Flow functions
         if: function(o) {
-            o.length < 3 && q("Missing arguments to if function."), o.length > 3 && q("Too many arguments to if function.");
+            o.length < 3 && W("Missing arguments to if function."), o.length > 3 && W("Too many arguments to if function.");
             const a = o.map(e);
             return "(" + a[0] + "?" + a[1] + ":" + a[2] + ")";
         }
     };
 }
 
 function Aae(e) {
@@ -28640,38 +28627,38 @@
         o = e.fieldvar,
         a = Me(s) ? s : (g) => `${s}["${g}"]`;
     let u = {},
         l = {},
         c = 0;
 
     function f(g) {
-        if (ie(g))
+        if (se(g))
             return g;
         const p = d[g.type];
-        return p == null && q("Unsupported type: " + g.type), p(g);
+        return p == null && W("Unsupported type: " + g.type), p(g);
     }
     const d = {
         Literal: (g) => g.raw,
         Identifier: (g) => {
             const p = g.name;
-            return c > 0 ? p : be(n, p) ? q("Illegal identifier: " + p) : be(i, p) ? i[p] : be(t, p) ? p : (u[p] = 1, a(p));
+            return c > 0 ? p : xe(n, p) ? W("Illegal identifier: " + p) : xe(i, p) ? i[p] : xe(t, p) ? p : (u[p] = 1, a(p));
         },
         MemberExpression: (g) => {
             const p = !g.computed,
                 m = f(g.object);
             p && (c += 1);
             const y = f(g.property);
             return m === o && (l[Aae(y)] = 1), p && (c -= 1), m + (p ? "." + y : "[" + y + "]");
         },
         CallExpression: (g) => {
-            g.callee.type !== "Identifier" && q("Illegal callee type: " + g.callee.type);
+            g.callee.type !== "Identifier" && W("Illegal callee type: " + g.callee.type);
             const p = g.callee.name,
                 m = g.arguments,
-                y = be(r, p) && r[p];
-            return y || q("Unrecognized function: " + p), Me(y) ? y(m) : y + "(" + m.map(f).join(",") + ")";
+                y = xe(r, p) && r[p];
+            return y || W("Unrecognized function: " + p), Me(y) ? y(m) : y + "(" + m.map(f).join(",") + ")";
         },
         ArrayExpression: (g) => "[" + g.elements.map(f).join(",") + "]",
         BinaryExpression: (g) => "(" + f(g.left) + " " + g.operator + " " + f(g.right) + ")",
         UnaryExpression: (g) => "(" + g.operator + f(g.argument) + ")",
         ConditionalExpression: (g) => "(" + f(g.test) + "?" + f(g.consequent) + ":" + f(g.alternate) + ")",
         LogicalExpression: (g) => "(" + f(g.left) + g.operator + f(g.right) + ")",
         ObjectExpression: (g) => "{" + g.properties.map(f).join(",") + "}",
@@ -28688,38 +28675,38 @@
             globals: Object.keys(u),
             fields: Object.keys(l)
         };
         return u = {}, l = {}, p;
     }
     return h.functions = r, h.constants = i, h;
 }
-const QC = Symbol("vega_selection_getter");
+const Q$ = Symbol("vega_selection_getter");
 
 function mL(e) {
-    return (!e.getter || !e.getter[QC]) && (e.getter = Ki(e.field), e.getter[QC] = !0), e.getter;
+    return (!e.getter || !e.getter[Q$]) && (e.getter = Ki(e.field), e.getter[Q$] = !0), e.getter;
 }
 const H3 = "intersect",
-    ZC = "union",
-    $ae = "vlMulti",
-    Cae = "vlPoint",
+    Z$ = "union",
+    Cae = "vlMulti",
+    $ae = "vlPoint",
     e8 = "or",
     Mae = "and",
     Zr = "_vgsid_",
     Fh = Ki(Zr),
     Tae = "E",
     Fae = "R",
     Nae = "R-E",
     Oae = "R-LE",
     Dae = "R-RE",
     R0 = "index:unit";
 
 function t8(e, t) {
     for (var n = t.fields, i = t.values, r = n.length, s = 0, o, a; s < r; ++s)
-        if (a = n[s], o = mL(a)(e), na(o) && (o = dn(o)), na(i[s]) && (i[s] = dn(i[s])), W(i[s]) && na(i[s][0]) && (i[s] = i[s].map(dn)), a.type === Tae) {
-            if (W(i[s]) ? i[s].indexOf(o) < 0 : o !== i[s])
+        if (a = n[s], o = mL(a)(e), na(o) && (o = hn(o)), na(i[s]) && (i[s] = hn(i[s])), V(i[s]) && na(i[s][0]) && (i[s] = i[s].map(hn)), a.type === Tae) {
+            if (V(i[s]) ? i[s].indexOf(o) < 0 : o !== i[s])
                 return !1;
         } else if (a.type === Fae) {
         if (!ic(o, i[s]))
             return !1;
     } else if (a.type === Dae) {
         if (!ic(o, i[s], !0, !1))
             return !1;
@@ -28763,36 +28750,36 @@
         if (Iae(r, a) - u < s.size)
             return !1;
     }
     return !0;
 }
 
 function zae(e, t) {
-    return e.map((n) => Ce(t.fields ? {
+    return e.map((n) => $e(t.fields ? {
         values: t.fields.map((i) => mL(i)(n.datum))
     } : {
         [Zr]: Fh(n.datum)
     }, t));
 }
 
 function Bae(e, t, n, i) {
-    for (var r = this.context.data[e], s = r ? r.values.value : [], o = {}, a = {}, u = {}, l, c, f, d, h, g, p, m, y, b, v = s.length, x = 0, w, S; x < v; ++x)
+    for (var r = this.context.data[e], s = r ? r.values.value : [], o = {}, a = {}, u = {}, l, c, f, d, h, g, p, m, y, b, v = s.length, x = 0, w, E; x < v; ++x)
         if (l = s[x], d = l.unit, c = l.fields, f = l.values, c && f) {
-            for (w = 0, S = c.length; w < S; ++w)
-                h = c[w], p = o[h.field] || (o[h.field] = {}), m = p[d] || (p[d] = []), u[h.field] = y = h.type.charAt(0), b = Pv[`${y}_union`], p[d] = b(m, ne(f[w]));
-            n && (m = a[d] || (a[d] = []), m.push(ne(f).reduce((_, k, A) => (_[c[A].field] = k, _), {})));
+            for (w = 0, E = c.length; w < E; ++w)
+                h = c[w], p = o[h.field] || (o[h.field] = {}), m = p[d] || (p[d] = []), u[h.field] = y = h.type.charAt(0), b = Pv[`${y}_union`], p[d] = b(m, re(f[w]));
+            n && (m = a[d] || (a[d] = []), m.push(re(f).reduce((_, k, A) => (_[c[A].field] = k, _), {})));
         } else
             h = Zr, g = Fh(l), p = o[h] || (o[h] = {}), m = p[d] || (p[d] = []), m.push(g), n && (m = a[d] || (a[d] = []), m.push({
                 [Zr]: g
             }));
-    if (t = t || ZC, o[Zr] ? o[Zr] = Pv[`${Zr}_${t}`](...Object.values(o[Zr])) : Object.keys(o).forEach((_) => {
+    if (t = t || Z$, o[Zr] ? o[Zr] = Pv[`${Zr}_${t}`](...Object.values(o[Zr])) : Object.keys(o).forEach((_) => {
             o[_] = Object.keys(o[_]).map((k) => o[_][k]).reduce((k, A) => k === void 0 ? A : Pv[`${u[_]}_${t}`](k, A));
         }), s = Object.keys(a), n && s.length) {
-        const _ = i ? Cae : $ae;
-        o[_] = t === ZC ? {
+        const _ = i ? $ae : Cae;
+        o[_] = t === Z$ ? {
             [e8]: s.reduce((k, A) => (k.push(...a[A]), k), [])
         } : {
             [Mae]: s.map((k) => ({
                 [e8]: a[k]
             }))
         };
     }
@@ -28808,35 +28795,35 @@
             e.indexOf(t[n]) < 0 && e.push(t[n]);
         return e;
     },
     E_intersect: function(e, t) {
         return e.length ? e.filter((n) => t.indexOf(n) >= 0) : t;
     },
     R_union: function(e, t) {
-        var n = dn(t[0]),
-            i = dn(t[1]);
+        var n = hn(t[0]),
+            i = hn(t[1]);
         return n > i && (n = t[1], i = t[0]), e.length ? (e[0] > n && (e[0] = n), e[1] < i && (e[1] = i), e) : [n, i];
     },
     R_intersect: function(e, t) {
-        var n = dn(t[0]),
-            i = dn(t[1]);
+        var n = hn(t[0]),
+            i = hn(t[1]);
         return n > i && (n = t[1], i = t[0]), e.length ? i < e[0] || e[1] < n ? [] : (e[0] < n && (e[0] = n), e[1] > i && (e[1] = i), e) : [n, i];
     }
 };
 const Uae = ":",
     jae = "@";
 
 function G3(e, t, n, i) {
-    t[0].type !== Vu && q("First argument to selection functions must be a string literal.");
+    t[0].type !== Vu && W("First argument to selection functions must be a string literal.");
     const r = t[0].value,
         s = t.length >= 2 && Ie(t).value,
         o = "unit",
         a = jae + o,
         u = Uae + r;
-    s === H3 && !be(i, a) && (i[a] = n.getData(r).indataRef(n, o)), be(i, u) || (i[u] = n.getData(r).tuplesRef());
+    s === H3 && !xe(i, a) && (i[a] = n.getData(r).indataRef(n, o)), xe(i, u) || (i[u] = n.getData(r).tuplesRef());
 }
 
 function bL(e) {
     const t = this.context.data[e];
     return t ? t.values.value : [];
 }
 
@@ -28892,59 +28879,59 @@
 }
 const eue = ":",
     tue = "@",
     aw = "%",
     xL = "$";
 
 function V3(e, t, n, i) {
-    t[0].type !== Vu && q("First argument to data functions must be a string literal.");
+    t[0].type !== Vu && W("First argument to data functions must be a string literal.");
     const r = t[0].value,
         s = eue + r;
-    if (!be(s, i))
+    if (!xe(s, i))
         try {
             i[s] = n.getData(r).tuplesRef();
         } catch {}
 }
 
 function nue(e, t, n, i) {
-    t[0].type !== Vu && q("First argument to indata must be a string literal."), t[1].type !== Vu && q("Second argument to indata must be a string literal.");
+    t[0].type !== Vu && W("First argument to indata must be a string literal."), t[1].type !== Vu && W("Second argument to indata must be a string literal.");
     const r = t[0].value,
         s = t[1].value,
         o = tue + s;
-    be(o, i) || (i[o] = n.getData(r).indataRef(n, s));
+    xe(o, i) || (i[o] = n.getData(r).indataRef(n, s));
 }
 
-function Pn(e, t, n, i) {
+function zn(e, t, n, i) {
     if (t[0].type === Vu)
         n8(n, i, t[0].value);
     else
         for (e in n.scales)
             n8(n, i, e);
 }
 
 function n8(e, t, n) {
     const i = aw + n;
-    if (!be(t, i))
+    if (!xe(t, i))
         try {
             t[i] = e.scaleRef(n);
         } catch {}
 }
 
 function Ts(e, t) {
     if (Me(e))
         return e;
-    if (ie(e)) {
+    if (se(e)) {
         const n = t.scales[e];
         return n && kJ(n.value) ? n.value : void 0;
     }
 }
 
 function iue(e, t, n) {
-    t.__bandwidth = (r) => r && r.bandwidth ? r.bandwidth() : 0, n._bandwidth = Pn, n._range = Pn, n._scale = Pn;
-    const i = (r) => "_[" + (r.type === Vu ? Z(aw + r.value) : Z(aw) + "+" + e(r)) + "]";
+    t.__bandwidth = (r) => r && r.bandwidth ? r.bandwidth() : 0, n._bandwidth = zn, n._range = zn, n._scale = zn;
+    const i = (r) => "_[" + (r.type === Vu ? ee(aw + r.value) : ee(aw) + "+" + e(r)) + "]";
     return {
         _bandwidth: (r) => `this.__bandwidth(${i(r[0])})`,
         _range: (r) => `${i(r[0])}.range()`,
         _scale: (r) => `${i(r[0])}(${e(r[1])})`
     };
 }
 
@@ -29020,19 +29007,19 @@
         r = Math.max(n, i),
         s = Math.min(n, i);
     return (r + 0.05) / (s + 0.05);
 }
 
 function hue() {
     const e = [].slice.call(arguments);
-    return e.unshift({}), Ce(...e);
+    return e.unshift({}), $e(...e);
 }
 
 function wL(e, t) {
-    return e === t || e !== e && t !== t ? !0 : W(e) ? W(t) && e.length === t.length ? gue(e, t) : !1 : re(e) && re(t) ? _L(e, t) : !1;
+    return e === t || e !== e && t !== t ? !0 : V(e) ? V(t) && e.length === t.length ? gue(e, t) : !1 : oe(e) && oe(t) ? _L(e, t) : !1;
 }
 
 function gue(e, t) {
     for (let n = 0, i = e.length; n < i; ++n)
         if (!wL(e[n], t[n]))
             return !1;
     return !0;
@@ -29056,15 +29043,15 @@
         l = o.stamp();
     let c = a.changes,
         f, d;
     if (o._trigger === !1 || !(u.value.length || t || i))
         return 0;
     if ((!c || c.stamp < l) && (a.changes = c = o.changeset(), c.stamp = l, o.runAfter(() => {
             a.modified = !0, o.pulse(u, c).run();
-        }, !0, 1)), n && (f = n === !0 ? Ji : W(n) || w1(n) ? n : i8(n), c.remove(f)), t && c.insert(t), i && (f = i8(i), u.value.some(f) ? c.remove(f) : c.insert(i)), r)
+        }, !0, 1)), n && (f = n === !0 ? Ji : V(n) || w1(n) ? n : i8(n), c.remove(f)), t && c.insert(t), i && (f = i8(i), u.value.some(f) ? c.remove(f) : c.insert(i)), r)
         for (d in s)
             c.modify(r, d, s[d]);
     return 1;
 }
 
 function mue(e) {
     const t = e.touches,
@@ -29077,23 +29064,23 @@
     const t = e.touches;
     return Math.atan2(t[0].clientY - t[1].clientY, t[0].clientX - t[1].clientX);
 }
 const r8 = {};
 
 function bue(e, t) {
     const n = r8[t] || (r8[t] = Ki(t));
-    return W(e) ? e.map(n) : n(e);
+    return V(e) ? e.map(n) : n(e);
 }
 
 function K3(e) {
-    return W(e) || ArrayBuffer.isView(e) ? e : null;
+    return V(e) || ArrayBuffer.isView(e) ? e : null;
 }
 
 function J3(e) {
-    return K3(e) || (ie(e) ? e : null);
+    return K3(e) || (se(e) ? e : null);
 }
 
 function vue(e) {
     for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
         n[i - 1] = arguments[i];
     return K3(e).join(...n);
 }
@@ -29113,15 +29100,15 @@
 function _ue(e) {
     for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
         n[i - 1] = arguments[i];
     return J3(e).slice(...n);
 }
 
 function Eue(e, t, n) {
-    return Me(n) && q("Function argument passed to replace."), String(e).replace(t, n);
+    return Me(n) && W("Function argument passed to replace."), String(e).replace(t, n);
 }
 
 function Sue(e) {
     return K3(e).slice().reverse();
 }
 
 function kue(e, t, n) {
@@ -29129,27 +29116,27 @@
 }
 
 function Aue(e, t) {
     const n = Ts(e, (t || this).context);
     return n && n.bandwidth ? n.bandwidth() : 0;
 }
 
-function $ue(e, t) {
+function Cue(e, t) {
     const n = Ts(e, (t || this).context);
     return n ? n.copy() : void 0;
 }
 
-function Cue(e, t) {
+function $ue(e, t) {
     const n = Ts(e, (t || this).context);
     return n ? n.domain() : [];
 }
 
 function Mue(e, t, n) {
     const i = Ts(e, (n || this).context);
-    return i ? W(t) ? (i.invertRange || i.invert)(t) : (i.invert || i.invertExtent)(t) : void 0;
+    return i ? V(t) ? (i.invertRange || i.invert)(t) : (i.invert || i.invertExtent)(t) : void 0;
 }
 
 function Tue(e, t) {
     const n = Ts(e, (t || this).context);
     return n && n.range ? n.range() : [];
 }
 
@@ -29160,15 +29147,15 @@
 
 function Nue(e, t, n, i, r) {
     e = Ts(e, (r || this).context);
     const s = lO(t, n);
     let o = e.domain(),
         a = o[0],
         u = Ie(o),
-        l = Sn;
+        l = kn;
     return u - a ? l = JN(e, a, u) : e = (e.interpolator ? qe("sequential")().interpolator(e.interpolator()) : qe("linear")().interpolate(e.interpolate()).range(e.range())).domain([a = 0, u = 1]), e.ticks && (o = e.ticks(+i || 15), a !== o[0] && o.unshift(a), u !== Ie(o) && o.push(u)), o.forEach((c) => s.stop(l(c), e(c))), s;
 }
 
 function Oue(e, t, n) {
     const i = Ts(e, (n || this).context);
     return function(r) {
         return i ? i.path.context(r)(t) : "";
@@ -29223,30 +29210,30 @@
     const [i, r] = e, s = new $t().set(i[0], i[1], r[0], r[1]), o = n || this.context.dataflow.scenegraph().root;
     return nD(o, s, Bue(t));
 }
 
 function Bue(e) {
     let t = null;
     if (e) {
-        const n = ne(e.marktype),
-            i = ne(e.markname);
+        const n = re(e.marktype),
+            i = re(e.markname);
         t = (r) => (!n.length || n.some((s) => r.marktype === s)) && (!i.length || i.some((s) => r.name === s));
     }
     return t;
 }
 
 function Uue(e, t, n) {
     let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 5;
-    e = ne(e);
+    e = re(e);
     const r = e[e.length - 1];
     return r === void 0 || Math.hypot(r[0] - t, r[1] - n) > i ? [...e, [t, n]] : e;
 }
 
 function jue(e) {
-    return ne(e).reduce((t, n, i) => {
+    return re(e).reduce((t, n, i) => {
         let [r, s] = n;
         return t += i == 0 ? `M ${r},${s} ` : i === e.length - 1 ? " Z" : `L ${r},${s} `;
     }, "");
 }
 
 function que(e, t, n) {
     const {
@@ -29277,40 +29264,40 @@
         // override default
         cumulativeNormal: A1,
         cumulativeLogNormal: Z_,
         cumulativeUniform: iE,
         densityNormal: Y_,
         densityLogNormal: Q_,
         densityUniform: nE,
-        quantileNormal: $1,
+        quantileNormal: C1,
         quantileLogNormal: eE,
         quantileUniform: rE,
         sampleNormal: k1,
         sampleLogNormal: J_,
         sampleUniform: tE,
-        isArray: W,
+        isArray: V,
         isBoolean: Oa,
         isDate: na,
         isDefined(e) {
             return e !== void 0;
         },
         isNumber: ze,
-        isObject: re,
+        isObject: oe,
         isRegExp: aM,
-        isString: ie,
+        isString: se,
         isTuple: w1,
         isValid(e) {
             return e != null && e === e;
         },
-        toBoolean: $_,
+        toBoolean: C_,
         toDate(e) {
-            return C_(e);
+            return $_(e);
         },
         // suppress extra arguments
-        toNumber: dn,
+        toNumber: hn,
         toString: M_,
         indexof: xue,
         join: vue,
         lastindexof: wue,
         replace: Eue,
         reverse: Sue,
         slice: _ue,
@@ -29325,15 +29312,15 @@
         truncate: dM,
         rgb: nr,
         lab: Wm,
         hcl: Hm,
         hsl: jm,
         luminance: uw,
         contrast: due,
-        sequence: hn,
+        sequence: gn,
         format: Gae,
         utcFormat: Vae,
         utcParse: Xae,
         utcOffset: nT,
         utcSequence: sT,
         timeFormat: vL,
         timeParse: Yae,
@@ -29370,90 +29357,90 @@
         pathShape: Due,
         panLinear: J9,
         panLog: Q9,
         panPow: Z9,
         panSymlog: eM,
         zoomLinear: w_,
         zoomLog: __,
-        zoomPow: Cm,
+        zoomPow: $m,
         zoomSymlog: E_,
         encode: Hae,
         modify: pue,
         lassoAppend: Uue,
         lassoPath: jue,
         intersectLasso: que
     },
     Hue = ["view", "item", "group", "xy", "x", "y"],
     Gue = "event.vega.",
-    $L = "this.",
+    CL = "this.",
     Q3 = {},
-    CL = {
+    $L = {
         forbidden: ["_"],
         allowed: ["datum", "event", "item"],
         fieldvar: "datum",
-        globalvar: (e) => `_[${Z(xL + e)}]`,
+        globalvar: (e) => `_[${ee(xL + e)}]`,
         functions: Vue,
         constants: hL,
         visitors: Q3
     },
-    lw = pL(CL);
+    lw = pL($L);
 
 function Vue(e) {
     const t = gL(e);
     Hue.forEach((n) => t[n] = Gue + n);
     for (const n in Nh)
-        t[n] = $L + n;
-    return Ce(t, iue(e, Nh, Q3)), t;
+        t[n] = CL + n;
+    return $e(t, iue(e, Nh, Q3)), t;
 }
 
-function At(e, t, n) {
-    return arguments.length === 1 ? Nh[e] : (Nh[e] = t, n && (Q3[e] = n), lw && (lw.functions[e] = $L + e), this);
+function Ct(e, t, n) {
+    return arguments.length === 1 ? Nh[e] : (Nh[e] = t, n && (Q3[e] = n), lw && (lw.functions[e] = CL + e), this);
 }
-At("bandwidth", Aue, Pn);
-At("copy", $ue, Pn);
-At("domain", Cue, Pn);
-At("range", Tue, Pn);
-At("invert", Mue, Pn);
-At("scale", Fue, Pn);
-At("gradient", Nue, Pn);
-At("geoArea", rue, Pn);
-At("geoBounds", sue, Pn);
-At("geoCentroid", oue, Pn);
-At("geoShape", Oue, Pn);
-At("geoScale", aue, Pn);
-At("indata", qae, nue);
-At("data", bL, V3);
-At("treePath", Rue, V3);
-At("treeAncestors", Lue, V3);
-At("vlSelectionTest", Rae, G3);
-At("vlSelectionIdTest", Pae, G3);
-At("vlSelectionResolve", Bae, G3);
-At("vlSelectionTuples", zae);
+Ct("bandwidth", Aue, zn);
+Ct("copy", Cue, zn);
+Ct("domain", $ue, zn);
+Ct("range", Tue, zn);
+Ct("invert", Mue, zn);
+Ct("scale", Fue, zn);
+Ct("gradient", Nue, zn);
+Ct("geoArea", rue, zn);
+Ct("geoBounds", sue, zn);
+Ct("geoCentroid", oue, zn);
+Ct("geoShape", Oue, zn);
+Ct("geoScale", aue, zn);
+Ct("indata", qae, nue);
+Ct("data", bL, V3);
+Ct("treePath", Rue, V3);
+Ct("treeAncestors", Lue, V3);
+Ct("vlSelectionTest", Rae, G3);
+Ct("vlSelectionIdTest", Pae, G3);
+Ct("vlSelectionResolve", Bae, G3);
+Ct("vlSelectionTuples", zae);
 
 function bs(e, t) {
     const n = {};
     let i;
     try {
-        e = ie(e) ? e : Z(e) + "", i = W3(e);
+        e = se(e) ? e : ee(e) + "", i = W3(e);
     } catch {
-        q("Expression parse error: " + e);
+        W("Expression parse error: " + e);
     }
     i.visit((s) => {
         if (s.type !== oL)
             return;
         const o = s.callee.name,
-            a = CL.visitors[o];
+            a = $L.visitors[o];
         a && a(o, s.arguments, t, n);
     });
     const r = lw(i);
     return r.globals.forEach((s) => {
         const o = xL + s;
-        !be(n, o) && t.getSignal(s) && (n[o] = t.signalRef(s));
+        !xe(n, o) && t.getSignal(s) && (n[o] = t.signalRef(s));
     }), {
-        $expr: Ce({
+        $expr: $e({
             code: r.code
         }, t.options.ast ? {
             ast: i
         } : null),
         $fields: r.fields,
         $params: n
     };
@@ -29522,25 +29509,25 @@
     encode: (e, t) => {
         const {
             marktype: n,
             channels: i
         } = t;
         let r = "var o=item,datum=o.datum,m=0,$;";
         for (const s in i) {
-            const o = "o[" + Z(s) + "]";
+            const o = "o[" + ee(s) + "]";
             r += `$=${i[s].code};if(${o}!==$)${o}=$,m=1;`;
         }
         return r += Kue(i, n), r += "return m;", nd(e, ["item", "_"], r);
     },
     /**
      * Optimized code generators for access and comparison.
      */
     codegen: {
         get(e) {
-            const t = `[${e.map(Z).join("][")}]`,
+            const t = `[${e.map(ee).join("][")}]`,
                 n = Function("_", `return _${t};`);
             return n.path = t, n;
         },
         comparator(e, t) {
             let n;
             const i = (s, o) => {
                     const a = t[o];
@@ -29558,33 +29545,33 @@
     Jue(e.type) || !e.type ? t.operator(e, e.update ? t.operatorExpression(e.update) : null) : t.transform(e, e.type);
 }
 
 function nle(e) {
     const t = this;
     if (e.params) {
         const n = t.get(e.id);
-        n || q("Invalid operator id: " + e.id), t.dataflow.connect(n, n.parameters(t.parseParameters(e.params), e.react, e.initonly));
+        n || W("Invalid operator id: " + e.id), t.dataflow.connect(n, n.parameters(t.parseParameters(e.params), e.react, e.initonly));
     }
 }
 
 function ile(e, t) {
     t = t || {};
     const n = this;
     for (const i in e) {
         const r = e[i];
-        t[i] = W(r) ? r.map((s) => o8(s, n, t)) : o8(r, n, t);
+        t[i] = V(r) ? r.map((s) => o8(s, n, t)) : o8(r, n, t);
     }
     return t;
 }
 
 function o8(e, t, n) {
-    if (!e || !re(e))
+    if (!e || !oe(e))
         return e;
     for (let i = 0, r = a8.length, s; i < r; ++i)
-        if (s = a8[i], be(e, s.key))
+        if (s = a8[i], xe(e, s.key))
             return s.parse(e, t, n);
     return e;
 }
 var a8 = [{
     key: "$ref",
     parse: rle
 }, {
@@ -29610,15 +29597,15 @@
     parse: fle
 }, {
     key: "$tupleid",
     parse: dle
 }];
 
 function rle(e, t) {
-    return t.get(e.$ref) || q("Operator not defined: " + e.$ref);
+    return t.get(e.$ref) || W("Operator not defined: " + e.$ref);
 }
 
 function sle(e, t, n) {
     e.$params && t.parseParameters(e.$params, n);
     const i = "e:" + e.$expr.code;
     return t.fn[i] || (t.fn[i] = hi(t.parameterExpression(e.$expr), e.$fields));
 }
@@ -29633,15 +29620,15 @@
         return null;
     const n = "f:" + e.$field + "_" + e.$name;
     return t.fn[n] || (t.fn[n] = Ki(e.$field, e.$name, t.expr.codegen));
 }
 
 function ule(e, t) {
     const n = "c:" + e.$compare + "_" + e.$order,
-        i = ne(e.$compare).map((r) => r && r.$tupleid ? me : r);
+        i = re(e.$compare).map((r) => r && r.$tupleid ? be : r);
     return t.fn[n] || (t.fn[n] = S_(i, e.$order, t.expr.codegen));
 }
 
 function lle(e, t) {
     const n = e.$encode,
         i = {};
     for (const r in n) {
@@ -29662,33 +29649,33 @@
             a = o.get(n.operators[0].id),
             u = o.signals.parent;
         return u && u.set(s), a.detachSubflow = () => t.detach(o), a;
     };
 }
 
 function dle() {
-    return me;
+    return be;
 }
 
 function hle(e) {
     var t = this,
         n = e.filter != null ? t.eventExpression(e.filter) : void 0,
         i = e.stream != null ? t.get(e.stream) : void 0,
         r;
-    e.source ? i = t.events(e.source, e.type, n) : e.merge && (r = e.merge.map((s) => t.get(s)), i = r[0].merge.apply(r[0], r.slice(1))), e.between && (r = e.between.map((s) => t.get(s)), i = i.between(r[0], r[1])), e.filter && (i = i.filter(n)), e.throttle != null && (i = i.throttle(+e.throttle)), e.debounce != null && (i = i.debounce(+e.debounce)), i == null && q("Invalid stream definition: " + JSON.stringify(e)), e.consume && i.consume(!0), t.stream(e, i);
+    e.source ? i = t.events(e.source, e.type, n) : e.merge && (r = e.merge.map((s) => t.get(s)), i = r[0].merge.apply(r[0], r.slice(1))), e.between && (r = e.between.map((s) => t.get(s)), i = i.between(r[0], r[1])), e.filter && (i = i.filter(n)), e.throttle != null && (i = i.throttle(+e.throttle)), e.debounce != null && (i = i.debounce(+e.debounce)), i == null && W("Invalid stream definition: " + JSON.stringify(e)), e.consume && i.consume(!0), t.stream(e, i);
 }
 
 function gle(e) {
     var t = this,
-        n = re(n = e.source) ? n.$ref : n,
+        n = oe(n = e.source) ? n.$ref : n,
         i = t.get(n),
         r = null,
         s = e.update,
         o = void 0;
-    i || q("Source not defined: " + e.source), r = e.target && e.target.$expr ? t.eventExpression(e.target.$expr) : t.get(e.target), s && s.$expr && (s.$params && (o = t.parseParameters(s.$params)), s = t.handlerExpression(s.$expr)), t.update(e, i, r, s, o);
+    i || W("Source not defined: " + e.source), r = e.target && e.target.$expr ? t.eventExpression(e.target.$expr) : t.get(e.target), s && s.$expr && (s.$params && (o = t.parseParameters(s.$params)), s = t.handlerExpression(s.$expr)), t.update(e, i, r, s, o);
 }
 const ple = {
     skip: !0
 };
 
 function mle(e) {
     var t = this,
@@ -29834,46 +29821,46 @@
 function xle(e) {
     const t = e._signals.cursor || (e._signals.cursor = e.add({
         user: Bv,
         item: null
     }));
     e.on(e.events("view", "pointermove"), t, (n, i) => {
         const r = t.value,
-            s = r ? ie(r) ? r : r.user : Bv,
+            s = r ? se(r) ? r : r.user : Bv,
             o = i.item && i.item.cursor || null;
         return r && s === r.user && o == r.item ? r : {
             user: s,
             item: o
         };
     }), e.add(null, function(n) {
         let i = n.cursor,
             r = this.value;
-        return ie(i) || (r = i.item, i = i.user), cw(e, i && i !== Bv ? i : r || i), r;
+        return se(i) || (r = i.item, i = i.user), cw(e, i && i !== Bv ? i : r || i), r;
     }, {
         cursor: t
     });
 }
 
 function cw(e, t) {
     const n = e.globalCursor() ? typeof document < "u" && document.body : e.container();
     if (n)
         return t == null ? n.style.removeProperty("cursor") : n.style.cursor = t;
 }
 
 function L0(e, t) {
     var n = e._runtime.data;
-    return be(n, t) || q("Unrecognized data set: " + t), n[t];
+    return xe(n, t) || W("Unrecognized data set: " + t), n[t];
 }
 
 function wle(e, t) {
     return arguments.length < 2 ? L0(this, e).values.value : _y.call(this, e, ml().remove(Ji).insert(t));
 }
 
 function _y(e, t) {
-    NT(t) || q("Second argument to changes must be a changeset.");
+    NT(t) || W("Second argument to changes must be a changeset.");
     const n = L0(this, e);
     return n.modified = !0, this.pulse(n.input, t);
 }
 
 function _le(e, t) {
     return _y.call(this, e, ml().insert(t));
 }
@@ -29933,82 +29920,82 @@
         }
         return a && a.mark && a.mark.interactive ? a : {};
     }
 
     function s(o) {
         if (!o)
             return n;
-        ie(o) && (o = r(o));
+        se(o) && (o = r(o));
         const a = n.slice();
         for (; o;)
             a[0] -= o.x || 0, a[1] -= o.y || 0, o = o.mark && o.mark.group;
         return a;
     }
     return {
-        view: kn(e),
-        item: kn(t || {}),
+        view: An(e),
+        item: An(t || {}),
         group: r,
         xy: s,
         x: (o) => s(o)[0],
         y: (o) => s(o)[1]
     };
 }
 const l8 = "view",
-    $le = "timer",
-    Cle = "window",
+    Cle = "timer",
+    $le = "window",
     Mle = {
         trap: !1
     };
 
 function Tle(e) {
-    const t = Ce({
+    const t = $e({
             defaults: {}
         }, e),
         n = (i, r) => {
             r.forEach((s) => {
-                W(i[s]) && (i[s] = Fr(i[s]));
+                V(i[s]) && (i[s] = Fr(i[s]));
             });
         };
     return n(t.defaults, ["prevent", "allow"]), n(t, ["view", "window", "selector"]), t;
 }
 
 function DL(e, t, n, i) {
     e._eventListeners.push({
         type: n,
-        sources: ne(t),
+        sources: re(t),
         handler: i
     });
 }
 
 function Fle(e, t) {
     var n = e._eventConfig.defaults,
         i = n.prevent,
         r = n.allow;
     return i === !1 || r === !0 ? !1 : i === !0 || r === !1 ? !0 : i ? i[t] : r ? !r[t] : e.preventDefault();
 }
 
 function Sp(e, t, n) {
     const i = e._eventConfig && e._eventConfig[t];
-    return i === !1 || re(i) && !i[n] ? (e.warn(`Blocked ${t} ${n} event listener.`), !1) : !0;
+    return i === !1 || oe(i) && !i[n] ? (e.warn(`Blocked ${t} ${n} event listener.`), !1) : !0;
 }
 
 function Nle(e, t, n) {
     var i = this,
         r = new S1(n),
         s = function(l, c) {
             i.runAsync(null, () => {
                 e === l8 && Fle(i, t) && l.preventDefault(), r.receive(kle(i, l, c));
             });
         },
         o;
-    if (e === $le)
+    if (e === Cle)
         Sp(i, "timer", t) && i.timer(s, t);
     else if (e === l8)
         Sp(i, "view", t) && i.addEventListener(t, s, Mle);
-    else if (e === Cle ? Sp(i, "window", t) && typeof window < "u" && (o = [window]) : typeof document < "u" && Sp(i, "selector", t) && (o = Array.from(document.querySelectorAll(e))), !o)
+    else if (e === $le ? Sp(i, "window", t) && typeof window < "u" && (o = [window]) : typeof document < "u" && Sp(i, "selector", t) && (o = Array.from(document.querySelectorAll(e))), !o)
         i.warn("Can not resolve event source: " + e);
     else {
         for (var a = 0, u = o.length; a < u; ++a)
             o[a].addEventListener(t, s);
         DL(i, o, t, s);
     }
     return r;
@@ -30262,28 +30249,28 @@
         top: e,
         bottom: e,
         left: e,
         right: e
     });
 
 function h8(e) {
-    return re(e) ? {
+    return oe(e) ? {
         top: id(e.top),
         bottom: id(e.bottom),
         left: id(e.left),
         right: id(e.right)
     } : Xle(id(e));
 }
 async function t5(e, t, n, i) {
     const r = ly(t),
         s = r && r.headless;
-    return s || q("Unrecognized renderer type: " + t), await e.runAsync(), RL(e, null, null, s, n, i).renderAsync(e._scenegraph.root);
+    return s || W("Unrecognized renderer type: " + t), await e.runAsync(), RL(e, null, null, s, n, i).renderAsync(e._scenegraph.root);
 }
 async function Kle(e, t) {
-    e !== Yo.Canvas && e !== Yo.SVG && e !== Yo.PNG && q("Unrecognized image type: " + e);
+    e !== Yo.Canvas && e !== Yo.SVG && e !== Yo.PNG && W("Unrecognized image type: " + e);
     const n = await t5(this, e, t);
     return e === Yo.SVG ? Jle(n.svg(), "image/svg+xml") : n.canvas().toDataURL("image/png");
 }
 
 function Jle(e, t) {
     const n = new Blob([e], {
         type: t
@@ -30294,20 +30281,20 @@
     return (await t5(this, Yo.Canvas, e, t)).canvas();
 }
 async function Zle(e) {
     return (await t5(this, Yo.SVG, e)).svg();
 }
 
 function ece(e, t, n) {
-    return ML(e, Cc, Nh, n).parse(t);
+    return ML(e, $c, Nh, n).parse(t);
 }
 
 function tce(e) {
     var t = this._runtime.scales;
-    return be(t, e) || q("Unrecognized scale or projection: " + e), t[e].value;
+    return xe(t, e) || W("Unrecognized scale or projection: " + e), t[e].value;
 }
 var LL = "width",
     IL = "height",
     n5 = "padding",
     g8 = {
         skip: !0
     };
@@ -30360,19 +30347,19 @@
         data: sce,
         signals: oce,
         recurse: !0
     });
 }
 
 function sce(e, t) {
-    return t.modified && W(t.input.value) && !e.startsWith("_:vega:_");
+    return t.modified && V(t.input.value) && !e.startsWith("_:vega:_");
 }
 
 function oce(e, t) {
-    return !(e === "parent" || t instanceof Cc.proxy);
+    return !(e === "parent" || t instanceof $c.proxy);
 }
 
 function ace(e) {
     return this.runAsync(null, (t) => {
         t._trigger = !1, t._runtime.setState(e);
     }, (t) => {
         t._trigger = !0;
@@ -30391,31 +30378,31 @@
 
 function lce(e, t, n, i) {
     const r = e.element();
     r && r.setAttribute("title", cce(i));
 }
 
 function cce(e) {
-    return e == null ? "" : W(e) ? BL(e) : re(e) && !na(e) ? fce(e) : e + "";
+    return e == null ? "" : V(e) ? BL(e) : oe(e) && !na(e) ? fce(e) : e + "";
 }
 
 function fce(e) {
     return Object.keys(e).map((t) => {
         const n = e[t];
-        return t + ": " + (W(n) ? BL(n) : UL(n));
+        return t + ": " + (V(n) ? BL(n) : UL(n));
     }).join(`
 `);
 }
 
 function BL(e) {
     return "[" + e.map(UL).join(", ") + "]";
 }
 
 function UL(e) {
-    return W(e) ? "[…]" : re(e) && !na(e) ? "{…}" : e;
+    return V(e) ? "[…]" : oe(e) && !na(e) ? "{…}" : e;
 }
 
 function dce() {
     if (this.renderer() === "canvas" && this._renderer._canvas) {
         let e = null;
         const t = () => {
             e != null && e();
@@ -30427,29 +30414,29 @@
         t();
     }
 }
 
 function jL(e, t) {
     const n = this;
     if (t = t || {}, fc.call(n), t.loader && n.loader(t.loader), t.logger && n.logger(t.logger), t.logLevel != null && n.logLevel(t.logLevel), t.locale || e.locale) {
-        const s = Ce({}, e.locale, t.locale);
+        const s = $e({}, e.locale, t.locale);
         n.locale(_T(s.number, s.time));
     }
     n._el = null, n._elBind = null, n._renderType = t.renderer || Yo.Canvas, n._scenegraph = new OS();
     const i = n._scenegraph.root;
     n._renderer = null, n._tooltip = t.tooltip || lce, n._redraw = !0, n._handler = new Ea().scene(i), n._globalCursor = !1, n._preventDefault = !1, n._timers = [], n._eventListeners = [], n._resizeListeners = [], n._eventConfig = Tle(e.eventConfig), n.globalCursor(n._eventConfig.globalCursor);
     const r = ece(n, e, t.expr);
     n._runtime = r, n._signals = r.signals, n._bind = (e.bindings || []).map((s) => ({
         state: null,
-        param: Ce({}, s)
+        param: $e({}, s)
     })), r.root && r.root.set(i), i.source = r.data.root.input, n.pulse(r.data.root.input, n.changeset().insert(i.items)), n._width = n.width(), n._height = n.height(), n._viewWidth = PL(n, n._width), n._viewHeight = zL(n, n._height), n._origin = [0, 0], n._resize = 0, n._autosize = 1, nce(n), vle(n), xle(n), n.description(e.description), t.hover && n.hover(), t.container && n.initialize(t.container, t.bind), t.watchPixelRatio && n._watchPixelRatio();
 }
 
 function kp(e, t) {
-    return be(e._signals, t) ? e._signals[t] : q("Unrecognized signal name: " + Z(t));
+    return xe(e._signals, t) ? e._signals[t] : W("Unrecognized signal name: " + ee(t));
 }
 
 function qL(e, t) {
     const n = (e._targets || []).filter((i) => i._update && i._update.handler === t);
     return n.length ? n[0] : null;
 }
 
@@ -30458,15 +30445,15 @@
     return r || (r = e5(e, () => i(t, n.value)), r.handler = i, e.on(n, null, r)), e;
 }
 
 function m8(e, t, n) {
     const i = qL(t, n);
     return i && t._targets.remove(i), e;
 }
-Q(jL, fc, {
+Z(jL, fc, {
     // -- DATAFLOW / RENDERING ----
     async evaluate(e, t, n) {
         if (await fc.prototype.evaluate.call(this, e, t), this._redraw || this._resize)
             try {
                 this._renderer && (this._resize && (this._resize = 0, Sle(this)), await this._renderer.renderAsync(this._scenegraph.root)), this._redraw = !1;
             } catch (i) {
                 this.error(i);
@@ -30509,15 +30496,15 @@
     autosize(e) {
         return arguments.length ? this.signal("autosize", e) : this.signal("autosize");
     },
     background(e) {
         return arguments.length ? this.signal("background", e) : this.signal("background");
     },
     renderer(e) {
-        return arguments.length ? (ly(e) || q("Unrecognized renderer type: " + e), e !== this._renderType && (this._renderType = e, this._resetRenderer()), this) : this._renderType;
+        return arguments.length ? (ly(e) || W("Unrecognized renderer type: " + e), e !== this._renderType && (this._renderType = e, this._resetRenderer()), this) : this._renderType;
     },
     tooltip(e) {
         return arguments.length ? (e !== this._tooltip && (this._tooltip = e, this._resetRenderer()), this) : this._tooltip;
     },
     loader(e) {
         return arguments.length ? (e !== this._loader && (fc.prototype.loader.call(this, e), this._resetRenderer()), this) : this._loader;
     },
@@ -30730,66 +30717,66 @@
         if (i !== i)
             throw e;
         return i;
     });
 }
 
 function Ece(e) {
-    return re(e) ? e : {
+    return oe(e) ? e : {
         type: e || "pad"
     };
 }
 const rd = (e) => +e || 0,
     Sce = (e) => ({
         top: e,
         bottom: e,
         left: e,
         right: e
     });
 
 function kce(e) {
-    return re(e) ? e.signal ? e : {
+    return oe(e) ? e.signal ? e : {
         top: rd(e.top),
         bottom: rd(e.bottom),
         left: rd(e.left),
         right: rd(e.right)
     } : Sce(rd(e));
 }
-const jt = (e) => re(e) && !W(e) ? Ce({}, e) : {
+const qt = (e) => oe(e) && !V(e) ? $e({}, e) : {
     value: e
 };
 
 function y8(e, t, n, i) {
-    return n != null ? (re(n) && !W(n) || W(n) && n.length && re(n[0]) ? e.update[t] = n : e[i || "enter"][t] = {
+    return n != null ? (oe(n) && !V(n) || V(n) && n.length && oe(n[0]) ? e.update[t] = n : e[i || "enter"][t] = {
         value: n
     }, 1) : 0;
 }
 
-function rn(e, t, n) {
+function sn(e, t, n) {
     for (const i in t)
         y8(e, i, t[i]);
     for (const i in n)
         y8(e, i, n[i], "update");
 }
 
-function Cf(e, t, n) {
+function $f(e, t, n) {
     for (const i in t)
-        n && be(n, i) || (e[i] = Ce(e[i] || {}, t[i]));
+        n && xe(n, i) || (e[i] = $e(e[i] || {}, t[i]));
     return e;
 }
 
 function tc(e, t) {
     return t && (t.enter && t.enter[e] || t.update && t.update[e]);
 }
 const i5 = "mark",
     r5 = "frame",
     s5 = "scope",
     Ace = "axis",
-    $ce = "axis-domain",
-    Cce = "axis-grid",
+    Cce = "axis-domain",
+    $ce = "axis-grid",
     Mce = "axis-label",
     Tce = "axis-tick",
     Fce = "axis-title",
     Nce = "legend",
     Oce = "legend-band",
     Dce = "legend-entry",
     Rce = "legend-gradient",
@@ -30800,76 +30787,76 @@
     zce = "title-text",
     Bce = "title-subtitle";
 
 function Uce(e, t, n, i, r) {
     const s = {},
         o = {};
     let a, u, l, c;
-    u = "lineBreak", t === "text" && r[u] != null && !tc(u, e) && jv(s, u, r[u]), (n == "legend" || String(n).startsWith("axis")) && (n = null), c = n === r5 ? r.group : n === i5 ? Ce({}, r.mark, r[t]) : null;
+    u = "lineBreak", t === "text" && r[u] != null && !tc(u, e) && jv(s, u, r[u]), (n == "legend" || String(n).startsWith("axis")) && (n = null), c = n === r5 ? r.group : n === i5 ? $e({}, r.mark, r[t]) : null;
     for (u in c)
         l = tc(u, e) || (u === "fill" || u === "stroke") && (tc("fill", e) || tc("stroke", e)), l || jv(s, u, c[u]);
-    ne(i).forEach((f) => {
+    re(i).forEach((f) => {
         const d = r.style && r.style[f];
         for (const h in d)
             tc(h, e) || jv(s, h, d[h]);
-    }), e = Ce({}, e);
+    }), e = $e({}, e);
     for (u in s)
         c = s[u], c.signal ? (a = a || {})[u] = c : o[u] = c;
-    return e.enter = Ce(o, e.enter), a && (e.update = Ce(a, e.update)), e;
+    return e.enter = $e(o, e.enter), a && (e.update = $e(a, e.update)), e;
 }
 
 function jv(e, t, n) {
     e[t] = n && n.signal ? {
         signal: n.signal
     } : {
         value: n
     };
 }
-const JL = (e) => ie(e) ? Z(e) : e.signal ? `(${e.signal})` : QL(e);
+const JL = (e) => se(e) ? ee(e) : e.signal ? `(${e.signal})` : QL(e);
 
 function Sy(e) {
     if (e.gradient != null)
         return qce(e);
-    let t = e.signal ? `(${e.signal})` : e.color ? jce(e.color) : e.field != null ? QL(e.field) : e.value !== void 0 ? Z(e.value) : void 0;
+    let t = e.signal ? `(${e.signal})` : e.color ? jce(e.color) : e.field != null ? QL(e.field) : e.value !== void 0 ? ee(e.value) : void 0;
     return e.scale != null && (t = Wce(e, t)), t === void 0 && (t = null), e.exponent != null && (t = `pow(${t},${gm(e.exponent)})`), e.mult != null && (t += `*${gm(e.mult)}`), e.offset != null && (t += `+${gm(e.offset)}`), e.round && (t = `round(${t})`), t;
 }
 const Ap = (e, t, n, i) => `(${e}(${[t, n, i].map(Sy).join(",")})+'')`;
 
 function jce(e) {
     return e.c ? Ap("hcl", e.h, e.c, e.l) : e.h || e.s ? Ap("hsl", e.h, e.s, e.l) : e.l || e.a ? Ap("lab", e.l, e.a, e.b) : e.r || e.g || e.b ? Ap("rgb", e.r, e.g, e.b) : null;
 }
 
 function qce(e) {
-    const t = [e.start, e.stop, e.count].map((n) => n == null ? null : Z(n));
+    const t = [e.start, e.stop, e.count].map((n) => n == null ? null : ee(n));
     for (; t.length && Ie(t) == null;)
         t.pop();
     return t.unshift(JL(e.gradient)), `gradient(${t.join(",")})`;
 }
 
 function gm(e) {
-    return re(e) ? "(" + Sy(e) + ")" : e;
+    return oe(e) ? "(" + Sy(e) + ")" : e;
 }
 
 function QL(e) {
-    return ZL(re(e) ? e : {
+    return ZL(oe(e) ? e : {
         datum: e
     });
 }
 
 function ZL(e) {
     let t, n, i;
     if (e.signal)
         t = "datum", i = e.signal;
     else if (e.group || e.parent) {
         for (n = Math.max(1, e.level || 1), t = "item"; n-- > 0;)
             t += ".mark.group";
         e.parent ? (i = e.parent, t += ".datum") : i = e.group;
     } else
-        e.datum ? (t = "datum", i = e.datum) : q("Invalid field reference: " + Z(e));
-    return e.signal || (i = ie(i) ? As(i).map(Z).join("][") : ZL(i)), t + "[" + i + "]";
+        e.datum ? (t = "datum", i = e.datum) : W("Invalid field reference: " + ee(e));
+    return e.signal || (i = se(i) ? As(i).map(ee).join("][") : ZL(i)), t + "[" + i + "]";
 }
 
 function Wce(e, t) {
     const n = JL(e.scale);
     return e.range != null ? t = `lerp(_range(${n}), ${+e.range})` : (t !== void 0 && (t = `_scale(${n}, ${t})`), e.band && (t = (t ? t + "+" : "") + `_bandwidth(${n})` + (+e.band == 1 ? "" : "*" + gm(e.band)), e.extra && (t = `(datum.extra ? _scale(${n}, datum.extra.value) : ${t})`)), t == null && (t = "0")), t;
 }
 
@@ -30903,26 +30890,26 @@
         },
         $fields: Object.keys(s),
         $output: Object.keys(e)
     };
 }
 
 function Vce(e) {
-    return W(e) ? Hce(e) : Sy(e);
+    return V(e) ? Hce(e) : Sy(e);
 }
 
 function Yce(e, t, n, i) {
     const r = bs(e, t);
-    return r.$fields.forEach((s) => i[s] = 1), Ce(n, r.$params), r.$expr;
+    return r.$fields.forEach((s) => i[s] = 1), $e(n, r.$params), r.$expr;
 }
 const Xce = "outer",
     Kce = ["value", "update", "init", "react", "bind"];
 
 function b8(e, t) {
-    q(e + ' for "outer" push: ' + Z(t));
+    W(e + ' for "outer" push: ' + ee(t));
 }
 
 function tI(e, t) {
     const n = e.name;
     if (e.push === Xce)
         t.signals[n] || b8("No prior signal definition", n), Kce.forEach((i) => {
             e[i] !== void 0 && b8("Invalid property ", i);
@@ -30941,15 +30928,15 @@
     return new dw(e, t, n, i);
 }
 
 function B0(e, t) {
     return ky("operator", e, t);
 }
 
-function pe(e) {
+function ye(e) {
     const t = {
         $ref: e.id
     };
     return e.id < 0 && (e.refs = e.refs || []).push(t), t;
 }
 
 function Oh(e, t) {
@@ -30975,35 +30962,35 @@
     };
     return t && (n.$flat = !0), n;
 }
 const Qce = "ascending",
     Zce = "descending";
 
 function efe(e) {
-    return re(e) ? (e.order === Zce ? "-" : "+") + Ay(e.op, e.field) : "";
+    return oe(e) ? (e.order === Zce ? "-" : "+") + Ay(e.op, e.field) : "";
 }
 
 function Ay(e, t) {
     return (e && e.signal ? "$" + e.signal : e || "") + (e && t ? "_" : "") + (t && t.signal ? "$" + t.signal : t || "");
 }
 const o5 = "scope",
     gw = "view";
 
-function Nt(e) {
+function Ot(e) {
     return e && e.signal;
 }
 
 function tfe(e) {
     return e && e.expr;
 }
 
 function pm(e) {
-    if (Nt(e))
+    if (Ot(e))
         return !0;
-    if (re(e)) {
+    if (oe(e)) {
         for (const t in e)
             if (pm(e[t]))
                 return !0;
     }
     return !1;
 }
 
@@ -31013,15 +31000,15 @@
 
 function Au(e) {
     return e && e.signal || e;
 }
 const x8 = "timer";
 
 function Dh(e, t) {
-    return (e.merge ? ife : e.stream ? rfe : e.type ? sfe : q("Invalid stream specification: " + Z(e)))(e, t);
+    return (e.merge ? ife : e.stream ? rfe : e.type ? sfe : W("Invalid stream specification: " + ee(e)))(e, t);
 }
 
 function nfe(e) {
     return e === o5 ? gw : e || gw;
 }
 
 function ife(e, t) {
@@ -31050,15 +31037,15 @@
         stream: n
     }, e, t);
     return Object.keys(i).length === 1 ? n : t.addStream(i).id;
 }
 
 function a5(e, t, n) {
     let i = t.between;
-    return i && (i.length !== 2 && q('Stream "between" parameter must have 2 entries: ' + Z(t)), e.between = [Dh(i[0], n), Dh(i[1], n)]), i = t.filter ? [].concat(t.filter) : [], (t.marktype || t.markname || t.markrole) && i.push(ofe(t.marktype, t.markname, t.markrole)), t.source === o5 && i.push("inScope(event.item)"), i.length && (e.filter = bs("(" + i.join(")&&(") + ")", n).$expr), (i = t.throttle) != null && (e.throttle = +i), (i = t.debounce) != null && (e.debounce = +i), t.consume && (e.consume = !0), e;
+    return i && (i.length !== 2 && W('Stream "between" parameter must have 2 entries: ' + ee(t)), e.between = [Dh(i[0], n), Dh(i[1], n)]), i = t.filter ? [].concat(t.filter) : [], (t.marktype || t.markname || t.markrole) && i.push(ofe(t.marktype, t.markname, t.markrole)), t.source === o5 && i.push("inScope(event.item)"), i.length && (e.filter = bs("(" + i.join(")&&(") + ")", n).$expr), (i = t.throttle) != null && (e.throttle = +i), (i = t.debounce) != null && (e.debounce = +i), t.consume && (e.consume = !0), e;
 }
 
 function ofe(e, t, n) {
     const i = "event.item";
     return i + (e && e !== "*" ? "&&" + i + ".mark.marktype==='" + e + "'" : "") + (n ? "&&" + i + ".mark.role==='" + n + "'" : "") + (t ? "&&" + i + ".mark.name==='" + t + "'" : "");
 }
 const afe = {
@@ -31073,24 +31060,24 @@
     const i = e.encode,
         r = {
             target: n
         };
     let s = e.events,
         o = e.update,
         a = [];
-    s || q("Signal update missing events specification."), ie(s) && (s = za(s, t.isSubscope() ? o5 : gw)), s = ne(s).filter((u) => u.signal || u.scale ? (a.push(u), 0) : 1), a.length > 1 && (a = [cfe(a)]), s.length && a.push(s.length > 1 ? {
+    s || W("Signal update missing events specification."), se(s) && (s = za(s, t.isSubscope() ? o5 : gw)), s = re(s).filter((u) => u.signal || u.scale ? (a.push(u), 0) : 1), a.length > 1 && (a = [cfe(a)]), s.length && a.push(s.length > 1 ? {
         merge: s
-    } : s[0]), i != null && (o && q("Signal encode and update are mutually exclusive."), o = "encode(item()," + Z(i) + ")"), r.update = ie(o) ? bs(o, t) : o.expr != null ? bs(o.expr, t) : o.value != null ? o.value : o.signal != null ? {
+    } : s[0]), i != null && (o && W("Signal encode and update are mutually exclusive."), o = "encode(item()," + ee(i) + ")"), r.update = se(o) ? bs(o, t) : o.expr != null ? bs(o.expr, t) : o.value != null ? o.value : o.signal != null ? {
         $expr: afe,
         $params: {
             $value: t.signalRef(o.signal)
         }
-    } : q("Invalid signal update specification."), e.force && (r.options = {
+    } : W("Invalid signal update specification."), e.force && (r.options = {
         force: !0
-    }), a.forEach((u) => t.addUpdate(Ce(lfe(u, t), r)));
+    }), a.forEach((u) => t.addUpdate($e(lfe(u, t), r)));
 }
 
 function lfe(e, t) {
     return {
         source: e.signal ? t.signalRef(e.signal) : e.scale ? t.scaleRef(e.scale) : Dh(e, t)
     };
 }
@@ -31100,15 +31087,15 @@
         signal: "[" + e.map((t) => t.scale ? 'scale("' + t.scale + '")' : t.signal) + "]"
     };
 }
 
 function ffe(e, t) {
     const n = t.getSignal(e.name);
     let i = e.update;
-    e.init && (i ? q("Signals can not include both init and update expressions.") : (i = e.init, n.initonly = !0)), i && (i = bs(i, t), n.update = i.$expr, n.params = i.$params), e.on && e.on.forEach((r) => ufe(r, t, n.id));
+    e.init && (i ? W("Signals can not include both init and update expressions.") : (i = e.init, n.initonly = !0)), i && (i = bs(i, t), n.update = i.$expr, n.params = i.$params), e.on && e.on.forEach((r) => ufe(r, t, n.id));
 }
 const Ze = (e) => (t, n, i) => ky(e, n, t || void 0, i),
     nI = Ze("aggregate"),
     dfe = Ze("axisticks"),
     iI = Ze("bound"),
     Pr = Ze("collect"),
     w8 = Ze("compare"),
@@ -31124,205 +31111,205 @@
     wfe = Ze("multiextent"),
     _fe = Ze("multivalues"),
     Efe = Ze("overlap"),
     Sfe = Ze("params"),
     sI = Ze("prefacet"),
     kfe = Ze("projection"),
     Afe = Ze("proxy"),
-    $fe = Ze("relay"),
+    Cfe = Ze("relay"),
     oI = Ze("render"),
-    Cfe = Ze("scale"),
+    $fe = Ze("scale"),
     xl = Ze("sieve"),
     Mfe = Ze("sortitems"),
     aI = Ze("viewlayout"),
     Tfe = Ze("values");
 let Ffe = 0;
 const uI = {
     min: "min",
     max: "max",
     count: "sum"
 };
 
 function Nfe(e, t) {
     const n = e.type || "linear";
-    HN(n) || q("Unrecognized scale type: " + Z(n)), t.addScale(e.name, {
+    HN(n) || W("Unrecognized scale type: " + ee(n)), t.addScale(e.name, {
         type: n,
         domain: void 0
     });
 }
 
 function Ofe(e, t) {
     const n = t.getScale(e.name).params;
     let i;
     n.domain = lI(e.domain, e, t), e.range != null && (n.range = fI(e, t, n)), e.interpolate != null && qfe(e.interpolate, n), e.nice != null && (n.nice = jfe(e.nice, t)), e.bins != null && (n.bins = Ufe(e.bins, t));
     for (i in e)
-        be(n, i) || i === "name" || (n[i] = Wi(e[i], t));
+        xe(n, i) || i === "name" || (n[i] = Wi(e[i], t));
 }
 
 function Wi(e, t) {
-    return re(e) ? e.signal ? t.signalRef(e.signal) : q("Unsupported object: " + Z(e)) : e;
+    return oe(e) ? e.signal ? t.signalRef(e.signal) : W("Unsupported object: " + ee(e)) : e;
 }
 
 function mm(e, t) {
     return e.signal ? t.signalRef(e.signal) : e.map((n) => Wi(n, t));
 }
 
-function $y(e) {
-    q("Can not find data set: " + Z(e));
+function Cy(e) {
+    W("Can not find data set: " + ee(e));
 }
 
 function lI(e, t, n) {
     if (!e) {
-        (t.domainMin != null || t.domainMax != null) && q("No scale domain defined for domainMin/domainMax to override.");
+        (t.domainMin != null || t.domainMax != null) && W("No scale domain defined for domainMin/domainMax to override.");
         return;
     }
-    return e.signal ? n.signalRef(e.signal) : (W(e) ? Dfe : e.fields ? Lfe : Rfe)(e, t, n);
+    return e.signal ? n.signalRef(e.signal) : (V(e) ? Dfe : e.fields ? Lfe : Rfe)(e, t, n);
 }
 
 function Dfe(e, t, n) {
     return e.map((i) => Wi(i, n));
 }
 
 function Rfe(e, t, n) {
     const i = n.getData(e.data);
-    return i || $y(e.data), Nc(t.type) ? i.valuesRef(n, e.field, cI(e.sort, !1)) : YN(t.type) ? i.domainRef(n, e.field) : i.extentRef(n, e.field);
+    return i || Cy(e.data), Nc(t.type) ? i.valuesRef(n, e.field, cI(e.sort, !1)) : YN(t.type) ? i.domainRef(n, e.field) : i.extentRef(n, e.field);
 }
 
 function Lfe(e, t, n) {
     const i = e.data,
-        r = e.fields.reduce((s, o) => (o = ie(o) ? {
+        r = e.fields.reduce((s, o) => (o = se(o) ? {
             data: i,
             field: o
-        } : W(o) || o.signal ? Ife(o, n) : o, s.push(o), s), []);
+        } : V(o) || o.signal ? Ife(o, n) : o, s.push(o), s), []);
     return (Nc(t.type) ? Pfe : YN(t.type) ? zfe : Bfe)(e, n, r);
 }
 
 function Ife(e, t) {
     const n = "_:vega:_" + Ffe++,
         i = Pr({});
-    if (W(e))
+    if (V(e))
         i.value = {
             $ingest: e
         };
     else if (e.signal) {
-        const r = "setdata(" + Z(n) + "," + e.signal + ")";
+        const r = "setdata(" + ee(n) + "," + e.signal + ")";
         i.params.input = t.signalRef(r);
     }
     return t.addDataPipeline(n, [i, xl({})]), {
         data: n,
         field: "data"
     };
 }
 
 function Pfe(e, t, n) {
     const i = cI(e.sort, !0);
     let r, s;
     const o = n.map((l) => {
             const c = t.getData(l.data);
-            return c || $y(l.data), c.countsRef(t, l.field, i);
+            return c || Cy(l.data), c.countsRef(t, l.field, i);
         }),
         a = {
             groupby: hw,
             pulse: o
         };
     i && (r = i.op || "count", s = i.field ? Ay(r, i.field) : "count", a.ops = [uI[r]], a.fields = [t.fieldRef(s)], a.as = [s]), r = t.add(nI(a));
     const u = t.add(Pr({
-        pulse: pe(r)
+        pulse: ye(r)
     }));
     return s = t.add(Tfe({
         field: hw,
         sort: t.sortRef(i),
-        pulse: pe(u)
-    })), pe(s);
+        pulse: ye(u)
+    })), ye(s);
 }
 
 function cI(e, t) {
-    return e && (!e.field && !e.op ? re(e) ? e.field = "key" : e = {
+    return e && (!e.field && !e.op ? oe(e) ? e.field = "key" : e = {
         field: "key"
-    } : !e.field && e.op !== "count" ? q("No field provided for sort aggregate op: " + e.op) : t && e.field && e.op && !uI[e.op] && q("Multiple domain scales can not be sorted using " + e.op)), e;
+    } : !e.field && e.op !== "count" ? W("No field provided for sort aggregate op: " + e.op) : t && e.field && e.op && !uI[e.op] && W("Multiple domain scales can not be sorted using " + e.op)), e;
 }
 
 function zfe(e, t, n) {
     const i = n.map((r) => {
         const s = t.getData(r.data);
-        return s || $y(r.data), s.domainRef(t, r.field);
+        return s || Cy(r.data), s.domainRef(t, r.field);
     });
-    return pe(t.add(_fe({
+    return ye(t.add(_fe({
         values: i
     })));
 }
 
 function Bfe(e, t, n) {
     const i = n.map((r) => {
         const s = t.getData(r.data);
-        return s || $y(r.data), s.extentRef(t, r.field);
+        return s || Cy(r.data), s.extentRef(t, r.field);
     });
-    return pe(t.add(wfe({
+    return ye(t.add(wfe({
         extents: i
     })));
 }
 
 function Ufe(e, t) {
-    return e.signal || W(e) ? mm(e, t) : t.objectProperty(e);
+    return e.signal || V(e) ? mm(e, t) : t.objectProperty(e);
 }
 
 function jfe(e, t) {
-    return e.signal ? t.signalRef(e.signal) : re(e) ? {
+    return e.signal ? t.signalRef(e.signal) : oe(e) ? {
         interval: Wi(e.interval),
         step: Wi(e.step)
     } : Wi(e);
 }
 
 function qfe(e, t) {
     t.interpolate = Wi(e.type || e), e.gamma != null && (t.interpolateGamma = Wi(e.gamma));
 }
 
 function fI(e, t, n) {
     const i = t.config.range;
     let r = e.range;
     if (r.signal)
         return t.signalRef(r.signal);
-    if (ie(r)) {
-        if (i && be(i, r))
-            return e = Ce({}, e, {
+    if (se(r)) {
+        if (i && xe(i, r))
+            return e = $e({}, e, {
                 range: i[r]
             }), fI(e, t, n);
         r === "width" ? r = [0, {
             signal: "width"
         }] : r === "height" ? r = Nc(e.type) ? [0, {
             signal: "height"
         }] : [{
             signal: "height"
-        }, 0] : q("Unrecognized scale range value: " + Z(r));
+        }, 0] : W("Unrecognized scale range value: " + ee(r));
     } else if (r.scheme) {
-        n.scheme = W(r.scheme) ? mm(r.scheme, t) : Wi(r.scheme, t), r.extent && (n.schemeExtent = mm(r.extent, t)), r.count && (n.schemeCount = Wi(r.count, t));
+        n.scheme = V(r.scheme) ? mm(r.scheme, t) : Wi(r.scheme, t), r.extent && (n.schemeExtent = mm(r.extent, t)), r.count && (n.schemeCount = Wi(r.count, t));
         return;
     } else if (r.step) {
         n.rangeStep = Wi(r.step, t);
         return;
     } else {
-        if (Nc(e.type) && !W(r))
+        if (Nc(e.type) && !V(r))
             return lI(r, e, t);
-        W(r) || q("Unsupported range type: " + Z(r));
+        V(r) || W("Unsupported range type: " + ee(r));
     }
-    return r.map((s) => (W(s) ? mm : Wi)(s, t));
+    return r.map((s) => (V(s) ? mm : Wi)(s, t));
 }
 
 function Wfe(e, t) {
     const n = t.config.projection || {},
         i = {};
     for (const r in e)
         r !== "name" && (i[r] = pw(e[r], r, t));
     for (const r in n)
         i[r] == null && (i[r] = pw(n[r], r, t));
     t.addProjection(e.name, i);
 }
 
 function pw(e, t, n) {
-    return W(e) ? e.map((i) => pw(i, t, n)) : re(e) ? e.signal ? n.signalRef(e.signal) : t === "fit" ? e : q("Unsupported parameter object: " + Z(e)) : e;
+    return V(e) ? e.map((i) => pw(i, t, n)) : oe(e) ? e.signal ? n.signalRef(e.signal) : t === "fit" ? e : W("Unsupported parameter object: " + ee(e)) : e;
 }
 const zr = "top",
     Mf = "left",
     Tf = "right",
     ka = "bottom",
     dI = "center",
     Hfe = "vertical",
@@ -31346,33 +31333,33 @@
     Zfe = "shape",
     ede = "fill",
     tde = "stroke",
     nde = "strokeWidth",
     ide = "strokeDash",
     rde = "opacity",
     c5 = [bw, Zfe, ede, tde, nde, ide, rde],
-    $g = {
+    Cg = {
         name: 1,
         style: 1,
         interactive: 1
     },
     Pe = {
         value: 0
     },
     Vi = {
         value: 1
     },
-    Cy = "group",
+    $y = "group",
     hI = "rect",
     f5 = "rule",
     sde = "symbol",
     wl = "text";
 
 function Rh(e) {
-    return e.type = Cy, e.interactive = e.interactive || !1, e;
+    return e.type = $y, e.interactive = e.interactive || !1, e;
 }
 
 function gi(e, t) {
     const n = (i, r) => vr(e[i], vr(t[i], r));
     return n.isVertical = (i) => Hfe === vr(e.direction, t.direction || (i ? t.symbolDirection : t.gradientDirection)), n.gradientLength = () => vr(e.gradientLength, t.gradientLength || t.gradientWidth), n.gradientThickness = () => vr(e.gradientThickness, t.gradientThickness || t.gradientHeight), n.entryColumns = () => vr(e.columns, vr(t.columns, +n.isVertical(!0))), n;
 }
 
@@ -31385,74 +31372,74 @@
     const i = t.config.style[n];
     return i && i[e];
 }
 
 function My(e, t, n) {
     return `item.anchor === '${Gfe}' ? ${e} : item.anchor === '${Yfe}' ? ${t} : ${n}`;
 }
-const d5 = My(Z(Mf), Z(Tf), Z(dI));
+const d5 = My(ee(Mf), ee(Tf), ee(dI));
 
 function ade(e) {
     const t = e("tickBand");
     let n = e("tickOffset"),
         i, r;
     return t ? t.signal ? (i = {
         signal: `(${t.signal}) === 'extent' ? 1 : 0.5`
     }, r = {
         signal: `(${t.signal}) === 'extent'`
-    }, re(n) || (n = {
+    }, oe(n) || (n = {
         signal: `(${t.signal}) === 'extent' ? 0 : ${n}`
     })) : t === "extent" ? (i = 1, r = !0, n = 0) : (i = 0.5, r = !1) : (i = e("bandPosition"), r = e("tickExtra")), {
         extra: r,
         band: i,
         offset: n
     };
 }
 
 function pI(e, t) {
-    return t ? e ? re(e) ? Object.assign({}, e, {
+    return t ? e ? oe(e) ? Object.assign({}, e, {
         offset: pI(e.offset, t)
     }) : {
         value: e,
         offset: t
     } : t : e;
 }
 
 function Fi(e, t) {
-    return t ? (e.name = t.name, e.style = t.style || e.style, e.interactive = !!t.interactive, e.encode = Cf(e.encode, t, $g)) : e.interactive = !1, e;
+    return t ? (e.name = t.name, e.style = t.style || e.style, e.interactive = !!t.interactive, e.encode = $f(e.encode, t, Cg)) : e.interactive = !1, e;
 }
 
 function ude(e, t, n, i) {
     const r = gi(e, n),
         s = r.isVertical(),
         o = r.gradientThickness(),
         a = r.gradientLength();
     let u, l, c, f, d;
     s ? (l = [0, 1], c = [0, 0], f = o, d = a) : (l = [0, 0], c = [1, 0], f = a, d = o);
     const h = {
         enter: u = {
             opacity: Pe,
             x: Pe,
             y: Pe,
-            width: jt(f),
-            height: jt(d)
+            width: qt(f),
+            height: qt(d)
         },
-        update: Ce({}, u, {
+        update: $e({}, u, {
             opacity: Vi,
             fill: {
                 gradient: t,
                 start: l,
                 stop: c
             }
         }),
         exit: {
             opacity: Pe
         }
     };
-    return rn(h, {
+    return sn(h, {
         stroke: r("gradientStrokeColor"),
         strokeWidth: r("gradientStrokeWidth")
     }, {
         // update
         opacity: r("gradientOpacity")
     }), Fi({
         type: hI,
@@ -31477,25 +31464,25 @@
     };
     g[l] = {
         signal: h + "datum." + Uc,
         mult: u
     }, g[c] = Pe, g[f] = {
         signal: h + "datum." + Kfe,
         mult: u
-    }, g[d] = jt(a);
+    }, g[d] = qt(a);
     const p = {
         enter: g,
-        update: Ce({}, g, {
+        update: $e({}, g, {
             opacity: Vi
         }),
         exit: {
             opacity: Pe
         }
     };
-    return rn(p, {
+    return sn(p, {
         stroke: s("gradientStrokeColor"),
         strokeWidth: s("gradientStrokeWidth")
     }, {
         // update
         opacity: s("gradientOpacity")
     }), Fi({
         type: hI,
@@ -31507,15 +31494,15 @@
 }
 const cde = `datum.${Uc}<=0?"${Mf}":datum.${Uc}>=1?"${Tf}":"${dI}"`,
     fde = `datum.${Uc}<=0?"${ka}":datum.${Uc}>=1?"${zr}":"${Vfe}"`;
 
 function E8(e, t, n, i) {
     const r = gi(e, t),
         s = r.isVertical(),
-        o = jt(r.gradientThickness()),
+        o = qt(r.gradientThickness()),
         a = r.gradientLength();
     let u = r("labelOverlap"),
         l, c, f, d, h = "";
     const g = {
         enter: l = {
             opacity: Pe
         },
@@ -31525,15 +31512,15 @@
                 field: u5
             }
         },
         exit: {
             opacity: Pe
         }
     };
-    return rn(g, {
+    return sn(g, {
         fill: r("labelColor"),
         fillOpacity: r("labelOpacity"),
         font: r("labelFont"),
         fontSize: r("labelFontSize"),
         fontStyle: r("labelFontStyle"),
         fontWeight: r("labelFontWeight"),
         limit: vr(e.labelLimit, t.gradientLabelLimit)
@@ -31570,15 +31557,15 @@
         u = o ? o.name : void 0,
         l = s("clipHeight"),
         c = s("symbolOffset"),
         f = {
             data: "value"
         },
         d = `(${r}) ? datum.${Xfe} : datum.${bw}`,
-        h = l ? jt(l) : {
+        h = l ? qt(l) : {
             field: bw
         },
         g = `datum.${mw}`,
         p = `max(1, ${r})`;
     let m, y, b, v, x;
     h.mult = 0.5, m = {
         enter: y = {
@@ -31596,41 +31583,41 @@
             y: y.y
         },
         exit: {
             opacity: Pe
         }
     };
     let w = null,
-        S = null;
-    e.fill || (w = t.symbolBaseFillColor, S = t.symbolBaseStrokeColor), rn(m, {
+        E = null;
+    e.fill || (w = t.symbolBaseFillColor, E = t.symbolBaseStrokeColor), sn(m, {
         fill: s("symbolFillColor", w),
         shape: s("symbolType"),
         size: s("symbolSize"),
-        stroke: s("symbolStrokeColor", S),
+        stroke: s("symbolStrokeColor", E),
         strokeDash: s("symbolDash"),
         strokeDashOffset: s("symbolDashOffset"),
         strokeWidth: s("symbolStrokeWidth")
     }, {
         // update
         opacity: s("symbolOpacity")
-    }), c5.forEach((F) => {
-        e[F] && (b[F] = y[F] = {
-            scale: e[F],
+    }), c5.forEach((T) => {
+        e[T] && (b[T] = y[T] = {
+            scale: e[T],
             field: Gi
         });
     });
     const _ = Fi({
             type: sde,
             role: Lce,
             key: Gi,
             from: f,
             clip: l ? !0 : void 0,
             encode: m
         }, n.symbols),
-        k = jt(c);
+        k = qt(c);
     k.offset = s("labelOffset"), m = {
         enter: y = {
             opacity: Pe,
             x: {
                 signal: d,
                 offset: k
             },
@@ -31643,15 +31630,15 @@
             },
             x: y.x,
             y: y.y
         },
         exit: {
             opacity: Pe
         }
-    }, rn(m, {
+    }, sn(m, {
         align: s("labelAlign"),
         baseline: s("labelBaseline"),
         fill: s("labelColor"),
         fillOpacity: s("labelOpacity"),
         font: s("labelFont"),
         fontSize: s("labelFontSize"),
         fontStyle: s("labelFontStyle"),
@@ -31669,15 +31656,15 @@
     return m = {
         enter: {
             noBound: {
                 value: !l
             },
             // ignore width/height in bounds calc
             width: Pe,
-            height: l ? jt(l) : Pe,
+            height: l ? qt(l) : Pe,
             opacity: Pe
         },
         exit: {
             opacity: Pe
         },
         update: b = {
             opacity: Vi,
@@ -31697,15 +31684,15 @@
             data: i,
             name: "value",
             groupby: mw
         }
     }, Rh({
         role: s5,
         from: i,
-        encode: Cf(m, o, $g),
+        encode: $f(m, o, Cg),
         marks: [_, A],
         name: u,
         interactive: a,
         sort: x
     });
 }
 
@@ -31754,15 +31741,15 @@
                     }
                 }
             },
             exit: {
                 opacity: Pe
             }
         };
-    return rn(s, {
+    return sn(s, {
         orient: r("titleOrient"),
         _anchor: r("titleAnchor"),
         anchor: {
             signal: bde
         },
         angle: {
             signal: vde
@@ -31793,24 +31780,24 @@
         from: i,
         encode: s
     }, n);
 }
 
 function _de(e, t) {
     let n;
-    return re(e) && (e.signal ? n = e.signal : e.path ? n = "pathShape(" + S8(e.path) + ")" : e.sphere && (n = "geoShape(" + S8(e.sphere) + ', {type: "Sphere"})')), n ? t.signalRef(n) : !!e;
+    return oe(e) && (e.signal ? n = e.signal : e.path ? n = "pathShape(" + S8(e.path) + ")" : e.sphere && (n = "geoShape(" + S8(e.sphere) + ', {type: "Sphere"})')), n ? t.signalRef(n) : !!e;
 }
 
 function S8(e) {
-    return re(e) && e.signal ? e.signal : Z(e);
+    return oe(e) && e.signal ? e.signal : ee(e);
 }
 
 function mI(e) {
     const t = e.role || "";
-    return t.startsWith("axis") || t.startsWith("legend") || t.startsWith("title") ? t : e.type === Cy ? s5 : t || i5;
+    return t.startsWith("axis") || t.startsWith("legend") || t.startsWith("title") ? t : e.type === $y ? s5 : t || i5;
 }
 
 function Ede(e) {
     return {
         marktype: e.type,
         name: e.name || void 0,
         role: e.role || mI(e),
@@ -31822,15 +31809,15 @@
 
 function Sde(e, t) {
     return e && e.signal ? t.signalRef(e.signal) : e !== !1;
 }
 
 function p5(e, t) {
     const n = RT(e.type);
-    n || q("Unrecognized transform type: " + Z(e.type));
+    n || W("Unrecognized transform type: " + ee(e.type));
     const i = ky(n.type.toLowerCase(), null, yI(n, e, t));
     return e.signal && t.addSignal(e.signal, t.proxy(i)), i.metadata = n.metadata || {}, i;
 }
 
 function yI(e, t, n) {
     const i = {},
         r = e.params.length;
@@ -31843,42 +31830,42 @@
 
 function kde(e, t, n) {
     const i = e.type,
         r = t[e.name];
     if (i === "index")
         return Ade(e, t, n);
     if (r === void 0) {
-        e.required && q("Missing required " + Z(t.type) + " parameter: " + Z(e.name));
+        e.required && W("Missing required " + ee(t.type) + " parameter: " + ee(e.name));
         return;
     } else {
         if (i === "param")
-            return $de(e, t, n);
+            return Cde(e, t, n);
         if (i === "projection")
             return n.projectionRef(t[e.name]);
     }
-    return e.array && !Nt(r) ? r.map((s) => k8(e, s, n)) : k8(e, r, n);
+    return e.array && !Ot(r) ? r.map((s) => k8(e, s, n)) : k8(e, r, n);
 }
 
 function k8(e, t, n) {
     const i = e.type;
-    if (Nt(t))
-        return $8(i) ? q("Expression references can not be signals.") : qv(i) ? n.fieldRef(t) : C8(i) ? n.compareRef(t) : n.signalRef(t.signal);
+    if (Ot(t))
+        return C8(i) ? W("Expression references can not be signals.") : qv(i) ? n.fieldRef(t) : $8(i) ? n.compareRef(t) : n.signalRef(t.signal);
     {
         const r = e.expr || qv(i);
-        return r && Cde(t) ? n.exprRef(t.expr, t.as) : r && Mde(t) ? Oh(t.field, t.as) : $8(i) ? bs(t, n) : Tde(i) ? pe(n.getData(t).values) : qv(i) ? Oh(t) : C8(i) ? n.compareRef(t) : t;
+        return r && $de(t) ? n.exprRef(t.expr, t.as) : r && Mde(t) ? Oh(t.field, t.as) : C8(i) ? bs(t, n) : Tde(i) ? ye(n.getData(t).values) : qv(i) ? Oh(t) : $8(i) ? n.compareRef(t) : t;
     }
 }
 
 function Ade(e, t, n) {
-    return ie(t.from) || q('Lookup "from" parameter must be a string literal.'), n.getData(t.from).lookupRef(n, t.key);
+    return se(t.from) || W('Lookup "from" parameter must be a string literal.'), n.getData(t.from).lookupRef(n, t.key);
 }
 
-function $de(e, t, n) {
+function Cde(e, t, n) {
     const i = t[e.name];
-    return e.array ? (W(i) || q("Expected an array of sub-parameters. Instead: " + Z(i)), i.map((r) => A8(e, r, n))) : A8(e, i, n);
+    return e.array ? (V(i) || W("Expected an array of sub-parameters. Instead: " + ee(i)), i.map((r) => A8(e, r, n))) : A8(e, i, n);
 }
 
 function A8(e, t, n) {
     const i = e.params.length;
     let r;
     for (let o = 0; o < i; ++o) {
         r = e.params[o];
@@ -31886,58 +31873,58 @@
             if (r.key[a] !== t[a]) {
                 r = null;
                 break;
             }
         if (r)
             break;
     }
-    r || q("Unsupported parameter: " + Z(t));
-    const s = Ce(yI(r, t, n), r.key);
-    return pe(n.add(Sfe(s)));
+    r || W("Unsupported parameter: " + ee(t));
+    const s = $e(yI(r, t, n), r.key);
+    return ye(n.add(Sfe(s)));
 }
-const Cde = (e) => e && e.expr,
+const $de = (e) => e && e.expr,
     Mde = (e) => e && e.field,
     Tde = (e) => e === "data",
-    $8 = (e) => e === "expr",
+    C8 = (e) => e === "expr",
     qv = (e) => e === "field",
-    C8 = (e) => e === "compare";
+    $8 = (e) => e === "compare";
 
 function Fde(e, t, n) {
     let i, r, s, o, a;
-    return e ? (i = e.facet) && (t || q("Only group marks can be faceted."), i.field != null ? o = a = bm(i, n) : (e.data ? a = pe(n.getData(e.data).aggregate) : (s = p5(Ce({
+    return e ? (i = e.facet) && (t || W("Only group marks can be faceted."), i.field != null ? o = a = bm(i, n) : (e.data ? a = ye(n.getData(e.data).aggregate) : (s = p5($e({
         type: "aggregate",
-        groupby: ne(i.groupby)
-    }, i.aggregate), n), s.params.key = n.keyRef(i.groupby), s.params.pulse = bm(i, n), o = a = pe(n.add(s))), r = n.keyRef(i.groupby, !0))) : o = pe(n.add(Pr(null, [{}]))), o || (o = bm(e, n)), {
+        groupby: re(i.groupby)
+    }, i.aggregate), n), s.params.key = n.keyRef(i.groupby), s.params.pulse = bm(i, n), o = a = ye(n.add(s))), r = n.keyRef(i.groupby, !0))) : o = ye(n.add(Pr(null, [{}]))), o || (o = bm(e, n)), {
         key: r,
         pulse: o,
         parent: a
     };
 }
 
 function bm(e, t) {
-    return e.$ref ? e : e.data && e.data.$ref ? e.data : pe(t.getData(e.data).output);
+    return e.$ref ? e : e.data && e.data.$ref ? e.data : ye(t.getData(e.data).output);
 }
 
 function Ku(e, t, n, i, r) {
     this.scope = e, this.input = t, this.output = n, this.values = i, this.aggregate = r, this.index = {};
 }
 Ku.fromEntries = function(e, t) {
     const n = t.length,
         i = t[n - 1],
         r = t[n - 2];
     let s = t[0],
         o = null,
         a = 1;
     for (s && s.type === "load" && (s = t[1]), e.add(t[0]); a < n; ++a)
-        t[a].params.pulse = pe(t[a - 1]), e.add(t[a]), t[a].type === "aggregate" && (o = t[a]);
+        t[a].params.pulse = ye(t[a - 1]), e.add(t[a]), t[a].type === "aggregate" && (o = t[a]);
     return new Ku(e, s, r, i, o);
 };
 
 function bI(e) {
-    return ie(e) ? e : null;
+    return se(e) ? e : null;
 }
 
 function M8(e, t, n) {
     const i = Ay(n.op, n.field);
     let r;
     if (t.ops) {
         for (let s = 0, o = t.as.length; s < o; ++s)
@@ -31955,38 +31942,38 @@
         c, f;
     if (l != null && (e = t.scope, l = l + (u ? "|" + u : ""), c = a[l]), !c) {
         const d = s ? {
             field: hw,
             pulse: t.countsRef(e, r, s)
         } : {
             field: e.fieldRef(r),
-            pulse: pe(t.output)
+            pulse: ye(t.output)
         };
-        u && (d.sort = e.sortRef(s)), f = e.add(ky(i, void 0, d)), o && (t.index[r] = f), c = pe(f), l != null && (a[l] = c);
+        u && (d.sort = e.sortRef(s)), f = e.add(ky(i, void 0, d)), o && (t.index[r] = f), c = ye(f), l != null && (a[l] = c);
     }
     return c;
 }
 Ku.prototype = {
     countsRef(e, t, n) {
         const i = this,
             r = i.counts || (i.counts = {}),
             s = bI(t);
         let o, a, u;
         return s != null && (e = i.scope, o = r[s]), o ? n && n.field && M8(e, o.agg.params, n) : (u = {
             groupby: e.fieldRef(t, "key"),
-            pulse: pe(i.output)
+            pulse: ye(i.output)
         }, n && n.field && M8(e, u, n), a = e.add(nI(u)), o = e.add(Pr({
-            pulse: pe(a)
+            pulse: ye(a)
         })), o = {
             agg: a,
-            ref: pe(o)
+            ref: ye(o)
         }, s != null && (r[s] = o)), o.ref;
     },
     tuplesRef() {
-        return pe(this.values);
+        return ye(this.values);
     },
     extentRef(e, t) {
         return sd(e, this, "extent", "extent", t, !1);
     },
     domainRef(e, t) {
         return sd(e, this, "domain", "values", t, !1);
     },
@@ -32002,26 +31989,26 @@
 };
 
 function Nde(e, t, n) {
     const i = e.from.facet,
         r = i.name,
         s = bm(i, t);
     let o;
-    i.name || q("Facet must have a name: " + Z(i)), i.data || q("Facet must reference a data set: " + Z(i)), i.field ? o = t.add(sI({
+    i.name || W("Facet must have a name: " + ee(i)), i.data || W("Facet must reference a data set: " + ee(i)), i.field ? o = t.add(sI({
         field: t.fieldRef(i.field),
         pulse: s
     })) : i.groupby ? o = t.add(pfe({
         key: t.keyRef(i.groupby),
-        group: pe(t.proxy(n.parent)),
+        group: ye(t.proxy(n.parent)),
         pulse: s
-    })) : q("Facet must specify groupby or field: " + Z(i));
+    })) : W("Facet must specify groupby or field: " + ee(i));
     const a = t.fork(),
         u = a.add(Pr()),
         l = a.add(xl({
-            pulse: pe(u)
+            pulse: ye(u)
         }));
     a.addData(r, new Ku(a, u, u, l)), a.addSignal("parent", null), o.params.subflow = {
         $subflow: a.parse(e).toRuntime()
     };
 }
 
 function Ode(e, t, n) {
@@ -32044,125 +32031,125 @@
         l = "if(" + e.trigger + ',modify("' + n + '",' + [r, i, s, o, a].map((f) => f ?? "null").join(",") + "),0)",
         c = bs(l, t);
     u.update = c.$expr, u.params = c.$params;
 }
 
 function Fy(e, t) {
     const n = mI(e),
-        i = e.type === Cy,
+        i = e.type === $y,
         r = e.from && e.from.facet,
         s = e.overlap;
     let o = e.layout || n === s5 || n === r5,
         a, u, l, c, f, d, h;
     const g = n === i5 || o || r,
         p = Fde(e.from, i, t);
     u = t.add(hfe({
         key: p.key || (e.key ? Oh(e.key) : void 0),
         pulse: p.pulse,
         clean: !i
     }));
-    const m = pe(u);
+    const m = ye(u);
     u = l = t.add(Pr({
         pulse: m
     })), u = t.add(xfe({
         markdef: Ede(e),
         interactive: Sde(e.interactive, t),
         clip: _de(e.clip, t),
         context: {
             $context: !0
         },
         groups: t.lookup(),
         parent: t.signals.parent ? t.signalRef("parent") : null,
         index: t.markpath(),
-        pulse: pe(u)
+        pulse: ye(u)
     }));
-    const y = pe(u);
+    const y = ye(u);
     u = c = t.add(rI(eI(e.encode, e.type, n, e.style, t, {
         mod: !1,
         pulse: y
-    }))), u.params.parent = t.encode(), e.transform && e.transform.forEach((S) => {
-        const _ = p5(S, t),
+    }))), u.params.parent = t.encode(), e.transform && e.transform.forEach((E) => {
+        const _ = p5(E, t),
             k = _.metadata;
-        (k.generates || k.changes) && q("Mark transforms should not generate new data."), k.nomod || (c.params.mod = !0), _.params.pulse = pe(u), t.add(u = _);
+        (k.generates || k.changes) && W("Mark transforms should not generate new data."), k.nomod || (c.params.mod = !0), _.params.pulse = ye(u), t.add(u = _);
     }), e.sort && (u = t.add(Mfe({
         sort: t.compareRef(e.sort),
-        pulse: pe(u)
+        pulse: ye(u)
     })));
-    const b = pe(u);
+    const b = ye(u);
     (r || o) && (o = t.add(aI({
         layout: t.objectProperty(e.layout),
         legends: t.legends,
         mark: y,
         pulse: b
-    })), d = pe(o));
+    })), d = ye(o));
     const v = t.add(iI({
         mark: y,
         pulse: d || b
     }));
-    h = pe(v), i && (g && (a = t.operators, a.pop(), o && a.pop()), t.pushState(b, d || h, m), r ? Nde(e, t, p) : g ? Ode(e, t, p) : t.parse(e), t.popState(), g && (o && a.push(o), a.push(v))), s && (h = Dde(s, h, t));
+    h = ye(v), i && (g && (a = t.operators, a.pop(), o && a.pop()), t.pushState(b, d || h, m), r ? Nde(e, t, p) : g ? Ode(e, t, p) : t.parse(e), t.popState(), g && (o && a.push(o), a.push(v))), s && (h = Dde(s, h, t));
     const x = t.add(oI({
             pulse: h
         })),
         w = t.add(xl({
-            pulse: pe(x)
+            pulse: ye(x)
         }, void 0, t.parent()));
-    e.name != null && (f = e.name, t.addData(f, new Ku(t, l, x, w)), e.on && e.on.forEach((S) => {
-        (S.insert || S.remove || S.toggle) && q("Marks only support modify triggers."), vI(S, t, f);
+    e.name != null && (f = e.name, t.addData(f, new Ku(t, l, x, w)), e.on && e.on.forEach((E) => {
+        (E.insert || E.remove || E.toggle) && W("Marks only support modify triggers."), vI(E, t, f);
     }));
 }
 
 function Dde(e, t, n) {
     const i = e.method,
         r = e.bound,
         s = e.separation,
         o = {
-            separation: Nt(s) ? n.signalRef(s.signal) : s,
-            method: Nt(i) ? n.signalRef(i.signal) : i,
+            separation: Ot(s) ? n.signalRef(s.signal) : s,
+            method: Ot(i) ? n.signalRef(i.signal) : i,
             pulse: t
         };
     if (e.order && (o.sort = n.compareRef({
             field: e.order
         })), r) {
         const a = r.tolerance;
-        o.boundTolerance = Nt(a) ? n.signalRef(a.signal) : +a, o.boundScale = n.scaleRef(r.scale), o.boundOrient = r.orient;
+        o.boundTolerance = Ot(a) ? n.signalRef(a.signal) : +a, o.boundScale = n.scaleRef(r.scale), o.boundOrient = r.orient;
     }
-    return pe(n.add(Efe(o)));
+    return ye(n.add(Efe(o)));
 }
 
 function Rde(e, t) {
     const n = t.config.legend,
         i = e.encode || {},
         r = gi(e, n),
         s = i.legend || {},
         o = s.name || void 0,
         a = s.interactive,
         u = s.style,
         l = {};
     let c = 0,
         f, d, h;
-    c5.forEach((v) => e[v] ? (l[v] = e[v], c = c || e[v]) : 0), c || q("Missing valid scale for legend.");
+    c5.forEach((v) => e[v] ? (l[v] = e[v], c = c || e[v]) : 0), c || W("Missing valid scale for legend.");
     const g = Lde(e, t.scaleType(c)),
         p = {
             title: e.title != null,
             scales: l,
             type: g,
             vgrad: g !== "symbol" && r.isVertical()
         },
-        m = pe(t.add(Pr(null, [p]))),
+        m = ye(t.add(Pr(null, [p]))),
         y = {
             enter: {
                 x: {
                     value: 0
                 },
                 y: {
                     value: 0
                 }
             }
         },
-        b = pe(t.add(bfe(d = {
+        b = ye(t.add(bfe(d = {
             type: g,
             scale: t.scaleRef(c),
             count: t.objectProperty(r("tickCount")),
             limit: t.property(r("symbolLimit")),
             values: t.objectProperty(e.values),
             minstep: t.property(e.tickMinStep),
             formatType: t.property(e.formatType),
@@ -32174,15 +32161,15 @@
         encode: y,
         marks: h,
         layout: f,
         interactive: a
     })], p.title && h.push(wde(e, n, i.title, m)), Fy(Rh({
         role: Nce,
         from: m,
-        encode: Cf(Pde(r, e, n), s, $g),
+        encode: $f(Pde(r, e, n), s, Cg),
         marks: h,
         aria: r("aria"),
         description: r("description"),
         zindex: r("zindex"),
         name: o,
         interactive: a,
         style: u
@@ -32199,15 +32186,15 @@
 }
 
 function Pde(e, t, n) {
     const i = {
         enter: {},
         update: {}
     };
-    return rn(i, {
+    return sn(i, {
         orient: e("orient"),
         offset: e("offset"),
         padding: e("padding"),
         titlePadding: e("titlePadding"),
         cornerRadius: e("cornerRadius"),
         fill: e("fillColor"),
         stroke: e("strokeColor"),
@@ -32234,26 +32221,26 @@
 
 function Bde(e, t, n) {
     return gI("fontSize", e) || ode("fontSize", t, n);
 }
 const Ude = `item.orient==="${Mf}"?-90:item.orient==="${Tf}"?90:0`;
 
 function jde(e, t) {
-    e = ie(e) ? {
+    e = se(e) ? {
         text: e
     } : e;
     const n = gi(e, t.config.title),
         i = e.encode || {},
         r = i.group || {},
         s = r.name || void 0,
         o = r.interactive,
         a = r.style,
         u = [],
         l = {},
-        c = pe(t.add(Pr(null, [l])));
+        c = ye(t.add(Pr(null, [l])));
     return u.push(Hde(e, n, qde(e), c)), e.subtitle && u.push(Gde(e, n, i.subtitle, c)), Fy(Rh({
         role: Pce,
         from: c,
         encode: Wde(n, r),
         marks: u,
         aria: n("aria"),
         description: n("description"),
@@ -32262,40 +32249,40 @@
         interactive: o,
         style: a
     }), t);
 }
 
 function qde(e) {
     const t = e.encode;
-    return t && t.title || Ce({
+    return t && t.title || $e({
         name: e.name,
         interactive: e.interactive,
         style: e.style
     }, t);
 }
 
 function Wde(e, t) {
     const n = {
         enter: {},
         update: {}
     };
-    return rn(n, {
+    return sn(n, {
         orient: e("orient"),
         anchor: e("anchor"),
         align: {
             signal: d5
         },
         angle: {
             signal: Ude
         },
         limit: e("limit"),
         frame: e("frame"),
         offset: e("offset") || 0,
         padding: e("subtitlePadding")
-    }), Cf(n, t, $g);
+    }), $f(n, t, Cg);
 }
 
 function Hde(e, t, n, i) {
     const r = {
             value: 0
         },
         s = e.text,
@@ -32308,15 +32295,15 @@
                     value: 1
                 }
             },
             exit: {
                 opacity: r
             }
         };
-    return rn(o, {
+    return sn(o, {
         text: s,
         align: {
             signal: "item.mark.group.align"
         },
         angle: {
             signal: "item.mark.group.angle"
         },
@@ -32360,15 +32347,15 @@
                     value: 1
                 }
             },
             exit: {
                 opacity: r
             }
         };
-    return rn(o, {
+    return sn(o, {
         text: s,
         align: {
             signal: "item.mark.group.align"
         },
         angle: {
             signal: "item.mark.group.angle"
         },
@@ -32409,23 +32396,23 @@
 
 function Yde(e, t, n) {
     const i = [];
     let r = null,
         s = !1,
         o = !1,
         a, u, l, c, f;
-    for (e.values ? Nt(e.values) || pm(e.format) ? (i.push(F8(t, e)), i.push(r = Za())) : i.push(r = Za({
+    for (e.values ? Ot(e.values) || pm(e.format) ? (i.push(F8(t, e)), i.push(r = Za())) : i.push(r = Za({
             $ingest: e.values,
             $format: e.format
         })) : e.url ? pm(e.url) || pm(e.format) ? (i.push(F8(t, e)), i.push(r = Za())) : i.push(r = Za({
             $request: e.url,
             $format: e.format
-        })) : e.source && (r = a = ne(e.source).map((d) => pe(t.getData(d).output)), i.push(null)), u = 0, l = n.length; u < l; ++u)
+        })) : e.source && (r = a = re(e.source).map((d) => ye(t.getData(d).output)), i.push(null)), u = 0, l = n.length; u < l; ++u)
         c = n[u], f = c.metadata, !r && !f.source && i.push(r = Za()), i.push(c), f.generates && (o = !0), f.modifies && !o && (s = !0), f.source ? r = c : f.changes && (r = null);
-    return a && (l = a.length - 1, i[0] = $fe({
+    return a && (l = a.length - 1, i[0] = Cfe({
         derive: s,
         pulse: l ? a : a[0]
     }), (s || l) && i.splice(1, 0, Za())), r || i.push(Za()), i.push(xl({})), i;
 }
 
 function Za(e) {
     const t = Pr({}, e);
@@ -32439,62 +32426,62 @@
         url: t.url ? e.property(t.url) : void 0,
         async: t.async ? e.property(t.async) : void 0,
         values: t.values ? e.property(t.values) : void 0,
         format: e.objectProperty(t.format)
     });
 }
 const xI = (e) => e === ka || e === zr,
-    Ny = (e, t, n) => Nt(e) ? Qde(e.signal, t, n) : e === Mf || e === zr ? t : n,
-    qt = (e, t, n) => Nt(e) ? Kde(e.signal, t, n) : xI(e) ? t : n,
-    Mr = (e, t, n) => Nt(e) ? Jde(e.signal, t, n) : xI(e) ? n : t,
-    wI = (e, t, n) => Nt(e) ? Zde(e.signal, t, n) : e === zr ? {
+    Ny = (e, t, n) => Ot(e) ? Qde(e.signal, t, n) : e === Mf || e === zr ? t : n,
+    Wt = (e, t, n) => Ot(e) ? Kde(e.signal, t, n) : xI(e) ? t : n,
+    Mr = (e, t, n) => Ot(e) ? Jde(e.signal, t, n) : xI(e) ? n : t,
+    wI = (e, t, n) => Ot(e) ? Zde(e.signal, t, n) : e === zr ? {
         value: t
     } : {
         value: n
     },
-    Xde = (e, t, n) => Nt(e) ? ehe(e.signal, t, n) : e === Tf ? {
+    Xde = (e, t, n) => Ot(e) ? ehe(e.signal, t, n) : e === Tf ? {
         value: t
     } : {
         value: n
     },
     Kde = (e, t, n) => _I(`${e} === '${zr}' || ${e} === '${ka}'`, t, n),
     Jde = (e, t, n) => _I(`${e} !== '${zr}' && ${e} !== '${ka}'`, t, n),
     Qde = (e, t, n) => m5(`${e} === '${Mf}' || ${e} === '${zr}'`, t, n),
     Zde = (e, t, n) => m5(`${e} === '${zr}'`, t, n),
     ehe = (e, t, n) => m5(`${e} === '${Tf}'`, t, n),
-    _I = (e, t, n) => (t = t != null ? jt(t) : t, n = n != null ? jt(n) : n, N8(t) && N8(n) ? (t = t ? t.signal || Z(t.value) : null, n = n ? n.signal || Z(n.value) : null, {
+    _I = (e, t, n) => (t = t != null ? qt(t) : t, n = n != null ? qt(n) : n, N8(t) && N8(n) ? (t = t ? t.signal || ee(t.value) : null, n = n ? n.signal || ee(n.value) : null, {
         signal: `${e} ? (${t}) : (${n})`
-    }) : [Ce({
+    }) : [$e({
         test: e
     }, t)].concat(n || [])),
     N8 = (e) => e == null || Object.keys(e).length === 1,
     m5 = (e, t, n) => ({
         signal: `${e} ? (${uc(t)}) : (${uc(n)})`
     }),
     the = (e, t, n, i, r) => ({
         signal: (i != null ? `${e} === '${Mf}' ? (${uc(i)}) : ` : "") + (n != null ? `${e} === '${ka}' ? (${uc(n)}) : ` : "") + (r != null ? `${e} === '${Tf}' ? (${uc(r)}) : ` : "") + (t != null ? `${e} === '${zr}' ? (${uc(t)}) : ` : "") + "(null)"
     }),
-    uc = (e) => Nt(e) ? e.signal : e == null ? null : Z(e),
-    nhe = (e, t) => t === 0 ? 0 : Nt(e) ? {
+    uc = (e) => Ot(e) ? e.signal : e == null ? null : ee(e),
+    nhe = (e, t) => t === 0 ? 0 : Ot(e) ? {
         signal: `(${e.signal}) * ${t}`
     } : {
         value: e * t
     },
     mc = (e, t) => {
         const n = e.signal;
         return n && n.endsWith("(null)") ? {
             signal: n.slice(0, -6) + t.signal
         } : e;
     };
 
 function Hl(e, t, n, i) {
     let r;
-    if (t && be(t, e))
+    if (t && xe(t, e))
         return t[e];
-    if (be(n, e))
+    if (xe(n, e))
         return n[e];
     if (e.startsWith("title")) {
         switch (e) {
             case "titleColor":
                 r = "fill";
                 break;
             case "titleFont":
@@ -32529,26 +32516,26 @@
 function ihe(e, t) {
     var n = t.config,
         i = n.style,
         r = n.axis,
         s = t.scaleType(e.scale) === "band" && n.axisBand,
         o = e.orient,
         a, u, l;
-    if (Nt(o)) {
+    if (Ot(o)) {
         const f = O8([n.axisX, n.axisY]),
             d = O8([n.axisTop, n.axisBottom, n.axisLeft, n.axisRight]);
         a = {};
         for (l of f)
-            a[l] = qt(o, Hl(l, n.axisX, r, i), Hl(l, n.axisY, r, i));
+            a[l] = Wt(o, Hl(l, n.axisX, r, i), Hl(l, n.axisY, r, i));
         u = {};
         for (l of d)
             u[l] = the(o.signal, Hl(l, n.axisTop, r, i), Hl(l, n.axisBottom, r, i), Hl(l, n.axisLeft, r, i), Hl(l, n.axisRight, r, i));
     } else
         a = o === zr || o === ka ? n.axisX : n.axisY, u = n["axis" + o[0].toUpperCase() + o.slice(1)];
-    return a || u || s ? Ce({}, r, a, u, s) : r;
+    return a || u || s ? $e({}, r, a, u, s) : r;
 }
 
 function rhe(e, t, n, i) {
     const r = gi(e, t),
         s = e.orient;
     let o, a;
     const u = {
@@ -32558,27 +32545,27 @@
         update: a = {
             opacity: Vi
         },
         exit: {
             opacity: Pe
         }
     };
-    rn(u, {
+    sn(u, {
         stroke: r("domainColor"),
         strokeCap: r("domainCap"),
         strokeDash: r("domainDash"),
         strokeDashOffset: r("domainDashOffset"),
         strokeWidth: r("domainWidth"),
         strokeOpacity: r("domainOpacity")
     });
     const l = D8(e, 0),
         c = D8(e, 1);
-    return o.x = a.x = qt(s, l, Pe), o.x2 = a.x2 = qt(s, c), o.y = a.y = Mr(s, l, Pe), o.y2 = a.y2 = Mr(s, c), Fi({
+    return o.x = a.x = Wt(s, l, Pe), o.x2 = a.x2 = Wt(s, c), o.y = a.y = Mr(s, l, Pe), o.y2 = a.y2 = Mr(s, c), Fi({
         type: f5,
-        role: $ce,
+        role: Cce,
         from: i,
         encode: u
     }, n);
 }
 
 function D8(e, t) {
     return {
@@ -32601,15 +32588,15 @@
         update: d = {
             opacity: Vi
         },
         exit: f = {
             opacity: Pe
         }
     };
-    rn(h, {
+    sn(h, {
         stroke: s("gridColor"),
         strokeCap: s("gridCap"),
         strokeDash: s("gridDash"),
         strokeDashOffset: s("gridDashOffset"),
         strokeOpacity: s("gridOpacity"),
         strokeWidth: s("gridWidth")
     });
@@ -32617,15 +32604,15 @@
             scale: e.scale,
             field: Gi,
             band: r.band,
             extra: r.extra,
             offset: r.offset,
             round: s("tickRound")
         },
-        p = qt(o, {
+        p = Wt(o, {
             signal: "height"
         }, {
             signal: "width"
         }),
         m = a ? {
             scale: a,
             range: 0,
@@ -32636,40 +32623,40 @@
             offset: l
         },
         y = a ? {
             scale: a,
             range: 1,
             mult: u,
             offset: l
-        } : Ce(p, {
+        } : $e(p, {
             mult: u,
             offset: l
         });
-    return c.x = d.x = qt(o, g, m), c.y = d.y = Mr(o, g, m), c.x2 = d.x2 = Mr(o, y), c.y2 = d.y2 = qt(o, y), f.x = qt(o, g), f.y = Mr(o, g), Fi({
+    return c.x = d.x = Wt(o, g, m), c.y = d.y = Mr(o, g, m), c.x2 = d.x2 = Mr(o, y), c.y2 = d.y2 = Wt(o, y), f.x = Wt(o, g), f.y = Mr(o, g), Fi({
         type: f5,
-        role: Cce,
+        role: $ce,
         key: Gi,
         from: i,
         encode: h
     }, n);
 }
 
 function ohe(e, t) {
     if (t !== 1)
-        if (!re(e))
-            e = Nt(t) ? {
+        if (!oe(e))
+            e = Ot(t) ? {
                 signal: `(${t.signal}) * (${e || 0})`
             } : t * (e || 0);
         else {
-            let n = e = Ce({}, e);
+            let n = e = $e({}, e);
             for (; n.mult != null;)
-                if (re(n.mult))
-                    n = n.mult = Ce({}, n.mult);
+                if (oe(n.mult))
+                    n = n.mult = $e({}, n.mult);
                 else
-                    return n.mult = Nt(t) ? {
+                    return n.mult = Ot(t) ? {
                         signal: `(${n.mult}) * (${t.signal})`
                     } : n.mult * t, e;
             n.mult = t;
         }
     return e;
 }
 
@@ -32685,33 +32672,33 @@
         update: f = {
             opacity: Vi
         },
         exit: c = {
             opacity: Pe
         }
     };
-    rn(d, {
+    sn(d, {
         stroke: o("tickColor"),
         strokeCap: o("tickCap"),
         strokeDash: o("tickDash"),
         strokeDashOffset: o("tickDashOffset"),
         strokeOpacity: o("tickOpacity"),
         strokeWidth: o("tickWidth")
     });
-    const h = jt(r);
+    const h = qt(r);
     h.mult = u;
     const g = {
         scale: e.scale,
         field: Gi,
         band: s.band,
         extra: s.extra,
         offset: s.offset,
         round: o("tickRound")
     };
-    return f.y = l.y = qt(a, Pe, g), f.y2 = l.y2 = qt(a, h), c.x = qt(a, g), f.x = l.x = Mr(a, Pe, g), f.x2 = l.x2 = Mr(a, h), c.y = Mr(a, g), Fi({
+    return f.y = l.y = Wt(a, Pe, g), f.y2 = l.y2 = Wt(a, h), c.x = Wt(a, g), f.x = l.x = Mr(a, Pe, g), f.x2 = l.x2 = Mr(a, h), c.y = Mr(a, g), Fi({
         type: f5,
         role: Tce,
         key: Gi,
         from: i,
         encode: d
     }, n);
 }
@@ -32729,36 +32716,36 @@
         l = Ny(a, -1, 1),
         c = Au(o("labelFlush")),
         f = Au(o("labelFlushOffset")),
         d = o("labelAlign"),
         h = o("labelBaseline");
     let g = c === 0 || !!c,
         p;
-    const m = jt(r);
-    m.mult = l, m.offset = jt(o("labelPadding") || 0), m.offset.mult = l;
+    const m = qt(r);
+    m.mult = l, m.offset = qt(o("labelPadding") || 0), m.offset.mult = l;
     const y = {
             scale: u,
             field: Gi,
             band: 0.5,
             offset: pI(s.offset, o("labelOffset"))
         },
-        b = qt(a, g ? Wv(u, c, '"left"', '"right"', '"center"') : {
+        b = Wt(a, g ? Wv(u, c, '"left"', '"right"', '"center"') : {
             value: "center"
         }, Xde(a, "left", "right")),
-        v = qt(a, wI(a, "bottom", "top"), g ? Wv(u, c, '"top"', '"bottom"', '"middle"') : {
+        v = Wt(a, wI(a, "bottom", "top"), g ? Wv(u, c, '"top"', '"bottom"', '"middle"') : {
             value: "middle"
         }),
         x = Wv(u, c, `-(${f})`, f, 0);
     g = g && f;
     const w = {
             opacity: Pe,
-            x: qt(a, y, m),
+            x: Wt(a, y, m),
             y: Mr(a, y, m)
         },
-        S = {
+        E = {
             enter: w,
             update: p = {
                 opacity: Vi,
                 text: {
                     field: u5
                 },
                 x: w.x,
@@ -32768,18 +32755,18 @@
             },
             exit: {
                 opacity: Pe,
                 x: w.x,
                 y: w.y
             }
         };
-    rn(S, {
-        dx: !d && g ? qt(a, x) : null,
+    sn(E, {
+        dx: !d && g ? Wt(a, x) : null,
         dy: !h && g ? Mr(a, x) : null
-    }), rn(S, {
+    }), sn(E, {
         angle: o("labelAngle"),
         fill: o("labelColor"),
         fillOpacity: o("labelOpacity"),
         font: o("labelFont"),
         fontSize: o("labelFontSize"),
         fontWeight: o("labelFontWeight"),
         fontStyle: o("labelFontStyle"),
@@ -32802,46 +32789,46 @@
         } : null
     } : void 0, p.align !== b && (p.align = mc(p.align, b)), p.baseline !== v && (p.baseline = mc(p.baseline, v)), Fi({
         type: wl,
         role: Mce,
         style: Ag,
         key: Gi,
         from: i,
-        encode: S,
+        encode: E,
         overlap: k
     }, n);
 }
 
 function lhe(e, t, n, i) {
     const r = gi(e, t),
         s = e.orient,
         o = Ny(s, -1, 1);
     let a, u;
     const l = {
             enter: a = {
                 opacity: Pe,
-                anchor: jt(r("titleAnchor", null)),
+                anchor: qt(r("titleAnchor", null)),
                 align: {
                     signal: d5
                 }
             },
-            update: u = Ce({}, a, {
+            update: u = $e({}, a, {
                 opacity: Vi,
-                text: jt(e.title)
+                text: qt(e.title)
             }),
             exit: {
                 opacity: Pe
             }
         },
         c = {
             signal: `lerp(range("${e.scale}"), ${My(0, 1, 0.5)})`
         };
-    return u.x = qt(s, c), u.y = Mr(s, c), a.angle = qt(s, Pe, nhe(o, 90)), a.baseline = qt(s, wI(s, ka, zr), {
+    return u.x = Wt(s, c), u.y = Mr(s, c), a.angle = Wt(s, Pe, nhe(o, 90)), a.baseline = Wt(s, wI(s, ka, zr), {
         value: ka
-    }), u.angle = a.angle, u.baseline = a.baseline, rn(l, {
+    }), u.angle = a.angle, u.baseline = a.baseline, sn(l, {
         fill: r("titleColor"),
         fillOpacity: r("titleOpacity"),
         font: r("titleFont"),
         fontSize: r("titleFontSize"),
         fontStyle: r("titleFontStyle"),
         fontWeight: r("titleFontWeight"),
         limit: r("titleLimit"),
@@ -32857,18 +32844,18 @@
         style: l5,
         from: i,
         encode: l
     }, n);
 }
 
 function che(e, t, n, i) {
-    const r = (a, u) => a != null ? (n.update[u] = mc(jt(a), n.update[u]), !1) : !tc(u, i),
+    const r = (a, u) => a != null ? (n.update[u] = mc(qt(a), n.update[u]), !1) : !tc(u, i),
         s = r(e("titleX"), "x"),
         o = r(e("titleY"), "y");
-    n.enter.auto = o === s ? jt(o) : qt(t, jt(o), jt(s));
+    n.enter.auto = o === s ? qt(o) : Wt(t, qt(o), qt(s));
 }
 
 function fhe(e, t) {
     const n = ihe(e, t),
         i = e.encode || {},
         r = i.axis || {},
         s = r.name || void 0,
@@ -32880,30 +32867,30 @@
             scale: e.scale,
             ticks: !!u("ticks"),
             labels: !!u("labels"),
             grid: !!u("grid"),
             domain: !!u("domain"),
             title: e.title != null
         },
-        f = pe(t.add(Pr({}, [c]))),
-        d = pe(t.add(dfe({
+        f = ye(t.add(Pr({}, [c]))),
+        d = ye(t.add(dfe({
             scale: t.scaleRef(e.scale),
             extra: t.property(l.extra),
             count: t.objectProperty(e.tickCount),
             values: t.objectProperty(e.values),
             minstep: t.property(e.tickMinStep),
             formatType: t.property(e.formatType),
             formatSpecifier: t.property(e.format)
         }))),
         h = [];
     let g;
     return c.grid && h.push(she(e, n, i.grid, d, l)), c.ticks && (g = u("tickSize"), h.push(ahe(e, n, i.ticks, d, g, l))), c.labels && (g = c.ticks ? g : 0, h.push(uhe(e, n, i.labels, d, g, l))), c.domain && h.push(rhe(e, n, i.domain, f)), c.title && h.push(lhe(e, n, i.title, f)), Fy(Rh({
         role: Ace,
         from: f,
-        encode: Cf(dhe(u, e), r, $g),
+        encode: $f(dhe(u, e), r, Cg),
         marks: h,
         aria: u("aria"),
         description: u("description"),
         zindex: u("zindex"),
         name: s,
         interactive: o,
         style: a
@@ -32911,15 +32898,15 @@
 }
 
 function dhe(e, t) {
     const n = {
         enter: {},
         update: {}
     };
-    return rn(n, {
+    return sn(n, {
         orient: e("orient"),
         offset: e("offset") || 0,
         position: vr(t.position, 0),
         titlePadding: e("titlePadding"),
         minExtent: e("minExtent"),
         maxExtent: e("maxExtent"),
         range: {
@@ -32929,19 +32916,19 @@
         // accessibility support
         format: t.format,
         formatType: t.formatType
     }), n;
 }
 
 function EI(e, t, n) {
-    const i = ne(e.signals),
-        r = ne(e.scales);
-    return n || i.forEach((s) => tI(s, t)), ne(e.projections).forEach((s) => Wfe(s, t)), r.forEach((s) => Nfe(s, t)), ne(e.data).forEach((s) => Vde(s, t)), r.forEach((s) => Ofe(s, t)), (n || i).forEach((s) => ffe(s, t)), ne(e.axes).forEach((s) => fhe(s, t)), ne(e.marks).forEach((s) => Fy(s, t)), ne(e.legends).forEach((s) => Rde(s, t)), e.title && jde(e.title, t), t.parseLambdas(), t;
+    const i = re(e.signals),
+        r = re(e.scales);
+    return n || i.forEach((s) => tI(s, t)), re(e.projections).forEach((s) => Wfe(s, t)), r.forEach((s) => Nfe(s, t)), re(e.data).forEach((s) => Vde(s, t)), r.forEach((s) => Ofe(s, t)), (n || i).forEach((s) => ffe(s, t)), re(e.axes).forEach((s) => fhe(s, t)), re(e.marks).forEach((s) => Fy(s, t)), re(e.legends).forEach((s) => Rde(s, t)), e.title && jde(e.title, t), t.parseLambdas(), t;
 }
-const hhe = (e) => Cf({
+const hhe = (e) => $f({
     enter: {
         x: {
             value: 0
         },
         y: {
             value: 0
         }
@@ -32954,37 +32941,37 @@
             signal: "height"
         }
     }
 }, e);
 
 function ghe(e, t) {
     const n = t.config,
-        i = pe(t.root = t.add(B0())),
+        i = ye(t.root = t.add(B0())),
         r = phe(e, n);
     r.forEach((l) => tI(l, t)), t.description = e.description || n.description, t.eventConfig = n.events, t.legends = t.objectProperty(n.legend && n.legend.layout), t.locale = n.locale;
     const s = t.add(Pr()),
-        o = t.add(rI(eI(hhe(e.encode), Cy, r5, e.style, t, {
-            pulse: pe(s)
+        o = t.add(rI(eI(hhe(e.encode), $y, r5, e.style, t, {
+            pulse: ye(s)
         }))),
         a = t.add(aI({
             layout: t.objectProperty(e.layout),
             legends: t.legends,
             autosize: t.signalRef("autosize"),
             mark: i,
-            pulse: pe(o)
+            pulse: ye(o)
         }));
-    t.operators.pop(), t.pushState(pe(o), pe(a), null), EI(e, t, r), t.operators.push(a);
+    t.operators.pop(), t.pushState(ye(o), ye(a), null), EI(e, t, r), t.operators.push(a);
     let u = t.add(iI({
         mark: i,
-        pulse: pe(a)
+        pulse: ye(a)
     }));
     return u = t.add(oI({
-        pulse: pe(u)
+        pulse: ye(u)
     })), u = t.add(xl({
-        pulse: pe(u)
+        pulse: ye(u)
     })), t.addData("root", new Ku(t, s, s, u)), t;
 }
 
 function od(e, t) {
     return t && t.signal ? {
         name: e,
         update: t.signal
@@ -32995,18 +32982,18 @@
 }
 
 function phe(e, t) {
     const n = (o) => vr(e[o], t[o]),
         i = [od("background", n("background")), od("autosize", Ece(n("autosize"))), od("padding", kce(n("padding"))), od("width", n("width") || 0), od("height", n("height") || 0)],
         r = i.reduce((o, a) => (o[a.name] = a, o), {}),
         s = {};
-    return ne(e.signals).forEach((o) => {
-        be(r, o.name) ? o = Ce(r[o.name], o) : i.push(o), s[o.name] = o;
-    }), ne(t.signals).forEach((o) => {
-        !be(s, o.name) && !be(r, o.name) && i.push(o);
+    return re(e.signals).forEach((o) => {
+        xe(r, o.name) ? o = $e(r[o.name], o) : i.push(o), s[o.name] = o;
+    }), re(t.signals).forEach((o) => {
+        !xe(s, o.name) && !xe(r, o.name) && i.push(o);
     }), i;
 }
 
 function SI(e, t) {
     this.config = e || {}, this.options = t || {}, this.bindings = [], this.field = {}, this.signals = {}, this.lambdas = {}, this.scales = {}, this.events = {}, this.data = {}, this.streams = [], this.updates = [], this.operators = [], this.eventConfig = null, this.locale = null, this._id = 0, this._subid = 0, this._nextsub = [0], this._parent = [], this._encode = [], this._lookup = [], this._markpath = [];
 }
 
@@ -33039,15 +33026,15 @@
     },
     add(e) {
         return this.operators.push(e), e.id = this.id(), e.refs && (e.refs.forEach((t) => {
             t.$ref = e.id;
         }), e.refs = null), e;
     },
     proxy(e) {
-        const t = e instanceof dw ? pe(e) : e;
+        const t = e instanceof dw ? ye(e) : e;
         return this.add(Afe({
             value: t
         }));
     },
     addStream(e) {
         return this.streams.push(e), e.id = this.id(), e;
     },
@@ -33072,17 +33059,17 @@
             for (const i in t.index)
                 n(t.index[i], e, "index:" + i);
         }
         return this;
     },
     // ----
     pushState(e, t, n) {
-        this._encode.push(pe(this.add(xl({
+        this._encode.push(ye(this.add(xl({
             pulse: e
-        })))), this._parent.push(t), this._lookup.push(n ? pe(this.proxy(n)) : null), this._markpath.push(-1);
+        })))), this._parent.push(t), this._lookup.push(n ? ye(this.proxy(n)) : null), this._markpath.push(-1);
     },
     popState() {
         this._encode.pop(), this._parent.pop(), this._lookup.pop(), this._markpath.pop();
     },
     parent() {
         return Ie(this._parent);
     },
@@ -33094,52 +33081,52 @@
     },
     markpath() {
         const e = this._markpath;
         return ++e[e.length - 1];
     },
     // ----
     fieldRef(e, t) {
-        if (ie(e))
+        if (se(e))
             return Oh(e, t);
-        e.signal || q("Unsupported field reference: " + Z(e));
+        e.signal || W("Unsupported field reference: " + ee(e));
         const n = e.signal;
         let i = this.field[n];
         if (!i) {
             const r = {
                 name: this.signalRef(n)
             };
-            t && (r.as = t), this.field[n] = i = pe(this.add(mfe(r)));
+            t && (r.as = t), this.field[n] = i = ye(this.add(mfe(r)));
         }
         return i;
     },
     compareRef(e) {
         let t = !1;
-        const n = (s) => Nt(s) ? (t = !0, this.signalRef(s.signal)) : tfe(s) ? (t = !0, this.exprRef(s.expr)) : s,
-            i = ne(e.field).map(n),
-            r = ne(e.order).map(n);
-        return t ? pe(this.add(w8({
+        const n = (s) => Ot(s) ? (t = !0, this.signalRef(s.signal)) : tfe(s) ? (t = !0, this.exprRef(s.expr)) : s,
+            i = re(e.field).map(n),
+            r = re(e.order).map(n);
+        return t ? ye(this.add(w8({
             fields: i,
             orders: r
         }))) : v8(i, r);
     },
     keyRef(e, t) {
         let n = !1;
-        const i = (s) => Nt(s) ? (n = !0, pe(r[s.signal])) : s,
+        const i = (s) => Ot(s) ? (n = !0, ye(r[s.signal])) : s,
             r = this.signals;
-        return e = ne(e).map(i), n ? pe(this.add(yfe({
+        return e = re(e).map(i), n ? ye(this.add(yfe({
             fields: e,
             flat: t
         }))) : Jce(e, t);
     },
     sortRef(e) {
         if (!e)
             return e;
         const t = Ay(e.op, e.field),
             n = e.order || Qce;
-        return n.signal ? pe(this.add(w8({
+        return n.signal ? ye(this.add(w8({
             fields: t,
             orders: this.signalRef(n.signal)
         }))) : v8(t, n);
     },
     // ----
     event(e, t) {
         const n = e + ":" + t;
@@ -33151,110 +33138,110 @@
                 type: t
             }), this.events[n] = i;
         }
         return this.events[n];
     },
     // ----
     hasOwnSignal(e) {
-        return be(this.signals, e);
+        return xe(this.signals, e);
     },
     addSignal(e, t) {
-        this.hasOwnSignal(e) && q("Duplicate signal name: " + Z(e));
+        this.hasOwnSignal(e) && W("Duplicate signal name: " + ee(e));
         const n = t instanceof dw ? t : this.add(B0(t));
         return this.signals[e] = n;
     },
     getSignal(e) {
-        return this.signals[e] || q("Unrecognized signal name: " + Z(e)), this.signals[e];
+        return this.signals[e] || W("Unrecognized signal name: " + ee(e)), this.signals[e];
     },
     signalRef(e) {
-        return this.signals[e] ? pe(this.signals[e]) : (be(this.lambdas, e) || (this.lambdas[e] = this.add(B0(null))), pe(this.lambdas[e]));
+        return this.signals[e] ? ye(this.signals[e]) : (xe(this.lambdas, e) || (this.lambdas[e] = this.add(B0(null))), ye(this.lambdas[e]));
     },
     parseLambdas() {
         const e = Object.keys(this.lambdas);
         for (let t = 0, n = e.length; t < n; ++t) {
             const i = e[t],
                 r = bs(i, this),
                 s = this.lambdas[i];
             s.params = r.$params, s.update = r.$expr;
         }
     },
     property(e) {
         return e && e.signal ? this.signalRef(e.signal) : e;
     },
     objectProperty(e) {
-        return !e || !re(e) ? e : this.signalRef(e.signal || y5(e));
+        return !e || !oe(e) ? e : this.signalRef(e.signal || y5(e));
     },
     exprRef(e, t) {
         const n = {
             expr: bs(e, this)
         };
-        return t && (n.expr.$name = t), pe(this.add(gfe(n)));
+        return t && (n.expr.$name = t), ye(this.add(gfe(n)));
     },
     addBinding(e, t) {
-        this.bindings || q("Nested signals do not support binding: " + Z(e)), this.bindings.push(Ce({
+        this.bindings || W("Nested signals do not support binding: " + ee(e)), this.bindings.push($e({
             signal: e
         }, t));
     },
     // ----
     addScaleProj(e, t) {
-        be(this.scales, e) && q("Duplicate scale or projection name: " + Z(e)), this.scales[e] = this.add(t);
+        xe(this.scales, e) && W("Duplicate scale or projection name: " + ee(e)), this.scales[e] = this.add(t);
     },
     addScale(e, t) {
-        this.addScaleProj(e, Cfe(t));
+        this.addScaleProj(e, $fe(t));
     },
     addProjection(e, t) {
         this.addScaleProj(e, kfe(t));
     },
     getScale(e) {
-        return this.scales[e] || q("Unrecognized scale name: " + Z(e)), this.scales[e];
+        return this.scales[e] || W("Unrecognized scale name: " + ee(e)), this.scales[e];
     },
     scaleRef(e) {
-        return pe(this.getScale(e));
+        return ye(this.getScale(e));
     },
     scaleType(e) {
         return this.getScale(e).params.type;
     },
     projectionRef(e) {
         return this.scaleRef(e);
     },
     projectionType(e) {
         return this.scaleType(e);
     },
     // ----
     addData(e, t) {
-        return be(this.data, e) && q("Duplicate data set name: " + Z(e)), this.data[e] = t;
+        return xe(this.data, e) && W("Duplicate data set name: " + ee(e)), this.data[e] = t;
     },
     getData(e) {
-        return this.data[e] || q("Undefined data set name: " + Z(e)), this.data[e];
+        return this.data[e] || W("Undefined data set name: " + ee(e)), this.data[e];
     },
     addDataPipeline(e, t) {
-        return be(this.data, e) && q("Duplicate data set name: " + Z(e)), this.addData(e, Ku.fromEntries(this, t));
+        return xe(this.data, e) && W("Duplicate data set name: " + ee(e)), this.addData(e, Ku.fromEntries(this, t));
     }
 };
 
 function y5(e) {
-    return (W(e) ? mhe : yhe)(e);
+    return (V(e) ? mhe : yhe)(e);
 }
 
 function mhe(e) {
     const t = e.length;
     let n = "[";
     for (let i = 0; i < t; ++i) {
         const r = e[i];
-        n += (i > 0 ? "," : "") + (re(r) ? r.signal || y5(r) : Z(r));
+        n += (i > 0 ? "," : "") + (oe(r) ? r.signal || y5(r) : ee(r));
     }
     return n + "]";
 }
 
 function yhe(e) {
     let t = "{",
         n = 0,
         i, r;
     for (i in e)
-        r = e[i], t += (++n > 1 ? "," : "") + Z(i) + ":" + (re(r) ? r.signal || y5(r) : Z(r));
+        r = e[i], t += (++n > 1 ? "," : "") + ee(i) + ":" + (oe(r) ? r.signal || y5(r) : ee(r));
     return t + "}";
 }
 
 function bhe() {
     const e = "sans-serif",
         i = "#4c78a8",
         r = "#000",
@@ -33472,41 +33459,41 @@
             },
             symbol: ["circle", "square", "triangle-up", "cross", "diamond", "triangle-right", "triangle-down", "triangle-left"]
         }
     };
 }
 
 function vhe(e, t, n) {
-    return re(e) || q("Input Vega specification must be an object."), t = ff(bhe(), t, e.config), ghe(e, new SI(t, n)).toRuntime();
+    return oe(e) || W("Input Vega specification must be an object."), t = ff(bhe(), t, e.config), ghe(e, new SI(t, n)).toRuntime();
 }
 var xhe = "5.28.0";
-Ce(Cc, PX, rte, Lte, lie, ire, Tse, lse, Nse, noe, doe, voe);
+$e($c, PX, rte, Lte, lie, ire, Tse, lse, Nse, noe, doe, voe);
 const whe = /* @__PURE__ */ Object.freeze( /* @__PURE__ */ Object.defineProperty({
     __proto__: null,
     Bounds: $t,
     CanvasHandler: Ea,
     CanvasRenderer: wh,
     DATE: ui,
-    DAY: fn,
+    DAY: dn,
     DAYOFYEAR: ps,
     Dataflow: fc,
     Debug: G9,
     Error: b_,
     EventStream: S1,
     Gradient: lO,
     GroupItem: ey,
-    HOURS: Ci,
+    HOURS: $i,
     Handler: _a,
     HybridHandler: jS,
     HybridRenderer: r0,
     Info: H9,
     Item: Z1,
     MILLISECONDS: Nr,
     MINUTES: Mi,
-    MONTH: wn,
+    MONTH: _n,
     Marks: Ti,
     MultiPulse: q_,
     None: W9,
     Operator: et,
     Parameters: E1,
     Pulse: sa,
     QUARTER: ai,
@@ -33517,90 +33504,90 @@
     SVGHandler: RS,
     SVGRenderer: uy,
     SVGStringRenderer: US,
     Scenegraph: OS,
     TIME_UNITS: R_,
     Transform: B,
     View: jL,
-    WEEK: Tt,
+    WEEK: Ft,
     Warn: v_,
-    YEAR: tn,
+    YEAR: nn,
     accessor: hi,
-    accessorFields: bn,
-    accessorName: _t,
-    array: ne,
+    accessorFields: vn,
+    accessorName: Et,
+    array: re,
     ascending: p1,
     bandwidthNRD: V_,
     bin: PT,
     bootstrapCI: zT,
     boundClip: oD,
     boundContext: hg,
     boundItem: hx,
-    boundMark: CO,
+    boundMark: $O,
     boundStroke: _o,
     changeset: ml,
     clampRange: iM,
     codegenExpression: pL,
     compare: S_,
-    constant: kn,
+    constant: An,
     cumulativeLogNormal: Z_,
     cumulativeNormal: A1,
     cumulativeUniform: iE,
     dayofyear: HM,
     debounce: k_,
     defaultLocale: P_,
     definition: RT,
     densityLogNormal: Q_,
     densityNormal: Y_,
     densityUniform: nE,
-    domChild: Mt,
+    domChild: Tt,
     domClear: Bi,
     domCreate: Go,
     domFind: DS,
     dotbin: BT,
-    error: q,
-    expressionFunction: At,
-    extend: Ce,
+    error: W,
+    expressionFunction: Ct,
+    extend: $e,
     extent: hs,
     extentIndex: rM,
     falsy: Ro,
     fastmap: hf,
     field: Ki,
     flush: sM,
     font: sy,
     fontFamily: mg,
-    fontSize: $s,
+    fontSize: Cs,
     format: Kp,
     formatLocale: Dm,
     formats: U_,
-    hasOwnProperty: be,
+    hasOwnProperty: xe,
     id: Kh,
-    identity: Sn,
+    identity: kn,
     inferType: ST,
     inferTypes: kT,
     ingest: Ge,
-    inherits: Q,
+    inherits: Z,
     inrange: ic,
     interpolate: lS,
     interpolateColors: J1,
     interpolateRange: XN,
     intersect: nD,
     intersectBoxLine: rc,
     intersectPath: bS,
     intersectPoint: vS,
     intersectRule: yO,
-    isArray: W,
+    isArray: V,
     isBoolean: Oa,
     isDate: na,
     isFunction: Me,
     isIterable: oM,
     isNumber: ze,
-    isObject: re,
+    isObject: oe,
     isRegExp: aM,
-    isString: ie,
+    isString: se,
     isTuple: w1,
     key: A_,
     lerp: uM,
     lineHeight: xa,
     loader: v1,
     locale: _T,
     logger: x_,
@@ -33626,15 +33613,15 @@
     pathRender: yh,
     pathSymbols: fO,
     pathTrail: hO,
     peek: Ie,
     point: ay,
     projection: l3,
     quantileLogNormal: eE,
-    quantileNormal: $1,
+    quantileNormal: C1,
     quantileUniform: rE,
     quantiles: H_,
     quantizeInterpolator: KN,
     quarter: tM,
     quartiles: G_,
     get random() {
         return tr;
@@ -33642,29 +33629,29 @@
     randomInteger: jY,
     randomKDE: K_,
     randomLCG: UY,
     randomLogNormal: jT,
     randomMixture: qT,
     randomNormal: X_,
     randomUniform: WT,
-    read: CT,
+    read: $T,
     regressionConstant: sE,
     regressionExp: GT,
     regressionLinear: oE,
     regressionLoess: XT,
     regressionLog: HT,
     regressionPoly: YT,
     regressionPow: VT,
     regressionQuad: aE,
     renderModule: ly,
     repeat: md,
     resetDefaultLocale: PV,
     resetSVGClipId: pO,
     resetSVGDefIds: _ee,
-    responseType: $T,
+    responseType: CT,
     runtimeContext: ML,
     sampleCurve: M1,
     sampleLogNormal: J_,
     sampleNormal: k1,
     sampleUniform: tE,
     scale: qe,
     sceneEqual: qS,
@@ -33675,34 +33662,34 @@
     sceneZOrder: xS,
     scheme: cS,
     serializeXML: VO,
     setHybridRendererOptions: bee,
     setRandom: zY,
     span: Jh,
     splitAccessPath: As,
-    stringValue: Z,
+    stringValue: ee,
     textMetrics: ki,
     timeBin: uT,
     timeFloor: QM,
     timeFormatLocale: dh,
     timeInterval: bf,
     timeOffset: tT,
     timeSequence: rT,
     timeUnitSpecifier: WM,
     timeUnits: L_,
-    toBoolean: $_,
-    toDate: C_,
-    toNumber: dn,
+    toBoolean: C_,
+    toDate: $_,
+    toNumber: hn,
     toSet: Fr,
     toString: M_,
     transform: LT,
-    transforms: Cc,
+    transforms: $c,
     truncate: dM,
     truthy: Ji,
-    tupleid: me,
+    tupleid: be,
     typeParsers: K2,
     utcFloor: ZM,
     utcInterval: vf,
     utcOffset: nT,
     utcSequence: sT,
     utcdayofyear: YM,
     utcquarter: nM,
@@ -33710,15 +33697,15 @@
     version: xhe,
     visitArray: zo,
     week: GM,
     writeConfig: df,
     zero: Wo,
     zoomLinear: w_,
     zoomLog: __,
-    zoomPow: Cm,
+    zoomPow: $m,
     zoomSymlog: E_
 }, Symbol.toStringTag, {
     value: "Module"
 }));
 
 function _he(e, t, n) {
     let i;
@@ -33765,16 +33752,16 @@
         "!": (e) => !e
     };
 const Ahe = Array.prototype.slice,
     eu = (e, t, n) => {
         const i = n ? n(t[0]) : t[0];
         return i[e].apply(i, Ahe.call(t, 1));
     },
-    $he = (e, t, n, i, r, s, o) => new Date(e, t || 0, n ?? 1, i || 0, r || 0, s || 0, o || 0);
-var Che = {
+    Che = (e, t, n, i, r, s, o) => new Date(e, t || 0, n ?? 1, i || 0, r || 0, s || 0, o || 0);
+var $he = {
     // math functions
     isNaN: Number.isNaN,
     isFinite: Number.isFinite,
     abs: Math.abs,
     acos: Math.acos,
     asin: Math.asin,
     atan: Math.atan,
@@ -33792,15 +33779,15 @@
     sin: Math.sin,
     sqrt: Math.sqrt,
     tan: Math.tan,
     clamp: (e, t, n) => Math.max(t, Math.min(n, e)),
     // date functions
     now: Date.now,
     utc: Date.UTC,
-    datetime: $he,
+    datetime: Che,
     date: (e) => new Date(e).getDate(),
     day: (e) => new Date(e).getDay(),
     year: (e) => new Date(e).getFullYear(),
     month: (e) => new Date(e).getMonth(),
     hours: (e) => new Date(e).getHours(),
     minutes: (e) => new Date(e).getMinutes(),
     seconds: (e) => new Date(e).getSeconds(),
@@ -33868,15 +33855,15 @@
             return;
         }
         return i[r];
     },
     CallExpression: (e, t) => {
         const n = t.arguments;
         let i = t.callee.name;
-        return i.startsWith("_") && (i = i.slice(1)), i === "if" ? e(n[0]) ? e(n[1]) : e(n[2]) : (e.fn[i] || Che[i]).apply(e.fn, n.map(e));
+        return i.startsWith("_") && (i = i.slice(1)), i === "if" ? e(n[0]) ? e(n[1]) : e(n[2]) : (e.fn[i] || $he[i]).apply(e.fn, n.map(e));
     },
     ArrayExpression: (e, t) => t.elements.map(e),
     BinaryExpression: (e, t) => She[t.operator](e(t.left), e(t.right)),
     UnaryExpression: (e, t) => khe[t.operator](e(t.argument)),
     ConditionalExpression: (e, t) => e(t.test) ? e(t.consequent) : e(t.alternate),
     LogicalExpression: (e, t) => t.operator === "&&" ? e(t.left) && e(t.right) : e(t.left) || e(t.right),
     ObjectExpression: (e, t) => t.properties.reduce((n, i) => {
@@ -34150,15 +34137,15 @@
 function kI(e) {
     throw new Error(e);
 }
 
 function jc(e, t) {
     const n = {};
     for (const i of t)
-        be(e, i) && (n[i] = e[i]);
+        xe(e, i) && (n[i] = e[i]);
     return n;
 }
 
 function ii(e, t) {
     const n = {
         ...e
     };
@@ -34169,15 +34156,15 @@
 Set.prototype.toJSON = function() {
     return `Set(${[...this].map((e) => Qe(e)).join(",")})`;
 };
 
 function Oe(e) {
     if (ze(e))
         return e;
-    const t = ie(e) ? e : Qe(e);
+    const t = se(e) ? e : Qe(e);
     if (t.length < 250)
         return t;
     let n = 0;
     for (let i = 0; i < t.length; i++) {
         const r = t.charCodeAt(i);
         n = (n << 5) - n + r, n = n & n;
     }
@@ -34211,39 +34198,39 @@
 function AI(e, ...t) {
     for (const n of t)
         tge(e, n ?? {});
     return e;
 }
 
 function tge(e, t) {
-    for (const n of Y(t))
+    for (const n of X(t))
         df(e, n, t[n], !0);
 }
 
 function rs(e, t) {
     const n = [],
         i = {};
     let r;
     for (const s of e)
         r = t(s), !(r in i) && (i[r] = 1, n.push(s));
     return n;
 }
 
 function nge(e, t) {
-    const n = Y(e),
-        i = Y(t);
+    const n = X(e),
+        i = X(t);
     if (n.length !== i.length)
         return !1;
     for (const r of n)
         if (e[r] !== t[r])
             return !1;
     return !0;
 }
 
-function $I(e, t) {
+function CI(e, t) {
     if (e.size !== t.size)
         return !1;
     for (const n of e)
         if (!t.has(n))
             return !1;
     return !0;
 }
@@ -34267,18 +34254,18 @@
 }
 
 function E5(e, t) {
     return e === void 0 || t === void 0 ? !0 : _5(ww(e), ww(t));
 }
 
 function Je(e) {
-    return Y(e).length === 0;
+    return X(e).length === 0;
 }
-const Y = Object.keys,
-    nn = Object.values,
+const X = Object.keys,
+    rn = Object.values,
     Aa = Object.entries;
 
 function Lh(e) {
     return e === !0 || e === !1;
 }
 
 function ft(e) {
@@ -34293,30 +34280,30 @@
 function U0(e, t) {
     if (t.length === 0)
         return !0;
     const n = t.shift();
     return n in e && U0(e[n], t) && delete e[n], Je(e);
 }
 
-function Cg(e) {
+function $g(e) {
     return e.charAt(0).toUpperCase() + e.substr(1);
 }
 
 function S5(e, t = "datum") {
     const n = As(e),
         i = [];
     for (let r = 1; r <= n.length; r++) {
-        const s = `[${n.slice(0, r).map(Z).join("][")}]`;
+        const s = `[${n.slice(0, r).map(ee).join("][")}]`;
         i.push(`${t}${s}`);
     }
     return i.join(" && ");
 }
 
-function CI(e, t = "datum") {
-    return `${t}[${Z(As(e).join("."))}]`;
+function $I(e, t = "datum") {
+    return `${t}[${ee(As(e).join("."))}]`;
 }
 
 function ige(e) {
     return e.replace(/(\[|\]|\.|'|")/g, "\\$1");
 }
 
 function sr(e) {
@@ -34331,15 +34318,15 @@
     return `${As(e).join(".")}`;
 }
 
 function qc(e) {
     return e ? As(e).length : 0;
 }
 
-function St(...e) {
+function kt(...e) {
     for (const t of e)
         if (t !== void 0)
             return t;
 }
 let MI = 42;
 
 function TI(e) {
@@ -34462,15 +34449,15 @@
         return t.splice(o, 1), `{${s}}`;
     }(e);
 }
 const uo = "row",
     lo = "column",
     Dy = "facet",
     ht = "x",
-    Yt = "y",
+    Xt = "y",
     Br = "x2",
     Fs = "y2",
     Ba = "xOffset",
     Ff = "yOffset",
     Ur = "radius",
     So = "radius2",
     lr = "theta",
@@ -34481,15 +34468,15 @@
     or = "longitude2",
     ci = "color",
     Ns = "fill",
     Os = "stroke",
     fi = "shape",
     Ao = "size",
     _l = "angle",
-    $o = "opacity",
+    Co = "opacity",
     Ua = "fillOpacity",
     ja = "strokeOpacity",
     qa = "strokeWidth",
     Wa = "strokeDash",
     Mg = "text",
     Wc = "order",
     Tg = "detail",
@@ -34533,16 +34520,16 @@
             return "x2";
     }
 }
 
 function LI(e) {
     return e in A5;
 }
-const oge = Y(A5),
-    $5 = {
+const oge = X(A5),
+    C5 = {
         ...sge,
         ...OI,
         ...A5,
         xOffset: 1,
         yOffset: 1,
         // color
         color: 1,
@@ -34572,65 +34559,65 @@
     return e === ci || e === Ns || e === Os;
 }
 const II = {
         row: 1,
         column: 1,
         facet: 1
     },
-    Hi = Y(II),
-    C5 = {
-        ...$5,
+    Hi = X(II),
+    $5 = {
+        ...C5,
         ...II
     },
-    age = Y(C5),
+    age = X($5),
     {
-        order: v$e,
-        detail: x$e,
-        tooltip: w$e,
+        order: vCe,
+        detail: xCe,
+        tooltip: wCe,
         ...uge
-    } = C5,
+    } = $5,
     {
-        row: _$e,
-        column: E$e,
-        facet: S$e,
+        row: _Ce,
+        column: ECe,
+        facet: SCe,
         ...lge
     } = uge;
 
 function cge(e) {
     return !!lge[e];
 }
 
 function PI(e) {
-    return !!C5[e];
+    return !!$5[e];
 }
 const fge = [Br, Fs, Wr, or, ko, So];
 
 function zI(e) {
     return El(e) !== e;
 }
 
 function El(e) {
     switch (e) {
         case Br:
             return ht;
         case Fs:
-            return Yt;
+            return Xt;
         case Wr:
             return jr;
         case or:
             return qr;
         case ko:
             return lr;
         case So:
             return Ur;
     }
     return e;
 }
 
-function $a(e) {
+function Ca(e) {
     if (DI(e))
         switch (e) {
             case lr:
                 return "startAngle";
             case ko:
                 return "endAngle";
             case Ur:
@@ -34641,15 +34628,15 @@
     return e;
 }
 
 function Ds(e) {
     switch (e) {
         case ht:
             return Br;
-        case Yt:
+        case Xt:
             return Fs;
         case jr:
             return Wr;
         case qr:
             return or;
         case lr:
             return ko;
@@ -34659,25 +34646,25 @@
 }
 
 function di(e) {
     switch (e) {
         case ht:
         case Br:
             return "width";
-        case Yt:
+        case Xt:
         case Fs:
             return "height";
     }
 }
 
 function BI(e) {
     switch (e) {
         case ht:
             return "xOffset";
-        case Yt:
+        case Xt:
             return "yOffset";
         case Br:
             return "x2Offset";
         case Fs:
             return "y2Offset";
         case lr:
             return "thetaOffset";
@@ -34690,103 +34677,103 @@
     }
 }
 
 function M5(e) {
     switch (e) {
         case ht:
             return "xOffset";
-        case Yt:
+        case Xt:
             return "yOffset";
     }
 }
 
 function dge(e) {
     switch (e) {
         case "xOffset":
             return "x";
         case "yOffset":
             return "y";
     }
 }
-const hge = Y($5),
+const hge = X(C5),
     {
-        x: k$e,
-        y: A$e,
+        x: kCe,
+        y: ACe,
         // x2 and y2 share the same scale as x and y
-        x2: $$e,
-        y2: C$e,
+        x2: CCe,
+        y2: $Ce,
         //
-        xOffset: M$e,
-        yOffset: T$e,
-        latitude: F$e,
-        longitude: N$e,
-        latitude2: O$e,
-        longitude2: D$e,
-        theta: R$e,
-        theta2: L$e,
-        radius: I$e,
-        radius2: P$e,
+        xOffset: MCe,
+        yOffset: TCe,
+        latitude: FCe,
+        longitude: NCe,
+        latitude2: OCe,
+        longitude2: DCe,
+        theta: RCe,
+        theta2: LCe,
+        radius: ICe,
+        radius2: PCe,
         // The rest of unit channels then have scale
         ...T5
-    } = $5,
-    gge = Y(T5),
+    } = C5,
+    gge = X(T5),
     F5 = {
         x: 1,
         y: 1
     },
-    Rs = Y(F5);
+    Rs = X(F5);
 
-function kt(e) {
+function At(e) {
     return e in F5;
 }
 const N5 = {
         theta: 1,
         radius: 1
     },
-    pge = Y(N5);
+    pge = X(N5);
 
 function zy(e) {
-    return e === "width" ? ht : Yt;
+    return e === "width" ? ht : Xt;
 }
 const UI = {
     xOffset: 1,
     yOffset: 1
 };
 
 function Fg(e) {
     return e in UI;
 }
 const {
     // x2 and y2 share the same scale as x and y
     // text and tooltip have format instead of scale,
     // href has neither format, nor scale
-    text: z$e,
-    tooltip: B$e,
-    href: U$e,
-    url: j$e,
-    description: q$e,
+    text: zCe,
+    tooltip: BCe,
+    href: UCe,
+    url: jCe,
+    description: qCe,
     // detail and order have no scale
-    detail: W$e,
-    key: H$e,
-    order: G$e,
+    detail: WCe,
+    key: HCe,
+    order: GCe,
     ...jI
-} = T5, mge = Y(jI);
+} = T5, mge = X(jI);
 
 function yge(e) {
     return !!T5[e];
 }
 
 function bge(e) {
     switch (e) {
         case ci:
         case Ns:
         case Os:
         case Ao:
         case fi:
-        case $o:
+        case Co:
         case qa:
         case Wa:
             return !0;
         case Ua:
         case ja:
         case _l:
             return !1;
@@ -34794,17 +34781,17 @@
 }
 const qI = {
         ...F5,
         ...N5,
         ...UI,
         ...jI
     },
-    By = Y(qI);
+    By = X(qI);
 
-function Co(e) {
+function $o(e) {
     return !!qI[e];
 }
 
 function vge(e, t) {
     return wge(e)[t];
 }
 const WI = {
@@ -34821,39 +34808,39 @@
         rect: "always",
         square: "always",
         trail: "always",
         text: "always",
         tick: "always"
     },
     {
-        geoshape: V$e,
+        geoshape: VCe,
         ...xge
     } = WI;
 
 function wge(e) {
     switch (e) {
         case ci:
         case Ns:
         case Os:
         case Py:
         case Tg:
         case Ry:
         case Zu:
         case Ly:
         case Wc:
-        case $o:
+        case Co:
         case Ua:
         case ja:
         case qa:
         case Dy:
         case uo:
         case lo:
             return WI;
         case ht:
-        case Yt:
+        case Xt:
         case Ba:
         case Ff:
         case jr:
         case qr:
             return xge;
         case Br:
         case Fs:
@@ -34926,23 +34913,23 @@
             };
     }
 }
 
 function Hv(e) {
     switch (e) {
         case ht:
-        case Yt:
+        case Xt:
         case lr:
         case Ur:
         case Ba:
         case Ff:
         case Ao:
         case _l:
         case qa:
-        case $o:
+        case Co:
         case Ua:
         case ja:
         case Br:
         case Fs:
         case ko:
         case So:
             return;
@@ -35009,61 +34996,61 @@
 }
 
 function Ha(e) {
     return !!e && !!e.argmax;
 }
 
 function O5(e) {
-    return ie(e) && !!_ge[e];
+    return se(e) && !!_ge[e];
 }
 const Sge = /* @__PURE__ */ new Set([
     "count",
     "valid",
     "missing",
     "distinct"
 ]);
 
 function HI(e) {
-    return ie(e) && Sge.has(e);
+    return se(e) && Sge.has(e);
 }
 
 function kge(e) {
-    return ie(e) && De(["min", "max"], e);
+    return se(e) && De(["min", "max"], e);
 }
 const Age = /* @__PURE__ */ new Set([
         "count",
         "sum",
         "distinct",
         "valid",
         "missing"
     ]),
-    $ge = /* @__PURE__ */ new Set([
+    Cge = /* @__PURE__ */ new Set([
         "mean",
         "average",
         "median",
         "q1",
         "q3",
         "min",
         "max"
     ]);
 
 function GI(e) {
-    return Oa(e) && (e = Qy(e, void 0)), "bin" + Y(e).map((t) => Uy(e[t]) ? ft(`_${t}_${Aa(e[t])}`) : ft(`_${t}_${e[t]}`)).join("");
+    return Oa(e) && (e = Qy(e, void 0)), "bin" + X(e).map((t) => Uy(e[t]) ? ft(`_${t}_${Aa(e[t])}`) : ft(`_${t}_${e[t]}`)).join("");
 }
 
-function rt(e) {
+function st(e) {
     return e === !0 || Sl(e) && !e.binned;
 }
 
-function Jt(e) {
+function Qt(e) {
     return e === "binned" || Sl(e) && e.binned === !0;
 }
 
 function Sl(e) {
-    return re(e);
+    return oe(e);
 }
 
 function Uy(e) {
     return e == null ? void 0 : e.param;
 }
 
 function I8(e) {
@@ -35071,15 +35058,15 @@
         case uo:
         case lo:
         case Ao:
         case ci:
         case Ns:
         case Os:
         case qa:
-        case $o:
+        case Co:
         case Ua:
         case ja:
         case fi:
             return 6;
         case Wa:
             return 4;
         default:
@@ -35088,15 +35075,15 @@
 }
 
 function Ng(e) {
     return !!(e != null && e.expr);
 }
 
 function Zn(e) {
-    const t = Y(e || {}),
+    const t = X(e || {}),
         n = {};
     for (const i of t)
         n[i] = bi(e[i]);
     return n;
 }
 
 function VI(e) {
@@ -35172,35 +35159,35 @@
         subtitleMarkConfig: v,
         nonMarkTitleProperties: y,
         subtitle: b
     };
 }
 
 function qo(e) {
-    return ie(e) || W(e) && ie(e[0]);
+    return se(e) || V(e) && se(e[0]);
 }
 
 function de(e) {
     return !!(e != null && e.signal);
 }
 
 function Ga(e) {
     return !!e.step;
 }
 
-function Cge(e) {
-    return W(e) ? !1 : "fields" in e && !("data" in e);
+function $ge(e) {
+    return V(e) ? !1 : "fields" in e && !("data" in e);
 }
 
 function Mge(e) {
-    return W(e) ? !1 : "fields" in e && "data" in e;
+    return V(e) ? !1 : "fields" in e && "data" in e;
 }
 
 function oo(e) {
-    return W(e) ? !1 : "field" in e && "data" in e;
+    return V(e) ? !1 : "field" in e && "data" in e;
 }
 const Tge = {
         aria: 1,
         description: 1,
         ariaRole: 1,
         ariaRoleDescription: 1,
         blend: 1,
@@ -35262,15 +35249,15 @@
         // x2: 1,
         // y2: 1,
         // xc'|'yc'
         // clip: 1,
         // path: 1,
         // url: 1,
     },
-    Fge = Y(Tge),
+    Fge = X(Tge),
     Nge = {
         arc: 1,
         area: 1,
         group: 1,
         image: 1,
         line: 1,
         path: 1,
@@ -35286,15 +35273,15 @@
         "cornerRadiusTopLeft",
         "cornerRadiusTopRight",
         "cornerRadiusBottomLeft",
         "cornerRadiusBottomRight"
     ];
 
 function YI(e) {
-    const t = W(e.condition) ? e.condition.map(P8) : P8(e.condition);
+    const t = V(e.condition) ? e.condition.map(P8) : P8(e.condition);
     return {
         ...bi(e),
         condition: t
     };
 }
 
 function bi(e) {
@@ -35321,15 +35308,15 @@
             signal: t,
             ...n
         };
     }
     return e;
 }
 
-function at(e) {
+function ut(e) {
     if (Ng(e)) {
         const {
             expr: t,
             ...n
         } = e;
         return {
             signal: t,
@@ -35338,29 +35325,29 @@
     }
     return de(e) ? e : e !== void 0 ? {
         value: e
     } : void 0;
 }
 
 function Oge(e) {
-    return de(e) ? e.signal : Z(e);
+    return de(e) ? e.signal : ee(e);
 }
 
 function z8(e) {
-    return de(e) ? e.signal : Z(e.value);
+    return de(e) ? e.signal : ee(e.value);
 }
 
 function kr(e) {
-    return de(e) ? e.signal : e == null ? null : Z(e);
+    return de(e) ? e.signal : e == null ? null : ee(e);
 }
 
 function Dge(e, t, n) {
     for (const i of n) {
         const r = vo(i, t.markDef, t.config);
-        r !== void 0 && (e[i] = at(r));
+        r !== void 0 && (e[i] = ut(r));
     }
     return e;
 }
 
 function XI(e) {
     return [].concat(e.type, e.style ?? []);
 }
@@ -35372,15 +35359,15 @@
     } = i;
     return r && t[r] !== void 0 ? t[r] : t[e] !== void 0 ? t[e] : s && (!r || r === e) ? void 0 : vo(e, t, n, i);
 }
 
 function vo(e, t, n, {
     vgChannel: i
 } = {}) {
-    return St(
+    return kt(
         // style config has highest precedence
         i ? j0(e, t, n.style) : void 0,
         j0(e, t, n.style),
         // then mark-specific config
         i ? n[t.type][i] : void 0,
         n[t.type][e],
         // Need to cast because MarkDef doesn't perfectly match with AnyMarkConfig, but if the type isn't available, we'll get nothing here, which is fine
@@ -35392,25 +35379,25 @@
 }
 
 function j0(e, t, n) {
     return KI(e, XI(t), n);
 }
 
 function KI(e, t, n) {
-    t = ne(t);
+    t = re(t);
     let i;
     for (const r of t) {
         const s = n[r];
         s && s[e] !== void 0 && (i = s[e]);
     }
     return i;
 }
 
 function JI(e, t) {
-    return ne(e).reduce((n, i) => (n.field.push(te(i, t)), n.order.push(i.sort ?? "ascending"), n), {
+    return re(e).reduce((n, i) => (n.field.push(ne(i, t)), n.order.push(i.sort ?? "ascending"), n), {
         field: [],
         order: []
     });
 }
 
 function QI(e, t) {
     const n = [...e];
@@ -35419,15 +35406,15 @@
             if (wi(r, i))
                 return;
         n.push(i);
     }), n;
 }
 
 function ZI(e, t) {
-    return wi(e, t) || !t ? e : e ? [...ne(e), ...ne(t)].join(", ") : t;
+    return wi(e, t) || !t ? e : e ? [...re(e), ...re(t)].join(", ") : t;
 }
 
 function eP(e, t) {
     const n = e.value,
         i = t.value;
     if (n == null || i === null)
         return {
@@ -35676,17 +35663,17 @@
 
 function Spe(e) {
     return `Dropping sort property ${Qe(e)} as unioned domains only support boolean or op "count", "min", and "max".`;
 }
 const V8 = "Domains that should be unioned has conflicting sort properties. Sort will be set to true.",
     kpe = "Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.",
     Ape = "Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.",
-    $pe = "Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.";
+    Cpe = "Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.";
 
-function Cpe(e) {
+function $pe(e) {
     return `Cannot stack "${e}" if there is already "${e}2".`;
 }
 
 function Mpe(e) {
     return `Cannot stack non-linear scale (${e}).`;
 }
 
@@ -35736,24 +35723,24 @@
     return Hc = e, Hc;
 }
 
 function Ppe() {
     return Hc = aP, Hc;
 }
 
-function K(...e) {
+function J(...e) {
     Hc.warn(...e);
 }
 
 function zpe(...e) {
     Hc.debug(...e);
 }
 
 function kl(e) {
-    if (e && re(e)) {
+    if (e && oe(e)) {
         for (const t of I5)
             if (t in e)
                 return !0;
     }
     return !1;
 }
 const uP = [
@@ -35772,15 +35759,15 @@
     ],
     Bpe = uP.map((e) => e.substr(0, 3)),
     lP = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"],
     Upe = lP.map((e) => e.substr(0, 3));
 
 function jpe(e) {
     if (Oy(e) && (e = +e), ze(e))
-        return e > 4 && K(q0("quarter", e)), e - 1;
+        return e > 4 && J(q0("quarter", e)), e - 1;
     throw new Error(q0("quarter", e));
 }
 
 function qpe(e) {
     if (Oy(e) && (e = +e), ze(e))
         return e - 1;
     {
@@ -35810,15 +35797,15 @@
             return r;
         throw new Error(q0("day", e));
     }
 }
 
 function L5(e, t) {
     const n = [];
-    if (t && e.day !== void 0 && Y(e).length > 1 && (K(Fpe(e)), e = ke(e), delete e.day), e.year !== void 0 ? n.push(e.year) : n.push(2012), e.month !== void 0) {
+    if (t && e.day !== void 0 && X(e).length > 1 && (J(Fpe(e)), e = ke(e), delete e.day), e.year !== void 0 ? n.push(e.year) : n.push(2012), e.month !== void 0) {
         const i = t ? qpe(e.month) : e.month;
         n.push(i);
     } else if (e.quarter !== void 0) {
         const i = t ? jpe(e.quarter) : e.quarter;
         n.push(ze(i) ? i * 3 : `${i}*3`);
     } else
         n.push(0);
@@ -35859,22 +35846,22 @@
         dayofyear: 1,
         date: 1,
         hours: 1,
         minutes: 1,
         seconds: 1,
         milliseconds: 1
     },
-    I5 = Y(cP);
+    I5 = X(cP);
 
 function Vpe(e) {
     return !!cP[e];
 }
 
 function Al(e) {
-    return re(e) ? e.binned : fP(e);
+    return oe(e) ? e.binned : fP(e);
 }
 
 function fP(e) {
     return e && e.startsWith("binned");
 }
 
 function P5(e) {
@@ -35931,41 +35918,41 @@
 function Jpe(e, t, n) {
     if (!e)
         return;
     const i = gP(e);
     return `${n || P5(e) ? "utc" : "time"}Format(${t}, ${i})`;
 }
 
-function Wt(e) {
+function Ht(e) {
     if (!e)
         return;
     let t;
-    return ie(e) ? fP(e) ? t = {
+    return se(e) ? fP(e) ? t = {
         unit: e.substring(6),
         binned: !0
     } : t = {
         unit: e
-    } : re(e) && (t = {
+    } : oe(e) && (t = {
         ...e,
         ...e.unit ? {
             unit: e.unit
         } : {}
     }), P5(t.unit) && (t.utc = !0, t.unit = Ype(t.unit)), t;
 }
 
 function Qpe(e) {
     const {
         utc: t,
         ...n
-    } = Wt(e);
-    return n.unit ? (t ? "utc" : "") + Y(n).map((i) => ft(`${i === "unit" ? "" : `_${i}_`}${n[i]}`)).join("") : (t ? "utc" : "") + "timeunit" + Y(n).map((i) => ft(`_${i}_${n[i]}`)).join("");
+    } = Ht(e);
+    return n.unit ? (t ? "utc" : "") + X(n).map((i) => ft(`${i === "unit" ? "" : `_${i}_`}${n[i]}`)).join("") : (t ? "utc" : "") + "timeunit" + X(n).map((i) => ft(`_${i}_${n[i]}`)).join("");
 }
 
 function pP(e, t = (n) => n) {
-    const n = Wt(e),
+    const n = Ht(e),
         i = dP(n.unit);
     if (i && i !== "day") {
         const r = {
                 year: 2001,
                 // pick a non-leap year
                 month: 1,
                 date: 1,
@@ -36044,24 +36031,24 @@
 
 function q5(e) {
     return !!(e != null && e.field) && e.gte !== void 0;
 }
 
 function W5(e) {
     if (e != null && e.field) {
-        if (W(e.range) && e.range.length === 2)
+        if (V(e.range) && e.range.length === 2)
             return !0;
         if (de(e.range))
             return !0;
     }
     return !1;
 }
 
 function H5(e) {
-    return !!(e != null && e.field) && (W(e.oneOf) || W(e.in));
+    return !!(e != null && e.field) && (V(e.oneOf) || V(e.in));
 }
 
 function nme(e) {
     return !!(e != null && e.field) && e.valid !== void 0;
 }
 
 function yP(e) {
@@ -36078,18 +36065,18 @@
 function ime(e, t) {
     return e.map((n) => Yr(n, t));
 }
 
 function bP(e, t = !0) {
     const {
         field: n
-    } = e, i = Wt(e.timeUnit), {
+    } = e, i = Ht(e.timeUnit), {
         unit: r,
         binned: s
-    } = i || {}, o = te(e, {
+    } = i || {}, o = ne(e, {
         expr: "datum"
     }), a = r ? (
         // For timeUnit, cast into integer with time() so we can use ===, inrange, indexOf to compare values directly.
         // TODO: We calculate timeUnit on the fly here. Consider if we would like to consolidate this with timeUnit pipeline
         // TODO: support utc
         `time(${s ? o : Kpe(r, n)})`
     ) : o;
@@ -36132,15 +36119,15 @@
 function G5(e, t = !0) {
     return t ? `isValid(${e}) && isFinite(+${e})` : `!isValid(${e}) || !isFinite(+${e})`;
 }
 
 function rme(e) {
     return yP(e) && e.timeUnit ? {
         ...e,
-        timeUnit: Wt(e.timeUnit)
+        timeUnit: Ht(e.timeUnit)
     } : e;
 }
 const Og = {
     quantitative: "quantitative",
     ordinal: "ordinal",
     temporal: "temporal",
     nominal: "nominal",
@@ -36283,15 +36270,15 @@
     cme = /* @__PURE__ */ new Set([
         "ordinal",
         "bin-ordinal",
         "point",
         "band"
     ]);
 
-function Ht(e) {
+function Gt(e) {
     return cme.has(e);
 }
 
 function Ni(e) {
     return lme.has(e);
 }
 
@@ -36320,27 +36307,27 @@
     maxStrokeWidth: 4,
     quantileCount: 4,
     quantizeCount: 4,
     zero: !0
 };
 
 function dme(e) {
-    return !ie(e) && !!e.name;
+    return !se(e) && !!e.name;
 }
 
 function SP(e) {
     return e == null ? void 0 : e.param;
 }
 
 function hme(e) {
     return e == null ? void 0 : e.unionWith;
 }
 
 function gme(e) {
-    return re(e) && "field" in e;
+    return oe(e) && "field" in e;
 }
 const pme = {
         type: 1,
         domain: 1,
         domainMax: 1,
         domainMin: 1,
         domainMid: 1,
@@ -36366,23 +36353,23 @@
         // zero depends on domain
         // band/point
         padding: 1,
         paddingInner: 1,
         paddingOuter: 1
     },
     {
-        type: Y$e,
-        domain: X$e,
-        range: K$e,
-        rangeMax: J$e,
-        rangeMin: Q$e,
-        scheme: Z$e,
+        type: YCe,
+        domain: XCe,
+        range: KCe,
+        rangeMax: JCe,
+        rangeMin: QCe,
+        scheme: ZCe,
         ...mme
     } = pme,
-    yme = Y(mme);
+    yme = X(mme);
 
 function kw(e, t) {
     switch (t) {
         case "type":
         case "domain":
         case "reverse":
         case "range":
@@ -36460,45 +36447,45 @@
         case "clamp":
         case "zero":
             return;
     }
 }
 
 function bme(e, t) {
-    return De([V5, Y5], t) ? e === void 0 || Ht(e) : t === Gc ? De([ri.TIME, ri.UTC, void 0], e) : t === tl ? _P(e) || Vc(e) || e === void 0 : !0;
+    return De([V5, Y5], t) ? e === void 0 || Gt(e) : t === Gc ? De([ri.TIME, ri.UTC, void 0], e) : t === tl ? _P(e) || Vc(e) || e === void 0 : !0;
 }
 
 function vme(e, t, n = !1) {
-    if (!Co(e))
+    if (!$o(e))
         return !1;
     switch (e) {
         case ht:
-        case Yt:
+        case Xt:
         case Ba:
         case Ff:
         case lr:
         case Ur:
             return Ar(t) || t === "band" ? !0 : t === "point" ? !n : !1;
         case Ao:
         case qa:
-        case $o:
+        case Co:
         case Ua:
         case ja:
         case _l:
             return Ar(t) || Vc(t) || De(["band", "point", "ordinal"], t);
         case ci:
         case Ns:
         case Os:
             return t !== "band";
         case Wa:
         case fi:
             return t === "ordinal" || Vc(t);
     }
 }
-const Gn = {
+const Vn = {
         arc: "arc",
         area: "area",
         bar: "bar",
         image: "image",
         line: "line",
         point: "point",
         rect: "rect",
@@ -36506,43 +36493,43 @@
         text: "text",
         tick: "tick",
         trail: "trail",
         circle: "circle",
         square: "square",
         geoshape: "geoshape"
     },
-    AP = Gn.arc,
-    Wy = Gn.area,
-    Hy = Gn.bar,
-    xme = Gn.image,
-    Gy = Gn.line,
-    Vy = Gn.point,
-    wme = Gn.rect,
-    W0 = Gn.rule,
-    $P = Gn.text,
-    X5 = Gn.tick,
-    _me = Gn.trail,
-    K5 = Gn.circle,
-    J5 = Gn.square,
-    CP = Gn.geoshape;
+    AP = Vn.arc,
+    Wy = Vn.area,
+    Hy = Vn.bar,
+    xme = Vn.image,
+    Gy = Vn.line,
+    Vy = Vn.point,
+    wme = Vn.rect,
+    W0 = Vn.rule,
+    CP = Vn.text,
+    X5 = Vn.tick,
+    _me = Vn.trail,
+    K5 = Vn.circle,
+    J5 = Vn.square,
+    $P = Vn.geoshape;
 
 function Va(e) {
     return ["line", "area", "trail"].includes(e);
 }
 
 function Ph(e) {
     return [
         "rect",
         "bar",
         "image",
         "arc"
         /* arc is rect/interval in polar coordinate */
     ].includes(e);
 }
-const Eme = new Set(Y(Gn));
+const Eme = new Set(X(Vn));
 
 function vs(e) {
     return e.type;
 }
 const Sme = [
         "stroke",
         "strokeWidth",
@@ -36550,26 +36537,26 @@
         "strokeDashOffset",
         "strokeOpacity",
         "strokeJoin",
         "strokeMiterLimit"
     ],
     kme = ["fill", "fillOpacity"],
     Ame = [...Sme, ...kme],
-    $me = {
+    Cme = {
         color: 1,
         filled: 1,
         invalid: 1,
         order: 1,
         radius2: 1,
         theta2: 1,
         timeUnitBandSize: 1,
         timeUnitBandPosition: 1
     },
-    K8 = Y($me),
-    Cme = {
+    K8 = X(Cme),
+    $me = {
         area: ["line", "point"],
         bar: ["binSpacing", "continuousBandSize", "discreteBandSize", "minBandSize"],
         rect: ["binSpacing", "continuousBandSize", "discreteBandSize", "minBandSize"],
         line: ["point"],
         tick: ["bandSize", "thickness"]
     },
     Mme = {
@@ -36590,15 +36577,15 @@
         rule: 1,
         square: 1,
         text: 1,
         tick: 1,
         trail: 1,
         geoshape: 1
     },
-    MP = Y(Tme);
+    MP = X(Tme);
 
 function nl(e) {
     return e && e.band != null;
 }
 const Fme = {
         horizontal: ["cornerRadiusTopRight", "cornerRadiusBottomRight"],
         vertical: ["cornerRadiusTopLeft", "cornerRadiusTopRight"]
@@ -36630,15 +36617,15 @@
         channelDef: n,
         markDef: i,
         scale: r,
         config: s
     } = e, o = e6(e);
     return (
         // Only this for field def without counting aggregate (as count wouldn't be null)
-        J(n) && !HI(n.aggregate) && // and only for continuous scale
+        Q(n) && !HI(n.aggregate) && // and only for continuous scale
         r && Ar(r.get("type")) ? Lme({
             fieldDef: n,
             channel: t,
             markDef: i,
             ref: o,
             config: s
         }) : o
@@ -36670,35 +36657,35 @@
     return {
         test: n,
         ...r
     };
 }
 
 function Z5(e, t = !0) {
-    return G5(ie(e) ? e : te(e, {
+    return G5(se(e) ? e : ne(e, {
         expr: "datum"
     }), !t);
 }
 
 function Pme(e) {
     const {
         datum: t
     } = e;
     return kl(t) ? el(t) : `${Qe(t)}`;
 }
 
-function $u(e, t, n, i) {
+function Cu(e, t, n, i) {
     const r = {};
     if (t && (r.scale = t), Ls(e)) {
         const {
             datum: s
         } = e;
         kl(s) ? r.signal = el(s) : de(s) ? r.signal = s.signal : Ng(s) ? r.signal = s.expr : r.value = s;
     } else
-        r.field = te(e, n);
+        r.field = ne(e, n);
     if (i) {
         const {
             offset: s,
             band: o
         } = i;
         s && (r.offset = s), o && (r.band = o);
     }
@@ -36711,21 +36698,21 @@
     fieldOrDatumDef2: n,
     offset: i,
     startSuffix: r,
     endSuffix: s = "end",
     bandPosition: o = 0.5
 }) {
     const a = !de(o) && 0 < o && o < 1 ? "datum" : void 0,
-        u = te(t, {
+        u = ne(t, {
             expr: a,
             suffix: r
         }),
-        l = n !== void 0 ? te(n, {
+        l = n !== void 0 ? ne(n, {
             expr: a
-        }) : te(t, {
+        }) : ne(t, {
             suffix: s,
             expr: a
         }),
         c = {};
     if (o === 0 || o === 1) {
         c.scale = e;
         const f = o === 0 ? u : l;
@@ -36737,18 +36724,18 @@
     return i && (c.offset = i), c;
 }
 
 function zme({
     scaleName: e,
     fieldDef: t
 }) {
-    const n = te(t, {
+    const n = ne(t, {
             expr: "datum"
         }),
-        i = te(t, {
+        i = ne(t, {
             expr: "datum",
             suffix: "end"
         });
     return `abs(scale("${e}", ${i}) - scale("${e}", ${n}))`;
 }
 
 function e6({
@@ -36763,57 +36750,57 @@
     offset: u,
     defaultRef: l,
     bandPosition: c
 }) {
     if (t) {
         if (Ae(t)) {
             const f = o == null ? void 0 : o.get("type");
-            if (Wn(t)) {
-                c ?? (c = Ca({
+            if (Hn(t)) {
+                c ?? (c = $a({
                     fieldDef: t,
                     fieldDef2: n,
                     markDef: i,
                     config: r
                 }));
                 const {
                     bin: d,
                     timeUnit: h,
                     type: g
                 } = t;
-                if (rt(d) || c && h && g === Gc)
-                    return a != null && a.impute ? $u(t, s, {
+                if (st(d) || c && h && g === Gc)
+                    return a != null && a.impute ? Cu(t, s, {
                         binSuffix: "mid"
                     }, {
                         offset: u
-                    }) : c && !Ht(f) ? H0({
+                    }) : c && !Gt(f) ? H0({
                         scaleName: s,
                         fieldOrDatumDef: t,
                         bandPosition: c,
                         offset: u
-                    }) : $u(t, s, Ig(t, e) ? {
+                    }) : Cu(t, s, Ig(t, e) ? {
                         binSuffix: "range"
                     } : {}, {
                         offset: u
                     });
-                if (Jt(d)) {
-                    if (J(n))
+                if (Qt(d)) {
+                    if (Q(n))
                         return H0({
                             scaleName: s,
                             fieldOrDatumDef: t,
                             fieldOrDatumDef2: n,
                             bandPosition: c,
                             offset: u
                         });
-                    K(oP(e === ht ? Br : Fs));
+                    J(oP(e === ht ? Br : Fs));
                 }
             }
-            return $u(
+            return Cu(
                 t,
                 s,
-                Ht(f) ? {
+                Gt(f) ? {
                     binSuffix: "range"
                 } : {},
                 // no need for bin suffix if there is no scale
                 {
                     offset: u,
                     // For band, to get mid point, need to offset by half of the band
                     band: f === "band" ? c ?? t.bandPosition ?? 0.5 : void 0
@@ -36844,15 +36831,15 @@
         field: {
             group: "width"
         }
     } : De(["y", "y2"], e) && t === "height" ? {
         field: {
             group: "height"
         }
-    } : at(t);
+    } : ut(t);
 }
 
 function il(e) {
     return e && e !== "number" && e !== "time";
 }
 
 function FP(e, t, n) {
@@ -36866,71 +36853,71 @@
     formatType: n,
     expr: i,
     normalizeStack: r,
     config: s
 }) {
     var u, l;
     if (il(n))
-        return $r({
+        return Cr({
             fieldOrDatumDef: e,
             format: t,
             formatType: n,
             expr: i,
             config: s
         });
     const o = NP(e, i, r),
         a = Yc(e);
     if (t === void 0 && n === void 0 && s.customFormatTypes) {
         if (a === "quantitative") {
             if (r && s.normalizedNumberFormatType)
-                return $r({
+                return Cr({
                     fieldOrDatumDef: e,
                     format: s.normalizedNumberFormat,
                     formatType: s.normalizedNumberFormatType,
                     expr: i,
                     config: s
                 });
             if (s.numberFormatType)
-                return $r({
+                return Cr({
                     fieldOrDatumDef: e,
                     format: s.numberFormat,
                     formatType: s.numberFormatType,
                     expr: i,
                     config: s
                 });
         }
-        if (a === "temporal" && s.timeFormatType && J(e) && e.timeUnit === void 0)
-            return $r({
+        if (a === "temporal" && s.timeFormatType && Q(e) && e.timeUnit === void 0)
+            return Cr({
                 fieldOrDatumDef: e,
                 format: s.timeFormat,
                 formatType: s.timeFormatType,
                 expr: i,
                 config: s
             });
     }
     if (Kc(e)) {
         const c = jme({
             field: o,
-            timeUnit: J(e) ? (u = Wt(e.timeUnit)) == null ? void 0 : u.unit : void 0,
+            timeUnit: Q(e) ? (u = Ht(e.timeUnit)) == null ? void 0 : u.unit : void 0,
             format: t,
             formatType: s.timeFormatType,
             rawTimeFormat: s.timeFormat,
-            isUTCScale: $l(e) && ((l = e.scale) == null ? void 0 : l.type) === ri.UTC
+            isUTCScale: Cl(e) && ((l = e.scale) == null ? void 0 : l.type) === ri.UTC
         });
         return c ? {
             signal: c
         } : void 0;
     }
     if (t = Aw({
             type: a,
             specifiedFormat: t,
             config: s,
             normalizeStack: r
-        }), J(e) && rt(e.bin)) {
-        const c = te(e, {
+        }), Q(e) && st(e.bin)) {
+        const c = ne(e, {
             expr: i,
             binSuffix: "end"
         });
         return {
             signal: Dg(o, c, t, n, s)
         };
     } else
@@ -36938,57 +36925,57 @@
             signal: `${RP(o, t)}`
         } : {
             signal: `isValid(${o}) ? ${o} : ""+${o}`
         };
 }
 
 function NP(e, t, n) {
-    return J(e) ? n ? `${te(e, { expr: t, suffix: "end" })}-${te(e, {
+    return Q(e) ? n ? `${ne(e, { expr: t, suffix: "end" })}-${ne(e, {
     expr: t,
     suffix: "start"
-  })}` : te(e, {
+  })}` : ne(e, {
         expr: t
     }) : Pme(e);
 }
 
-function $r({
+function Cr({
     fieldOrDatumDef: e,
     format: t,
     formatType: n,
     expr: i,
     normalizeStack: r,
     config: s,
     field: o
 }) {
     if (o ?? (o = NP(e, i, r)), o !== "datum.value" && // For axis/legend, we can't correctly know the end of the bin from `datum`
-        J(e) && rt(e.bin)) {
-        const a = te(e, {
+        Q(e) && st(e.bin)) {
+        const a = ne(e, {
             expr: i,
             binSuffix: "end"
         });
         return {
             signal: Dg(o, a, t, n, s)
         };
     }
     return {
         signal: FP(n, o, t)
     };
 }
 
 function OP(e, t, n, i, r, s) {
     var o;
-    if (!(ie(i) && il(i)) && !(n === void 0 && i === void 0 && r.customFormatTypes && Yc(e) === "quantitative" && (r.normalizedNumberFormatType && Xc(e) && e.stack === "normalize" || r.numberFormatType))) {
+    if (!(se(i) && il(i)) && !(n === void 0 && i === void 0 && r.customFormatTypes && Yc(e) === "quantitative" && (r.normalizedNumberFormatType && Xc(e) && e.stack === "normalize" || r.numberFormatType))) {
         if (Xc(e) && e.stack === "normalize" && r.normalizedNumberFormat)
             return Aw({
                 type: "quantitative",
                 config: r,
                 normalizeStack: !0
             });
         if (Kc(e)) {
-            const a = J(e) ? (o = Wt(e.timeUnit)) == null ? void 0 : o.unit : void 0;
+            const a = Q(e) ? (o = Ht(e.timeUnit)) == null ? void 0 : o.unit : void 0;
             return a === void 0 && r.customFormatTypes && r.timeFormatType ? void 0 : Ume({
                 specifiedFormat: n,
                 timeUnit: a,
                 config: r,
                 omitTimeFormatConfig: s
             });
         }
@@ -37001,24 +36988,24 @@
 }
 
 function DP(e, t, n) {
     var i;
     if (e && (de(e) || e === "number" || e === "time"))
         return e;
     if (Kc(t) && n !== "time" && n !== "utc")
-        return J(t) && ((i = Wt(t == null ? void 0 : t.timeUnit)) != null && i.utc) ? "utc" : "time";
+        return Q(t) && ((i = Ht(t == null ? void 0 : t.timeUnit)) != null && i.utc) ? "utc" : "time";
 }
 
 function Aw({
     type: e,
     specifiedFormat: t,
     config: n,
     normalizeStack: i
 }) {
-    if (ie(t))
+    if (se(t))
         return t;
     if (e === tl)
         return i ? n.normalizedNumberFormat : n.numberFormat;
 }
 
 function Ume({
     specifiedFormat: e,
@@ -37032,15 +37019,15 @@
 }
 
 function RP(e, t) {
     return `format(${e}, "${t || ""}")`;
 }
 
 function J8(e, t, n, i) {
-    return il(n) ? FP(n, e, t) : RP(e, (ie(t) ? t : void 0) ?? i.numberFormat);
+    return il(n) ? FP(n, e, t) : RP(e, (se(t) ? t : void 0) ?? i.numberFormat);
 }
 
 function Dg(e, t, n, i, r) {
     if (n === void 0 && i === void 0 && r.customFormatTypes && r.numberFormatType)
         return Dg(e, t, r.numberFormat, r.numberFormatType, r);
     const s = J8(e, n, i, r),
         o = J8(t, n, i, r);
@@ -37051,15 +37038,15 @@
     field: e,
     timeUnit: t,
     format: n,
     formatType: i,
     rawTimeFormat: r,
     isUTCScale: s
 }) {
-    return !t || n ? !t && i ? `${i}(${e}, '${n}')` : (n = ie(n) ? n : r, `${s ? "utc" : "time"}Format(${e}, '${n}')`) : Jpe(t, e, s);
+    return !t || n ? !t && i ? `${i}(${e}, '${n}')` : (n = se(n) ? n : r, `${s ? "utc" : "time"}Format(${e}, '${n}')`) : Jpe(t, e, s);
 }
 const Yy = "min",
     qme = {
         x: 1,
         y: 1,
         color: 1,
         fill: 1,
@@ -37082,15 +37069,15 @@
 }
 
 function ls(e) {
     return e && (e.op === "count" || !!e.field);
 }
 
 function IP(e) {
-    return e && W(e);
+    return e && V(e);
 }
 
 function Rg(e) {
     return "row" in e || "column" in e;
 }
 
 function n6(e) {
@@ -37102,15 +37089,15 @@
 }
 
 function Wme(e) {
     return e.param;
 }
 
 function Hme(e) {
-    return e && !ie(e) && "repeat" in e;
+    return e && !se(e) && "repeat" in e;
 }
 
 function Z8(e) {
     const {
         field: t,
         timeUnit: n,
         bin: i,
@@ -37130,30 +37117,30 @@
     };
 }
 
 function i6(e) {
     return "sort" in e;
 }
 
-function Ca({
+function $a({
     fieldDef: e,
     fieldDef2: t,
     markDef: n,
     config: i
 }) {
     if (Ae(e) && e.bandPosition !== void 0)
         return e.bandPosition;
-    if (J(e)) {
+    if (Q(e)) {
         const {
             timeUnit: r,
             bin: s
         } = e;
         if (r && !t)
             return vo("timeUnitBandPosition", n, i);
-        if (rt(s))
+        if (st(s))
             return 0.5;
     }
 }
 
 function PP({
     channel: e,
     fieldDef: t,
@@ -37166,36 +37153,36 @@
     var l, c, f;
     const a = di(e),
         u = He(o ? "size" : a, i, r, {
             vgChannel: a
         });
     if (u !== void 0)
         return u;
-    if (J(t)) {
+    if (Q(t)) {
         const {
             timeUnit: d,
             bin: h
         } = t;
         if (d && !n)
             return {
                 band: vo("timeUnitBandSize", i, r)
             };
-        if (rt(h) && !Ht(s))
+        if (st(h) && !Gt(s))
             return {
                 band: 1
             };
     }
     if (Ph(i.type))
-        return s ? Ht(s) ? ((l = r[i.type]) == null ? void 0 : l.discreteBandSize) || {
+        return s ? Gt(s) ? ((l = r[i.type]) == null ? void 0 : l.discreteBandSize) || {
             band: 1
         } : (c = r[i.type]) == null ? void 0 : c.continuousBandSize : (f = r[i.type]) == null ? void 0 : f.discreteBandSize;
 }
 
 function zP(e, t, n, i) {
-    return rt(e.bin) || e.timeUnit && Wn(e) && e.type === "temporal" ? Ca({
+    return st(e.bin) || e.timeUnit && Hn(e) && e.type === "temporal" ? $a({
         fieldDef: e,
         fieldDef2: t,
         markDef: n,
         config: i
     }) !== void 0 : !1;
 }
 
@@ -37205,64 +37192,64 @@
 
 function Ky(e) {
     return e && "condition" in e;
 }
 
 function Jy(e) {
     const t = e == null ? void 0 : e.condition;
-    return !!t && !W(t) && J(t);
+    return !!t && !V(t) && Q(t);
 }
 
 function Lg(e) {
     const t = e == null ? void 0 : e.condition;
-    return !!t && !W(t) && Ae(t);
+    return !!t && !V(t) && Ae(t);
 }
 
 function Gme(e) {
     const t = e == null ? void 0 : e.condition;
-    return !!t && (W(t) || Dr(t));
+    return !!t && (V(t) || Dr(t));
 }
 
-function J(e) {
+function Q(e) {
     return e && (!!e.field || e.aggregate === "count");
 }
 
 function Yc(e) {
     return e == null ? void 0 : e.type;
 }
 
 function Ls(e) {
     return e && "datum" in e;
 }
 
 function Zo(e) {
-    return Wn(e) && !V0(e) || G0(e);
+    return Hn(e) && !V0(e) || G0(e);
 }
 
 function e4(e) {
-    return Wn(e) && e.type === "quantitative" && !e.bin || G0(e);
+    return Hn(e) && e.type === "quantitative" && !e.bin || G0(e);
 }
 
 function G0(e) {
     return Ls(e) && ze(e.datum);
 }
 
 function Ae(e) {
-    return J(e) || Ls(e);
+    return Q(e) || Ls(e);
 }
 
-function Wn(e) {
+function Hn(e) {
     return e && ("field" in e || e.aggregate === "count") && "type" in e;
 }
 
 function Dr(e) {
     return e && "value" in e && "value" in e;
 }
 
-function $l(e) {
+function Cl(e) {
     return e && ("scale" in e || "sort" in e);
 }
 
 function Xc(e) {
     return e && ("axis" in e || "stack" in e || "impute" in e);
 }
 
@@ -37278,15 +37265,15 @@
     return ii(e, ["legend", "axis", "header", "scale"]);
 }
 
 function Yme(e) {
     return "op" in e;
 }
 
-function te(e, t = {}) {
+function ne(e, t = {}) {
     let n = e.field;
     const i = t.prefix;
     let r = t.suffix,
         s = "";
     if (Kme(e))
         n = FI("count");
     else {
@@ -37296,38 +37283,38 @@
                 o = e.op;
             else {
                 const {
                     bin: a,
                     aggregate: u,
                     timeUnit: l
                 } = e;
-                rt(a) ? (o = GI(a), r = (t.binSuffix ?? "") + (t.suffix ?? "")) : u ? Ha(u) ? (s = `["${n}"]`, n = `argmax_${u.argmax}`) : bo(u) ? (s = `["${n}"]`, n = `argmin_${u.argmin}`) : o = String(u) : l && !Al(l) && (o = Qpe(l), r = (!["range", "mid"].includes(t.binSuffix) && t.binSuffix || "") + (t.suffix ?? ""));
+                st(a) ? (o = GI(a), r = (t.binSuffix ?? "") + (t.suffix ?? "")) : u ? Ha(u) ? (s = `["${n}"]`, n = `argmax_${u.argmax}`) : bo(u) ? (s = `["${n}"]`, n = `argmin_${u.argmin}`) : o = String(u) : l && !Al(l) && (o = Qpe(l), r = (!["range", "mid"].includes(t.binSuffix) && t.binSuffix || "") + (t.suffix ?? ""));
             }
         o && (n = n ? `${o}_${n}` : o);
     }
-    return r && (n = `${n}_${r}`), i && (n = `${i}_${n}`), t.forAs ? k5(n) : t.expr ? CI(n, t.expr) + s : sr(n) + s;
+    return r && (n = `${n}_${r}`), i && (n = `${i}_${n}`), t.forAs ? k5(n) : t.expr ? $I(n, t.expr) + s : sr(n) + s;
 }
 
 function V0(e) {
     switch (e.type) {
         case "nominal":
         case "ordinal":
         case "geojson":
             return !0;
         case "quantitative":
-            return J(e) && !!e.bin;
+            return Q(e) && !!e.bin;
         case "temporal":
             return !1;
     }
     throw new Error(nP(e.type));
 }
 
 function Xme(e) {
     var t;
-    return $l(e) && Vc((t = e.scale) == null ? void 0 : t.type);
+    return Cl(e) && Vc((t = e.scale) == null ? void 0 : t.type);
 }
 
 function Kme(e) {
     return e.aggregate === "count";
 }
 
 function Jme(e, t) {
@@ -37336,38 +37323,38 @@
         field: n,
         bin: i,
         timeUnit: r,
         aggregate: s
     } = e;
     if (s === "count")
         return t.countTitle;
-    if (rt(i))
+    if (st(i))
         return `${n} (binned)`;
     if (r && !Al(r)) {
-        const a = (o = Wt(r)) == null ? void 0 : o.unit;
+        const a = (o = Ht(r)) == null ? void 0 : o.unit;
         if (a)
             return `${n} (${qy(a).join("-")})`;
     } else if (s)
-        return Ha(s) ? `${n} for max ${s.argmax}` : bo(s) ? `${n} for min ${s.argmin}` : `${Cg(s)} of ${n}`;
+        return Ha(s) ? `${n} for max ${s.argmax}` : bo(s) ? `${n} for min ${s.argmin}` : `${$g(s)} of ${n}`;
     return n;
 }
 
 function Qme(e) {
     const {
         aggregate: t,
         bin: n,
         timeUnit: i,
         field: r
     } = e;
     if (Ha(t))
         return `${r} for argmax(${t.argmax})`;
     if (bo(t))
         return `${r} for argmin(${t.argmin})`;
-    const s = i && !Al(i) ? Wt(i) : void 0,
-        o = t || (s == null ? void 0 : s.unit) || (s == null ? void 0 : s.maxbins) && "timeunit" || rt(n) && "bin";
+    const s = i && !Al(i) ? Ht(i) : void 0,
+        o = t || (s == null ? void 0 : s.unit) || (s == null ? void 0 : s.maxbins) && "timeunit" || st(n) && "bin";
     return o ? `${o.toUpperCase()}(${r})` : r;
 }
 const qP = (e, t) => {
     switch (t.fieldTitle) {
         case "plain":
             return e.field;
         case "functional":
@@ -37388,19 +37375,19 @@
 
 function vc(e, t, {
     allowDisabling: n,
     includeDefault: i = !0
 }) {
     var a;
     const r = (a = r6(e)) == null ? void 0 : a.title;
-    if (!J(e))
+    if (!Q(e))
         return r ?? e.title;
     const s = e,
         o = i ? s6(s, t) : void 0;
-    return n ? St(r, s.title, o) : r ?? s.title ?? o;
+    return n ? kt(r, s.title, o) : r ?? s.title ?? o;
 }
 
 function r6(e) {
     if (Xc(e) && e.axis)
         return e.axis;
     if (UP(e) && e.legend)
         return e.legend;
@@ -37446,54 +37433,54 @@
         case "facet":
         case "shape":
         case "strokeDash":
             return "nominal";
         case "order":
             return "ordinal";
     }
-    if (i6(e) && W(e.sort))
+    if (i6(e) && V(e.sort))
         return "ordinal";
     const {
         aggregate: n,
         bin: i,
         timeUnit: r
     } = e;
     if (r)
         return "temporal";
     if (i || n && !Ha(n) && !bo(n))
         return "quantitative";
-    if ($l(e) && ((s = e.scale) != null && s.type))
+    if (Cl(e) && ((s = e.scale) != null && s.type))
         switch (Sw[e.scale.type]) {
             case "numeric":
             case "discretizing":
                 return "quantitative";
             case "time":
                 return "temporal";
         }
     return "nominal";
 }
 
 function xs(e) {
-    if (J(e))
+    if (Q(e))
         return e;
     if (Jy(e))
         return e.condition;
 }
 
-function Ft(e) {
+function Nt(e) {
     if (Ae(e))
         return e;
     if (Lg(e))
         return e.condition;
 }
 
 function GP(e, t, n, i = {}) {
-    if (ie(e) || ze(e) || Oa(e)) {
-        const r = ie(e) ? "string" : ze(e) ? "number" : "boolean";
-        return K(tpe(t, r, e)), {
+    if (se(e) || ze(e) || Oa(e)) {
+        const r = se(e) ? "string" : ze(e) ? "number" : "boolean";
+        return J(tpe(t, r, e)), {
             value: e
         };
     }
     return Ae(e) ? X0(e, t, n, i) : Lg(e) ? {
         ...e,
         // Need to cast as normalizeFieldDef normally return FieldDef, but here we know that it is definitely Condition<FieldDef>
         condition: X0(e.condition, t, n, i)
@@ -37504,41 +37491,41 @@
     if (jP(e)) {
         const {
             format: r,
             formatType: s,
             ...o
         } = e;
         if (il(s) && !n.customFormatTypes)
-            return K(G8(t)), X0(o, t, n, i);
+            return J(G8(t)), X0(o, t, n, i);
     } else {
         const r = Xc(e) ? "axis" : UP(e) ? "legend" : n6(e) ? "header" : null;
         if (r && e[r]) {
             const {
                 format: s,
                 formatType: o,
                 ...a
             } = e[r];
             if (il(o) && !n.customFormatTypes)
-                return K(G8(t)), X0({
+                return J(G8(t)), X0({
                     ...e,
                     [r]: a
                 }, t, n, i);
         }
     }
-    return J(e) ? o6(e, t, i) : t0e(e);
+    return Q(e) ? o6(e, t, i) : t0e(e);
 }
 
 function t0e(e) {
     let t = e.type;
     if (t)
         return e;
     const {
         datum: n
     } = e;
-    return t = ze(n) ? "quantitative" : ie(n) ? "nominal" : kl(n) ? "temporal" : void 0, {
+    return t = ze(n) ? "quantitative" : se(n) ? "nominal" : kl(n) ? "temporal" : void 0, {
         ...e,
         type: t
     };
 }
 
 function o6(e, t, {
     compositeMark: n = !1
@@ -37547,31 +37534,31 @@
         aggregate: i,
         timeUnit: r,
         bin: s,
         field: o
     } = e, a = {
         ...e
     };
-    if (!n && i && !O5(i) && !Ha(i) && !bo(i) && (K(ipe(i)), delete a.aggregate), r && (a.timeUnit = Wt(r)), o && (a.field = `${o}`), rt(s) && (a.bin = Qy(s, t)), Jt(s) && !kt(t) && K(Rpe(t)), Wn(a)) {
+    if (!n && i && !O5(i) && !Ha(i) && !bo(i) && (J(ipe(i)), delete a.aggregate), r && (a.timeUnit = Ht(r)), o && (a.field = `${o}`), st(s) && (a.bin = Qy(s, t)), Qt(s) && !At(t) && J(Rpe(t)), Hn(a)) {
         const {
             type: u
         } = a, l = ome(u);
-        u !== l && (a.type = l), u !== "quantitative" && HI(i) && (K(npe(u, i)), a.type = "quantitative");
+        u !== l && (a.type = l), u !== "quantitative" && HI(i) && (J(npe(u, i)), a.type = "quantitative");
     } else if (!zI(t)) {
         const u = e0e(a, t);
         a.type = u;
     }
-    if (Wn(a)) {
+    if (Hn(a)) {
         const {
             compatible: u,
             warning: l
         } = n0e(a, t) || {};
-        u === !1 && K(l);
+        u === !1 && J(l);
     }
-    if (i6(a) && ie(a.sort)) {
+    if (i6(a) && se(a.sort)) {
         const {
             sort: u
         } = a;
         if (Q8(u))
             return {
                 ...a,
                 sort: {
@@ -37637,15 +37624,15 @@
         case lo:
         case Dy:
             return V0(e) ? Gl : {
                 compatible: !1,
                 warning: ape(t)
             };
         case ht:
-        case Yt:
+        case Xt:
         case Ba:
         case Ff:
         case ci:
         case Ns:
         case Os:
         case Mg:
         case Tg:
@@ -37662,15 +37649,15 @@
         case or:
         case jr:
         case Wr:
             return n !== tl ? {
                 compatible: !1,
                 warning: `Channel ${t} should be used with a quantitative field only, not ${e.type} field.`
             } : Gl;
-        case $o:
+        case Co:
         case Ua:
         case ja:
         case qa:
         case Ao:
         case ko:
         case So:
         case Br:
@@ -37697,51 +37684,51 @@
     const {
         formatType: t
     } = Y0(e);
     return t === "time" || !t && i0e(e);
 }
 
 function i0e(e) {
-    return e && (e.type === "temporal" || J(e) && !!e.timeUnit);
+    return e && (e.type === "temporal" || Q(e) && !!e.timeUnit);
 }
 
 function Zy(e, {
     timeUnit: t,
     type: n,
     wrapTime: i,
     undefinedIfExprNotRequired: r
 }) {
     var u;
-    const s = t && ((u = Wt(t)) == null ? void 0 : u.unit);
+    const s = t && ((u = Ht(t)) == null ? void 0 : u.unit);
     let o = s || n === "temporal",
         a;
-    return Ng(e) ? a = e.expr : de(e) ? a = e.signal : kl(e) ? (o = !0, a = el(e)) : (ie(e) || ze(e)) && o && (a = `datetime(${Qe(e)})`, Vpe(s) && (ze(e) && e < 1e4 || ie(e) && isNaN(Date.parse(e))) && (a = el({
+    return Ng(e) ? a = e.expr : de(e) ? a = e.signal : kl(e) ? (o = !0, a = el(e)) : (se(e) || ze(e)) && o && (a = `datetime(${Qe(e)})`, Vpe(s) && (ze(e) && e < 1e4 || se(e) && isNaN(Date.parse(e))) && (a = el({
         [s]: e
     }))), a ? i && o ? `time(${a})` : a : r ? void 0 : Qe(e);
 }
 
 function VP(e, t) {
     const {
         type: n
     } = e;
     return t.map((i) => {
-        const r = J(e) && !Al(e.timeUnit) ? e.timeUnit : void 0,
+        const r = Q(e) && !Al(e.timeUnit) ? e.timeUnit : void 0,
             s = Zy(i, {
                 timeUnit: r,
                 type: n,
                 undefinedIfExprNotRequired: !0
             });
         return s !== void 0 ? {
             signal: s
         } : i;
     });
 }
 
 function Ig(e, t) {
-    return rt(e.bin) ? Co(t) && ["ordinal", "nominal"].includes(e.type) : (console.warn("Only call this method for binned field defs."), !1);
+    return st(e.bin) ? $o(t) && ["ordinal", "nominal"].includes(e.type) : (console.warn("Only call this method for binned field defs."), !1);
 }
 const t4 = {
     labelAlign: {
         part: "labels",
         vgProp: "align"
     },
     labelBaseline: {
@@ -38018,54 +38005,54 @@
         axisY: 1,
         axisYBand: 1,
         axisYDiscrete: 1,
         axisYPoint: 1,
         axisYQuantitative: 1,
         axisYTemporal: 1
     },
-    KP = Y(o0e);
+    KP = X(o0e);
 
 function Mo(e) {
     return "mark" in e;
 }
 class eb {
     constructor(t, n) {
         this.name = t, this.run = n;
     }
     hasMatchingType(t) {
         return Mo(t) ? Rme(t.mark) === this.name : !1;
     }
 }
 
-function Cu(e, t) {
+function $u(e, t) {
     const n = e && e[t];
-    return n ? W(n) ? Ju(n, (i) => !!i.field) : J(n) || Jy(n) : !1;
+    return n ? V(n) ? Ju(n, (i) => !!i.field) : Q(n) || Jy(n) : !1;
 }
 
 function JP(e, t) {
     const n = e && e[t];
-    return n ? W(n) ? Ju(n, (i) => !!i.field) : J(n) || Ls(n) || Lg(n) : !1;
+    return n ? V(n) ? Ju(n, (i) => !!i.field) : Q(n) || Ls(n) || Lg(n) : !1;
 }
 
 function QP(e, t) {
-    if (kt(t)) {
+    if (At(t)) {
         const n = e[t];
-        if ((J(n) || Ls(n)) && (vP(n.type) || J(n) && n.timeUnit)) {
+        if ((Q(n) || Ls(n)) && (vP(n.type) || Q(n) && n.timeUnit)) {
             const i = M5(t);
             return JP(e, i);
         }
     }
     return !1;
 }
 
 function a6(e) {
     return Ju(age, (t) => {
-        if (Cu(e, t)) {
+        if ($u(e, t)) {
             const n = e[t];
-            if (W(n))
+            if (V(n))
                 return Ju(n, (i) => !!i.aggregate);
             {
                 const i = xs(n);
                 return i && !!i.aggregate;
             }
         }
         return !1;
@@ -38075,26 +38062,26 @@
 function ZP(e, t) {
     const n = [],
         i = [],
         r = [],
         s = [],
         o = {};
     return u6(e, (a, u) => {
-        if (J(a)) {
+        if (Q(a)) {
             const {
                 field: l,
                 aggregate: c,
                 bin: f,
                 timeUnit: d,
                 ...h
             } = a;
             if (c || d || f) {
                 const g = r6(a),
                     p = g == null ? void 0 : g.title;
-                let m = te(a, {
+                let m = ne(a, {
                     forAs: !0
                 });
                 const y = {
                     // Only add title if it doesn't exist
                     ...p ? [] : {
                         title: vc(a, t, {
                             allowDisabling: !0
@@ -38102,58 +38089,58 @@
                     },
                     ...h,
                     // Always overwrite field
                     field: m
                 };
                 if (c) {
                     let b;
-                    if (Ha(c) ? (b = "argmax", m = te({
+                    if (Ha(c) ? (b = "argmax", m = ne({
                             op: "argmax",
                             field: c.argmax
                         }, {
                             forAs: !0
-                        }), y.field = `${m}.${l}`) : bo(c) ? (b = "argmin", m = te({
+                        }), y.field = `${m}.${l}`) : bo(c) ? (b = "argmin", m = ne({
                             op: "argmin",
                             field: c.argmin
                         }, {
                             forAs: !0
                         }), y.field = `${m}.${l}`) : c !== "boxplot" && c !== "errorbar" && c !== "errorband" && (b = c), b) {
                         const v = {
                             op: b,
                             as: m
                         };
                         l && (v.field = l), s.push(v);
                     }
-                } else if (n.push(m), Wn(a) && rt(f)) {
+                } else if (n.push(m), Hn(a) && st(f)) {
                     if (i.push({
                             bin: f,
                             field: l,
                             as: m
-                        }), n.push(te(a, {
+                        }), n.push(ne(a, {
                             binSuffix: "end"
-                        })), Ig(a, u) && n.push(te(a, {
+                        })), Ig(a, u) && n.push(ne(a, {
                             binSuffix: "range"
-                        })), kt(u)) {
+                        })), At(u)) {
                         const b = {
                             field: `${m}_end`
                         };
                         o[`${u}2`] = b;
                     }
                     y.bin = "binned", zI(u) || (y.type = tl);
                 } else if (d && !Al(d)) {
                     r.push({
                         timeUnit: d,
                         field: l,
                         as: m
                     });
-                    const b = Wn(a) && a.type !== Gc && "time";
+                    const b = Hn(a) && a.type !== Gc && "time";
                     b && (u === Mg || u === Zu ? y.formatType = b : yge(u) ? y.legend = {
                         formatType: b,
                         ...y.legend
-                    } : kt(u) && (y.axis = {
+                    } : At(u) && (y.axis = {
                         formatType: b,
                         ...y.axis
                     }));
                 }
                 o[u] = y;
             } else
                 n.push(l), o[u] = e[u];
@@ -38168,127 +38155,127 @@
     };
 }
 
 function a0e(e, t, n) {
     const i = vge(t, n);
     if (i) {
         if (i === "binned") {
-            const r = e[t === Br ? ht : Yt];
-            return !!(J(r) && J(e[t]) && Jt(r.bin));
+            const r = e[t === Br ? ht : Xt];
+            return !!(Q(r) && Q(e[t]) && Qt(r.bin));
         }
     } else
         return !1;
     return !0;
 }
 
 function u0e(e, t, n, i) {
     const r = {};
-    for (const s of Y(e))
-        PI(s) || K(ope(s));
+    for (const s of X(e))
+        PI(s) || J(ope(s));
     for (let s of hge) {
         if (!e[s])
             continue;
         const o = e[s];
         if (Fg(s)) {
             const a = dge(s),
                 u = r[a];
-            if (J(u) && sme(u.type) && J(o) && !u.timeUnit) {
-                K(epe(a));
+            if (Q(u) && sme(u.type) && Q(o) && !u.timeUnit) {
+                J(epe(a));
                 continue;
             }
         }
-        if (s === "angle" && t === "arc" && !e.theta && (K(Zge), s = lr), !a0e(e, s, t)) {
-            K(jy(s, t));
+        if (s === "angle" && t === "arc" && !e.theta && (J(Zge), s = lr), !a0e(e, s, t)) {
+            J(jy(s, t));
             continue;
         }
         if (s === Ao && t === "line") {
             const a = xs(e[s]);
             if (a != null && a.aggregate) {
-                K(spe);
+                J(spe);
                 continue;
             }
         }
         if (s === ci && (n ? "fill" in e : "stroke" in e)) {
-            K(iP("encoding", {
+            J(iP("encoding", {
                 fill: "fill" in e,
                 stroke: "stroke" in e
             }));
             continue;
         }
-        if (s === Tg || s === Wc && !W(o) && !Dr(o) || s === Zu && W(o)) {
+        if (s === Tg || s === Wc && !V(o) && !Dr(o) || s === Zu && V(o)) {
             if (o) {
                 if (s === Wc) {
                     const a = e[s];
                     if (BP(a)) {
                         r[s] = a;
                         continue;
                     }
                 }
-                r[s] = ne(o).reduce((a, u) => (J(u) ? a.push(o6(u, s)) : K(Ew(u, s)), a), []);
+                r[s] = re(o).reduce((a, u) => (Q(u) ? a.push(o6(u, s)) : J(Ew(u, s)), a), []);
             }
         } else {
             if (s === Zu && o === null)
                 r[s] = null;
-            else if (!J(o) && !Ls(o) && !Dr(o) && !Ky(o) && !de(o)) {
-                K(Ew(o, s));
+            else if (!Q(o) && !Ls(o) && !Dr(o) && !Ky(o) && !de(o)) {
+                J(Ew(o, s));
                 continue;
             }
             r[s] = GP(o, s, i);
         }
     }
     return r;
 }
 
 function tb(e, t) {
     const n = {};
-    for (const i of Y(e)) {
+    for (const i of X(e)) {
         const r = GP(e[i], i, t, {
             compositeMark: !0
         });
         n[i] = r;
     }
     return n;
 }
 
 function l0e(e) {
     const t = [];
-    for (const n of Y(e))
-        if (Cu(e, n)) {
+    for (const n of X(e))
+        if ($u(e, n)) {
             const i = e[n],
-                r = ne(i);
+                r = re(i);
             for (const s of r)
-                J(s) ? t.push(s) : Jy(s) && t.push(s.condition);
+                Q(s) ? t.push(s) : Jy(s) && t.push(s.condition);
         }
     return t;
 }
 
 function u6(e, t, n) {
     if (e)
-        for (const i of Y(e)) {
+        for (const i of X(e)) {
             const r = e[i];
-            if (W(r))
+            if (V(r))
                 for (const s of r)
                     t.call(n, s, i);
             else
                 t.call(n, r, i);
         }
 }
 
 function c0e(e, t, n, i) {
-    return e ? Y(e).reduce((r, s) => {
+    return e ? X(e).reduce((r, s) => {
         const o = e[s];
-        return W(o) ? o.reduce((a, u) => t.call(i, a, u, s), r) : t.call(i, r, o, s);
+        return V(o) ? o.reduce((a, u) => t.call(i, a, u, s), r) : t.call(i, r, o, s);
     }, n) : n;
 }
 
 function ez(e, t) {
-    return Y(t).reduce((n, i) => {
+    return X(t).reduce((n, i) => {
         switch (i) {
             case ht:
-            case Yt:
+            case Xt:
             case Ly:
             case Py:
             case Iy:
             case Br:
             case Fs:
             case Ba:
             case Ff:
@@ -38307,32 +38294,32 @@
                 return n;
             case Wc:
                 if (e === "line" || e === "trail")
                     return n;
             case Tg:
             case Ry: {
                 const r = t[i];
-                if (W(r) || J(r))
-                    for (const s of ne(r))
-                        s.aggregate || n.push(te(s, {}));
+                if (V(r) || Q(r))
+                    for (const s of re(r))
+                        s.aggregate || n.push(ne(s, {}));
                 return n;
             }
             case Ao:
                 if (e === "trail")
                     return n;
             case ci:
             case Ns:
             case Os:
-            case $o:
+            case Co:
             case Ua:
             case ja:
             case Wa:
             case qa: {
                 const r = xs(t[i]);
-                return r && !r.aggregate && n.push(te(r, {})), n;
+                return r && !r.aggregate && n.push(ne(r, {})), n;
             }
         }
     }, []);
 }
 
 function f0e(e) {
     const {
@@ -38340,27 +38327,27 @@
         ...n
     } = e;
     if (!t)
         return {
             filteredEncoding: n
         };
     let i, r;
-    if (W(t)) {
+    if (V(t)) {
         for (const s of t)
             s.aggregate ? (i || (i = []), i.push(s)) : (r || (r = []), r.push(s));
         i && (n.tooltip = i);
     } else
         t.aggregate ? n.tooltip = t : r = t;
-    return W(r) && r.length === 1 && (r = r[0]), {
+    return V(r) && r.length === 1 && (r = r[0]), {
         customTooltipWithoutAggregatedField: r,
         filteredEncoding: n
     };
 }
 
-function $w(e, t, n, i = !0) {
+function Cw(e, t, n, i = !0) {
     if ("tooltip" in n)
         return {
             tooltip: n.tooltip
         };
     const r = e.map(({
             fieldPrefix: o,
             titlePrefix: a
@@ -38385,15 +38372,15 @@
 }
 
 function l6(e) {
     const {
         title: t,
         field: n
     } = e;
-    return St(t, n);
+    return kt(t, n);
 }
 
 function c6(e, t, n, i, r) {
     const {
         scale: s,
         axis: o
     } = n;
@@ -38418,15 +38405,15 @@
                     ...s !== void 0 ? {
                         scale: s
                     } : {},
                     ...o !== void 0 ? {
                         axis: o
                     } : {}
                 },
-                ...ie(c) ? {
+                ...se(c) ? {
                     [`${t}2`]: {
                         field: `${c}_${n.field}`
                     }
                 } : {},
                 ...i,
                 ...f
             }
@@ -38463,29 +38450,29 @@
 }
 
 function nz(e, t, n) {
     const {
         encoding: i
     } = e, r = t === "vertical" ? "y" : "x", s = i[r], o = i[`${r}2`], a = i[`${r}Error`], u = i[`${r}Error2`];
     return {
-        continuousAxisChannelDef: $p(s, n),
-        continuousAxisChannelDef2: $p(o, n),
-        continuousAxisChannelDefError: $p(a, n),
-        continuousAxisChannelDefError2: $p(u, n),
+        continuousAxisChannelDef: Cp(s, n),
+        continuousAxisChannelDef2: Cp(o, n),
+        continuousAxisChannelDefError: Cp(a, n),
+        continuousAxisChannelDefError2: Cp(u, n),
         continuousAxis: r
     };
 }
 
-function $p(e, t) {
+function Cp(e, t) {
     if (e != null && e.aggregate) {
         const {
             aggregate: n,
             ...i
         } = e;
-        return n !== t && K(Dpe(n, t)), i;
+        return n !== t && J(Dpe(n, t)), i;
     } else
         return e;
 }
 
 function iz(e, t) {
     const {
         mark: n,
@@ -38494,16 +38481,16 @@
         x: r,
         y: s
     } = i;
     if (vs(n) && n.orient)
         return n.orient;
     if (Zo(r)) {
         if (Zo(s)) {
-            const o = J(r) && r.aggregate,
-                a = J(s) && s.aggregate;
+            const o = Q(r) && r.aggregate,
+                a = Q(s) && s.aggregate;
             if (!o && a === t)
                 return "vertical";
             if (!a && o === t)
                 return "horizontal";
             if (o === t && a === t)
                 throw new Error("Both x and y cannot have aggregate");
             return Kc(s) && !Kc(r) ? "horizontal" : "vertical";
@@ -38535,15 +38522,15 @@
         encoding: i,
         params: r,
         projection: s,
         ...o
     } = e, a = vs(n) ? n : {
         type: n
     };
-    r && K(tP("boxplot"));
+    r && J(tP("boxplot"));
     const u = a.extent ?? t.boxplot.extent,
         l = He(
             "size",
             a,
             // TODO: https://github.com/vega/vega-lite/issues/6245
             t
         ),
@@ -38556,31 +38543,31 @@
             continuousAxisChannelDef: p,
             continuousAxis: m,
             groupby: y,
             aggregate: b,
             encodingWithoutContinuousAxis: v,
             ticksOrient: x,
             boxOrient: w,
-            customTooltipWithoutAggregatedField: S
+            customTooltipWithoutAggregatedField: E
         } = g0e(e, u, t),
         {
             color: _,
             size: k,
             ...A
         } = v,
-        F = (st) => c6(a, m, p, st, t.boxplot),
-        T = F(A),
-        I = F(v),
-        N = F({
+        T = (ot) => c6(a, m, p, ot, t.boxplot),
+        M = T(A),
+        L = T(v),
+        F = T({
             ...A,
             ...k ? {
                 size: k
             } : {}
         }),
-        D = $w([{
+        O = Cw([{
             fieldPrefix: f === "min-max" ? "upper_whisker_" : "max_",
             titlePrefix: "Max"
         }, {
             fieldPrefix: "upper_box_",
             titlePrefix: "Q3"
         }, {
             fieldPrefix: "mid_box_",
@@ -38588,122 +38575,122 @@
         }, {
             fieldPrefix: "lower_box_",
             titlePrefix: "Q1"
         }, {
             fieldPrefix: f === "min-max" ? "lower_whisker_" : "min_",
             titlePrefix: "Min"
         }], p, v),
-        M = {
+        N = {
             type: "tick",
             color: "black",
             opacity: 1,
             orient: x,
             invalid: c,
             aria: !1
         },
-        E = f === "min-max" ? D : (
+        R = f === "min-max" ? O : (
             // for tukey / k-IQR, just show upper/lower-whisker
-            $w([{
+            Cw([{
                 fieldPrefix: "upper_whisker_",
                 titlePrefix: "Upper Whisker"
             }, {
                 fieldPrefix: "lower_whisker_",
                 titlePrefix: "Lower Whisker"
             }], p, v)
         ),
-        $ = [
-            ...T({
+        P = [
+            ...M({
                 partName: "rule",
                 mark: {
                     type: "rule",
                     invalid: c,
                     aria: !1
                 },
                 positionPrefix: "lower_whisker",
                 endPositionPrefix: "lower_box",
-                extraEncoding: E
+                extraEncoding: R
             }),
-            ...T({
+            ...M({
                 partName: "rule",
                 mark: {
                     type: "rule",
                     invalid: c,
                     aria: !1
                 },
                 positionPrefix: "upper_box",
                 endPositionPrefix: "upper_whisker",
-                extraEncoding: E
+                extraEncoding: R
             }),
-            ...T({
+            ...M({
                 partName: "ticks",
-                mark: M,
+                mark: N,
                 positionPrefix: "lower_whisker",
-                extraEncoding: E
+                extraEncoding: R
             }),
-            ...T({
+            ...M({
                 partName: "ticks",
-                mark: M,
+                mark: N,
                 positionPrefix: "upper_whisker",
-                extraEncoding: E
+                extraEncoding: R
             })
         ],
-        C = [
-            ...f !== "tukey" ? $ : [],
-            ...I({
+        S = [
+            ...f !== "tukey" ? P : [],
+            ...L({
                 partName: "box",
                 mark: {
                     type: "bar",
                     ...l ? {
                         size: l
                     } : {},
                     orient: w,
                     invalid: c,
                     ariaRoleDescription: "box"
                 },
                 positionPrefix: "lower_box",
                 endPositionPrefix: "upper_box",
-                extraEncoding: D
+                extraEncoding: O
             }),
-            ...N({
+            ...F({
                 partName: "median",
                 mark: {
                     type: "tick",
                     invalid: c,
-                    ...re(t.boxplot.median) && t.boxplot.median.color ? {
+                    ...oe(t.boxplot.median) && t.boxplot.median.color ? {
                         color: t.boxplot.median.color
                     } : {},
                     ...l ? {
                         size: l
                     } : {},
                     orient: x,
                     aria: !1
                 },
                 positionPrefix: "mid_box",
-                extraEncoding: D
+                extraEncoding: O
             })
         ];
     if (f === "min-max")
         return {
             ...o,
             transform: (o.transform ?? []).concat(g),
-            layer: C
+            layer: S
         };
-    const O = `datum["lower_box_${p.field}"]`,
-        R = `datum["upper_box_${p.field}"]`,
-        L = `(${R} - ${O})`,
-        P = `${O} - ${u} * ${L}`,
-        z = `${R} + ${u} * ${L}`,
-        V = `datum["${p.field}"]`,
-        X = {
+    const $ = `datum["lower_box_${p.field}"]`,
+        C = `datum["upper_box_${p.field}"]`,
+        D = `(${C} - ${$})`,
+        I = `${$} - ${u} * ${D}`,
+        z = `${C} + ${u} * ${D}`,
+        H = `datum["${p.field}"]`,
+        G = {
             joinaggregate: oz(p.field),
             groupby: y
         },
-        se = {
+        te = {
             transform: [{
-                filter: `(${P} <= ${V}) && (${V} <= ${z})`
+                filter: `(${I} <= ${H}) && (${H} <= ${z})`
             }, {
                 aggregate: [{
                         op: "min",
                         field: p.field,
                         as: `lower_whisker_${p.field}`
                     }, {
                         op: "max",
@@ -38720,67 +38707,67 @@
                         field: `upper_box_${p.field}`,
                         as: `upper_box_${p.field}`
                     },
                     ...b
                 ],
                 groupby: y
             }],
-            layer: $
+            layer: P
         },
         {
-            tooltip: ee,
-            ...ue
+            tooltip: K,
+            ...ae
         } = A,
         {
-            scale: G,
-            axis: ae
+            scale: U,
+            axis: ie
         } = p,
-        ce = l6(p),
-        H = ii(ae, ["title"]),
+        le = l6(p),
+        Y = ii(ie, ["title"]),
         Be = tz(a, "outliers", t.boxplot, {
             transform: [{
-                filter: `(${V} < ${P}) || (${V} > ${z})`
+                filter: `(${H} < ${I}) || (${H} > ${z})`
             }],
             mark: "point",
             encoding: {
                 [m]: {
                     field: p.field,
                     type: p.type,
-                    ...ce !== void 0 ? {
-                        title: ce
+                    ...le !== void 0 ? {
+                        title: le
                     } : {},
-                    ...G !== void 0 ? {
-                        scale: G
+                    ...U !== void 0 ? {
+                        scale: U
                     } : {},
                     // add axis without title since we already added the title above
-                    ...Je(H) ? {} : {
-                        axis: H
+                    ...Je(Y) ? {} : {
+                        axis: Y
                     }
                 },
-                ...ue,
+                ...ae,
                 ..._ ? {
                     color: _
                 } : {},
-                ...S ? {
-                    tooltip: S
+                ...E ? {
+                    tooltip: E
                 } : {}
             }
         })[0];
     let Ee;
-    const Ve = [...d, ...h, X];
+    const Ve = [...d, ...h, G];
     return Be ? Ee = {
         transform: Ve,
-        layer: [Be, se]
-    } : (Ee = se, Ee.transform.unshift(...Ve)), {
+        layer: [Be, te]
+    } : (Ee = te, Ee.transform.unshift(...Ve)), {
         ...o,
         layer: [
             Ee, {
                 // boxplot
                 transform: g,
-                layer: C
+                layer: S
             }
         ]
     };
 }
 
 function oz(e) {
     return [{
@@ -39027,15 +39014,15 @@
         encoding: r,
         params: s,
         projection: o,
         ...a
     } = e, u = vs(i) ? i : {
         type: i
     };
-    s && K(tP(t));
+    s && J(tP(t));
     const {
         orient: l,
         inputType: c
     } = y0e(e, t), {
         continuousAxisChannelDef: f,
         continuousAxisChannelDef2: d,
         continuousAxisChannelDefError: h,
@@ -39045,55 +39032,55 @@
         errorBarSpecificAggregate: m,
         postAggregateCalculates: y,
         tooltipSummary: b,
         tooltipTitleWithFieldName: v
     } = w0e(u, f, d, h, g, c, t, n), {
         [p]: x,
         [p === "x" ? "x2" : "y2"]: w,
-        [p === "x" ? "xError" : "yError"]: S,
+        [p === "x" ? "xError" : "yError"]: E,
         [p === "x" ? "xError2" : "yError2"]: _,
         ...k
     } = r, {
         bins: A,
-        timeUnits: F,
-        aggregate: T,
-        groupby: I,
-        encoding: N
-    } = ZP(k, n), D = [...T, ...m], M = c !== "raw" ? [] : I, E = $w(b, f, N, v);
+        timeUnits: T,
+        aggregate: M,
+        groupby: L,
+        encoding: F
+    } = ZP(k, n), O = [...M, ...m], N = c !== "raw" ? [] : L, R = Cw(b, f, F, v);
     return {
         transform: [
             ...a.transform ?? [],
             ...A,
-            ...F,
-            ...D.length === 0 ? [] : [{
-                aggregate: D,
-                groupby: M
+            ...T,
+            ...O.length === 0 ? [] : [{
+                aggregate: O,
+                groupby: N
             }],
             ...y
         ],
-        groupby: M,
+        groupby: N,
         continuousAxisChannelDef: f,
         continuousAxis: p,
-        encodingWithoutContinuousAxis: N,
+        encodingWithoutContinuousAxis: F,
         ticksOrient: l === "vertical" ? "horizontal" : "vertical",
         markDef: u,
         outerSpec: a,
-        tooltipEncoding: E
+        tooltipEncoding: R
     };
 }
 
 function w0e(e, t, n, i, r, s, o, a) {
     let u = [],
         l = [];
     const c = t.field;
     let f, d = !1;
     if (s === "raw") {
         const h = e.center ? e.center : e.extent ? e.extent === "iqr" ? "median" : "mean" : a.errorbar.center,
             g = e.extent ? e.extent : h === "mean" ? "stderr" : "iqr";
-        if (h === "median" != (g === "iqr") && K(Ope(h, g, o)), g === "stderr" || g === "stdev")
+        if (h === "median" != (g === "iqr") && J(Ope(h, g, o)), g === "stderr" || g === "stdev")
             u = [{
                 op: g,
                 field: c,
                 as: `extent_${c}`
             }, {
                 op: h,
                 field: c,
@@ -39102,15 +39089,15 @@
                 calculate: `datum["center_${c}"] + datum["extent_${c}"]`,
                 as: `upper_${c}`
             }, {
                 calculate: `datum["center_${c}"] - datum["extent_${c}"]`,
                 as: `lower_${c}`
             }], f = [{
                 fieldPrefix: "center_",
-                titlePrefix: Cg(h)
+                titlePrefix: $g(h)
             }, {
                 fieldPrefix: "upper_",
                 titlePrefix: i4(h, g, "+")
             }, {
                 fieldPrefix: "lower_",
                 titlePrefix: i4(h, g, "-")
             }], d = !0;
@@ -39154,15 +39141,15 @@
                     type: "quantitative"
                 }, a, {
                     allowDisabling: !1
                 })
             }];
         }
     } else {
-        (e.center || e.extent) && K(Npe(e.center, e.extent)), s === "aggregated-upper-lower" ? (f = [], l = [{
+        (e.center || e.extent) && J(Npe(e.center, e.extent)), s === "aggregated-upper-lower" ? (f = [], l = [{
             calculate: `datum["${n.field}"]`,
             as: `upper_${c}`
         }, {
             calculate: `datum["${c}"]`,
             as: `lower_${c}`
         }]) : s === "aggregated-error" && (f = [{
             fieldPrefix: "",
@@ -39188,15 +39175,15 @@
         errorBarSpecificAggregate: u,
         tooltipSummary: f,
         tooltipTitleWithFieldName: d
     };
 }
 
 function i4(e, t, n) {
-    return `${Cg(e)} ${n} ${t}`;
+    return `${$g(e)} ${n} ${t}`;
 }
 const d6 = "errorband",
     _0e = ["band", "borders"],
     E0e = new eb(d6, lz);
 
 function lz(e, {
     config: t
@@ -39232,15 +39219,15 @@
         ...d,
         ...g,
         ariaRoleDescription: "errorband"
     }, h = {
         ...h,
         ...g,
         aria: !1
-    }) : l.interpolate ? K(Y8("interpolate")) : l.tension && K(Y8("tension")), {
+    }) : l.interpolate ? J(Y8("interpolate")) : l.tension && J(Y8("tension")), {
         ...a,
         transform: n,
         layer: [
             ...c({
                 partName: "band",
                 mark: d,
                 positionPrefix: "lower",
@@ -39269,15 +39256,15 @@
     cz[e] = {
         normalizer: i,
         parts: n
     };
 }
 
 function S0e() {
-    return Y(cz);
+    return X(cz);
 }
 h6(K0, sz, d0e);
 h6(f6, az, p0e);
 h6(d6, lz, _0e);
 const k0e = [
         "gradientHorizontalMaxLength",
         "gradientHorizontalMinLength",
@@ -39311,23 +39298,23 @@
         labelFontStyle: "fontStyle",
         labelFontWeight: "fontWeight",
         labelLimit: "limit",
         labelLineHeight: "lineHeight",
         labelOrient: "orient",
         labelPadding: "offset"
     },
-    A0e = Y(fz),
-    $0e = Y(dz),
-    C0e = {
+    A0e = X(fz),
+    C0e = X(dz),
+    $0e = {
         header: 1,
         headerRow: 1,
         headerColumn: 1,
         headerFacet: 1
     },
-    hz = Y(C0e),
+    hz = X($0e),
     gz = [
         "size",
         "shape",
         "fill",
         "stroke",
         "strokeDash",
         "strokeWidth",
@@ -39433,15 +39420,15 @@
     };
 
 function g6(e) {
     return e === "legend" || !!(e != null && e.legend);
 }
 
 function Vv(e) {
-    return g6(e) && re(e);
+    return g6(e) && oe(e);
 }
 
 function p6(e) {
     return !!(e != null && e.select);
 }
 
 function pz(e) {
@@ -39497,29 +39484,29 @@
     step: e,
     offsetIsDiscrete: t
 }) {
     return t ? e.for ?? "offset" : "position";
 }
 
 function ws(e) {
-    return re(e) && e.step !== void 0;
+    return oe(e) && e.step !== void 0;
 }
 
 function r4(e) {
     return e.view || e.width || e.height;
 }
 const s4 = 20,
     O0e = {
         align: 1,
         bounds: 1,
         center: 1,
         columns: 1,
         spacing: 1
     },
-    D0e = Y(O0e);
+    D0e = X(O0e);
 
 function R0e(e, t, n) {
     const i = n[t],
         r = {},
         {
             spacing: s,
             columns: o
@@ -39534,26 +39521,26 @@
                     column: u.column ?? s
                 };
             } else
                 r[a] = e[a];
     return r;
 }
 
-function Cw(e, t) {
+function $w(e, t) {
     return e[t] ?? e[t === "width" ? "continuousWidth" : "continuousHeight"];
 }
 
 function J0(e, t) {
     const n = Q0(e, t);
     return ws(n) ? n.step : yz;
 }
 
 function Q0(e, t) {
     const n = e[t] ?? e[t === "width" ? "discreteWidth" : "discreteHeight"];
-    return St(n, {
+    return kt(n, {
         step: e.step
     });
 }
 const yz = 20,
     L0e = {
         continuousWidth: 200,
         continuousHeight: 200,
@@ -39676,15 +39663,15 @@
         gray15: "#fff"
     };
 
 function P0e(e = {}) {
     return {
         signals: [{
             name: "color",
-            value: re(e) ? {
+            value: oe(e) ? {
                 ...a4,
                 ...e
             } : a4
         }],
         mark: {
             color: {
                 signal: "color.blue"
@@ -39764,15 +39751,15 @@
     };
 }
 
 function z0e(e) {
     return {
         signals: [{
             name: "fontSize",
-            value: re(e) ? {
+            value: oe(e) ? {
                 ...o4,
                 ...e
             } : o4
         }],
         text: {
             fontSize: {
                 signal: "fontSize.text"
@@ -39822,25 +39809,25 @@
                 font: e
             }
         }
     };
 }
 
 function bz(e) {
-    const t = Y(e || {}),
+    const t = X(e || {}),
         n = {};
     for (const i of t) {
         const r = e[i];
         n[i] = Pg(r) ? YI(r) : bi(r);
     }
     return n;
 }
 
 function U0e(e) {
-    const t = Y(e),
+    const t = X(e),
         n = {};
     for (const i of t)
         n[i] = bz(e[i]);
     return n;
 }
 const j0e = [
     ...MP,
@@ -39909,15 +39896,15 @@
         "scale",
         "selection",
         "overlay"
         // FIXME: Redesign and unhide this
     ],
     H0e = {
         view: ["continuousWidth", "continuousHeight", "discreteWidth", "discreteHeight", "step"],
-        ...Cme
+        ...$me
     };
 
 function G0e(e) {
     e = ke(e);
     for (const t of W0e)
         delete e[t];
     if (e.axis)
@@ -39925,15 +39912,15 @@
             Pg(e.axis[t]) && delete e.axis[t];
     if (e.legend)
         for (const t of k0e)
             delete e.legend[t];
     if (e.mark) {
         for (const t of K8)
             delete e.mark[t];
-        e.mark.tooltip && re(e.mark.tooltip) && delete e.mark.tooltip;
+        e.mark.tooltip && oe(e.mark.tooltip) && delete e.mark.tooltip;
     }
     e.params && (e.signals = (e.signals || []).concat(pz(e.params)), delete e.params);
     for (const t of q0e) {
         for (const i of K8)
             delete e[t][i];
         const n = H0e[t];
         if (n)
@@ -39941,15 +39928,15 @@
                 delete e[t][i];
         Y0e(e, t);
     }
     for (const t of S0e())
         delete e[t];
     V0e(e);
     for (const t in e)
-        re(e[t]) && Je(e[t]) && delete e[t];
+        oe(e[t]) && Je(e[t]) && delete e[t];
     return Je(e) ? void 0 : e;
 }
 
 function V0e(e) {
     const {
         titleMarkConfig: t,
         subtitleMarkConfig: n,
@@ -39980,15 +39967,15 @@
 }
 
 function X0e(e) {
     return "repeat" in e;
 }
 
 function K0e(e) {
-    return !W(e.repeat) && e.repeat.layer;
+    return !V(e.repeat) && e.repeat.layer;
 }
 class b6 {
     map(t, n) {
         return Xy(t) ? this.mapFacet(t, n) : X0e(t) ? this.mapRepeat(t, n) : y6(t) ? this.mapHConcat(t, n) : nb(t) ? this.mapVConcat(t, n) : m6(t) ? this.mapConcat(t, n) : this.mapLayerOrUnit(t, n);
     }
     mapLayerOrUnit(t, n) {
         if (ib(t))
@@ -40046,37 +40033,37 @@
     center: 1,
     normalize: 1
 };
 
 function Q0e(e) {
     return e in J0e;
 }
-const Z0e = /* @__PURE__ */ new Set([AP, Hy, Wy, W0, Vy, K5, J5, Gy, $P, X5]),
+const Z0e = /* @__PURE__ */ new Set([AP, Hy, Wy, W0, Vy, K5, J5, Gy, CP, X5]),
     e1e = /* @__PURE__ */ new Set([Hy, Wy, AP]);
 
 function Vl(e) {
-    return J(e) && Yc(e) === "quantitative" && !e.bin;
+    return Q(e) && Yc(e) === "quantitative" && !e.bin;
 }
 
 function u4(e, t, {
     orient: n,
     type: i
 }) {
     const r = t === "x" ? "y" : "radius",
         s = t === "x" && ["bar", "area"].includes(i),
         o = e[t],
         a = e[r];
-    if (J(o) && J(a))
+    if (Q(o) && Q(a))
         if (Vl(o) && Vl(a)) {
             if (o.stack)
                 return t;
             if (a.stack)
                 return r;
-            const u = J(o) && !!o.aggregate,
-                l = J(a) && !!a.aggregate;
+            const u = Q(o) && !!o.aggregate,
+                l = Q(a) && !!a.aggregate;
             if (u !== l)
                 return u ? t : r;
             if (s) {
                 if (n === "vertical")
                     return r;
                 if (n === "horizontal")
                     return t;
@@ -40116,60 +40103,60 @@
         i = n.type;
     if (!Z0e.has(i))
         return null;
     const r = u4(t, "x", n) || u4(t, "theta", n);
     if (!r)
         return null;
     const s = t[r],
-        o = J(s) ? te(s, {}) : void 0,
+        o = Q(s) ? ne(s, {}) : void 0,
         a = t1e(r),
         u = [],
         l = /* @__PURE__ */ new Set();
     if (t[a]) {
         const y = t[a],
-            b = J(y) ? te(y, {}) : void 0;
+            b = Q(y) ? ne(y, {}) : void 0;
         b && b !== o && (u.push(a), l.add(b));
     }
     const c = a === "x" ? "xOffset" : "yOffset",
         f = t[c],
-        d = J(f) ? te(f, {}) : void 0;
+        d = Q(f) ? ne(f, {}) : void 0;
     d && d !== o && (u.push(c), l.add(d));
     const h = gge.reduce((y, b) => {
-        if (b !== "tooltip" && Cu(t, b)) {
+        if (b !== "tooltip" && $u(t, b)) {
             const v = t[b];
-            for (const x of ne(v)) {
+            for (const x of re(v)) {
                 const w = xs(x);
                 if (w.aggregate)
                     continue;
-                const S = te(w, {});
+                const E = ne(w, {});
                 // if fielddef is a repeat, just include it in the stack by
-                (!S || // otherwise, the field must be different from the groupBy fields.
-                    !l.has(S)) && y.push({
+                (!E || // otherwise, the field must be different from the groupBy fields.
+                    !l.has(E)) && y.push({
                     channel: b,
                     fieldDef: w
                 });
             }
         }
         return y;
     }, []);
     let g;
-    return s.stack !== void 0 ? Oa(s.stack) ? g = s.stack ? "zero" : null : g = s.stack : e1e.has(i) && (g = "zero"), !g || !Q0e(g) || a6(t) && h.length === 0 ? null : (p = s == null ? void 0 : s.scale) != null && p.type && ((m = s == null ? void 0 : s.scale) == null ? void 0 : m.type) !== ri.LINEAR ? (s != null && s.stack && K(Mpe(s.scale.type)), null) : Ae(t[Ds(r)]) ? (s.stack !== void 0 && K(Cpe(r)), null) : (J(s) && s.aggregate && !Age.has(s.aggregate) && K(Tpe(s.aggregate)), {
+    return s.stack !== void 0 ? Oa(s.stack) ? g = s.stack ? "zero" : null : g = s.stack : e1e.has(i) && (g = "zero"), !g || !Q0e(g) || a6(t) && h.length === 0 ? null : (p = s == null ? void 0 : s.scale) != null && p.type && ((m = s == null ? void 0 : s.scale) == null ? void 0 : m.type) !== ri.LINEAR ? (s != null && s.stack && J(Mpe(s.scale.type)), null) : Ae(t[Ds(r)]) ? (s.stack !== void 0 && J($pe(r)), null) : (Q(s) && s.aggregate && !Age.has(s.aggregate) && J(Tpe(s.aggregate)), {
         groupbyChannels: u,
         groupbyFields: l,
         fieldChannel: r,
         impute: s.impute === null ? !1 : Va(i),
         stackBy: h,
         offset: g
     });
 }
 
 function wz(e, t, n) {
     const i = Zn(e),
         r = He("orient", i, n);
-    if (i.orient = s1e(i.type, t, r), r !== void 0 && r !== i.orient && K(dpe(i.orient, r)), i.type === "bar" && i.orient) {
+    if (i.orient = s1e(i.type, t, r), r !== void 0 && r !== i.orient && J(dpe(i.orient, r)), i.type === "bar" && i.orient) {
         const u = He("cornerRadiusEnd", i, n);
         if (u !== void 0) {
             const l = i.orient === "horizontal" && t.x2 || i.orient === "vertical" && t.y2 ? ["cornerRadius"] : Fme[i.orient];
             for (const c of l)
                 i[c] = u;
             i.cornerRadiusEnd !== void 0 && delete i.cornerRadiusEnd;
         }
@@ -40191,55 +40178,55 @@
 function r1e(e, t, {
     graticule: n
 }) {
     if (n)
         return !1;
     const i = vo("filled", e, t),
         r = e.type;
-    return St(i, r !== Vy && r !== Gy && r !== W0);
+    return kt(i, r !== Vy && r !== Gy && r !== W0);
 }
 
 function s1e(e, t, n) {
     switch (e) {
         case Vy:
         case K5:
         case J5:
-        case $P:
+        case CP:
         case wme:
         case xme:
             return;
     }
     const {
         x: i,
         y: r,
         x2: s,
         y2: o
     } = t;
     switch (e) {
         case Hy:
-            if (J(i) && (Jt(i.bin) || J(r) && r.aggregate && !i.aggregate))
+            if (Q(i) && (Qt(i.bin) || Q(r) && r.aggregate && !i.aggregate))
                 return "vertical";
-            if (J(r) && (Jt(r.bin) || J(i) && i.aggregate && !r.aggregate))
+            if (Q(r) && (Qt(r.bin) || Q(i) && i.aggregate && !r.aggregate))
                 return "horizontal";
             if (o || s) {
                 if (n)
                     return n;
                 if (!s)
-                    return (J(i) && i.type === tl && !rt(i.bin) || G0(i)) && J(r) && Jt(r.bin) ? "horizontal" : "vertical";
+                    return (Q(i) && i.type === tl && !st(i.bin) || G0(i)) && Q(r) && Qt(r.bin) ? "horizontal" : "vertical";
                 if (!o)
-                    return (J(r) && r.type === tl && !rt(r.bin) || G0(r)) && J(i) && Jt(i.bin) ? "vertical" : "horizontal";
+                    return (Q(r) && r.type === tl && !st(r.bin) || G0(r)) && Q(i) && Qt(i.bin) ? "vertical" : "horizontal";
             }
         case W0:
-            if (s && !(J(i) && Jt(i.bin)) && o && !(J(r) && Jt(r.bin)))
+            if (s && !(Q(i) && Qt(i.bin)) && o && !(Q(r) && Qt(r.bin)))
                 return;
         case Wy:
             if (o)
-                return J(r) && Jt(r.bin) ? "horizontal" : "vertical";
+                return Q(r) && Qt(r.bin) ? "horizontal" : "vertical";
             if (s)
-                return J(i) && Jt(i.bin) ? "vertical" : "horizontal";
+                return Q(i) && Qt(i.bin) ? "vertical" : "horizontal";
             if (e === W0) {
                 if (i && !r)
                     return "vertical";
                 if (r && !i)
                     return "horizontal";
             }
         case Gy:
@@ -40251,16 +40238,16 @@
             if (a && !u)
                 return e !== "tick" ? "horizontal" : "vertical";
             if (!a && u)
                 return e !== "tick" ? "vertical" : "horizontal";
             if (a && u)
                 return "vertical";
             {
-                const l = Wn(i) && i.type === Gc,
-                    c = Wn(r) && r.type === Gc;
+                const l = Hn(i) && i.type === Gc,
+                    c = Hn(r) && r.type === Gc;
                 if (l && !c)
                     return "vertical";
                 if (!l && c)
                     return "horizontal";
             }
             return;
         }
@@ -40270,15 +40257,15 @@
 
 function o1e(e) {
     const {
         point: t,
         line: n,
         ...i
     } = e;
-    return Y(i).length > 1 ? i : i.type;
+    return X(i).length > 1 ? i : i.type;
 }
 
 function a1e(e) {
     for (const t of ["line", "area", "rule", "trail"])
         e[t] && (e = {
             ...e,
             // TODO: remove as any
@@ -40286,15 +40273,15 @@
         });
     return e;
 }
 
 function Yv(e, t = {}, n) {
     return e.point === "transparent" ? {
         opacity: 0
-    } : e.point ? re(e.point) ? e.point : {} : e.point !== void 0 ? null : t.point || n.shape ? re(t.point) ? t.point : {} : void 0;
+    } : e.point ? oe(e.point) ? e.point : {} : e.point !== void 0 ? null : t.point || n.shape ? oe(t.point) ? t.point : {} : void 0;
 }
 
 function l4(e, t = {}) {
     return e.line ? e.line === !0 ? {} : e.line : e.line !== void 0 ? null : t.line ? t.line === !0 ? {} : t.line : void 0;
 }
 class u1e {
     constructor() {
@@ -40409,15 +40396,15 @@
     const i = t[e];
     if (Hme(i)) {
         if (i.repeat in n)
             return {
                 ...t,
                 [e]: n[i.repeat]
             };
-        K(Gge(i.repeat));
+        J(Gge(i.repeat));
         return;
     }
     return t;
 }
 
 function _z(e, t) {
     if (e = Mw("field", e, t), e !== void 0) {
@@ -40433,15 +40420,15 @@
             };
         }
         return e;
     }
 }
 
 function c4(e, t) {
-    if (J(e))
+    if (Q(e))
         return _z(e, t);
     {
         const n = Mw("datum", e, t);
         return n !== e && !n.type && (n.type = "nominal"), n;
     }
 }
 
@@ -40473,17 +40460,17 @@
         return e;
     }
 }
 
 function Ez(e, t) {
     const n = {};
     for (const i in e)
-        if (be(e, i)) {
+        if (xe(e, i)) {
             const r = e[i];
-            if (W(r))
+            if (V(r))
                 n[i] = r.map((s) => f4(s, t)).filter((s) => s);
             else {
                 const s = f4(r, t);
                 s !== void 0 && (n[i] = s);
             }
         }
     return n;
@@ -40498,28 +40485,28 @@
                 encoding: n,
                 mark: i
             } = t;
             if (i === "line" || vs(i) && i.type === "line")
                 for (const r of fge) {
                     const s = El(r),
                         o = n[s];
-                    if (n[r] && (J(o) && !Jt(o.bin) || Ls(o)))
+                    if (n[r] && (Q(o) && !Qt(o.bin) || Ls(o)))
                         return !0;
                 }
         }
         return !1;
     }
     run(t, n, i) {
         const {
             encoding: r,
             mark: s
         } = t;
-        return K(fpe(!!r.x2, !!r.y2)), i({
+        return J(fpe(!!r.x2, !!r.y2)), i({
             ...t,
-            mark: re(s) ? {
+            mark: oe(s) ? {
                 ...s,
                 type: "rule"
             } : "rule"
         }, n);
     }
 }
 class f1e extends b6 {
@@ -40530,17 +40517,17 @@
             E0e,
             new u1e(),
             new c1e()
         ];
     }
     map(t, n) {
         if (Mo(t)) {
-            const i = Cu(t.encoding, uo),
-                r = Cu(t.encoding, lo),
-                s = Cu(t.encoding, Dy);
+            const i = $u(t.encoding, uo),
+                r = $u(t.encoding, lo),
+                s = $u(t.encoding, Dy);
             if (i || r || s)
                 return this.mapFacetedUnit(t, n);
         }
         return super.map(t, n);
     }
     // This is for normalizing non-facet unit
     mapUnit(t, n) {
@@ -40616,55 +40603,55 @@
     mapNonLayerRepeat(t, n) {
         const {
             repeat: i,
             spec: r,
             data: s,
             ...o
         } = t;
-        !W(i) && t.columns && (t = ii(t, ["columns"]), K(W8("repeat")));
+        !V(i) && t.columns && (t = ii(t, ["columns"]), J(W8("repeat")));
         const a = [],
             {
                 repeater: u = {},
                 repeaterPrefix: l = ""
             } = n,
-            c = !W(i) && i.row || [u ? u.row : null],
-            f = !W(i) && i.column || [u ? u.column : null],
-            d = W(i) && i || [u ? u.repeat : null];
+            c = !V(i) && i.row || [u ? u.row : null],
+            f = !V(i) && i.column || [u ? u.column : null],
+            d = V(i) && i || [u ? u.repeat : null];
         for (const g of d)
             for (const p of c)
                 for (const m of f) {
                     const y = {
                             repeat: g,
                             row: p,
                             column: m,
                             layer: u.layer
                         },
-                        b = (r.name ? `${r.name}_` : "") + l + "child__" + (W(i) ? `${ft(g)}` : (i.row ? `row_${ft(p)}` : "") + (i.column ? `column_${ft(m)}` : "")),
+                        b = (r.name ? `${r.name}_` : "") + l + "child__" + (V(i) ? `${ft(g)}` : (i.row ? `row_${ft(p)}` : "") + (i.column ? `column_${ft(m)}` : "")),
                         v = this.map(r, {
                             ...n,
                             repeater: y,
                             repeaterPrefix: b
                         });
                     v.name = b, a.push(ii(v, ["data"]));
                 }
-        const h = W(i) ? t.columns : i.column ? i.column.length : 1;
+        const h = V(i) ? t.columns : i.column ? i.column.length : 1;
         return {
             data: r.data ?? s,
             // data from child spec should have precedence
             align: "all",
             ...o,
             columns: h,
             concat: a
         };
     }
     mapFacet(t, n) {
         const {
             facet: i
         } = t;
-        return Rg(i) && t.columns && (t = ii(t, ["columns"]), K(W8("facet"))), super.mapFacet(t, n);
+        return Rg(i) && t.columns && (t = ii(t, ["columns"]), J(W8("facet"))), super.mapFacet(t, n);
     }
     mapUnitWithParentEncodingOrProjection(t, n) {
         const {
             encoding: i,
             projection: r
         } = t, {
             parentEncoding: s,
@@ -40741,15 +40728,15 @@
     getFacetMappingAndLayout(t, n) {
         const {
             row: i,
             column: r,
             facet: s
         } = t;
         if (i || r) {
-            s && K(lpe([...i ? [uo] : [], ...r ? [lo] : []]));
+            s && J(lpe([...i ? [uo] : [], ...r ? [lo] : []]));
             const o = {},
                 a = {};
             for (const u of [uo, lo]) {
                 const l = t[u];
                 if (l) {
                     const {
                         align: c,
@@ -40827,15 +40814,15 @@
 function d4({
     parentEncoding: e,
     encoding: t = {},
     layer: n
 }) {
     let i = {};
     if (e) {
-        const r = /* @__PURE__ */ new Set([...Y(e), ...Y(t)]);
+        const r = /* @__PURE__ */ new Set([...X(e), ...X(t)]);
         for (const s of r) {
             const o = t[s],
                 a = e[s];
             if (Ae(o)) {
                 const u = {
                     ...a,
                     ...o
@@ -40844,27 +40831,27 @@
             } else
                 Lg(o) ? i[s] = {
                     ...o,
                     condition: {
                         ...a,
                         ...o.condition
                     }
-                } : o || o === null ? i[s] = o : (n || Dr(a) || de(a) || Ae(a) || W(a)) && (i[s] = a);
+                } : o || o === null ? i[s] = o : (n || Dr(a) || de(a) || Ae(a) || V(a)) && (i[s] = a);
         }
     } else
         i = t;
     return !i || Je(i) ? void 0 : i;
 }
 
 function h4(e) {
     const {
         parentProjection: t,
         projection: n
     } = e;
-    return t && n && K(Qge({
+    return t && n && J(Qge({
         parentProjection: t,
         projection: n
     })), n ?? t;
 }
 
 function v6(e) {
     return "filter" in e;
@@ -40934,19 +40921,19 @@
     return "impute" in e;
 }
 
 function A1e(e) {
     return "timeUnit" in e;
 }
 
-function $1e(e) {
+function C1e(e) {
     return "aggregate" in e;
 }
 
-function C1e(e) {
+function $1e(e) {
     return "stack" in e;
 }
 
 function M1e(e) {
     return "fold" in e;
 }
 
@@ -40986,15 +40973,15 @@
                 const {
                     init: a,
                     bind: u,
                     empty: l,
                     ...c
                 } = o;
                 c.type === "single" ? (c.type = "point", c.toggle = !1) : c.type === "multi" && (c.type = "point"), n.emptySelections[s] = l !== "none";
-                for (const f of nn(n.selectionPredicates[s] ?? {}))
+                for (const f of rn(n.selectionPredicates[s] ?? {}))
                     f.empty = l !== "none";
                 return {
                     name: s,
                     value: a,
                     select: c,
                     bind: u
                 };
@@ -41013,15 +41000,15 @@
             if (v6(s))
                 return {
                     filter: Tw(s, t)
                 };
             if (kz(s) && Sl(s.bin))
                 return {
                     ...s,
-                    bin: $z(s.bin)
+                    bin: Cz(s.bin)
                 };
             if (Sz(s)) {
                 const {
                     selection: o,
                     ...a
                 } = s.from;
                 return o ? {
@@ -41041,28 +41028,28 @@
     }
     return e;
 }
 
 function Az(e, t) {
     var i, r;
     const n = ke(e);
-    if (J(n) && Sl(n.bin) && (n.bin = $z(n.bin)), $l(n) && ((r = (i = n.scale) == null ? void 0 : i.domain) != null && r.selection)) {
+    if (Q(n) && Sl(n.bin) && (n.bin = Cz(n.bin)), Cl(n) && ((r = (i = n.scale) == null ? void 0 : i.domain) != null && r.selection)) {
         const {
             selection: s,
             ...o
         } = n.scale.domain;
         n.scale.domain = {
             ...o,
             ...s ? {
                 param: s
             } : {}
         };
     }
     if (Ky(n))
-        if (W(n.condition))
+        if (V(n.condition))
             n.condition = n.condition.map((s) => {
                 const {
                     selection: o,
                     param: a,
                     test: u,
                     ...l
                 } = s;
@@ -41082,15 +41069,15 @@
                 ...u,
                 test: Tw(n.condition, t)
             };
         }
     return n;
 }
 
-function $z(e) {
+function Cz(e) {
     const t = e.extent;
     if (t != null && t.selection) {
         const {
             selection: n,
             ...i
         } = t;
         return {
@@ -41134,15 +41121,15 @@
         const r = (n.path ?? []).concat(t.name),
             s = [];
         for (const o of i)
             if (!o.views || !o.views.length)
                 s.push(o);
             else
                 for (const a of o.views)
-                    (ie(a) && (a === t.name || r.includes(a)) || W(a) && // logic for backwards compatibility with view paths before we had unique names
+                    (se(a) && (a === t.name || r.includes(a)) || V(a) && // logic for backwards compatibility with view paths before we had unique names
                         // @ts-ignore
                         a.map((u) => r.indexOf(u)).every((u, l, c) => u !== -1 && (l === 0 || u > c[l - 1]))) && s.push(o);
         return s.length && (t.params = s), t;
     }
 }
 for (const e of ["mapFacet", "mapRepeat", "mapHConcat", "mapVConcat", "mapLayer"]) {
     const t = Fw.prototype[e];
@@ -41154,15 +41141,15 @@
 function O1e(e, t) {
     return e.name ? {
         ...t,
         path: (t.path ?? []).concat(e.name)
     } : t;
 }
 
-function Cz(e, t) {
+function $z(e, t) {
     t === void 0 && (t = vz(e.config));
     const n = I1e(e, t),
         {
             width: i,
             height: r
         } = e,
         s = P1e(n, {
@@ -41185,34 +41172,34 @@
     const n = {
         config: t
     };
     return L1e.map(D1e.map(R1e.map(e, n), n), n);
 }
 
 function p4(e) {
-    return ie(e) ? {
+    return se(e) ? {
         type: e
     } : e ?? {};
 }
 
 function P1e(e, t, n) {
     let {
         width: i,
         height: r
     } = t;
     const s = Mo(e) || ib(e),
         o = {};
-    s ? i == "container" && r == "container" ? (o.type = "fit", o.contains = "padding") : i == "container" ? (o.type = "fit-x", o.contains = "padding") : r == "container" && (o.type = "fit-y", o.contains = "padding") : (i == "container" && (K(B8("width")), i = void 0), r == "container" && (K(B8("height")), r = void 0));
+    s ? i == "container" && r == "container" ? (o.type = "fit", o.contains = "padding") : i == "container" ? (o.type = "fit-x", o.contains = "padding") : r == "container" && (o.type = "fit-y", o.contains = "padding") : (i == "container" && (J(B8("width")), i = void 0), r == "container" && (J(B8("height")), r = void 0));
     const a = {
         type: "pad",
         ...o,
         ...n ? p4(n.autosize) : {},
         ...p4(e.autosize)
     };
-    if (a.type === "fit" && !s && (K(Rge), a.type = "pad"), i == "container" && !(a.type == "fit" || a.type == "fit-x") && K(U8("width")), r == "container" && !(a.type == "fit" || a.type == "fit-y") && K(U8("height")), !wi(a, {
+    if (a.type === "fit" && !s && (J(Rge), a.type = "pad"), i == "container" && !(a.type == "fit" || a.type == "fit-x") && J(U8("width")), r == "container" && !(a.type == "fit" || a.type == "fit-y") && J(U8("height")), !wi(a, {
             type: "pad"
         }))
         return a;
 }
 
 function z1e(e) {
     return e === "fit" || e === "fit-x" || e === "fit-y";
@@ -41244,15 +41231,15 @@
         return {
             ...this.explicit,
             // Explicit properties comes first
             ...this.implicit
         };
     }
     get(t) {
-        return St(this.explicit[t], this.implicit[t]);
+        return kt(this.explicit[t], this.implicit[t]);
     }
     getWithExplicit(t) {
         return this.explicit[t] !== void 0 ? {
             explicit: !0,
             value: this.explicit[t]
         } : this.implicit[t] !== void 0 ? {
             explicit: !1,
@@ -41281,15 +41268,15 @@
         n[t] !== void 0 && this.set(t, n[t], !0);
     }
     /**
      * Merge split object into this split object. Properties from the other split
      * overwrite properties from this split.
      */
     copyAll(t) {
-        for (const n of Y(t.combine())) {
+        for (const n of X(t.combine())) {
             const i = t.getWithExplicit(n);
             this.setWithExplicit(n, i);
         }
     }
 }
 
 function Qr(e) {
@@ -41310,15 +41297,15 @@
     return (t, n, i, r) => {
         const s = e(t.value, n.value);
         return s > 0 ? t : s < 0 ? n : rb(t, n, i, r);
     };
 }
 
 function rb(e, t, n, i) {
-    return e.explicit && t.explicit && K(wpe(n, i, e.value, t.value)), e;
+    return e.explicit && t.explicit && J(wpe(n, i, e.value, t.value)), e;
 }
 
 function Ma(e, t, n, i, r = rb) {
     return e === void 0 || e.value === void 0 ? t : e.explicit && !t.explicit ? e : t.explicit && !e.explicit ? t : wi(e.value, t.value) ? e : r(e, t, n, i);
 }
 class j1e extends To {
     constructor(t = {}, n = {}, i = !1) {
@@ -41368,68 +41355,68 @@
         hasLegend: n,
         index: i,
         ...r
     } = e;
     return r.field = sr(r.field), r;
 }
 
-function rl(e, t = !0, n = Sn) {
-    if (W(e)) {
+function rl(e, t = !0, n = kn) {
+    if (V(e)) {
         const i = e.map((r) => rl(r, t, n));
         return t ? `[${i.join(", ")}]` : i;
     } else if (kl(e))
         return n(t ? el(e) : Gpe(e));
     return t ? n(Qe(e)) : e;
 }
 
 function q1e(e, t) {
-    for (const n of nn(e.component.selection ?? {})) {
+    for (const n of rn(e.component.selection ?? {})) {
         const i = n.name;
         let r = `${i}${Fa}, ${n.resolve === "global" ? "true" : `{unit: ${Mu(e)}}`}`;
         for (const s of ub)
             s.defined(n) && (s.signals && (t = s.signals(e, n, t)), s.modifyExpr && (r = s.modifyExpr(e, n, r)));
         t.push({
             name: i + wye,
             on: [{
                 events: {
                     signal: n.name + Fa
                 },
-                update: `modify(${Z(n.name + sl)}, ${r})`
+                update: `modify(${ee(n.name + sl)}, ${r})`
             }]
         });
     }
     return w6(t);
 }
 
 function W1e(e, t) {
-    if (e.component.selection && Y(e.component.selection).length) {
-        const n = Z(e.getName("cell"));
+    if (e.component.selection && X(e.component.selection).length) {
+        const n = ee(e.getName("cell"));
         t.unshift({
             name: "facet",
             value: {},
             on: [{
                 events: za("pointermove", "scope"),
                 update: `isTuple(facet) ? facet : group(${n}).datum`
             }]
         });
     }
     return w6(t);
 }
 
 function H1e(e, t) {
     let n = !1;
-    for (const i of nn(e.component.selection ?? {})) {
+    for (const i of rn(e.component.selection ?? {})) {
         const r = i.name,
-            s = Z(r + sl);
+            s = ee(r + sl);
         if (t.filter((a) => a.name === r).length === 0) {
             const a = i.resolve === "global" ? "union" : i.resolve,
                 u = i.type === "point" ? ", true, true)" : ")";
             t.push({
                 name: i.name,
-                update: `${Jz}(${s}, ${Z(a)}${u}`
+                update: `${Jz}(${s}, ${ee(a)}${u}`
             });
         }
         n = !0;
         for (const a of ub)
             a.defined(i) && a.topLevelSignals && (t = a.topLevelSignals(e, i, t));
     }
     return n && t.filter((r) => r.name === "unit").length === 0 && t.unshift({
@@ -41443,15 +41430,15 @@
 }
 
 function G1e(e, t) {
     const n = [...t],
         i = Mu(e, {
             escape: !1
         });
-    for (const r of nn(e.component.selection ?? {})) {
+    for (const r of rn(e.component.selection ?? {})) {
         const s = {
             name: r.name + sl
         };
         if (r.project.hasSelectionId && (s.transform = [{
                 type: "collect",
                 sort: {
                     field: Rr
@@ -41469,30 +41456,30 @@
         }
         n.filter((a) => a.name === r.name + sl).length || n.push(s);
     }
     return n;
 }
 
 function Dz(e, t) {
-    for (const n of nn(e.component.selection ?? {}))
+    for (const n of rn(e.component.selection ?? {}))
         for (const i of ub)
             i.defined(n) && i.marks && (t = i.marks(e, n, t));
     return t;
 }
 
 function V1e(e, t) {
     for (const n of e.children)
-        bt(n) && (t = Dz(n, t));
+        vt(n) && (t = Dz(n, t));
     return t;
 }
 
 function Y1e(e, t, n, i) {
     const r = nB(e, t.param, t);
     return {
-        signal: Ni(n.get("type")) && W(i) && i[0] > i[1] ? `isValid(${r}) && reverse(${r})` : r
+        signal: Ni(n.get("type")) && V(i) && i[0] > i[1] ? `isValid(${r}) && reverse(${r})` : r
     };
 }
 
 function w6(e) {
     return e.map((t) => (t.on && !t.on.length && delete t.on, t));
 }
 class Ke {
@@ -41518,15 +41505,15 @@
         return this._children;
     }
     numChildren() {
         return this._children.length;
     }
     addChild(t, n) {
         if (this._children.includes(t)) {
-            K(Xge);
+            J(Xge);
             return;
         }
         n !== void 0 ? this._children.splice(n, 0, t) : this._children.push(t);
     }
     removeChild(t) {
         const n = this._children.indexOf(t);
         return this._children.splice(n, 1), n;
@@ -41552,15 +41539,15 @@
         for (const r of this._children)
             r.parent = t;
         this._children = [], t.removeChild(this);
         const i = t.parent.removeChild(t);
         this._parent = n, n.addChild(this, i), t.parent = this;
     }
 }
-class zn extends Ke {
+class Bn extends Ke {
     clone() {
         const t = new this.constructor();
         return t.debugName = `clone_${this.debugName}`, t._source = this._source, t._name = `clone_${this._name}`, t.type = this.type, t.refCounts = this.refCounts, t.refCounts[t._name] = 0, t;
     }
     /**
      * @param source The name of the source. Will change in assemble.
      * @param type The type of the output node.
@@ -41617,62 +41604,62 @@
             const {
                 field: a,
                 timeUnit: u
             } = s;
             if (u) {
                 let l;
                 if (Al(u)) {
-                    if (bt(n)) {
+                    if (vt(n)) {
                         const {
                             mark: c,
                             markDef: f,
                             config: d
-                        } = n, h = Ca({
+                        } = n, h = $a({
                             fieldDef: s,
                             markDef: f,
                             config: d
                         });
                         (Ph(c) || h) && (l = {
-                            timeUnit: Wt(u),
+                            timeUnit: Ht(u),
                             field: a
                         });
                     }
                 } else
                     l = {
-                        as: te(s, {
+                        as: ne(s, {
                             forAs: !0
                         }),
                         field: a,
                         timeUnit: u
                     };
-                if (bt(n)) {
+                if (vt(n)) {
                     const {
                         mark: c,
                         markDef: f,
                         config: d
-                    } = n, h = Ca({
+                    } = n, h = $a({
                         fieldDef: s,
                         markDef: f,
                         config: d
                     });
-                    Ph(c) && kt(o) && h !== 0.5 && (l.rectBandPosition = h);
+                    Ph(c) && At(o) && h !== 0.5 && (l.rectBandPosition = h);
                 }
                 l && (r[Oe(l)] = l);
             }
             return r;
         }, {});
         return Je(i) ? null : new cs(t, i);
     }
     static makeFromTransform(t, n) {
         const {
             timeUnit: i,
             ...r
         } = {
             ...n
-        }, s = Wt(i), o = {
+        }, s = Ht(i), o = {
             ...r,
             timeUnit: s
         };
         return new cs(t, {
             [Oe(o)]: o
         });
     }
@@ -41698,28 +41685,28 @@
         for (const [i, r] of Aa(this.timeUnits)) {
             const s = Kv(r) ? r.as : `${r.field}_end`;
             t.has(s) || (n[i] = r);
         }
         this.timeUnits = n;
     }
     producedFields() {
-        return new Set(nn(this.timeUnits).map((t) => Kv(t) ? t.as : y4(t.field)));
+        return new Set(rn(this.timeUnits).map((t) => Kv(t) ? t.as : y4(t.field)));
     }
     dependentFields() {
-        return new Set(nn(this.timeUnits).map((t) => t.field));
+        return new Set(rn(this.timeUnits).map((t) => t.field));
     }
     hash() {
         return `TimeUnit ${Oe(this.timeUnits)}`;
     }
     assemble() {
         const t = [];
-        for (const n of nn(this.timeUnits)) {
+        for (const n of rn(this.timeUnits)) {
             const {
                 rectBandPosition: i
-            } = n, r = Wt(n.timeUnit);
+            } = n, r = Ht(n.timeUnit);
             if (Kv(n)) {
                 const {
                     field: s,
                     as: o
                 } = n, {
                     unit: a,
                     utc: u,
@@ -41820,74 +41807,74 @@
                         y = ft(`${i}_${m}_${b}`);
                     return a.add(y), {
                         [p]: y
                     };
                 },
                 l = t.type,
                 c = e.config.selection[l],
-                f = n.value !== void 0 ? ne(n.value) : null;
+                f = n.value !== void 0 ? re(n.value) : null;
             let {
                 fields: d,
                 encodings: h
-            } = re(n.select) ? n.select : {};
+            } = oe(n.select) ? n.select : {};
             if (!d && !h && f) {
                 for (const g of f)
-                    if (re(g))
-                        for (const p of Y(g))
-                            cge(p) ? (h || (h = [])).push(p) : l === "interval" ? (K(Hge), h = c.encodings) : (d ?? (d = [])).push(p);
+                    if (oe(g))
+                        for (const p of X(g))
+                            cge(p) ? (h || (h = [])).push(p) : l === "interval" ? (J(Hge), h = c.encodings) : (d ?? (d = [])).push(p);
             }!d && !h && (h = c.encodings, "fields" in c && (d = c.fields));
             for (const g of h ?? []) {
                 const p = e.fieldDef(g);
                 if (p) {
                     let m = p.field;
                     if (p.aggregate) {
-                        K(Lge(g, p.aggregate));
+                        J(Lge(g, p.aggregate));
                         continue;
                     } else if (!m) {
-                        K(q8(g));
+                        J(q8(g));
                         continue;
                     }
                     if (p.timeUnit && !Al(p.timeUnit)) {
                         m = e.vgField(g);
                         const y = {
                             timeUnit: p.timeUnit,
                             as: m,
                             field: p.field
                         };
                         o[Oe(y)] = y;
                     }
                     if (!s[m]) {
-                        const y = l === "interval" && Co(g) && Ni(e.getScaleComponent(g).get("type")) ? "R" : p.bin ? "R-RE" : "E",
+                        const y = l === "interval" && $o(g) && Ni(e.getScaleComponent(g).get("type")) ? "R" : p.bin ? "R-RE" : "E",
                             b = {
                                 field: m,
                                 channel: g,
                                 type: y,
                                 index: r.items.length
                             };
                         b.signals = {
                             ...u(b, "data"),
                             ...u(b, "visual")
                         }, r.items.push(s[m] = b), r.hasField[m] = s[m], r.hasSelectionId = r.hasSelectionId || m === Rr, LI(g) ? (b.geoChannel = g, b.channel = RI(g), r.hasChannel[b.channel] = s[m]) : r.hasChannel[g] = s[m];
                     }
                 } else
-                    K(q8(g));
+                    J(q8(g));
             }
             for (const g of d ?? []) {
                 if (r.hasField[g])
                     continue;
                 const p = {
                     type: "E",
                     field: g,
                     index: r.items.length
                 };
                 p.signals = {
                     ...u(p, "data")
                 }, r.items.push(p), r.hasField[g] = p, r.hasSelectionId = r.hasSelectionId || g === Rr;
             }
-            f && (t.init = f.map((g) => r.items.map((p) => re(g) ? g[p.geoChannel || p.channel] !== void 0 ? g[p.geoChannel || p.channel] : g[p.field] : g))), Je(o) || (r.timeUnit = new cs(null, o));
+            f && (t.init = f.map((g) => r.items.map((p) => oe(g) ? g[p.geoChannel || p.channel] !== void 0 ? g[p.geoChannel || p.channel] : g[p.field] : g))), Je(o) || (r.timeUnit = new cs(null, o));
         },
         signals: (e, t, n) => {
             const i = t.name + zg;
             return n.filter((s) => s.name === i).length > 0 || t.project.hasSelectionId ? n : n.concat({
                 name: i,
                 value: t.project.items.map(Oz)
             });
@@ -41895,20 +41882,20 @@
     },
     co = {
         defined: (e) => e.type === "interval" && e.resolve === "global" && e.bind && e.bind === "scales",
         parse: (e, t) => {
             const n = t.scales = [];
             for (const i of t.project.items) {
                 const r = i.channel;
-                if (!Co(r))
+                if (!$o(r))
                     continue;
                 const s = e.getScaleComponent(r),
                     o = s ? s.get("type") : void 0;
-                if (o == "sequential" && K(Bge), !s || !Ni(o)) {
-                    K(zge);
+                if (o == "sequential" && J(Bge), !s || !Ni(o)) {
+                    J(zge);
                     continue;
                 }
                 s.set("selectionExtent", {
                     param: t.name,
                     field: i.field
                 }, !0), n.push(i);
             }
@@ -41916,18 +41903,18 @@
         topLevelSignals: (e, t, n) => {
             const i = t.scales.filter((o) => n.filter((a) => a.name === o.signals.data).length === 0);
             if (!e.parent || x4(e) || i.length === 0)
                 return n;
             const r = n.filter((o) => o.name === t.name)[0];
             let s = r.update;
             if (s.indexOf(Jz) >= 0)
-                r.update = `{${i.map((o) => `${Z(sr(o.field))}: ${o.signals.data}`).join(", ")}}`;
+                r.update = `{${i.map((o) => `${ee(sr(o.field))}: ${o.signals.data}`).join(", ")}}`;
             else {
                 for (const o of i) {
-                    const a = `${Z(sr(o.field))}: ${o.signals.data}`;
+                    const a = `${ee(sr(o.field))}: ${o.signals.data}`;
                     s.includes(a) || (s = `${s.substring(0, s.length - 1)}, ${a}}`);
                 }
                 r.update = s;
             }
             return n.concat(i.map((o) => ({
                 name: o.signals.data
             })));
@@ -41939,15 +41926,15 @@
                     r.push = "outer", delete r.value, delete r.update;
                 }
             return n;
         }
     };
 
 function Nw(e, t) {
-    return `domain(${Z(e.scaleName(t))})`;
+    return `domain(${ee(e.scaleName(t))})`;
 }
 
 function x4(e) {
     return e.parent && If(e.parent) && !e.parent.parent;
 }
 const xc = "_brush",
     Lz = "_scale_trigger",
@@ -41956,59 +41943,59 @@
     J1e = "_center",
     Q1e = {
         defined: (e) => e.type === "interval",
         parse: (e, t, n) => {
             var i;
             if (e.hasProjection) {
                 const r = {
-                    ...re(n.select) ? n.select : {}
+                    ...oe(n.select) ? n.select : {}
                 };
-                r.fields = [Rr], r.encodings || (r.encodings = n.value ? Y(n.value) : [qr, jr]), n.select = {
+                r.fields = [Rr], r.encodings || (r.encodings = n.value ? X(n.value) : [qr, jr]), n.select = {
                     type: "interval",
                     ...r
                 };
             }
             if (t.translate && !co.defined(t)) {
-                const r = `!event.item || event.item.mark.name !== ${Z(t.name + xc)}`;
+                const r = `!event.item || event.item.mark.name !== ${ee(t.name + xc)}`;
                 for (const s of t.events) {
                     if (!s.between) {
-                        K(`${s} is not an ordered event stream for interval selections.`);
+                        J(`${s} is not an ordered event stream for interval selections.`);
                         continue;
                     }
-                    const o = ne((i = s.between[0]).filter ?? (i.filter = []));
+                    const o = re((i = s.between[0]).filter ?? (i.filter = []));
                     o.indexOf(r) < 0 && o.push(r);
                 }
             }
         },
         signals: (e, t, n) => {
             const i = t.name,
                 r = i + Fa,
-                s = nn(t.project.hasChannel).filter((a) => a.channel === ht || a.channel === Yt),
+                s = rn(t.project.hasChannel).filter((a) => a.channel === ht || a.channel === Xt),
                 o = t.init ? t.init[0] : null;
             if (n.push(...s.reduce((a, u) => a.concat(Z1e(e, t, u, o && o[u.index])), [])), e.hasProjection) {
-                const a = Z(e.projectionName()),
+                const a = ee(e.projectionName()),
                     u = e.projectionName() + J1e,
                     {
                         x: l,
                         y: c
                     } = t.project.hasChannel,
                     f = l && l.signals.visual,
                     d = c && c.signals.visual,
                     h = l ? o && o[l.index] : `${u}[0]`,
                     g = c ? o && o[c.index] : `${u}[1]`,
                     p = (w) => e.getSizeSignalRef(w).signal,
                     m = `[[${f ? f + "[0]" : "0"}, ${d ? d + "[0]" : "0"}],[${f ? f + "[1]" : p("width")}, ${d ? d + "[1]" : p("height")}]]`;
                 o && (n.unshift({
                     name: i + Iz,
                     init: `[scale(${a}, [${l ? h[0] : h}, ${c ? g[0] : g}]), scale(${a}, [${l ? h[1] : h}, ${c ? g[1] : g}])]`
-                }), (!l || !c) && (n.find((S) => S.name === u) || n.unshift({
+                }), (!l || !c) && (n.find((E) => E.name === u) || n.unshift({
                     name: u,
                     update: `invert(${a}, [${p("width")}/2, ${p("height")}/2])`
                 })));
-                const y = `intersect(${m}, {markname: ${Z(e.getName("marks"))}}, unit.mark)`,
+                const y = `intersect(${m}, {markname: ${ee(e.getName("marks"))}}, unit.mark)`,
                     b = `{unit: ${Mu(e)}}`,
                     v = `vlSelectionTuples(${y}, ${b})`,
                     x = s.map((w) => w.signals.visual);
                 return n.concat({
                     name: r,
                     on: [{
                         events: [
@@ -42027,15 +42014,15 @@
                     const l = i + Lz,
                         c = s.map((f) => {
                             const d = f.channel,
                                 {
                                     data: h,
                                     visual: g
                                 } = f.signals,
-                                p = Z(e.scaleName(d)),
+                                p = ee(e.scaleName(d)),
                                 m = e.getScaleComponent(d).get("type"),
                                 y = Ni(m) ? "+" : "";
                             return `(!isArray(${h}) || (${y}invert(${p}, ${g})[0] === ${y}${h}[0] && ${y}invert(${p}, ${g})[1] === ${y}${h}[1]))`;
                         });
                     c.length && n.push({
                         name: l,
                         value: {},
@@ -42062,15 +42049,15 @@
                             // Prevents double invocation, see https://github.com/vega/vega/issues/1672.
                             update: `${a.join(" && ")} ? {${u}: [${a}]} : null`
                         }]
                     } : {}
                 });
             }
         },
-        topLevelSignals: (e, t, n) => (bt(e) && e.hasProjection && t.init && (n.filter((r) => r.name === ud).length || n.unshift({
+        topLevelSignals: (e, t, n) => (vt(e) && e.hasProjection && t.init && (n.filter((r) => r.name === ud).length || n.unshift({
             name: ud,
             value: null,
             on: [{
                 events: "timer{1}",
                 update: `${ud} === null ? {} : ${ud}`
             }]
         })), n),
@@ -42078,15 +42065,15 @@
             const i = t.name,
                 {
                     x: r,
                     y: s
                 } = t.project.hasChannel,
                 o = r == null ? void 0 : r.signals.visual,
                 a = s == null ? void 0 : s.signals.visual,
-                u = `data(${Z(t.name + sl)})`;
+                u = `data(${ee(t.name + sl)})`;
             if (co.defined(t) || !r && !s)
                 return n;
             const l = {
                 x: r !== void 0 ? {
                     signal: `${o}[0]`
                 } : {
                     value: 0
@@ -42108,27 +42095,27 @@
                 } : {
                     field: {
                         group: "height"
                     }
                 }
             };
             if (t.resolve === "global")
-                for (const m of Y(l))
+                for (const m of X(l))
                     l[m] = [{
                         test: `${u}.length && ${u}[0].unit === ${Mu(e)}`,
                         ...l[m]
                     }, {
                         value: 0
                     }];
             const {
                 fill: c,
                 fillOpacity: f,
                 cursor: d,
                 ...h
-            } = t.mark, g = Y(h).reduce((m, y) => (m[y] = [{
+            } = t.mark, g = X(h).reduce((m, y) => (m[y] = [{
                 test: [r !== void 0 && `${o}[0] !== ${o}[1]`, s !== void 0 && `${a}[0] !== ${a}[1]`].filter((b) => b).join(" && "),
                 value: h[y]
             }, {
                 value: null
             }], m), {}), p = d ?? (t.translate ? "move" : null);
             return [{
                     name: `${i + xc}_bg`,
@@ -42171,15 +42158,15 @@
         }
     };
 
 function Z1e(e, t, n, i) {
     const r = !e.hasProjection,
         s = n.channel,
         o = n.signals.visual,
-        a = Z(r ? e.scaleName(s) : e.projectionName()),
+        a = ee(r ? e.scaleName(s) : e.projectionName()),
         u = (d) => `scale(${a}, ${d})`,
         l = e.getSizeSignalRef(s === ht ? "width" : "height").signal,
         c = `${s}(unit)`,
         f = t.events.reduce((d, h) => [
             ...d, {
                 events: h.between[0],
                 update: `[${c}, ${c}]`
@@ -42244,23 +42231,23 @@
 const eye = {
     defined: (e) => e.type === "point",
     signals: (e, t, n) => {
         const i = t.name,
             r = i + zg,
             s = t.project,
             o = "(item().isVoronoi ? datum.datum : datum)",
-            a = nn(e.component.selection ?? {}).reduce((f, d) => d.type === "interval" ? f.concat(d.name + xc) : f, []).map((f) => `indexof(item().mark.name, '${f}') < 0`).join(" && "),
+            a = rn(e.component.selection ?? {}).reduce((f, d) => d.type === "interval" ? f.concat(d.name + xc) : f, []).map((f) => `indexof(item().mark.name, '${f}') < 0`).join(" && "),
             u = `datum && item().mark.marktype !== 'group' && indexof(item().mark.role, 'legend') < 0${a ? ` && ${a}` : ""}`;
         let l = `unit: ${Mu(e)}, `;
         if (t.project.hasSelectionId)
-            l += `${Rr}: ${o}[${Z(Rr)}]`;
+            l += `${Rr}: ${o}[${ee(Rr)}]`;
         else {
             const f = s.items.map((d) => {
                 const h = e.fieldDef(d.channel);
-                return h != null && h.bin ? `[${o}[${Z(e.vgField(d.channel, {}))}], ${o}[${Z(e.vgField(d.channel, { binSuffix: "end" }))}]]` : `${o}[${Z(d.field)}]`;
+                return h != null && h.bin ? `[${o}[${ee(e.vgField(d.channel, {}))}], ${o}[${ee(e.vgField(d.channel, { binSuffix: "end" }))}]]` : `${o}[${ee(d.field)}]`;
             }).join(", ");
             l += `fields: ${r}, values: [${f}]`;
         }
         const c = t.events;
         return n.concat([{
             name: i + Fa,
             on: c ? [{
@@ -42272,15 +42259,15 @@
     }
 };
 
 function Of(e, t, n, i) {
     const r = Ky(t) && t.condition,
         s = i(t);
     if (r) {
-        const a = ne(r).map((u) => {
+        const a = re(r).map((u) => {
             const l = i(u);
             if (Wme(u)) {
                 const {
                     param: c,
                     empty: f
                 } = u;
                 return {
@@ -42309,15 +42296,15 @@
     const n = e.encoding[t];
     return Of(e, n, t, (i) => ab(i, e.config));
 }
 
 function ab(e, t, n = "datum") {
     if (e) {
         if (Dr(e))
-            return at(e.value);
+            return ut(e.value);
         if (Ae(e)) {
             const {
                 format: i,
                 formatType: r
             } = Y0(e);
             return t6({
                 fieldOrDatumDef: e,
@@ -42333,15 +42320,15 @@
 function Pz(e, t = {}) {
     const {
         encoding: n,
         markDef: i,
         config: r,
         stack: s
     } = e, o = n.tooltip;
-    if (W(o))
+    if (V(o))
         return {
             tooltip: w4({
                 tooltip: o
             }, s, r, t)
         };
     {
         const a = t.reactiveGeom ? "datum.datum" : "datum";
@@ -42350,19 +42337,19 @@
             if (l)
                 return l;
             if (u === null)
                 return;
             let c = He("tooltip", i, r);
             if (c === !0 && (c = {
                     content: "encoding"
-                }), ie(c))
+                }), se(c))
                 return {
                     value: c
                 };
-            if (re(c))
+            if (oe(c))
                 return de(c) ? c : c.content === "encoding" ? w4(n, s, r, t) : {
                     signal: a
                 };
         });
     }
 }
 
@@ -42375,40 +42362,40 @@
         },
         s = {},
         o = i ? "datum.datum" : "datum",
         a = [];
 
     function u(c, f) {
         const d = El(f),
-            h = Wn(c) ? c : {
+            h = Hn(c) ? c : {
                 ...c,
                 type: e[d].type
                 // for secondary field def, copy type from main channel
             },
             g = h.title || s6(h, r),
-            p = ne(g).join(", ").replaceAll(/"/g, '\\"');
+            p = re(g).join(", ").replaceAll(/"/g, '\\"');
         let m;
-        if (kt(f)) {
+        if (At(f)) {
             const y = f === "x" ? "x2" : "y2",
                 b = xs(e[y]);
-            if (Jt(h.bin) && b) {
-                const v = te(h, {
+            if (Qt(h.bin) && b) {
+                const v = ne(h, {
                         expr: o
                     }),
-                    x = te(b, {
+                    x = ne(b, {
                         expr: o
                     }),
                     {
                         format: w,
-                        formatType: S
+                        formatType: E
                     } = Y0(h);
-                m = Dg(v, x, w, S, r), s[y] = !0;
+                m = Dg(v, x, w, E, r), s[y] = !0;
             }
         }
-        if ((kt(f) || f === lr || f === Ur) && t && t.fieldChannel === f && t.offset === "normalize") {
+        if ((At(f) || f === lr || f === Ur) && t && t.fieldChannel === f && t.offset === "normalize") {
             const {
                 format: y,
                 formatType: b
             } = Y0(h);
             m = t6({
                 fieldOrDatumDef: h,
                 format: y,
@@ -42421,15 +42408,15 @@
         m ?? (m = ab(h, r, o).signal), a.push({
             channel: f,
             key: p,
             value: m
         });
     }
     u6(e, (c, f) => {
-        J(c) ? u(c, f) : Jy(c) && u(c.condition, f);
+        Q(c) ? u(c, f) : Jy(c) && u(c.condition, f);
     });
     const l = {};
     for (const {
             channel: c,
             key: f,
             value: d
         }
@@ -42492,43 +42479,43 @@
         stack: r
     } = e, s = t.description;
     if (s)
         return Of(e, s, "description", (u) => ab(u, e.config));
     const o = He("description", n, i);
     if (o != null)
         return {
-            description: at(o)
+            description: ut(o)
         };
     if (i.aria === !1)
         return {};
     const a = zz(t, r, i);
     if (!Je(a))
         return {
             description: {
                 signal: Aa(a).map(([u, l], c) => `"${c > 0 ? "; " : ""}${u}: " + (${l})`).join(" + ")
             }
         };
 }
 
-function Pt(e, t, n = {}) {
+function zt(e, t, n = {}) {
     const {
         markDef: i,
         encoding: r,
         config: s
     } = t, {
         vgChannel: o
     } = n;
     let {
         defaultRef: a,
         defaultValue: u
     } = n;
     a === void 0 && (u ?? (u = He(e, i, s, {
         vgChannel: o,
         ignoreVgConfig: !0
-    })), u !== void 0 && (a = at(u)));
+    })), u !== void 0 && (a = ut(u)));
     const l = r[e];
     return Of(t, l, o ?? e, (c) => e6({
         channel: e,
         channelDef: c,
         markDef: i,
         config: s,
         scaleName: t.scaleName(e),
@@ -42554,46 +42541,46 @@
         r.mark[o === !0 && "color"] ?? // If there is no fill, always fill symbols, bar, geoshape
         // with transparent fills https://github.com/vega/vega-lite/issues/1316
         a, l = He(o === !1 ? "color" : void 0, n, r, {
             vgChannel: "stroke"
         }) ?? // need to add this manually as getMarkConfig normally drops config.mark[channel] if vgChannel is specified
         r.mark[o === !1 && "color"], c = o ? "fill" : "stroke", f = {
             ...u ? {
-                fill: at(u)
+                fill: ut(u)
             } : {},
             ...l ? {
-                stroke: at(l)
+                stroke: ut(l)
             } : {}
         };
-    return n.color && (o ? n.fill : n.stroke) && K(iP("property", {
+    return n.color && (o ? n.fill : n.stroke) && J(iP("property", {
         fill: "fill" in n,
         stroke: "stroke" in n
     })), {
         ...f,
-        ...Pt("color", e, {
+        ...zt("color", e, {
             vgChannel: c,
             defaultValue: o ? u : l
         }),
-        ...Pt("fill", e, {
+        ...zt("fill", e, {
             // if there is encoding.fill, include default fill just in case we have conditional-only fill encoding
             defaultValue: i.fill ? u : void 0
         }),
-        ...Pt("stroke", e, {
+        ...zt("stroke", e, {
             // if there is encoding.stroke, include default fill just in case we have conditional-only stroke encoding
             defaultValue: i.stroke ? l : void 0
         })
     };
 }
 
 function rye(e) {
     const {
         encoding: t,
         mark: n
     } = e, i = t.order;
-    return !Va(n) && Dr(i) ? Of(e, i, "zindex", (r) => at(r.value)) : {};
+    return !Va(n) && Dr(i) ? Of(e, i, "zindex", (r) => ut(r.value)) : {};
 }
 
 function Qc({
     channel: e,
     markDef: t,
     encoding: n = {},
     model: i,
@@ -42609,26 +42596,26 @@
                 channel: s,
                 channelDef: a,
                 markDef: t,
                 config: i == null ? void 0 : i.config,
                 scaleName: i.scaleName(s),
                 scale: i.getScaleComponent(s),
                 stack: null,
-                defaultRef: at(o),
+                defaultRef: ut(o),
                 bandPosition: r
             })
         };
     const u = t[s];
     return u ? {
         offsetType: "visual",
         offset: u
     } : {};
 }
 
-function gn(e, t, {
+function pn(e, t, {
     defaultPos: n,
     vgChannel: i
 }) {
     const {
         encoding: r,
         markDef: s,
         config: o,
@@ -42644,15 +42631,15 @@
         bandPosition: 0.5
     }), g = E6({
         model: t,
         defaultPos: n,
         channel: e,
         scaleName: c,
         scale: f
-    }), p = !u && kt(e) && (r.latitude || r.longitude) ? (
+    }), p = !u && At(e) && (r.latitude || r.longitude) ? (
         // use geopoint output if there are lat/long and there is no point position overriding lat/long.
         {
             field: t.getName(e)
         }
     ) : sye({
         channel: e,
         channelDef: u,
@@ -42677,27 +42664,27 @@
         channelDef: n,
         scaleName: i,
         stack: r,
         offset: s,
         markDef: o
     } = e;
     if (Ae(n) && r && t === r.fieldChannel) {
-        if (J(n)) {
+        if (Q(n)) {
             let a = n.bandPosition;
             if (a === void 0 && o.type === "text" && (t === "radius" || t === "theta") && (a = 0.5), a !== void 0)
                 return H0({
                     scaleName: i,
                     fieldOrDatumDef: n,
                     // positionRef always have type
                     startSuffix: "start",
                     bandPosition: a,
                     offset: s
                 });
         }
-        return $u(n, i, {
+        return Cu(n, i, {
             suffix: "end"
         }, {
             offset: s
         });
     }
     return Q5(e);
 }
@@ -42711,15 +42698,15 @@
 }) {
     const {
         markDef: s,
         config: o
     } = e;
     return () => {
         const a = El(n),
-            u = $a(n),
+            u = Ca(n),
             l = He(n, s, o, {
                 vgChannel: u
             });
         if (l !== void 0)
             return nh(n, l);
         switch (t) {
             case "zeroOrMin":
@@ -42779,30 +42766,30 @@
         top: "y",
         middle: "yc",
         bottom: "y2"
     };
 
 function Uz(e, t, n, i = "middle") {
     if (e === "radius" || e === "theta")
-        return $a(e);
+        return Ca(e);
     const r = e === "x" ? "align" : "baseline",
         s = He(r, t, n);
     let o;
-    return de(s) ? (K(cpe(r)), o = void 0) : o = s, e === "x" ? oye[o || (i === "top" ? "left" : "center")] : aye[o || i];
+    return de(s) ? (J(cpe(r)), o = void 0) : o = s, e === "x" ? oye[o || (i === "top" ? "left" : "center")] : aye[o || i];
 }
 
 function Z0(e, t, {
     defaultPos: n,
     defaultPos2: i,
     range: r
 }) {
     return r ? jz(e, t, {
         defaultPos: n,
         defaultPos2: i
-    }) : gn(e, t, {
+    }) : pn(e, t, {
         defaultPos: n
     });
 }
 
 function jz(e, t, {
     defaultPos: n,
     defaultPos2: i
@@ -42811,33 +42798,33 @@
         markDef: r,
         config: s
     } = t, o = Ds(e), a = di(e), u = uye(t, i, o), l = u[a] ? (
         // If there is width/height, we need to position the marks based on the alignment.
         Uz(e, r, s)
     ) : (
         // Otherwise, make sure to apply to the right Vg Channel (for arc mark)
-        $a(e)
+        Ca(e)
     );
     return {
-        ...gn(e, t, {
+        ...pn(e, t, {
             defaultPos: n,
             vgChannel: l
         }),
         ...u
     };
 }
 
 function uye(e, t, n) {
     const {
         encoding: i,
         mark: r,
         markDef: s,
         stack: o,
         config: a
-    } = e, u = El(n), l = di(n), c = $a(n), f = i[u], d = e.scaleName(u), h = e.getScaleComponent(u), {
+    } = e, u = El(n), l = di(n), c = Ca(n), f = i[u], d = e.scaleName(u), h = e.getScaleComponent(u), {
         offset: g
     } = n in i || n in s ? Qc({
         channel: n,
         markDef: s,
         encoding: i,
         model: e
     }) : Qc({
@@ -42869,18 +42856,18 @@
         scale: h,
         stack: o,
         offset: g,
         defaultRef: void 0
     });
     return p !== void 0 ? {
         [c]: p
-    } : Cp(n, s) || Cp(n, {
+    } : $p(n, s) || $p(n, {
         [n]: j0(n, s, a.style),
         [l]: j0(l, s, a.style)
-    }) || Cp(n, a[r]) || Cp(n, a.mark) || {
+    }) || $p(n, a[r]) || $p(n, a.mark) || {
         [c]: E6({
             model: e,
             defaultPos: t,
             channel: n,
             scaleName: d,
             scale: h
         })()
@@ -42896,15 +42883,15 @@
     scaleName: s,
     scale: o,
     stack: a,
     offset: u,
     defaultRef: l
 }) {
     return Ae(t) && a && // If fieldChannel is X and channel is X2 (or Y and Y2)
-        e.charAt(0) === a.fieldChannel.charAt(0) ? $u(t, s, {
+        e.charAt(0) === a.fieldChannel.charAt(0) ? Cu(t, s, {
             suffix: "start"
         }, {
             offset: u
         }) : Q5({
             channel: e,
             channelDef: n,
             scaleName: s,
@@ -42913,29 +42900,29 @@
             markDef: i,
             config: r,
             offset: u,
             defaultRef: l
         });
 }
 
-function Cp(e, t) {
+function $p(e, t) {
     const n = di(e),
-        i = $a(e);
+        i = Ca(e);
     if (t[i] !== void 0)
         return {
             [i]: nh(e, t[i])
         };
     if (t[e] !== void 0)
         return {
             [i]: nh(e, t[e])
         };
     if (t[n]) {
         const r = t[n];
         if (nl(r))
-            K(rpe(n));
+            J(rpe(n));
         else
             return {
                 [n]: nh(e, r)
             };
     }
 }
 
@@ -42943,20 +42930,20 @@
     const {
         config: n,
         encoding: i,
         markDef: r
     } = e, s = r.type, o = Ds(t), a = di(t), u = i[t], l = i[o], c = e.getScaleComponent(t), f = c ? c.get("type") : void 0, d = r.orient, h = i[a] ?? i.size ?? He("size", r, n, {
         vgChannel: a
     }), g = BI(t), p = s === "bar" && (t === "x" ? d === "vertical" : d === "horizontal");
-    return J(u) && (rt(u.bin) || Jt(u.bin) || u.timeUnit && !l) && !(h && !nl(h)) && !i[g] && !Ht(f) ? dye({
+    return Q(u) && (st(u.bin) || Qt(u.bin) || u.timeUnit && !l) && !(h && !nl(h)) && !i[g] && !Gt(f) ? dye({
         fieldDef: u,
         fieldDef2: l,
         channel: t,
         model: e
-    }) : (Ae(u) && Ht(f) || p) && !l ? fye(u, t, e) : jz(t, e, {
+    }) : (Ae(u) && Gt(f) || p) && !l ? fye(u, t, e) : jz(t, e, {
         defaultPos: "zeroOrMax",
         defaultPos2: "zeroOrMin"
     });
 }
 
 function cye(e, t, n, i, r, s, o) {
     if (nl(r))
@@ -42968,15 +42955,15 @@
                 const c = vo("minBandSize", {
                     type: o
                 }, i);
                 return {
                     signal: c ? `max(${kr(c)}, ${l})` : l
                 };
             } else
-                r.band !== 1 && (K(gpe(u)), r = void 0);
+                r.band !== 1 && (J(gpe(u)), r = void 0);
         } else
             return {
                 mult: r.band,
                 field: {
                     group: e
                 }
             };
@@ -42996,15 +42983,15 @@
             };
     }
     if (!s) {
         const {
             bandPaddingInner: u,
             barBandPaddingInner: l,
             rectBandPaddingInner: c
-        } = i.scale, f = St(u, o === "bar" ? l : c);
+        } = i.scale, f = kt(u, o === "bar" ? l : c);
         if (de(f))
             return {
                 signal: `(1 - (${f.signal})) * ${e}`
             };
         if (ze(f))
             return {
                 signal: `${1 - f} * ${e}`
@@ -43012,43 +42999,43 @@
     }
     return {
         value: J0(i.view, e) - 2
     };
 }
 
 function fye(e, t, n) {
-    var A, F;
+    var A, T;
     const {
         markDef: i,
         encoding: r,
         config: s,
         stack: o
     } = n, a = i.orient, u = n.scaleName(t), l = n.getScaleComponent(t), c = di(t), f = Ds(t), d = BI(t), h = n.scaleName(d), g = n.getScaleComponent(M5(t)), p = a === "horizontal" && t === "y" || a === "vertical" && t === "x";
     let m;
-    (r.size || i.size) && (p ? m = Pt("size", n, {
+    (r.size || i.size) && (p ? m = zt("size", n, {
         vgChannel: c,
-        defaultRef: at(i.size)
-    }) : K(bpe(i.type)));
+        defaultRef: ut(i.size)
+    }) : J(bpe(i.type)));
     const y = !!m,
         b = PP({
             channel: t,
             fieldDef: e,
             markDef: i,
             config: s,
             scaleType: (A = l || g) == null ? void 0 : A.get("type"),
             useVlSizeChannel: p
         });
     m = m || {
         [c]: cye(c, h || u, g || l, s, b, !!e, i.type)
     };
-    const v = ((F = l || g) == null ? void 0 : F.get("type")) === "band" && nl(b) && !y ? "top" : "middle",
+    const v = ((T = l || g) == null ? void 0 : T.get("type")) === "band" && nl(b) && !y ? "top" : "middle",
         x = Uz(t, i, s, v),
         w = x === "xc" || x === "yc",
         {
-            offset: S,
+            offset: E,
             offsetType: _
         } = Qc({
             channel: t,
             markDef: i,
             encoding: r,
             model: n,
             bandPosition: w ? 0.5 : 0
@@ -43057,15 +43044,15 @@
             channel: t,
             channelDef: e,
             markDef: i,
             config: s,
             scaleName: u,
             scale: l,
             stack: o,
-            offset: S,
+            offset: E,
             defaultRef: E6({
                 model: n,
                 defaultPos: "mid",
                 channel: t,
                 scaleName: u,
                 scale: l
             }),
@@ -43075,29 +43062,29 @@
         });
     if (c)
         return {
             [x]: k,
             ...m
         };
     {
-        const T = $a(f),
-            I = m[c],
-            N = S ? {
-                ...I,
-                offset: S
-            } : I;
+        const M = Ca(f),
+            L = m[c],
+            F = E ? {
+                ...L,
+                offset: E
+            } : L;
         return {
             [x]: k,
             // posRef might be an array that wraps position invalid test
-            [T]: W(k) ? [k[0], {
+            [M]: V(k) ? [k[0], {
                 ...k[1],
-                offset: N
+                offset: F
             }] : {
                 ...k,
-                offset: N
+                offset: F
             }
         };
     }
 }
 
 function _4(e, t, n, i, r, s, o) {
     if (DI(e))
@@ -43122,26 +43109,26 @@
 
 function dye({
     fieldDef: e,
     fieldDef2: t,
     channel: n,
     model: i
 }) {
-    var F;
+    var T;
     const {
         config: r,
         markDef: s,
         encoding: o
     } = i, a = i.getScaleComponent(n), u = i.scaleName(n), l = a ? a.get("type") : void 0, c = a.get("reverse"), f = PP({
         channel: n,
         fieldDef: e,
         markDef: s,
         config: r,
         scaleType: l
-    }), d = (F = i.component.axes[n]) == null ? void 0 : F[0], h = (d == null ? void 0 : d.get("translate")) ?? 0.5, g = kt(n) ? He("binSpacing", s, r) ?? 0 : 0, p = Ds(n), m = $a(n), y = $a(p), b = vo("minBandSize", s, r), {
+    }), d = (T = i.component.axes[n]) == null ? void 0 : T[0], h = (d == null ? void 0 : d.get("translate")) ?? 0.5, g = At(n) ? He("binSpacing", s, r) ?? 0 : 0, p = Ds(n), m = Ca(n), y = Ca(p), b = vo("minBandSize", s, r), {
         offset: v
     } = Qc({
         channel: n,
         markDef: s,
         encoding: o,
         model: i,
         bandPosition: 0
@@ -43152,63 +43139,63 @@
         markDef: s,
         encoding: o,
         model: i,
         bandPosition: 0
     }), w = zme({
         fieldDef: e,
         scaleName: u
-    }), S = _4(n, g, c, h, v, b, w), _ = _4(p, g, c, h, x ?? v, b, w), k = de(f) ? {
+    }), E = _4(n, g, c, h, v, b, w), _ = _4(p, g, c, h, x ?? v, b, w), k = de(f) ? {
         signal: `(1-${f.signal})/2`
-    } : nl(f) ? (1 - f.band) / 2 : 0.5, A = Ca({
+    } : nl(f) ? (1 - f.band) / 2 : 0.5, A = $a({
         fieldDef: e,
         fieldDef2: t,
         markDef: s,
         config: r
     });
-    if (rt(e.bin) || e.timeUnit) {
-        const T = e.timeUnit && A !== 0.5;
+    if (st(e.bin) || e.timeUnit) {
+        const M = e.timeUnit && A !== 0.5;
         return {
             [y]: E4({
                 fieldDef: e,
                 scaleName: u,
                 bandPosition: k,
                 offset: _,
-                useRectOffsetField: T
+                useRectOffsetField: M
             }),
             [m]: E4({
                 fieldDef: e,
                 scaleName: u,
                 bandPosition: de(k) ? {
                     signal: `1-${k.signal}`
                 } : 1 - k,
-                offset: S,
-                useRectOffsetField: T
+                offset: E,
+                useRectOffsetField: M
             })
         };
-    } else if (Jt(e.bin)) {
-        const T = $u(e, u, {}, {
+    } else if (Qt(e.bin)) {
+        const M = Cu(e, u, {}, {
             offset: _
         });
-        if (J(t))
+        if (Q(t))
             return {
-                [y]: T,
-                [m]: $u(t, u, {}, {
-                    offset: S
+                [y]: M,
+                [m]: Cu(t, u, {}, {
+                    offset: E
                 })
             };
         if (Sl(e.bin) && e.bin.step)
             return {
-                [y]: T,
+                [y]: M,
                 [m]: {
-                    signal: `scale("${u}", ${te(e, { expr: "datum" })} + ${e.bin.step})`,
-                    offset: S
+                    signal: `scale("${u}", ${ne(e, { expr: "datum" })} + ${e.bin.step})`,
+                    offset: E
                 }
             };
     }
-    K(oP(p));
+    J(oP(p));
 }
 
 function E4({
     fieldDef: e,
     scaleName: t,
     bandPosition: n,
     offset: i,
@@ -43232,19 +43219,19 @@
         fill: n = void 0,
         stroke: i = void 0
     } = t.color === "include" ? Bz(e) : {};
     return {
         ...gye(e.markDef, t),
         ...S4(e, "fill", n),
         ...S4(e, "stroke", i),
-        ...Pt("opacity", e),
-        ...Pt("fillOpacity", e),
-        ...Pt("strokeOpacity", e),
-        ...Pt("strokeWidth", e),
-        ...Pt("strokeDash", e),
+        ...zt("opacity", e),
+        ...zt("fillOpacity", e),
+        ...zt("strokeOpacity", e),
+        ...zt("strokeWidth", e),
+        ...zt("strokeDash", e),
         ...rye(e),
         ...Pz(e),
         ..._6(e, "href"),
         ...tye(e)
     };
 }
 
@@ -43264,25 +43251,25 @@
                 [t]: [
                     // prepend the invalid case
                     // TODO: support custom value
                     {
                         test: a,
                         value: null
                     },
-                    ...ne(n)
+                    ...re(n)
                 ]
             };
     }
     return n ? {
         [t]: n
     } : {};
 }
 
 function gye(e, t) {
-    return Fge.reduce((n, i) => (!hye.has(i) && e[i] !== void 0 && t[i] !== "ignore" && (n[i] = at(e[i])), n), {});
+    return Fge.reduce((n, i) => (!hye.has(i) && e[i] !== void 0 && t[i] !== "ignore" && (n[i] = ut(e[i])), n), {});
 }
 
 function pye(e, {
     invalid: t = !1,
     channels: n
 }) {
     const i = n.reduce((s, o) => {
@@ -43292,15 +43279,15 @@
                     l = e.vgField(o, {
                         expr: "datum"
                     });
                 l && Ni(u) && (s[l] = !0);
             }
             return s;
         }, {}),
-        r = Y(i);
+        r = X(i);
     if (r.length > 0) {
         const s = t ? "||" : "&&";
         return r.map((o) => Z5(o, t)).join(` ${s} `);
     }
 }
 
 function S6(e) {
@@ -43335,25 +43322,25 @@
                         expr: "datum",
                         binSuffix: (u = e.stack) != null && u.impute ? "mid" : void 0
                     });
                 c && Ni(l) && (s[c] = !0);
             }
             return s;
         }, {}),
-        r = Y(i);
+        r = X(i);
     if (r.length > 0) {
         const s = t ? "||" : "&&";
         return r.map((o) => Z5(o, t)).join(` ${s} `);
     }
 }
 
 function k4(e, t) {
     if (t !== void 0)
         return {
-            [e]: at(t)
+            [e]: ut(t)
         };
 }
 const Jv = "voronoi",
     qz = {
         defined: (e) => e.type === "point" && e.nearest,
         parse: (e, t) => {
             if (t.events)
@@ -43362,15 +43349,15 @@
         },
         marks: (e, t, n) => {
             const {
                 x: i,
                 y: r
             } = t.project.hasChannel, s = e.mark;
             if (Va(s))
-                return K(Ige(s)), n;
+                return J(Ige(s)), n;
             const o = {
                 name: e.getName(Jv),
                 type: "path",
                 interactive: !0,
                 from: {
                     data: e.getName("marks")
                 },
@@ -43428,15 +43415,15 @@
                     ...o ? {
                         init: rl(o[l])
                     } : {
                         value: null
                     },
                     on: t.events ? [{
                         events: t.events,
-                        update: `datum && item().mark.marktype !== 'group' ? ${a}[${Z(u.field)}] : null`
+                        update: `datum && item().mark.marktype !== 'group' ? ${a}[${ee(u.field)}] : null`
                     }] : [],
                     bind: s[u.field] ?? s[u.channel] ?? s
                 });
             }), n;
         },
         signals: (e, t, n) => {
             const i = t.name,
@@ -43464,15 +43451,15 @@
                 i = t.name + e1;
             return `${i} ? null : ${n}, ` + (t.resolve === "global" ? `${i} ? null : true, ` : `${i} ? null : {unit: ${Mu(e)}}, `) + `${i} ? ${n} : null`;
         }
     },
     yye = {
         defined: (e) => e.clear !== void 0 && e.clear !== !1,
         parse: (e, t) => {
-            t.clear && (t.clear = ie(t.clear) ? za(t.clear, "view") : t.clear);
+            t.clear && (t.clear = se(t.clear) ? za(t.clear, "view") : t.clear);
         },
         topLevelSignals: (e, t, n) => {
             if (Wz.defined(t))
                 for (const i of t.project.items) {
                     const r = n.findIndex((s) => s.name === ft(`${t.name}_${i.field}`));
                     r !== -1 && n[r].on.push({
                         events: t.clear,
@@ -43503,31 +43490,31 @@
             return n;
         }
     },
     Gz = {
         defined: (e) => {
             const t = e.resolve === "global" && e.bind && g6(e.bind),
                 n = e.project.items.length === 1 && e.project.items[0].field !== Rr;
-            return t && !n && K(Uge), t && n;
+            return t && !n && J(Uge), t && n;
         },
         parse: (e, t, n) => {
             const i = ke(n);
-            if (i.select = ie(i.select) ? {
+            if (i.select = se(i.select) ? {
                     type: i.select,
                     toggle: t.toggle
                 } : {
                     ...i.select,
                     toggle: t.toggle
-                }, Qz(t, i), re(n.select) && (n.select.on || n.select.clear)) {
+                }, Qz(t, i), oe(n.select) && (n.select.on || n.select.clear)) {
                 const o = 'event.item && indexof(event.item.mark.role, "legend") < 0';
                 for (const a of t.events)
-                    a.filter = ne(a.filter ?? []), a.filter.includes(o) || a.filter.push(o);
+                    a.filter = re(a.filter ?? []), a.filter.includes(o) || a.filter.push(o);
             }
             const r = Vv(t.bind) ? t.bind.legend : "click",
-                s = ie(r) ? za(r, "view") : ne(r);
+                s = se(r) ? za(r, "view") : re(r);
             t.bind = {
                 legend: {
                     merge: s
                 }
             };
         },
         topLevelSignals: (e, t, n) => {
@@ -43587,15 +43574,15 @@
             }) : c.on[0].events = f), n;
         }
     };
 
 function bye(e, t, n) {
     var r;
     const i = (r = e.fieldDef(t)) == null ? void 0 : r.field;
-    for (const s of nn(e.component.selection ?? {})) {
+    for (const s of rn(e.component.selection ?? {})) {
         const o = s.project.hasField[i] ?? s.project.hasChannel[t];
         if (o && Gz.defined(s)) {
             const a = n.get("selections") ?? [];
             a.push(s.name), n.set("selections", a, !1), o.hasLegend = !0;
         }
     }
 }
@@ -43613,15 +43600,15 @@
                 } = t.project.hasChannel;
             let u = za(t.translate, "scope");
             return r || (u = u.map((l) => (l.between[0].markname = i + xc, l))), n.push({
                 name: s,
                 value: {},
                 on: [{
                     events: u.map((l) => l.between[0]),
-                    update: "{x: x(unit), y: y(unit)" + (o !== void 0 ? `, extent_x: ${r ? Nw(e, ht) : `slice(${o.signals.visual})`}` : "") + (a !== void 0 ? `, extent_y: ${r ? Nw(e, Yt) : `slice(${a.signals.visual})`}` : "") + "}"
+                    update: "{x: x(unit), y: y(unit)" + (o !== void 0 ? `, extent_x: ${r ? Nw(e, ht) : `slice(${o.signals.visual})`}` : "") + (a !== void 0 ? `, extent_y: ${r ? Nw(e, Xt) : `slice(${a.signals.visual})`}` : "") + "}"
                 }]
             }, {
                 name: i + Yz,
                 value: {},
                 on: [{
                     events: u,
                     update: `{x: ${s}.x - x(unit), y: ${s}.y - y(unit)}`
@@ -43662,35 +43649,35 @@
             const i = t.name,
                 r = co.defined(t),
                 s = i + Kz,
                 {
                     x: o,
                     y: a
                 } = t.project.hasChannel,
-                u = Z(e.scaleName(ht)),
-                l = Z(e.scaleName(Yt));
+                u = ee(e.scaleName(ht)),
+                l = ee(e.scaleName(Xt));
             let c = za(t.zoom, "scope");
             return r || (c = c.map((f) => (f.markname = i + xc, f))), n.push({
                 name: i + Xz,
                 on: [{
                     events: c,
                     update: r ? "{" + [u ? `x: invert(${u}, x(unit))` : "", l ? `y: invert(${l}, y(unit))` : ""].filter((f) => f).join(", ") + "}" : "{x: x(unit), y: y(unit)}"
                 }]
             }, {
                 name: s,
                 on: [{
                     events: c,
                     force: !0,
                     update: "pow(1.001, event.deltaY * pow(16, event.deltaMode))"
                 }]
-            }), o !== void 0 && $4(e, t, o, "width", n), a !== void 0 && $4(e, t, a, "height", n), n;
+            }), o !== void 0 && C4(e, t, o, "width", n), a !== void 0 && C4(e, t, a, "height", n), n;
         }
     };
 
-function $4(e, t, n, i, r) {
+function C4(e, t, n, i, r) {
     const s = t.name,
         o = n.channel,
         a = co.defined(t),
         u = r.filter((b) => b.name === n.signals[a ? "data" : "visual"])[0],
         l = e.getSizeSignalRef(i).signal,
         c = e.getScaleComponent(o),
         f = c && c.get("type"),
@@ -43724,42 +43711,42 @@
         vye,
         xye,
         qz
     ];
 
 function _ye(e) {
     let t = e.parent;
-    for (; t && !$i(t);)
+    for (; t && !Ci(t);)
         t = t.parent;
     return t;
 }
 
 function Mu(e, {
     escape: t
 } = {
     escape: !0
 }) {
-    let n = t ? Z(e.name) : e.name;
+    let n = t ? ee(e.name) : e.name;
     const i = _ye(e);
     if (i) {
         const {
             facet: r
         } = i;
         for (const s of Hi)
-            r[s] && (n += ` + '__facet_${s}_' + (facet[${Z(i.vgField(s))}])`);
+            r[s] && (n += ` + '__facet_${s}_' + (facet[${ee(i.vgField(s))}])`);
     }
     return n;
 }
 
 function k6(e) {
-    return nn(e.component.selection ?? {}).reduce((t, n) => t || n.project.hasSelectionId, !1);
+    return rn(e.component.selection ?? {}).reduce((t, n) => t || n.project.hasSelectionId, !1);
 }
 
 function Qz(e, t) {
-    (ie(t.select) || !t.select.on) && delete e.events, (ie(t.select) || !t.select.clear) && delete e.clear, (ie(t.select) || !t.select.toggle) && delete e.toggle;
+    (se(t.select) || !t.select.on) && delete e.events, (se(t.select) || !t.select.clear) && delete e.clear, (se(t.select) || !t.select.toggle) && delete e.toggle;
 }
 
 function Ow(e) {
     const t = [];
     return e.type === "Identifier" ? [e.name] : e.type === "Literal" ? [e.value] : (e.type === "MemberExpression" && (t.push(...Ow(e.object)), t.push(...Ow(e.property))), t);
 }
 
@@ -43802,56 +43789,56 @@
     const n = {},
         i = e.config.selection;
     if (!t || !t.length)
         return n;
     for (const r of t) {
         const s = ft(r.name),
             o = r.select,
-            a = ie(o) ? o : o.type,
-            u = re(o) ? ke(o) : {
+            a = se(o) ? o : o.type,
+            u = oe(o) ? ke(o) : {
                 type: a
             },
             l = i[a];
         for (const d in l)
             d === "fields" || d === "encodings" || (d === "mark" && (u[d] = {
                 ...l[d],
                 ...u[d]
             }), (u[d] === void 0 || u[d] === !0) && (u[d] = ke(l[d] ?? u[d])));
         const c = n[s] = {
                 ...u,
                 name: s,
                 type: a,
                 init: r.value,
                 bind: r.bind,
-                events: ie(u.on) ? za(u.on, "scope") : ne(ke(u.on))
+                events: se(u.on) ? za(u.on, "scope") : re(ke(u.on))
             },
             f = ke(r);
         for (const d of ub)
             d.defined(c) && d.parse && d.parse(e, c, f);
     }
     return n;
 }
 
 function tB(e, t, n, i = "datum") {
-    const r = ie(t) ? t : t.param,
+    const r = se(t) ? t : t.param,
         s = ft(r),
-        o = Z(s + sl);
+        o = ee(s + sl);
     let a;
     try {
         a = e.getSelectionComponent(s, r);
     } catch {
         return `!!${s}`;
     }
     if (a.project.timeUnit) {
         const d = n ?? e.component.data.raw,
             h = a.project.timeUnit.clone();
         d.parent ? h.insertAsParentOf(d) : d.parent = h;
     }
     const u = a.project.hasSelectionId ? "vlSelectionIdTest(" : "vlSelectionTest(",
-        l = a.resolve === "global" ? ")" : `, ${Z(a.resolve)})`,
+        l = a.resolve === "global" ? ")" : `, ${ee(a.resolve)})`,
         c = `${u}${o}, ${i}${l}`,
         f = `length(data(${o}))`;
     return t.empty === !1 ? `${f} && ${c}` : `!${f} || ${c}`;
 }
 
 function nB(e, t, n) {
     const i = ft(t),
@@ -43860,38 +43847,38 @@
         o;
     try {
         o = e.getSelectionComponent(i, t);
     } catch {
         return i;
     }
     if (!r && !s)
-        s = o.project.items[0].field, o.project.items.length > 1 && K(`A "field" or "encoding" must be specified when using a selection as a scale domain. Using "field": ${Z(s)}.`);
+        s = o.project.items[0].field, o.project.items.length > 1 && J(`A "field" or "encoding" must be specified when using a selection as a scale domain. Using "field": ${ee(s)}.`);
     else if (r && !s) {
         const a = o.project.items.filter((u) => u.channel === r);
-        !a.length || a.length > 1 ? (s = o.project.items[0].field, K((a.length ? "Multiple " : "No ") + `matching ${Z(r)} encoding found for selection ${Z(n.param)}. Using "field": ${Z(s)}.`)) : s = a[0].field;
+        !a.length || a.length > 1 ? (s = o.project.items[0].field, J((a.length ? "Multiple " : "No ") + `matching ${ee(r)} encoding found for selection ${ee(n.param)}. Using "field": ${ee(s)}.`)) : s = a[0].field;
     }
-    return `${o.name}[${Z(sr(s))}]`;
+    return `${o.name}[${ee(sr(s))}]`;
 }
 
 function Sye(e, t) {
     for (const [n, i] of Aa(e.component.selection ?? {})) {
         const r = e.getName(`lookup_${n}`);
-        e.component.data.outputNodes[r] = i.materialized = new zn(new Df(t, e, {
+        e.component.data.outputNodes[r] = i.materialized = new Bn(new Df(t, e, {
             param: n
         }), r, nt.Lookup, e.component.data.outputNodeRefCounts);
     }
 }
 
 function t1(e, t, n) {
-    return th(t, (i) => ie(i) ? i : tme(i) ? tB(e, i, n) : bP(i));
+    return th(t, (i) => se(i) ? i : tme(i) ? tB(e, i, n) : bP(i));
 }
 
 function kye(e, t) {
     if (e)
-        return W(e) && !qo(e) ? e.map((n) => s6(n, t)).join(", ") : e;
+        return V(e) && !qo(e) ? e.map((n) => s6(n, t)).join(", ") : e;
 }
 
 function Qv(e, t, n, i) {
     var r, s;
     e.encode ?? (e.encode = {}), (r = e.encode)[t] ?? (r[t] = {}), (s = e.encode[t]).update ?? (s.update = {}), e.encode[t].update[n] = i;
 }
 
@@ -43914,41 +43901,41 @@
                 p = c[h];
             if (g && g !== t && g !== "both")
                 delete c[h];
             else if (Pg(p)) {
                 const {
                     condition: m,
                     ...y
-                } = p, b = ne(m), v = t4[h];
+                } = p, b = re(m), v = t4[h];
                 if (v) {
                     const {
                         vgProp: x,
                         part: w
-                    } = v, S = [
+                    } = v, E = [
                         ...b.map((_) => {
                             const {
                                 test: k,
                                 ...A
                             } = _;
                             return {
                                 test: t1(null, k),
                                 ...A
                             };
                         }),
                         y
                     ];
-                    Qv(c, w, x, S), delete c[h];
+                    Qv(c, w, x, E), delete c[h];
                 } else if (v === null) {
                     const x = {
                         signal: b.map((w) => {
                             const {
-                                test: S,
+                                test: E,
                                 ..._
                             } = w;
-                            return `${t1(null, S)} ? ${z8(_)} : `;
+                            return `${t1(null, E)} ? ${z8(_)} : `;
                         }).join("") + z8(y)
                     };
                     c[h] = x;
                 }
             } else if (de(p)) {
                 const m = t4[h];
                 if (m) {
@@ -43983,15 +43970,15 @@
                 aria: !1,
                 // always hide grid axis
                 // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`
                 // would not affect gridAxis
                 maxExtent: 0,
                 minExtent: 0,
                 ticks: !1,
-                zindex: St(l, 0)
+                zindex: kt(l, 0)
                 // put grid behind marks by default
             };
         } else {
             if (!i.header && e.mainExtracted)
                 return;
             if (a !== void 0) {
                 let g = a;
@@ -44012,15 +43999,15 @@
                 ...h ? {
                     title: h
                 } : {},
                 ...c,
                 ...n.aria === !1 ? {
                     aria: !1
                 } : {},
-                zindex: St(l, 0)
+                zindex: kt(l, 0)
                 // put axis line above marks by default
             };
         }
     }
 }
 
 function iB(e) {
@@ -44051,60 +44038,60 @@
         ...n.map((r) => Id(r, "grid", t)),
         ...i.map((r) => Id(r, "grid", t)),
         ...n.map((r) => Id(r, "main", t)),
         ...i.map((r) => Id(r, "main", t))
     ].filter((r) => r);
 }
 
-function C4(e, t, n, i) {
+function $4(e, t, n, i) {
     return Object.assign.apply(null, [{},
         ...e.map((r) => {
             if (r === "axisOrient") {
                 const s = n === "x" ? "bottom" : "left",
                     o = t[n === "x" ? "axisBottom" : "axisLeft"] || {},
                     a = t[n === "x" ? "axisTop" : "axisRight"] || {},
-                    u = /* @__PURE__ */ new Set([...Y(o), ...Y(a)]),
+                    u = /* @__PURE__ */ new Set([...X(o), ...X(a)]),
                     l = {};
                 for (const c of u.values())
                     l[c] = {
                         // orient is surely signal in this case
                         signal: `${i.signal} === "${s}" ? ${kr(o[c])} : ${kr(a[c])}`
                     };
                 return l;
             }
             return t[r];
         })
     ]);
 }
 
-function $ye(e, t, n, i) {
+function Cye(e, t, n, i) {
     const r = t === "band" ? ["axisDiscrete", "axisBand"] : t === "point" ? ["axisDiscrete", "axisPoint"] : _P(t) ? ["axisQuantitative"] : t === "time" || t === "utc" ? ["axisTemporal"] : [],
         s = e === "x" ? "axisX" : "axisY",
-        o = de(n) ? "axisOrient" : `axis${Cg(n)}`,
+        o = de(n) ? "axisOrient" : `axis${$g(n)}`,
         a = [
             // technically Vega does have axisBand, but if we make another separation here,
             // it will further introduce complexity in the code
             ...r,
             ...r.map((l) => s + l.substr(4))
         ],
         u = ["axis", o, s];
     return {
-        vlOnlyAxisConfig: C4(a, i, e, n),
-        vgAxisConfig: C4(u, i, e, n),
-        axisConfigStyle: Cye([...u, ...a], i)
+        vlOnlyAxisConfig: $4(a, i, e, n),
+        vgAxisConfig: $4(u, i, e, n),
+        axisConfigStyle: $ye([...u, ...a], i)
     };
 }
 
-function Cye(e, t) {
+function $ye(e, t) {
     var i;
     const n = [{}];
     for (const r of e) {
         let s = (i = t[r]) == null ? void 0 : i.style;
         if (s) {
-            s = ne(s);
+            s = re(s);
             for (const o of s)
                 n.push(t.style[o]);
         }
     }
     return Object.assign.apply(null, n);
 }
 
@@ -44167,15 +44154,15 @@
         fieldOrDatumDef: t,
         channel: n
     }) => e.labelFlush ?? Nye(t.type, n),
     labelOverlap: ({
         axis: e,
         fieldOrDatumDef: t,
         scaleType: n
-    }) => e.labelOverlap ?? Oye(t.type, n, J(t) && !!t.timeUnit, J(t) ? t.sort : void 0),
+    }) => e.labelOverlap ?? Oye(t.type, n, Q(t) && !!t.timeUnit, Q(t) ? t.sort : void 0),
     // we already calculate orient in parse
     orient: ({
         orient: e
     }) => e,
     // Need to cast until Vega supports signal
     tickCount: ({
         channel: e,
@@ -44203,29 +44190,29 @@
             return e.title;
         const i = oB(t, n);
         if (i !== void 0)
             return i;
         const r = t.typedFieldDef(n),
             s = n === "x" ? "x2" : "y2",
             o = t.fieldDef(s);
-        return QI(r ? [Z8(r)] : [], J(o) ? [Z8(o)] : []);
+        return QI(r ? [Z8(r)] : [], Q(o) ? [Z8(o)] : []);
     },
     values: ({
         axis: e,
         fieldOrDatumDef: t
     }) => Iye(e, t),
     zindex: ({
         axis: e,
         fieldOrDatumDef: t,
         mark: n
     }) => e.zindex ?? Pye(n, t)
 };
 
 function Mye(e, t) {
-    return !Ht(e) && J(t) && !rt(t == null ? void 0 : t.bin) && !Jt(t == null ? void 0 : t.bin);
+    return !Gt(e) && Q(t) && !st(t == null ? void 0 : t.bin) && !Qt(t == null ? void 0 : t.bin);
 }
 
 function Tye(e, t) {
     const n = t === "x" ? "y" : "x";
     if (e.getScaleComponent(n))
         return e.scaleName(n);
 }
@@ -44234,15 +44221,15 @@
     const s = t == null ? void 0 : t.labelAngle;
     if (s !== void 0)
         return de(s) ? s : Ih(s);
     {
         const {
             configValue: o
         } = Dw("labelAngle", i, t == null ? void 0 : t.style, r);
-        return o !== void 0 ? Ih(o) : n === ht && De([Y5, V5], e.type) && !(J(e) && e.timeUnit) ? 270 : void 0;
+        return o !== void 0 ? Ih(o) : n === ht && De([Y5, V5], e.type) && !(Q(e) && e.timeUnit) ? 270 : void 0;
     }
 }
 
 function Rw(e) {
     return `(((${e.signal} % 360) + 360) % 360)`;
 }
 
@@ -44311,51 +44298,51 @@
 
 function Nye(e, t) {
     if (t === "x" && De(["quantitative", "temporal"], e))
         return !0;
 }
 
 function Oye(e, t, n, i) {
-    if (n && !re(i) || e !== "nominal" && e !== "ordinal")
+    if (n && !oe(i) || e !== "nominal" && e !== "ordinal")
         return t === "log" || t === "symlog" ? "greedy" : !0;
 }
 
 function Dye(e) {
     return e === "x" ? "bottom" : "left";
 }
 
 function Rye({
     fieldOrDatumDef: e,
     scaleType: t,
     size: n,
     values: i
 }) {
     var r;
-    if (!i && !Ht(t) && t !== "log") {
-        if (J(e)) {
-            if (rt(e.bin))
+    if (!i && !Gt(t) && t !== "log") {
+        if (Q(e)) {
+            if (st(e.bin))
                 return {
                     signal: `ceil(${n.signal}/10)`
                 };
-            if (e.timeUnit && De(["month", "hours", "day", "quarter"], (r = Wt(e.timeUnit)) == null ? void 0 : r.unit))
+            if (e.timeUnit && De(["month", "hours", "day", "quarter"], (r = Ht(e.timeUnit)) == null ? void 0 : r.unit))
                 return;
         }
         return {
             signal: `ceil(${n.signal}/40)`
         };
     }
 }
 
 function Lye({
     format: e,
     fieldOrDatumDef: t
 }) {
     if (e === "d")
         return 1;
-    if (J(t)) {
+    if (Q(t)) {
         const {
             timeUnit: n
         } = t;
         if (n) {
             const i = pP(n);
             if (i)
                 return {
@@ -44381,15 +44368,15 @@
         return s;
     if (o !== void 0)
         return o;
 }
 
 function Iye(e, t) {
     const n = e.values;
-    if (W(n))
+    if (V(n))
         return VP(t, n);
     if (de(n))
         return n;
 }
 
 function Pye(e, t) {
     return e === "rect" && V0(t) ? 1 : 0;
@@ -44399,15 +44386,15 @@
         return new Zc(null, ke(this.transform));
     }
     constructor(t, n) {
         super(t), this.transform = n, this._dependentFields = eB(this.transform.calculate);
     }
     static parseAllForSortIndex(t, n) {
         return n.forEachFieldDef((i, r) => {
-            if ($l(i) && IP(i.sort)) {
+            if (Cl(i) && IP(i.sort)) {
                 const {
                     field: s,
                     timeUnit: o
                 } = i, a = i.sort, u = a.map((l, c) => `${bP({ field: s, timeUnit: o, equal: l })} ? ${c} : `).join("") + a.length;
                 t = new Zc(t, {
                     calculate: u,
                     as: ef(i, r, {
@@ -44432,40 +44419,40 @@
     }
     hash() {
         return `Calculate ${Oe(this.transform)}`;
     }
 }
 
 function ef(e, t, n) {
-    return te(e, {
+    return ne(e, {
         prefix: t,
         suffix: "sort_index",
         ...n
     });
 }
 
 function lb(e, t) {
     return De(["top", "bottom"], t) ? "column" : De(["left", "right"], t) || e === "row" ? "row" : "column";
 }
 
 function tf(e, t, n, i) {
     const r = i === "row" ? n.headerRow : i === "column" ? n.headerColumn : n.headerFacet;
-    return St((t || {})[e], r[e], n.header[e]);
+    return kt((t || {})[e], r[e], n.header[e]);
 }
 
 function cb(e, t, n, i) {
     const r = {};
     for (const s of e) {
         const o = tf(s, t || {}, n, i);
         o !== void 0 && (r[s] = o);
     }
     return r;
 }
 const A6 = ["row", "column"],
-    $6 = ["header", "footer"];
+    C6 = ["header", "footer"];
 
 function zye(e, t) {
     const n = e.component.layoutHeaders[t].title,
         i = e.config ? e.config : void 0,
         r = e.component.layoutHeaders[t].facetFieldDef ? e.component.layoutHeaders[t].facetFieldDef : void 0,
         {
             titleAnchor: s,
@@ -44514,39 +44501,39 @@
         baseline: n
     } : {};
 }
 
 function Bye(e, t) {
     const n = e.component.layoutHeaders[t],
         i = [];
-    for (const r of $6)
+    for (const r of C6)
         if (n[r])
             for (const s of n[r]) {
                 const o = jye(e, t, r, n, s);
                 o != null && i.push(o);
             }
     return i;
 }
 
 function Uye(e, t) {
     const {
         sort: n
     } = e;
     return ls(n) ? {
-        field: te(n, {
+        field: ne(n, {
             expr: "datum"
         }),
         order: n.order ?? "ascending"
-    } : W(n) ? {
+    } : V(n) ? {
         field: ef(e, t, {
             expr: "datum"
         }),
         order: "ascending"
     } : {
-        field: te(e, {
+        field: ne(e, {
             expr: "datum"
         }),
         order: n ?? "ascending"
     };
 }
 
 function Lw(e, t, n) {
@@ -44562,26 +44549,26 @@
         format: i,
         formatType: r,
         expr: "parent",
         config: n
     }).signal, c = lb(t, a);
     return {
         text: {
-            signal: u ? Qu(Qu(u, "datum.label", l), "datum.value", te(e, {
+            signal: u ? Qu(Qu(u, "datum.label", l), "datum.value", ne(e, {
                 expr: "parent"
             })) : l
         },
         ...t === "row" ? {
             orient: "left"
         } : {},
         style: "guide-label",
         frame: "group",
         ...uB(s, c),
         ...aB(c, s, o),
-        ...lB(n, e, t, $0e, dz)
+        ...lB(n, e, t, C0e, dz)
     };
 }
 
 function jye(e, t, n, i, r) {
     if (r) {
         let s = null;
         const {
@@ -44589,15 +44576,15 @@
         } = i, a = e.config ? e.config : void 0;
         if (o && r.labels) {
             const {
                 labelOrient: f
             } = cb(["labelOrient"], o.header, a, t);
             (t === "row" && !De(["top", "bottom"], f) || t === "column" && !De(["left", "right"], f)) && (s = Lw(o, t, a));
         }
-        const u = $i(e) && !Rg(e.facet),
+        const u = Ci(e) && !Rg(e.facet),
             l = r.axes,
             c = (l == null ? void 0 : l.length) > 0;
         if (s || c) {
             const f = t === "row" ? "height" : "width";
             return {
                 name: e.getName(`${t}_${n}`),
                 type: "group",
@@ -44668,15 +44655,15 @@
             continue;
         const a = tf(o, t == null ? void 0 : t.header, e, n);
         a !== void 0 && (s[r[o]] = a);
     }
     return s;
 }
 
-function C6(e) {
+function $6(e) {
     return [
         ...Mp(e, "width"),
         ...Mp(e, "height"),
         ...Mp(e, "childWidth"),
         ...Mp(e, "childHeight")
     ];
 }
@@ -44688,29 +44675,29 @@
         return [];
     const r = e.getSizeSignalRef(t).signal;
     if (i === "step") {
         const s = e.getScaleComponent(n);
         if (s) {
             const o = s.get("type"),
                 a = s.get("range");
-            if (Ht(o) && Ga(a)) {
+            if (Gt(o) && Ga(a)) {
                 const u = e.scaleName(n);
-                return $i(e.parent) && e.parent.component.resolve.scale[n] === "independent" ? [T4(u, a)] : [
+                return Ci(e.parent) && e.parent.component.resolve.scale[n] === "independent" ? [T4(u, a)] : [
                     T4(u, a), {
                         name: r,
                         update: cB(u, s, `domain('${u}').length`)
                     }
                 ];
             }
         }
         throw new Error("layout size is step although width/height is not step.");
     } else if (i == "container") {
         const s = r.endsWith("width"),
             o = s ? "containerSize()[0]" : "containerSize()[1]",
-            a = Cw(e.config.view, s ? "width" : "height"),
+            a = $w(e.config.view, s ? "width" : "height"),
             u = `isFinite(${o}) ? ${o} : ${a}`;
         return [{
             name: r,
             init: u,
             on: [{
                 update: u,
                 events: "window:resize"
@@ -44733,15 +44720,15 @@
         value: t.step
     };
 }
 
 function cB(e, t, n) {
     const i = t.get("type"),
         r = t.get("padding"),
-        s = St(t.get("paddingOuter"), r);
+        s = kt(t.get("paddingOuter"), r);
     let o = t.get("paddingInner");
     return o = i === "band" ? (
         // only band has real paddingInner
         o !== void 0 ? o : r
     ) : (
         // For point, as calculated in https://github.com/vega/vega-scale/blob/master/src/band.js#L128,
         // it's equivalent to have paddingInner = 1 since there is only n-1 steps between n points.
@@ -44750,37 +44737,37 @@
 }
 
 function fB(e) {
     return e === "childWidth" ? "width" : e === "childHeight" ? "height" : e;
 }
 
 function dB(e, t) {
-    return Y(e).reduce((n, i) => {
+    return X(e).reduce((n, i) => {
         const r = e[i];
         return {
             ...n,
-            ...Of(t, r, i, (s) => at(s.value))
+            ...Of(t, r, i, (s) => ut(s.value))
         };
     }, {});
 }
 
 function hB(e, t) {
-    if ($i(t))
+    if (Ci(t))
         return e === "theta" ? "independent" : "shared";
     if (If(t))
         return "shared";
     if (R6(t))
-        return kt(e) || e === "theta" || e === "radius" ? "independent" : "shared";
+        return At(e) || e === "theta" || e === "radius" ? "independent" : "shared";
     throw new Error("invalid model type for resolve");
 }
 
 function M6(e, t) {
     const n = e.scale[t],
-        i = kt(t) ? "axis" : "legend";
-    return n === "independent" ? (e[i][t] === "shared" && K(Epe(t)), "independent") : e[i][t] || "shared";
+        i = At(t) ? "axis" : "legend";
+    return n === "independent" ? (e[i][t] === "shared" && J(Epe(t)), "independent") : e[i][t] || "shared";
 }
 const Gye = {
         ...T0e,
         disable: 1,
         labelExpr: 1,
         selections: 1,
         // channel scales
@@ -44790,15 +44777,15 @@
         fill: 1,
         size: 1,
         strokeWidth: 1,
         strokeDash: 1,
         // encode
         encode: 1
     },
-    gB = Y(Gye);
+    gB = X(Gye);
 class Vye extends To {}
 const F4 = {
     symbols: Yye,
     gradient: Xye,
     labels: Kye,
     entries: Jye
 };
@@ -44828,40 +44815,40 @@
         h = r.get("symbolFillColor") ?? u.legend.symbolFillColor,
         g = r.get("symbolStrokeColor") ?? u.legend.symbolStrokeColor,
         p = d === void 0 ? pB(a.opacity) ?? o.opacity : void 0;
     if (f.fill) {
         if (i === "fill" || c && i === ci)
             delete f.fill;
         else if (f.fill.field)
-            h ? delete f.fill : (f.fill = at(u.legend.symbolBaseFillColor ?? "black"), f.fillOpacity = at(p ?? 1));
-        else if (W(f.fill)) {
+            h ? delete f.fill : (f.fill = ut(u.legend.symbolBaseFillColor ?? "black"), f.fillOpacity = ut(p ?? 1));
+        else if (V(f.fill)) {
             const m = Iw(a.fill ?? a.color) ?? o.fill ?? (c && o.color);
-            m && (f.fill = at(m));
+            m && (f.fill = ut(m));
         }
     }
     if (f.stroke) {
         if (i === "stroke" || !c && i === ci)
             delete f.stroke;
         else if (f.stroke.field || g)
             delete f.stroke;
-        else if (W(f.stroke)) {
-            const m = St(Iw(a.stroke || a.color), o.stroke, c ? o.color : void 0);
+        else if (V(f.stroke)) {
+            const m = kt(Iw(a.stroke || a.color), o.stroke, c ? o.color : void 0);
             m && (f.stroke = {
                 value: m
             });
         }
     }
-    if (i !== $o) {
-        const m = J(t) && yB(n, r, t);
+    if (i !== Co) {
+        const m = Q(t) && yB(n, r, t);
         m ? f.opacity = [{
                 test: m,
-                ...at(p ?? 1)
+                ...ut(p ?? 1)
             },
-            at(u.legend.unselectedOpacity)
-        ] : p && (f.opacity = at(p));
+            ut(u.legend.unselectedOpacity)
+        ] : p && (f.opacity = ut(p));
     }
     return f = {
         ...f,
         ...e
     }, Je(f) ? void 0 : f;
 }
 
@@ -44875,53 +44862,53 @@
     const {
         config: r,
         markDef: s,
         encoding: o
     } = t;
     let a = {};
     const l = (i.get("gradientOpacity") ?? r.legend.gradientOpacity) === void 0 ? pB(o.opacity) || s.opacity : void 0;
-    return l && (a.opacity = at(l)), a = {
+    return l && (a.opacity = ut(l)), a = {
         ...a,
         ...e
     }, Je(a) ? void 0 : a;
 }
 
 function Kye(e, {
     fieldOrDatumDef: t,
     model: n,
     channel: i,
     legendCmpt: r
 }) {
     const s = n.legend(i) || {},
         o = n.config,
-        a = J(t) ? yB(n, r, t) : void 0,
+        a = Q(t) ? yB(n, r, t) : void 0,
         u = a ? [{
             test: a,
             value: 1
         }, {
             value: o.legend.unselectedOpacity
         }] : void 0,
         {
             format: l,
             formatType: c
         } = s;
     let f;
-    il(c) ? f = $r({
+    il(c) ? f = Cr({
         fieldOrDatumDef: t,
         field: "datum.value",
         format: l,
         formatType: c,
         config: o
-    }) : l === void 0 && c === void 0 && o.customFormatTypes && (t.type === "quantitative" && o.numberFormatType ? f = $r({
+    }) : l === void 0 && c === void 0 && o.customFormatTypes && (t.type === "quantitative" && o.numberFormatType ? f = Cr({
         fieldOrDatumDef: t,
         field: "datum.value",
         format: o.numberFormat,
         formatType: o.numberFormatType,
         config: o
-    }) : t.type === "temporal" && o.timeFormatType && J(t) && t.timeUnit === void 0 && (f = $r({
+    }) : t.type === "temporal" && o.timeFormatType && Q(t) && t.timeUnit === void 0 && (f = Cr({
         fieldOrDatumDef: t,
         field: "datum.value",
         format: o.timeFormat,
         formatType: o.timeFormatType,
         config: o
     })));
     const d = {
@@ -44949,30 +44936,30 @@
 }
 
 function pB(e) {
     return mB(e, (t, n) => Math.max(t, n.value));
 }
 
 function Iw(e) {
-    return mB(e, (t, n) => St(t, n.value));
+    return mB(e, (t, n) => kt(t, n.value));
 }
 
 function mB(e, t) {
     if (Gme(e))
-        return ne(e.condition).reduce(t, e.value);
+        return re(e.condition).reduce(t, e.value);
     if (Dr(e))
         return e.value;
 }
 
 function yB(e, t, n) {
     const i = t.get("selections");
     if (!(i != null && i.length))
         return;
-    const r = Z(n.field);
-    return i.map((s) => `(!length(data(${Z(ft(s) + sl)})) || (${s}[${r}] && indexof(${s}[${r}], datum.value) >= 0))`).join(" || ");
+    const r = ee(n.field);
+    return i.map((s) => `(!length(data(${ee(ft(s) + sl)})) || (${s}[${r}] && indexof(${s}[${r}], datum.value) >= 0))`).join(" || ");
 }
 const N4 = {
     direction: ({
         direction: e
     }) => e,
     format: ({
         fieldOrDatumDef: e,
@@ -45036,15 +45023,15 @@
         fieldOrDatumDef: e,
         legend: t
     }) => Qye(t, e)
 };
 
 function Qye(e, t) {
     const n = e.values;
-    if (W(n))
+    if (V(n))
         return VP(t, n);
     if (de(n))
         return n;
 }
 
 function Zye(e, t, n, i) {
     if (t !== "shape") {
@@ -45073,15 +45060,15 @@
     }
 }
 
 function ebe(e) {
     const {
         legend: t
     } = e;
-    return St(t.type, tbe(e));
+    return kt(t.type, tbe(e));
 }
 
 function tbe({
     channel: e,
     timeUnit: t,
     scaleType: n
 }) {
@@ -45143,25 +45130,25 @@
 
 function sbe(e) {
     if (De(["quantile", "threshold", "log", "symlog"], e))
         return "greedy";
 }
 
 function bB(e) {
-    const t = bt(e) ? obe(e) : cbe(e);
+    const t = vt(e) ? obe(e) : cbe(e);
     return e.component.legends = t, t;
 }
 
 function obe(e) {
     const {
         encoding: t
     } = e, n = {};
     for (const i of [ci, ...gz]) {
-        const r = Ft(t[i]);
-        !r || !e.getScaleComponent(i) || i === fi && J(r) && r.type === Nf || (n[i] = lbe(e, i));
+        const r = Nt(t[i]);
+        !r || !e.getScaleComponent(i) || i === fi && Q(r) && r.type === Nf || (n[i] = lbe(e, i));
     }
     return n;
 }
 
 function abe(e, t) {
     const n = e.scaleName(t);
     if (e.mark === "trail") {
@@ -45206,16 +45193,16 @@
     } = e, o = s.legend, a = new Vye({}, abe(e, t));
     bye(e, t, a);
     const u = n !== void 0 ? !n : o.disable;
     if (a.set("disable", u, n !== void 0), u)
         return a;
     n = n || {};
     const l = e.getScaleComponent(t).get("type"),
-        c = Ft(r[t]),
-        f = J(c) ? (x = Wt(c.timeUnit)) == null ? void 0 : x.unit : void 0,
+        c = Nt(r[t]),
+        f = Q(c) ? (x = Ht(c.timeUnit)) == null ? void 0 : x.unit : void 0,
         d = n.orient || s.legend.orient || "right",
         h = ebe({
             legend: n,
             channel: t,
             timeUnit: f,
             scaleType: l
         }),
@@ -45238,35 +45225,35 @@
             orient: d,
             legendType: h,
             direction: g
         };
     for (const w of gB) {
         if (h === "gradient" && w.startsWith("symbol") || h === "symbol" && w.startsWith("gradient"))
             continue;
-        const S = w in N4 ? N4[w](p) : n[w];
-        if (S !== void 0) {
-            const _ = ube(S, w, n, e.fieldDef(t));
-            (_ || s.legend[w] === void 0) && a.set(w, S, _);
+        const E = w in N4 ? N4[w](p) : n[w];
+        if (E !== void 0) {
+            const _ = ube(E, w, n, e.fieldDef(t));
+            (_ || s.legend[w] === void 0) && a.set(w, E, _);
         }
     }
     const m = (n == null ? void 0 : n.encoding) ?? {},
         y = a.get("selections"),
         b = {},
         v = {
             fieldOrDatumDef: c,
             model: e,
             channel: t,
             legendCmpt: a,
             legendType: h
         };
     for (const w of ["labels", "legend", "title", "symbols", "gradient", "entries"]) {
-        const S = dB(m[w] ?? {}, e),
-            _ = w in F4 ? F4[w](S, v) : S;
+        const E = dB(m[w] ?? {}, e),
+            _ = w in F4 ? F4[w](E, v) : E;
         _ !== void 0 && !Je(_) && (b[w] = {
-            ...y != null && y.length && J(c) ? {
+            ...y != null && y.length && Q(c) ? {
                 name: `${ft(c.field)}_legend_${w}`
             } : {},
             ...y != null && y.length ? {
                 interactive: !!y
             } : {},
             update: _
         });
@@ -45277,18 +45264,18 @@
 function cbe(e) {
     const {
         legends: t,
         resolve: n
     } = e.component;
     for (const i of e.children) {
         bB(i);
-        for (const r of Y(i.component.legends))
+        for (const r of X(i.component.legends))
             n.legend[r] = M6(e.component.resolve, r), n.legend[r] === "shared" && (t[r] = vB(t[r], i.component.legends[r]), t[r] || (n.legend[r] = "independent", delete t[r]));
     }
-    for (const i of Y(t))
+    for (const i of X(t))
         for (const r of e.children)
             r.component.legends[i] && n.legend[i] === "shared" && delete r.component.legends[i];
     return t;
 }
 
 function vB(e, t) {
     var s, o, a, u;
@@ -45331,24 +45318,24 @@
     var r, s;
     e.encode ?? (e.encode = {}), (r = e.encode)[t] ?? (r[t] = {}), (s = e.encode[t]).update ?? (s.update = {}), e.encode[t].update[n] = i;
 }
 
 function xB(e) {
     const t = e.component.legends,
         n = {};
-    for (const r of Y(t)) {
+    for (const r of X(t)) {
         const s = e.getScaleComponent(r),
             o = Qe(s.get("domains"));
         if (n[o])
             for (const a of n[o])
                 vB(a, t[r]) || n[o].push(t[r]);
         else
             n[o] = [t[r].clone()];
     }
-    return nn(n).flat().map((r) => hbe(r, e.config)).filter((r) => r !== void 0);
+    return rn(n).flat().map((r) => hbe(r, e.config)).filter((r) => r !== void 0);
 }
 
 function hbe(e, t) {
     var o, a, u;
     const {
         disable: n,
         labelExpr: i,
@@ -45455,15 +45442,15 @@
      */
     get isFit() {
         return !!this.data;
     }
 }
 
 function EB(e) {
-    e.component.projection = bt(e) ? ybe(e) : xbe(e);
+    e.component.projection = vt(e) ? ybe(e) : xbe(e);
 }
 
 function ybe(e) {
     if (e.hasProjection) {
         const t = Zn(e.specifiedProjection),
             n = !(t && (t.scale != null || t.translate != null)),
             i = n ? [e.getSizeSignalRef("width"), e.getSizeSignalRef("height")] : void 0,
@@ -45481,24 +45468,24 @@
         {
             encoding: n
         } = e;
     for (const i of [
             [qr, jr],
             [or, Wr]
         ])
-        (Ft(n[i[0]]) || Ft(n[i[1]])) && t.push({
+        (Nt(n[i[0]]) || Nt(n[i[1]])) && t.push({
             signal: e.getName(`geojson_${t.length}`)
         });
     return e.channelHasField(fi) && e.typedFieldDef(fi).type === Nf && t.push({
         signal: e.getName(`geojson_${t.length}`)
     }), t.length === 0 && t.push(e.requestDataName(nt.Main)), t;
 }
 
 function vbe(e, t) {
-    const n = w5(mbe, (r) => !!(!be(e.explicit, r) && !be(t.explicit, r) || be(e.explicit, r) && be(t.explicit, r) && // some properties might be signals or objects and require hashing for comparison
+    const n = w5(mbe, (r) => !!(!xe(e.explicit, r) && !xe(t.explicit, r) || xe(e.explicit, r) && xe(t.explicit, r) && // some properties might be signals or objects and require hashing for comparison
         wi(e.get(r), t.get(r))));
     if (wi(e.size, t.size)) {
         if (n)
             return e;
         if (wi(e.explicit, {}))
             return t;
         if (wi(t.explicit, {}))
@@ -45533,24 +45520,24 @@
         }
         return r;
     }
 }
 
 function wbe(e, t, n, i) {
     if (Ig(t, n)) {
-        const r = bt(e) ? e.axis(n) ?? e.legend(n) ?? {} : {},
-            s = te(t, {
+        const r = vt(e) ? e.axis(n) ?? e.legend(n) ?? {} : {},
+            s = ne(t, {
                 expr: "datum"
             }),
-            o = te(t, {
+            o = ne(t, {
                 expr: "datum",
                 binSuffix: "end"
             });
         return {
-            formulaAs: te(t, {
+            formulaAs: ne(t, {
                 binSuffix: "range",
                 forAs: !0
             }),
             formula: Dg(s, o, r.format, r.formatType, i)
         };
     }
     return {};
@@ -45575,17 +45562,17 @@
 
 function Ebe(e) {
     return "as" in e;
 }
 
 function D4(e, t, n) {
     let i, r;
-    Ebe(e) ? i = ie(e.as) ? [e.as, `${e.as}_end`] : [e.as[0], e.as[1]] : i = [te(e, {
+    Ebe(e) ? i = se(e.as) ? [e.as, `${e.as}_end`] : [e.as[0], e.as[1]] : i = [ne(e, {
         forAs: !0
-    }), te(e, {
+    }), ne(e, {
         binSuffix: "end",
         forAs: !0
     })];
     const s = {
             ...Qy(t, void 0)
         },
         o = SB(s, e.field),
@@ -45621,15 +45608,15 @@
         return new fs(null, ke(this.bins));
     }
     constructor(t, n) {
         super(t), this.bins = n;
     }
     static makeFromEncoding(t, n) {
         const i = n.reduceFieldDef((r, s, o) => {
-            if (Wn(s) && rt(s.bin)) {
+            if (Hn(s) && st(s.bin)) {
                 const {
                     key: a,
                     binComponent: u
                 } = D4(s, s.bin, n);
                 r[a] = {
                     ...u,
                     ...r[a],
@@ -45654,31 +45641,31 @@
         });
     }
     /**
      * Merge bin nodes. This method either integrates the bin config from the other node
      * or if this node already has a bin config, renames the corresponding signal in the model.
      */
     merge(t, n) {
-        for (const i of Y(t.bins))
+        for (const i of X(t.bins))
             i in this.bins ? (n(t.bins[i].signal, this.bins[i].signal), this.bins[i].as = rs([...this.bins[i].as, ...t.bins[i].as], Oe)) : this.bins[i] = t.bins[i];
         for (const i of t.children)
             t.removeChild(i), i.parent = this;
         t.remove();
     }
     producedFields() {
-        return new Set(nn(this.bins).map((t) => t.as).flat(2));
+        return new Set(rn(this.bins).map((t) => t.as).flat(2));
     }
     dependentFields() {
-        return new Set(nn(this.bins).map((t) => t.field));
+        return new Set(rn(this.bins).map((t) => t.field));
     }
     hash() {
         return `Bin ${Oe(this.bins)}`;
     }
     assemble() {
-        return nn(this.bins).flatMap((t) => {
+        return rn(this.bins).flatMap((t) => {
             const n = [],
                 [i, ...r] = t.as,
                 {
                     extent: s,
                     ...o
                 } = t.bin,
                 a = {
@@ -45705,15 +45692,15 @@
             }), a.extent = {
                 signal: t.extentSignal
             }), n.push(a);
             for (const u of r)
                 for (let l = 0; l < 2; l++)
                     n.push({
                         type: "formula",
-                        expr: te({
+                        expr: ne({
                             field: i[l]
                         }, {
                             expr: "datum"
                         }),
                         as: u[l]
                     });
             return t.formula && n.push({
@@ -45723,47 +45710,47 @@
             }), n;
         });
     }
 }
 
 function Sbe(e, t, n, i) {
     var s;
-    const r = bt(i) ? i.encoding[Ds(t)] : void 0;
-    if (Wn(n) && bt(i) && zP(n, r, i.markDef, i.config)) {
-        e.add(te(n, {})), e.add(te(n, {
+    const r = vt(i) ? i.encoding[Ds(t)] : void 0;
+    if (Hn(n) && vt(i) && zP(n, r, i.markDef, i.config)) {
+        e.add(ne(n, {})), e.add(ne(n, {
             suffix: "end"
         }));
         const {
             mark: o,
             markDef: a,
             config: u
-        } = i, l = Ca({
+        } = i, l = $a({
             fieldDef: n,
             markDef: a,
             config: u
         });
-        Ph(o) && l !== 0.5 && kt(t) && (e.add(te(n, {
+        Ph(o) && l !== 0.5 && At(t) && (e.add(ne(n, {
             suffix: sb
-        })), e.add(te(n, {
+        })), e.add(ne(n, {
             suffix: ob
-        }))), n.bin && Ig(n, t) && e.add(te(n, {
+        }))), n.bin && Ig(n, t) && e.add(ne(n, {
             binSuffix: "range"
         }));
     } else if (LI(t)) {
         const o = RI(t);
         e.add(i.getName(o));
     } else
-        e.add(te(n));
-    return $l(n) && gme((s = n.scale) == null ? void 0 : s.range) && e.add(n.scale.range.field), e;
+        e.add(ne(n));
+    return Cl(n) && gme((s = n.scale) == null ? void 0 : s.range) && e.add(n.scale.range.field), e;
 }
 
 function kbe(e, t) {
-    for (const n of Y(t)) {
+    for (const n of X(t)) {
         const i = t[n];
-        for (const r of Y(i))
+        for (const r of X(i))
             n in e ? e[n][r] = /* @__PURE__ */ new Set([...e[n][r] ?? [], ...i[r]]) : e[n] = {
                 [r]: i[r]
             };
     }
 }
 class Tr extends Ke {
     clone() {
@@ -45789,93 +45776,93 @@
         return !i || (n.forEachFieldDef((o, a) => {
             const {
                 aggregate: u,
                 field: l
             } = o;
             if (u)
                 if (u === "count")
-                    r["*"] ?? (r["*"] = {}), r["*"].count = /* @__PURE__ */ new Set([te(o, {
+                    r["*"] ?? (r["*"] = {}), r["*"].count = /* @__PURE__ */ new Set([ne(o, {
                         forAs: !0
                     })]);
                 else {
                     if (bo(u) || Ha(u)) {
                         const c = bo(u) ? "argmin" : "argmax",
                             f = u[c];
-                        r[f] ?? (r[f] = {}), r[f][c] = /* @__PURE__ */ new Set([te({
+                        r[f] ?? (r[f] = {}), r[f][c] = /* @__PURE__ */ new Set([ne({
                             op: c,
                             field: f
                         }, {
                             forAs: !0
                         })]);
                     } else
-                        r[l] ?? (r[l] = {}), r[l][u] = /* @__PURE__ */ new Set([te(o, {
+                        r[l] ?? (r[l] = {}), r[l][u] = /* @__PURE__ */ new Set([ne(o, {
                             forAs: !0
                         })]);
-                    Co(a) && n.scaleDomain(a) === "unaggregated" && (r[l] ?? (r[l] = {}), r[l].min = /* @__PURE__ */ new Set([te({
+                    $o(a) && n.scaleDomain(a) === "unaggregated" && (r[l] ?? (r[l] = {}), r[l].min = /* @__PURE__ */ new Set([ne({
                         field: l,
                         aggregate: "min"
                     }, {
                         forAs: !0
-                    })]), r[l].max = /* @__PURE__ */ new Set([te({
+                    })]), r[l].max = /* @__PURE__ */ new Set([ne({
                         field: l,
                         aggregate: "max"
                     }, {
                         forAs: !0
                     })]));
                 }
             else
                 Sbe(s, a, o, n);
-        }), s.size + Y(r).length === 0) ? null : new Tr(t, s, r);
+        }), s.size + X(r).length === 0) ? null : new Tr(t, s, r);
     }
     static makeFromTransform(t, n) {
         const i = /* @__PURE__ */ new Set(),
             r = {};
         for (const s of n.aggregate) {
             const {
                 op: o,
                 field: a,
                 as: u
             } = s;
-            o && (o === "count" ? (r["*"] ?? (r["*"] = {}), r["*"].count = /* @__PURE__ */ new Set([u || te(s, {
+            o && (o === "count" ? (r["*"] ?? (r["*"] = {}), r["*"].count = /* @__PURE__ */ new Set([u || ne(s, {
                 forAs: !0
-            })])) : (r[a] ?? (r[a] = {}), r[a][o] = /* @__PURE__ */ new Set([u || te(s, {
+            })])) : (r[a] ?? (r[a] = {}), r[a][o] = /* @__PURE__ */ new Set([u || ne(s, {
                 forAs: !0
             })])));
         }
         for (const s of n.groupby ?? [])
             i.add(s);
-        return i.size + Y(r).length === 0 ? null : new Tr(t, i, r);
+        return i.size + X(r).length === 0 ? null : new Tr(t, i, r);
     }
     merge(t) {
-        return $I(this.dimensions, t.dimensions) ? (kbe(this.measures, t.measures), !0) : (zpe("different dimensions, cannot merge"), !1);
+        return CI(this.dimensions, t.dimensions) ? (kbe(this.measures, t.measures), !0) : (zpe("different dimensions, cannot merge"), !1);
     }
     addDimensions(t) {
         t.forEach(this.dimensions.add, this.dimensions);
     }
     dependentFields() {
-        return /* @__PURE__ */ new Set([...this.dimensions, ...Y(this.measures)]);
+        return /* @__PURE__ */ new Set([...this.dimensions, ...X(this.measures)]);
     }
     producedFields() {
         const t = /* @__PURE__ */ new Set();
-        for (const n of Y(this.measures))
-            for (const i of Y(this.measures[n])) {
+        for (const n of X(this.measures))
+            for (const i of X(this.measures[n])) {
                 const r = this.measures[n][i];
                 r.size === 0 ? t.add(`${i}_${n}`) : r.forEach(t.add, t);
             }
         return t;
     }
     hash() {
         return `Aggregate ${Oe({ dimensions: this.dimensions, measures: this.measures })}`;
     }
     assemble() {
         const t = [],
             n = [],
             i = [];
-        for (const s of Y(this.measures))
-            for (const o of Y(this.measures[s]))
+        for (const s of X(this.measures))
+            for (const o of X(this.measures[s]))
                 for (const a of this.measures[s][o])
                     i.push(a), t.push(o), n.push(s === "*" ? null : sr(s));
         return {
             type: "aggregate",
             groupby: [...this.dimensions].map(sr),
             ops: t,
             fields: n,
@@ -45896,20 +45883,20 @@
             if (o) {
                 const {
                     bin: a,
                     sort: u
                 } = o;
                 this[s] = {
                     name: n.getName(`${s}_domain`),
-                    fields: [te(o), ...rt(a) ? [te(o, {
+                    fields: [ne(o), ...st(a) ? [ne(o, {
                         binSuffix: "end"
                     })] : []],
                     ...ls(u) ? {
                         sortField: u
-                    } : W(u) ? {
+                    } : V(u) ? {
                         sortIndexField: ef(o, s)
                     } : {}
                 };
             }
         }
         this.childModel = n.child;
     }
@@ -45944,18 +45931,18 @@
     getChildIndependentFieldsWithStep() {
         const t = {};
         for (const n of Rs) {
             const i = this.childModel.component.scales[n];
             if (i && !i.merged) {
                 const r = i.get("type"),
                     s = i.get("range");
-                if (Ht(r) && Ga(s)) {
+                if (Gt(r) && Ga(s)) {
                     const o = fb(this.childModel, n),
                         a = D6(o);
-                    a ? t[n] = a : K(R5(n));
+                    a ? t[n] = a : J(R5(n));
                 }
             }
         }
         return t;
     }
     assembleRowColumnHeaderData(t, n, i) {
         const r = {
@@ -45972,15 +45959,15 @@
             sortIndexField: l
         } = this[t];
         if (u) {
             const {
                 op: c = Yy,
                 field: f
             } = u;
-            s.push(f), o.push(c), a.push(te(u, {
+            s.push(f), o.push(c), a.push(ne(u, {
                 forAs: !0
             }));
         } else
             l && (s.push(l), o.push("max"), a.push(l));
         return {
             name: this[t].name,
             // Use data from the crossed one if it exist
@@ -46000,15 +45987,15 @@
         var u;
         const {
             columns: n
         } = this.model.layout, {
             layoutHeaders: i
         } = this.model.component, r = [], s = {};
         for (const l of A6) {
-            for (const c of $6) {
+            for (const c of C6) {
                 const f = (i[l] && i[l][c]) ?? [];
                 for (const d of f)
                     if (((u = d.axes) == null ? void 0 : u.length) > 0) {
                         s[l] = !0;
                         break;
                     }
             }
@@ -46090,73 +46077,73 @@
     if (t.startsWith("date:")) {
         const i = R4(t.slice(5, t.length));
         return `timeParse(${n},'${i}')`;
     } else if (t.startsWith("utc:")) {
         const i = R4(t.slice(4, t.length));
         return `utcParse(${n},'${i}')`;
     } else
-        return K(Yge(t)), null;
+        return J(Yge(t)), null;
 }
 
-function $be(e) {
+function Cbe(e) {
     const t = {};
     return vm(e.filter, (n) => {
         if (yP(n)) {
             let i = null;
-            z5(n) ? i = bi(n.equal) : U5(n) ? i = bi(n.lte) : B5(n) ? i = bi(n.lt) : j5(n) ? i = bi(n.gt) : q5(n) ? i = bi(n.gte) : W5(n) ? i = n.range[0] : H5(n) && (i = (n.oneOf ?? n.in)[0]), i && (kl(i) ? t[n.field] = "date" : ze(i) ? t[n.field] = "number" : ie(i) && (t[n.field] = "string")), n.timeUnit && (t[n.field] = "date");
+            z5(n) ? i = bi(n.equal) : U5(n) ? i = bi(n.lte) : B5(n) ? i = bi(n.lt) : j5(n) ? i = bi(n.gt) : q5(n) ? i = bi(n.gte) : W5(n) ? i = n.range[0] : H5(n) && (i = (n.oneOf ?? n.in)[0]), i && (kl(i) ? t[n.field] = "date" : ze(i) ? t[n.field] = "number" : se(i) && (t[n.field] = "string")), n.timeUnit && (t[n.field] = "date");
         }
     }), t;
 }
 
-function Cbe(e) {
+function $be(e) {
     const t = {};
 
     function n(i) {
-        Kc(i) ? t[i.field] = "date" : i.type === "quantitative" && kge(i.aggregate) ? t[i.field] = "number" : qc(i.field) > 1 ? i.field in t || (t[i.field] = "flatten") : $l(i) && ls(i.sort) && qc(i.sort.field) > 1 && (i.sort.field in t || (t[i.sort.field] = "flatten"));
+        Kc(i) ? t[i.field] = "date" : i.type === "quantitative" && kge(i.aggregate) ? t[i.field] = "number" : qc(i.field) > 1 ? i.field in t || (t[i.field] = "flatten") : Cl(i) && ls(i.sort) && qc(i.sort.field) > 1 && (i.sort.field in t || (t[i.sort.field] = "flatten"));
     }
-    if ((bt(e) || $i(e)) && e.forEachFieldDef((i, r) => {
-            if (Wn(i))
+    if ((vt(e) || Ci(e)) && e.forEachFieldDef((i, r) => {
+            if (Hn(i))
                 n(i);
             else {
                 const s = El(r),
                     o = e.fieldDef(s);
                 n({
                     ...i,
                     type: o.type
                 });
             }
-        }), bt(e)) {
+        }), vt(e)) {
         const {
             mark: i,
             markDef: r,
             encoding: s
         } = e;
         if (Va(i) && // No need to sort by dimension if we have a connected scatterplot (order channel is present)
             !e.encoding.order) {
             const o = r.orient === "horizontal" ? "y" : "x",
                 a = s[o];
-            J(a) && a.type === "quantitative" && !(a.field in t) && (t[a.field] = "number");
+            Q(a) && a.type === "quantitative" && !(a.field in t) && (t[a.field] = "number");
         }
     }
     return t;
 }
 
 function Mbe(e) {
     const t = {};
-    if (bt(e) && e.component.selection)
-        for (const n of Y(e.component.selection)) {
+    if (vt(e) && e.component.selection)
+        for (const n of X(e.component.selection)) {
             const i = e.component.selection[n];
             for (const r of i.project.items)
                 !r.channel && qc(r.field) > 1 && (t[r.field] = "flatten");
         }
     return t;
 }
-class pn extends Ke {
+class mn extends Ke {
     clone() {
-        return new pn(null, ke(this._parse));
+        return new mn(null, ke(this._parse));
     }
     constructor(t, n) {
         super(t), this._parse = n;
     }
     hash() {
         return `Parse ${Oe(this._parse)}`;
     }
@@ -46169,30 +46156,30 @@
         const s = n.data;
         return !ua(s) && ((o = s == null ? void 0 : s.format) != null && o.parse) && (r = s.format.parse), this.makeWithAncestors(t, r, {}, i);
     }
     /**
      * Creates a parse node from "explicit" parse and "implicit" parse and updates ancestorParse.
      */
     static makeWithAncestors(t, n, i, r) {
-        for (const a of Y(i)) {
+        for (const a of X(i)) {
             const u = r.getWithExplicit(a);
-            u.value !== void 0 && (u.explicit || u.value === i[a] || u.value === "derived" || i[a] === "flatten" ? delete i[a] : K(H8(a, i[a], u.value)));
+            u.value !== void 0 && (u.explicit || u.value === i[a] || u.value === "derived" || i[a] === "flatten" ? delete i[a] : J(H8(a, i[a], u.value)));
         }
-        for (const a of Y(n)) {
+        for (const a of X(n)) {
             const u = r.get(a);
-            u !== void 0 && (u === n[a] ? delete n[a] : K(H8(a, n[a], u)));
+            u !== void 0 && (u === n[a] ? delete n[a] : J(H8(a, n[a], u)));
         }
         const s = new To(n, i);
         r.copyAll(s);
         const o = {};
-        for (const a of Y(s.combine())) {
+        for (const a of X(s.combine())) {
             const u = s.get(a);
             u !== null && (o[a] = u);
         }
-        return Y(o).length === 0 || r.parseNothing ? null : new pn(t, o);
+        return X(o).length === 0 || r.parseNothing ? null : new mn(t, o);
     }
     get parse() {
         return this._parse;
     }
     merge(t) {
         this._parse = {
             ...this._parse,
@@ -46200,29 +46187,29 @@
         }, t.remove();
     }
     /**
      * Assemble an object for Vega's format.parse property.
      */
     assembleFormatParse() {
         const t = {};
-        for (const n of Y(this._parse)) {
+        for (const n of X(this._parse)) {
             const i = this._parse[n];
             qc(n) === 1 && (t[n] = i);
         }
         return t;
     }
     // format parse depends and produces all fields in its parse
     producedFields() {
-        return new Set(Y(this._parse));
+        return new Set(X(this._parse));
     }
     dependentFields() {
-        return new Set(Y(this._parse));
+        return new Set(X(this._parse));
     }
     assembleTransforms(t = !1) {
-        return Y(this._parse).filter((n) => t ? qc(n) > 1 : !0).map((n) => {
+        return X(this._parse).filter((n) => t ? qc(n) > 1 : !0).map((n) => {
             const i = Abe(n, this._parse[n]);
             return i ? {
                 type: "formula",
                 expr: i,
                 as: k5(n)
                 // Vega output is always flattened
             } : null;
@@ -46389,15 +46376,15 @@
         L4(this, Pd, !0, "f");
     }
     get modifiedFlag() {
         return Tbe(this, Pd, "f");
     }
 }
 Pd = /* @__PURE__ */ new WeakMap();
-class Cl extends N6 {
+class $l extends N6 {
     /**
      * Compute a map of node depths that we can use to determine a topological sort order.
      */
     getNodeDepths(t, n, i) {
         i.set(t, n);
         for (const r of t.children)
             this.getNodeDepths(r, n + 1, i);
@@ -46431,24 +46418,24 @@
             t.removeChild(r), r.parent = i, r.remove();
     }
     run(t) {
         const n = t.children.map((r) => r.hash()),
             i = {};
         for (let r = 0; r < n.length; r++)
             i[n[r]] === void 0 ? i[n[r]] = [t.children[r]] : i[n[r]].push(t.children[r]);
-        for (const r of Y(i))
+        for (const r of X(i))
             i[r].length > 1 && (this.setModified(), this.mergeNodes(t, i[r]));
     }
 }
 class Nbe extends O6 {
     constructor(t) {
         super(), this.requiresSelectionId = t && k6(t);
     }
     run(t) {
-        t instanceof Na && (this.requiresSelectionId && (F6(t.parent) || t.parent instanceof Tr || t.parent instanceof pn) || (this.setModified(), t.remove()));
+        t instanceof Na && (this.requiresSelectionId && (F6(t.parent) || t.parent instanceof Tr || t.parent instanceof mn) || (this.setModified(), t.remove()));
     }
 }
 class Obe extends N6 {
     optimize(t) {
         return this.run(t, /* @__PURE__ */ new Set()), this.modifiedFlag;
     }
     run(t, n) {
@@ -46459,96 +46446,96 @@
     }
 }
 class Dbe extends O6 {
     constructor() {
         super();
     }
     run(t) {
-        t instanceof zn && !t.isRequired() && (this.setModified(), t.remove());
+        t instanceof Bn && !t.isRequired() && (this.setModified(), t.remove());
     }
 }
-class Rbe extends Cl {
+class Rbe extends $l {
     run(t) {
         if (!F6(t) && !(t.numChildren() > 1)) {
             for (const n of t.children)
-                if (n instanceof pn)
-                    if (t instanceof pn)
+                if (n instanceof mn)
+                    if (t instanceof mn)
                         this.setModified(), t.merge(n);
                     else {
                         if (E5(t.producedFields(), n.dependentFields()))
                             continue;
                         this.setModified(), n.swapWithParent();
                     }
         }
     }
 }
-class Lbe extends Cl {
+class Lbe extends $l {
     run(t) {
         const n = [...t.children],
-            i = t.children.filter((r) => r instanceof pn);
+            i = t.children.filter((r) => r instanceof mn);
         if (t.numChildren() > 1 && i.length >= 1) {
             const r = {},
                 s = /* @__PURE__ */ new Set();
             for (const o of i) {
                 const a = o.parse;
-                for (const u of Y(a))
+                for (const u of X(a))
                     u in r ? r[u] !== a[u] && s.add(u) : r[u] = a[u];
             }
             for (const o of s)
                 delete r[o];
             if (!Je(r)) {
                 this.setModified();
-                const o = new pn(t, r);
+                const o = new mn(t, r);
                 for (const a of n) {
-                    if (a instanceof pn)
-                        for (const u of Y(r))
+                    if (a instanceof mn)
+                        for (const u of X(r))
                             delete a.parse[u];
-                    t.removeChild(a), a.parent = o, a instanceof pn && Y(a.parse).length === 0 && a.remove();
+                    t.removeChild(a), a.parent = o, a instanceof mn && X(a.parse).length === 0 && a.remove();
                 }
             }
         }
     }
 }
-class Ibe extends Cl {
+class Ibe extends $l {
     run(t) {
-        t instanceof zn || t.numChildren() > 0 || t instanceof Rf || t instanceof ol || (this.setModified(), t.remove());
+        t instanceof Bn || t.numChildren() > 0 || t instanceof Rf || t instanceof ol || (this.setModified(), t.remove());
     }
 }
-class Pbe extends Cl {
+class Pbe extends $l {
     run(t) {
         const n = t.children.filter((r) => r instanceof cs),
             i = n.pop();
         for (const r of n)
             this.setModified(), i.merge(r);
     }
 }
-class zbe extends Cl {
+class zbe extends $l {
     run(t) {
         const n = t.children.filter((r) => r instanceof Tr),
             i = {};
         for (const r of n) {
             const s = Oe(r.groupBy);
             s in i || (i[s] = []), i[s].push(r);
         }
-        for (const r of Y(i)) {
+        for (const r of X(i)) {
             const s = i[r];
             if (s.length > 1) {
                 const o = s.pop();
                 for (const a of s)
                     o.merge(a) && (t.removeChild(a), a.parent = o, a.remove(), this.setModified());
             }
         }
     }
 }
-class Bbe extends Cl {
+class Bbe extends $l {
     constructor(t) {
         super(), this.model = t;
     }
     run(t) {
-        const n = !(F6(t) || t instanceof Df || t instanceof pn || t instanceof Na),
+        const n = !(F6(t) || t instanceof Df || t instanceof mn || t instanceof Na),
             i = [],
             r = [];
         for (const s of t.children)
             s instanceof fs && (n && !E5(t.producedFields(), s.dependentFields()) ? i.push(s) : r.push(s));
         if (i.length > 0) {
             const s = i.pop();
             for (const o of i)
@@ -46559,27 +46546,27 @@
             const s = r.pop();
             for (const o of r)
                 s.merge(o, this.model.renameSignal.bind(this.model));
             this.setModified();
         }
     }
 }
-class Ube extends Cl {
+class Ube extends $l {
     run(t) {
         const n = [...t.children];
-        if (!Ju(n, (o) => o instanceof zn) || t.numChildren() <= 1)
+        if (!Ju(n, (o) => o instanceof Bn) || t.numChildren() <= 1)
             return;
         const r = [];
         let s;
         for (const o of n)
-            if (o instanceof zn) {
+            if (o instanceof Bn) {
                 let a = o;
                 for (; a.numChildren() === 1;) {
                     const [u] = a.children;
-                    if (u instanceof zn)
+                    if (u instanceof Bn)
                         a = u;
                     else
                         break;
                 }
                 r.push(...a.children), s ? (t.removeChild(o), o.parent = s.parent, s.parent.removeChild(s), s.parent = a, this.setModified()) : s = a;
             } else
                 r.push(o);
@@ -46604,15 +46591,15 @@
         const t = /* @__PURE__ */ new Set();
         return this.transform.groupby && this.transform.groupby.forEach(t.add, t), this.transform.joinaggregate.map((n) => n.field).filter((n) => n !== void 0).forEach(t.add, t), t;
     }
     producedFields() {
         return new Set(this.transform.joinaggregate.map(this.getDefaultName));
     }
     getDefaultName(t) {
-        return t.as ?? te(t);
+        return t.as ?? ne(t);
     }
     hash() {
         return `JoinAggregateTransform ${Oe(this.transform)}`;
     }
     assemble() {
         const t = [],
             n = [],
@@ -46631,21 +46618,21 @@
         };
     }
 }
 
 function jbe(e) {
     return e.stack.stackBy.reduce((t, n) => {
         const i = n.fieldDef,
-            r = te(i);
+            r = ne(i);
         return r && t.push(r), t;
     }, []);
 }
 
 function qbe(e) {
-    return W(e) && e.every((t) => ie(t)) && e.length > 1;
+    return V(e) && e.every((t) => se(t)) && e.length > 1;
 }
 class fo extends Ke {
     clone() {
         return new fo(null, ke(this._stack));
     }
     constructor(t, n) {
         super(t), this._stack = n;
@@ -46655,21 +46642,21 @@
             stack: i,
             groupby: r,
             as: s,
             offset: o = "zero"
         } = n, a = [], u = [];
         if (n.sort !== void 0)
             for (const f of n.sort)
-                a.push(f.field), u.push(St(f.order, "ascending"));
+                a.push(f.field), u.push(kt(f.order, "ascending"));
         const l = {
             field: a,
             order: u
         };
         let c;
-        return qbe(s) ? c = s : ie(s) ? c = [s, `${s}_end`] : c = [`${n.stack}_start`, `${n.stack}_end`], new fo(t, {
+        return qbe(s) ? c = s : se(s) ? c = [s, `${s}_end`] : c = [`${n.stack}_start`, `${n.stack}_end`], new fo(t, {
             dimensionFieldDefs: [],
             stackField: i,
             groupby: r,
             offset: o,
             sort: l,
             facetby: [],
             as: c
@@ -46688,15 +46675,15 @@
             offset: a,
             impute: u
         } = i, l = s.map((h) => {
             const g = r[h];
             return xs(g);
         }).filter((h) => !!h), c = jbe(n), f = n.encoding.order;
         let d;
-        if (W(f) || J(f))
+        if (V(f) || Q(f))
             d = JI(f);
         else {
             const h = BP(f) ? f.sort : o === "y" ? "descending" : "ascending";
             d = c.reduce((g, p) => (g.field.includes(p) || (g.field.push(p), g.order.push(h)), g), {
                 field: [],
                 order: []
             });
@@ -46739,23 +46726,23 @@
     }
     getGroupbyFields() {
         const {
             dimensionFieldDefs: t,
             impute: n,
             groupby: i
         } = this._stack;
-        return t.length > 0 ? t.map((r) => r.bin ? n ? [te(r, {
+        return t.length > 0 ? t.map((r) => r.bin ? n ? [ne(r, {
             binSuffix: "mid"
         })] : [
             // For binned group by field without impute, we need both bin (start) and bin_end
-            te(r, {}),
-            te(r, {
+            ne(r, {}),
+            ne(r, {
                 binSuffix: "end"
             })
-        ] : [te(r)]).flat() : i ?? [];
+        ] : [ne(r)]).flat() : i ?? [];
     }
     assemble() {
         const t = [],
             {
                 facetby: n,
                 dimensionFieldDefs: i,
                 stackField: r,
@@ -46768,35 +46755,35 @@
         if (u)
             for (const c of i) {
                 const {
                     bandPosition: f = 0.5,
                     bin: d
                 } = c;
                 if (d) {
-                    const h = te(c, {
+                    const h = ne(c, {
                             expr: "datum"
                         }),
-                        g = te(c, {
+                        g = ne(c, {
                             expr: "datum",
                             binSuffix: "end"
                         });
                     t.push({
                         type: "formula",
                         expr: `${f}*${h}+${1 - f}*${g}`,
-                        as: te(c, {
+                        as: ne(c, {
                             binSuffix: "mid",
                             forAs: !0
                         })
                     });
                 }
                 t.push({
                     type: "impute",
                     field: r,
                     groupby: [...s, ...n],
-                    key: te(c, {
+                    key: ne(c, {
                         binSuffix: "mid"
                     }),
                     method: "value",
                     value: 0
                 });
             }
         return t.push({
@@ -46823,15 +46810,15 @@
         const t = /* @__PURE__ */ new Set();
         return (this.transform.groupby ?? []).forEach(t.add, t), (this.transform.sort ?? []).forEach((n) => t.add(n.field)), this.transform.window.map((n) => n.field).filter((n) => n !== void 0).forEach(t.add, t), t;
     }
     producedFields() {
         return new Set(this.transform.window.map(this.getDefaultName));
     }
     getDefaultName(t) {
-        return t.as ?? te(t);
+        return t.as ?? ne(t);
     }
     hash() {
         return `WindowTransform ${Oe(this.transform)}`;
     }
     assemble() {
         const t = [],
             n = [],
@@ -46881,15 +46868,15 @@
     }
 }
 
 function Wbe(e) {
     function t(n) {
         if (!(n instanceof Rf)) {
             const i = n.clone();
-            if (i instanceof zn) {
+            if (i instanceof Bn) {
                 const r = zw + i.getSource();
                 i.setSource(r), e.model.component.data.outputNodes[r] = i;
             } else
                 (i instanceof Tr || i instanceof fo || i instanceof Lf || i instanceof Ml) && i.addDimensions(e.fields);
             for (const r of n.children.flatMap(t))
                 r.parent = i;
             return [i];
@@ -46897,15 +46884,15 @@
         return n.children.flatMap(t);
     }
     return t;
 }
 
 function Pw(e) {
     if (e instanceof Rf)
-        if (e.numChildren() === 1 && !(e.children[0] instanceof zn)) {
+        if (e.numChildren() === 1 && !(e.children[0] instanceof Bn)) {
             const t = e.children[0];
             (t instanceof Tr || t instanceof fo || t instanceof Lf || t instanceof Ml) && t.addDimensions(e.fields), t.swapWithParent(), Pw(e);
         } else {
             const t = e.model.component.data.main;
             kB(t);
             const n = Wbe(e),
                 i = e.children.map(n).flat();
@@ -46913,15 +46900,15 @@
                 r.parent = t;
         }
     else
         e.children.map(Pw);
 }
 
 function kB(e) {
-    if (e instanceof zn && e.type === nt.Main && e.numChildren() === 1) {
+    if (e instanceof Bn && e.type === nt.Main && e.numChildren() === 1) {
         const t = e.children[0];
         t instanceof Rf || (t.swapWithParent(), kB(e));
     }
 }
 const zw = "scale_",
     Tp = 5;
 
@@ -46954,73 +46941,73 @@
     let n = 0,
         i = 0;
     for (let r = 0; r < Tp && I4(e, t, !0); r++)
         n++;
     e.sources.map(Pw);
     for (let r = 0; r < Tp && I4(e, t, !1); r++)
         i++;
-    Bw(e.sources), Math.max(n, i) === Tp && K(`Maximum optimization runs(${Tp}) reached.`);
+    Bw(e.sources), Math.max(n, i) === Tp && J(`Maximum optimization runs(${Tp}) reached.`);
 }
-class It {
+class Pt {
     constructor(t) {
         Object.defineProperty(this, "signal", {
             enumerable: !0,
             get: t
         });
     }
     static fromName(t, n) {
-        return new It(() => t(n));
+        return new Pt(() => t(n));
     }
 }
 
 function AB(e) {
-    bt(e) ? Gbe(e) : Vbe(e);
+    vt(e) ? Gbe(e) : Vbe(e);
 }
 
 function Gbe(e) {
     const t = e.component.scales;
-    for (const n of Y(t)) {
+    for (const n of X(t)) {
         const i = Xbe(e, n);
         if (t[n].setWithExplicit("domains", i), Jbe(e, n), e.component.data.isFaceted) {
             let s = e;
-            for (; !$i(s) && s.parent;)
+            for (; !Ci(s) && s.parent;)
                 s = s.parent;
             if (s.component.resolve.scale[n] === "shared")
                 for (const a of i.value)
                     oo(a) && (a.data = zw + a.data.replace(zw, ""));
         }
     }
 }
 
 function Vbe(e) {
     for (const n of e.children)
         AB(n);
     const t = e.component.scales;
-    for (const n of Y(t)) {
+    for (const n of X(t)) {
         let i, r = null;
         for (const s of e.children) {
             const o = s.component.scales[n];
             if (o) {
                 i === void 0 ? i = o.getWithExplicit("domains") : i = Ma(i, o.getWithExplicit("domains"), "domains", "scale", Uw);
                 const a = o.get("selectionExtent");
-                r && a && r.param !== a.param && K(Wge), r = a;
+                r && a && r.param !== a.param && J(Wge), r = a;
             }
         }
         t[n].setWithExplicit("domains", i), r && t[n].set("selectionExtent", r, !0);
     }
 }
 
 function Ybe(e, t, n, i) {
     if (e === "unaggregated") {
         const {
             valid: r,
             reason: s
         } = P4(t, n);
         if (!r) {
-            K(s);
+            J(s);
             return;
         }
     } else if (e === void 0 && i.useUnaggregatedDomain) {
         const {
             valid: r
         } = P4(t, n);
         if (r)
@@ -47034,37 +47021,37 @@
         {
             encoding: i
         } = e,
         r = Ybe(e.scaleDomain(t), e.typedFieldDef(t), n, e.config.scale);
     return r !== e.scaleDomain(t) && (e.specifiedScales[t] = {
         ...e.specifiedScales[t],
         domain: r
-    }), t === "x" && Ft(i.x2) ? Ft(i.x) ? Ma(Io(n, r, e, "x"), Io(n, r, e, "x2"), "domain", "scale", Uw) : Io(n, r, e, "x2") : t === "y" && Ft(i.y2) ? Ft(i.y) ? Ma(Io(n, r, e, "y"), Io(n, r, e, "y2"), "domain", "scale", Uw) : Io(n, r, e, "y2") : Io(n, r, e, t);
+    }), t === "x" && Nt(i.x2) ? Nt(i.x) ? Ma(Io(n, r, e, "x"), Io(n, r, e, "x2"), "domain", "scale", Uw) : Io(n, r, e, "x2") : t === "y" && Nt(i.y2) ? Nt(i.y) ? Ma(Io(n, r, e, "y"), Io(n, r, e, "y2"), "domain", "scale", Uw) : Io(n, r, e, "y2") : Io(n, r, e, t);
 }
 
 function Kbe(e, t, n) {
     return e.map((i) => ({
         signal: `{data: ${Zy(i, { timeUnit: n, type: t })}}`
     }));
 }
 
 function Zv(e, t, n) {
     var r;
-    const i = (r = Wt(n)) == null ? void 0 : r.unit;
+    const i = (r = Ht(n)) == null ? void 0 : r.unit;
     return t === "temporal" || i ? Kbe(e, t, i) : [e];
 }
 
 function Io(e, t, n, i) {
     const {
         encoding: r,
         markDef: s,
         mark: o,
         config: a,
         stack: u
-    } = n, l = Ft(r[i]), {
+    } = n, l = Nt(r[i]), {
         type: c
     } = l, f = l.timeUnit;
     if (hme(t)) {
         const g = Io(e, void 0, n, i),
             p = Zv(t.unionWith, c, f);
         return Qr([...p, ...g.value]);
     } else {
@@ -47087,84 +47074,84 @@
         }, {
             data: g,
             field: n.vgField(i, {
                 suffix: "end"
             })
         }]);
     }
-    const d = Co(i) && J(l) ? Qbe(n, i, e) : void 0;
+    const d = $o(i) && Q(l) ? Qbe(n, i, e) : void 0;
     if (Ls(l)) {
         const g = Zv([l.datum], c, f);
         return pi(g);
     }
     const h = l;
     if (t === "unaggregated") {
         const g = n.requestDataName(nt.Main),
             {
                 field: p
             } = l;
         return pi([{
             data: g,
-            field: te({
+            field: ne({
                 field: p,
                 aggregate: "min"
             })
         }, {
             data: g,
-            field: te({
+            field: ne({
                 field: p,
                 aggregate: "max"
             })
         }]);
-    } else if (rt(h.bin)) {
-        if (Ht(e))
+    } else if (st(h.bin)) {
+        if (Gt(e))
             return pi(e === "bin-ordinal" ? [] : [{
                 // If sort by aggregation of a specified sort field, we need to use RAW table,
                 // so we can aggregate values for the scale independently from the main aggregation.
                 data: Lh(d) ? n.requestDataName(nt.Main) : n.requestDataName(nt.Raw),
                 // Use range if we added it and the scale does not support computing a range as a signal.
                 field: n.vgField(i, Ig(h, i) ? {
                     binSuffix: "range"
                 } : {}),
                 // we have to use a sort object if sort = true to make the sort correct by bin start
-                sort: d === !0 || !re(d) ? {
+                sort: d === !0 || !oe(d) ? {
                     field: n.vgField(i, {}),
                     op: "min"
                     // min or max doesn't matter since we sort by the start of the bin range
                 } : d
             }]);
         {
             const {
                 bin: g
             } = h;
-            if (rt(g)) {
+            if (st(g)) {
                 const p = T6(n, h.field, g);
                 return pi([
-                    new It(() => {
+                    new Pt(() => {
                         const m = n.getSignalName(p);
                         return `[${m}.start, ${m}.stop]`;
                     })
                 ]);
             } else
                 return pi([{
                     data: n.requestDataName(nt.Main),
                     field: n.vgField(i, {})
                 }]);
         }
     } else if (h.timeUnit && De(["time", "utc"], e)) {
         const g = r[Ds(i)];
         if (zP(h, g, s, a)) {
             const p = n.requestDataName(nt.Main),
-                m = Ca({
+                m = $a({
                     fieldDef: h,
                     fieldDef2: g,
                     markDef: s,
                     config: a
                 }),
-                y = Ph(o) && m !== 0.5 && kt(i);
+                y = Ph(o) && m !== 0.5 && At(i);
             return pi([{
                 data: p,
                 field: n.vgField(i, y ? {
                     suffix: sb
                 } : {})
             }, {
                 data: p,
@@ -47212,15 +47199,15 @@
         r = (a = e.fieldDef(t)) == null ? void 0 : a.bin,
         s = SP(i) && i,
         o = Sl(r) && Uy(r.extent) && r.extent;
     (s || o) && n.set("selectionExtent", s ?? o, !0);
 }
 
 function Qbe(e, t, n) {
-    if (!Ht(n))
+    if (!Gt(n))
         return;
     const i = e.fieldDef(t),
         r = i.sort;
     if (IP(r))
         return {
             op: "min",
             field: ef(i, t),
@@ -47238,15 +47225,15 @@
             order: u
         } = r, l = e.fieldDef(a), {
             aggregate: c,
             field: f
         } = l, d = s && !o.has(f);
         if (bo(c) || Ha(c))
             return e2({
-                field: te(l),
+                field: ne(l),
                 order: u
             }, d);
         if (O5(c) || !c)
             return e2({
                 op: c,
                 // can't be argmin/argmax since we don't support them in encoding field def
                 field: f,
@@ -47269,30 +47256,30 @@
 }
 
 function P4(e, t) {
     const {
         aggregate: n,
         type: i
     } = e;
-    return n ? ie(n) && !$ge.has(n) ? {
+    return n ? se(n) && !Cge.has(n) ? {
         valid: !1,
         reason: mpe(n)
     } : i === "quantitative" && t === "log" ? {
         valid: !1,
         reason: ype(e)
     } : {
         valid: !0
     } : {
         valid: !1,
         reason: ppe(e)
     };
 }
 
 function Uw(e, t, n, i) {
-    return e.explicit && t.explicit && K(_pe(n, i, e.value, t.value)), {
+    return e.explicit && t.explicit && J(_pe(n, i, e.value, t.value)), {
         explicit: e.explicit,
         value: [...e.value, ...t.value]
     };
 }
 
 function Zbe(e) {
     const t = rs(e.map((o) => {
@@ -47314,33 +47301,33 @@
     if (t.length === 0)
         return;
     if (t.length === 1) {
         const o = e[0];
         if (oo(o) && n.length > 0) {
             let a = n[0];
             if (n.length > 1) {
-                K(V8);
-                const u = n.filter((l) => re(l) && "op" in l && l.op !== "min");
-                n.every((l) => re(l) && "op" in l) && u.length === 1 ? a = u[0] : a = !0;
-            } else if (re(a) && "field" in a) {
+                J(V8);
+                const u = n.filter((l) => oe(l) && "op" in l && l.op !== "min");
+                n.every((l) => oe(l) && "op" in l) && u.length === 1 ? a = u[0] : a = !0;
+            } else if (oe(a) && "field" in a) {
                 const u = a.field;
                 o.field === u && (a = a.order ? {
                     order: a.order
                 } : !0);
             }
             return {
                 ...o,
                 sort: a
             };
         }
         return o;
     }
-    const i = rs(n.map((o) => Lh(o) || !("op" in o) || ie(o.op) && o.op in Ege ? o : (K(Spe(o)), !0)), Oe);
+    const i = rs(n.map((o) => Lh(o) || !("op" in o) || se(o.op) && o.op in Ege ? o : (J(Spe(o)), !0)), Oe);
     let r;
-    i.length === 1 ? r = i[0] : i.length > 1 && (K(V8), r = !0);
+    i.length === 1 ? r = i[0] : i.length > 1 && (J(V8), r = !0);
     const s = rs(e.map((o) => oo(o) ? o.data : null), (o) => o);
     return s.length === 1 && s[0] !== null ? {
         data: s[0],
         fields: t.map((a) => a.field),
         ...r ? {
             sort: r
         } : {}
@@ -47349,44 +47336,44 @@
         ...r ? {
             sort: r
         } : {}
     };
 }
 
 function D6(e) {
-    if (oo(e) && ie(e.field))
+    if (oo(e) && se(e.field))
         return e.field;
-    if (Cge(e)) {
+    if ($ge(e)) {
         let t;
         for (const n of e.fields)
-            if (oo(n) && ie(n.field)) {
+            if (oo(n) && se(n.field)) {
                 if (!t)
                     t = n.field;
                 else if (t !== n.field)
-                    return K(kpe), t;
+                    return J(kpe), t;
             }
-        return K(Ape), t;
+        return J(Ape), t;
     } else if (Mge(e)) {
-        K($pe);
+        J(Cpe);
         const t = e.fields[0];
-        return ie(t) ? t : void 0;
+        return se(t) ? t : void 0;
     }
 }
 
 function fb(e, t) {
     const i = e.component.scales[t].get("domains").map((r) => (oo(r) && (r.data = e.lookupDataSource(r.data)), r));
     return Zbe(i);
 }
 
-function $B(e) {
-    return If(e) || R6(e) ? e.children.reduce((t, n) => t.concat($B(n)), z4(e)) : z4(e);
+function CB(e) {
+    return If(e) || R6(e) ? e.children.reduce((t, n) => t.concat(CB(n)), z4(e)) : z4(e);
 }
 
 function z4(e) {
-    return Y(e.component.scales).reduce((t, n) => {
+    return X(e.component.scales).reduce((t, n) => {
         const i = e.component.scales[n];
         if (i.merged)
             return t;
         const r = i.combine(),
             {
                 name: s,
                 type: o,
@@ -47414,43 +47401,43 @@
             } : {},
             ...f
         }), t;
     }, []);
 }
 
 function eve(e, t, n, i) {
-    if (kt(n)) {
+    if (At(n)) {
         if (Ga(e))
             return {
                 step: {
                     signal: `${t}_step`
                 }
             };
-    } else if (re(e) && oo(e))
+    } else if (oe(e) && oo(e))
         return {
             ...e,
             data: i.lookupDataSource(e.data)
         };
     return e;
 }
-class CB extends To {
+class $B extends To {
     constructor(t, n) {
         super({},
             // no initial explicit property
             {
                 name: t
             }
             // name as initial implicit property
         ), this.merged = !1, this.setWithExplicit("type", n);
     }
     /**
      * Whether the scale definitely includes zero in the domain
      */
     domainDefinitelyIncludesZero() {
-        return this.get("zero") !== !1 ? !0 : Ju(this.get("domains"), (t) => W(t) && t.length === 2 && ze(t[0]) && t[0] <= 0 && ze(t[1]) && t[1] >= 0);
+        return this.get("zero") !== !1 ? !0 : Ju(this.get("domains"), (t) => V(t) && t.length === 2 && ze(t[0]) && t[0] <= 0 && ze(t[1]) && t[1] >= 0);
     }
 }
 const tve = ["range", "scheme"];
 
 function nve(e) {
     const t = e.component.scales;
     for (const n of By) {
@@ -47465,23 +47452,23 @@
 function B4(e, t) {
     const n = e.fieldDef(t);
     if (n != null && n.bin) {
         const {
             bin: i,
             field: r
         } = n, s = di(t), o = e.getName(s);
-        if (re(i) && i.binned && i.step !== void 0)
-            return new It(() => {
+        if (oe(i) && i.binned && i.step !== void 0)
+            return new Pt(() => {
                 const a = e.scaleName(t),
                     u = `(domain("${a}")[1] - domain("${a}")[0]) / ${i.step}`;
                 return `${e.getSignalName(o)} / (${u})`;
             });
-        if (rt(i)) {
+        if (st(i)) {
             const a = T6(e, r, i);
-            return new It(() => {
+            return new Pt(() => {
                 const u = e.getSignalName(a),
                     l = `(${u}.stop - ${u}.start) / ${u}.step`;
                 return `${e.getSignalName(o)} / (${l})`;
             });
         }
     }
 }
@@ -47493,32 +47480,32 @@
         } = t,
         s = t.getScaleComponent(e).get("type");
     for (const f of tve)
         if (n[f] !== void 0) {
             const d = kw(s, f),
                 h = kP(e, f);
             if (!d)
-                K(rP(s, f, e));
+                J(rP(s, f, e));
             else if (h)
-                K(h);
+                J(h);
             else
                 switch (f) {
                     case "range": {
                         const g = n.range;
-                        if (W(g)) {
-                            if (kt(e))
+                        if (V(g)) {
+                            if (At(e))
                                 return Qr(g.map((p) => {
                                     if (p === "width" || p === "height") {
                                         const m = t.getName(p),
                                             y = t.getSignalName.bind(t);
-                                        return It.fromName(y, m);
+                                        return Pt.fromName(y, m);
                                     }
                                     return p;
                                 }));
-                        } else if (re(g))
+                        } else if (oe(g))
                             return Qr({
                                 data: t.requestDataName(nt.Main),
                                 field: g.field,
                                 sort: {
                                     op: "min",
                                     field: t.vgField(e)
                                 }
@@ -47528,38 +47515,38 @@
                     case "scheme":
                         return Qr(rve(n[f]));
                 }
         }
     const o = e === ht || e === "xOffset" ? "width" : "height",
         a = i[o];
     if (ws(a)) {
-        if (kt(e))
-            if (Ht(s)) {
+        if (At(e))
+            if (Gt(s)) {
                 const f = TB(a, t, e);
                 if (f)
                     return Qr({
                         step: f
                     });
             } else
-                K(sP(o));
+                J(sP(o));
         else if (Fg(e)) {
             const f = e === Ba ? "x" : "y";
             if (t.getScaleComponent(f).get("type") === "band") {
                 const g = FB(a, s);
                 if (g)
                     return Qr(g);
             }
         }
     }
     const {
         rangeMin: u,
         rangeMax: l
     } = n, c = sve(e, t);
     return (u !== void 0 || l !== void 0) && // it's ok to check just rangeMin's compatibility since rangeMin/rangeMax are the same
-        kw(s, "rangeMin") && W(c) && c.length === 2 ? Qr([u ?? c[0], l ?? c[1]]) : pi(c);
+        kw(s, "rangeMin") && V(c) && c.length === 2 ? Qr([u ?? c[0], l ?? c[1]]) : pi(c);
 }
 
 function rve(e) {
     return dme(e) ? {
         scheme: e.name,
         ...ii(e, ["name"])
     } : {
@@ -47569,38 +47556,38 @@
 
 function MB(e, t, n, {
     center: i
 } = {}) {
     const r = di(e),
         s = t.getName(r),
         o = t.getSignalName.bind(t);
-    return e === Yt && Ni(n) ? i ? [
-        It.fromName((a) => `${o(a)}/2`, s),
-        It.fromName((a) => `-${o(a)}/2`, s)
-    ] : [It.fromName(o, s), 0] : i ? [
-        It.fromName((a) => `-${o(a)}/2`, s),
-        It.fromName((a) => `${o(a)}/2`, s)
-    ] : [0, It.fromName(o, s)];
+    return e === Xt && Ni(n) ? i ? [
+        Pt.fromName((a) => `${o(a)}/2`, s),
+        Pt.fromName((a) => `-${o(a)}/2`, s)
+    ] : [Pt.fromName(o, s), 0] : i ? [
+        Pt.fromName((a) => `-${o(a)}/2`, s),
+        Pt.fromName((a) => `${o(a)}/2`, s)
+    ] : [0, Pt.fromName(o, s)];
 }
 
 function sve(e, t) {
     const {
         size: n,
         config: i,
         mark: r,
         encoding: s
     } = t, {
         type: o
-    } = Ft(s[e]), u = t.getScaleComponent(e).get("type"), {
+    } = Nt(s[e]), u = t.getScaleComponent(e).get("type"), {
         domain: l,
         domainMid: c
     } = t.specifiedScales[e];
     switch (e) {
         case ht:
-        case Yt: {
+        case Xt: {
             if (De(["point", "band"], u)) {
                 const f = NB(e, n, i.view);
                 if (ws(f))
                     return {
                         step: TB(f, t, e)
                     };
             }
@@ -47618,17 +47605,17 @@
         case lr:
             return [0, Math.PI * 2];
         case _l:
             return [0, 360];
         case Ur:
             return [
                 0,
-                new It(() => {
-                    const f = t.getSignalName($i(t.parent) ? "child_width" : "width"),
-                        d = t.getSignalName($i(t.parent) ? "child_height" : "height");
+                new Pt(() => {
+                    const f = t.getSignalName(Ci(t.parent) ? "child_width" : "width"),
+                        d = t.getSignalName(Ci(t.parent) ? "child_height" : "height");
                     return `min(${f},${d})/2`;
                 })
             ];
         case qa:
             return [i.scale.minStrokeWidth, i.scale.maxStrokeWidth];
         case Wa:
             return [
@@ -47641,15 +47628,15 @@
             ];
         case fi:
             return "symbol";
         case ci:
         case Ns:
         case Os:
             return u === "ordinal" ? o === "nominal" ? "category" : "ordinal" : c !== void 0 ? "diverging" : r === "rect" || r === "geoshape" ? "heatmap" : "ramp";
-        case $o:
+        case Co:
         case Ua:
         case ja:
             return [i.scale.minOpacity, i.scale.maxOpacity];
     }
 }
 
 function TB(e, t, n) {
@@ -47674,15 +47661,15 @@
     } else
         return e.step;
 }
 
 function FB(e, t) {
     if (mz({
             step: e,
-            offsetIsDiscrete: Ht(t)
+            offsetIsDiscrete: Gt(t)
         }) === "offset")
         return {
             step: e.step
         };
 }
 
 function ove(e, t, n) {
@@ -47706,18 +47693,18 @@
                 return c;
         }
         return [0, {
             signal: `bandwidth('${o}')`
         }];
     } else {
         const l = t.encoding[i];
-        if (J(l) && l.timeUnit) {
+        if (Q(l) && l.timeUnit) {
             const c = pP(l.timeUnit, (g) => `scale('${o}', ${g})`),
                 f = t.config.scale.bandWithNestedOffsetPaddingInner,
-                d = Ca({
+                d = $a({
                     fieldDef: l,
                     markDef: a,
                     config: u
                 }) - 0.5,
                 h = d !== 0 ? ` + ${d}` : "";
             if (f) {
                 const g = de(f) ? `${f.signal}/2` + h : `${f / 2 + d}`,
@@ -47745,26 +47732,26 @@
 function ave(e, t, n, i) {
     switch (e) {
         case "quantile":
             return t.scale.quantileCount;
         case "quantize":
             return t.scale.quantizeCount;
         case "threshold":
-            return n !== void 0 && W(n) ? n.length + 1 : (K(Lpe(i)), 3);
+            return n !== void 0 && V(n) ? n.length + 1 : (J(Lpe(i)), 3);
     }
 }
 
 function uve(e, t, n) {
     const i = () => {
         const r = kr(t),
             s = kr(e),
             o = `(${r} - ${s}) / (${n} - 1)`;
         return `sequence(${s}, ${r} + ${o}, ${o})`;
     };
-    return de(t) ? new It(i) : {
+    return de(t) ? new Pt(i) : {
         signal: i()
     };
 }
 
 function OB(e, t, n) {
     if (t)
         return de(t) ? {
@@ -47796,67 +47783,67 @@
     };
     switch (e) {
         case "bar":
         case "tick": {
             if (i.scale.maxBandSize !== void 0)
                 return i.scale.maxBandSize;
             const s = j4(t, r, i.view);
-            return ze(s) ? s - 1 : new It(() => `${s.signal} - 1`);
+            return ze(s) ? s - 1 : new Pt(() => `${s.signal} - 1`);
         }
         case "line":
         case "trail":
         case "rule":
             return i.scale.maxStrokeWidth;
         case "text":
             return i.scale.maxFontSize;
         case "point":
         case "square":
         case "circle": {
             if (i.scale.maxSize)
                 return i.scale.maxSize;
             const s = j4(t, r, i.view);
-            return ze(s) ? Math.pow(U4 * s, 2) : new It(() => `pow(${U4} * ${s.signal}, 2)`);
+            return ze(s) ? Math.pow(U4 * s, 2) : new Pt(() => `pow(${U4} * ${s.signal}, 2)`);
         }
     }
     throw new Error(jy("size", e));
 }
 
 function j4(e, t, n) {
     const i = ws(e.width) ? e.width.step : J0(n, "width"),
         r = ws(e.height) ? e.height.step : J0(n, "height");
-    return t.x || t.y ? new It(() => `min(${[
+    return t.x || t.y ? new Pt(() => `min(${[
     t.x ? t.x.signal : i,
     t.y ? t.y.signal : r
   ].join(", ")})`) : Math.min(i, r);
 }
 
 function DB(e, t) {
-    bt(e) ? cve(e, t) : LB(e, t);
+    vt(e) ? cve(e, t) : LB(e, t);
 }
 
 function cve(e, t) {
     const n = e.component.scales,
         {
             config: i,
             encoding: r,
             markDef: s,
             specifiedScales: o
         } = e;
-    for (const a of Y(n)) {
+    for (const a of X(n)) {
         const u = o[a],
             l = n[a],
             c = e.getScaleComponent(a),
-            f = Ft(r[a]),
+            f = Nt(r[a]),
             d = u[t],
             h = c.get("type"),
             g = c.get("padding"),
             p = c.get("paddingInner"),
             m = kw(h, t),
             y = kP(a, t);
-        if (d !== void 0 && (m ? y && K(y) : K(rP(h, t, a))), m && y === void 0)
+        if (d !== void 0 && (m ? y && J(y) : J(rP(h, t, a))), m && y === void 0)
             if (d !== void 0) {
                 const b = f.timeUnit,
                     v = f.type;
                 switch (t) {
                     case "domainMax":
                     case "domainMin":
                         kl(u[t]) || v === "temporal" || b ? l.set(t, {
@@ -47889,15 +47876,15 @@
             }
     }
 }
 const q4 = {
     bins: ({
         model: e,
         fieldOrDatumDef: t
-    }) => J(t) ? fve(e, t) : void 0,
+    }) => Q(t) ? fve(e, t) : void 0,
     interpolate: ({
         channel: e,
         fieldOrDatumDef: t
     }) => dve(e, t.type),
     nice: ({
         scaleType: e,
         channel: t,
@@ -47931,37 +47918,37 @@
     }) => mve(e, t, n, i, r.scale, s),
     reverse: ({
         fieldOrDatumDef: e,
         scaleType: t,
         channel: n,
         config: i
     }) => {
-        const r = J(e) ? e.sort : void 0;
+        const r = Q(e) ? e.sort : void 0;
         return yve(t, r, n, i.scale);
     },
     zero: ({
         channel: e,
         fieldOrDatumDef: t,
         domain: n,
         markDef: i,
         scaleType: r,
         config: s,
         hasSecondaryRangeChannel: o
     }) => bve(e, t, n, i, r, s.scale, o)
 };
 
 function RB(e) {
-    bt(e) ? nve(e) : LB(e, "range");
+    vt(e) ? nve(e) : LB(e, "range");
 }
 
 function LB(e, t) {
     const n = e.component.scales;
     for (const i of e.children)
         t === "range" ? RB(i) : DB(i, t);
-    for (const i of Y(n)) {
+    for (const i of X(n)) {
         let r;
         for (const s of e.children) {
             const o = s.component.scales[i];
             if (o) {
                 const a = o.getWithExplicit(t);
                 r = Ma(r, a, t, "scale", Mz((u, l) => {
                     switch (t) {
@@ -47974,77 +47961,77 @@
         }
         n[i].setWithExplicit(t, r);
     }
 }
 
 function fve(e, t) {
     const n = t.bin;
-    if (rt(n)) {
+    if (st(n)) {
         const i = T6(e, t.field, n);
-        return new It(() => e.getSignalName(i));
-    } else if (Jt(n) && Sl(n) && n.step !== void 0)
+        return new Pt(() => e.getSignalName(i));
+    } else if (Qt(n) && Sl(n) && n.step !== void 0)
         return {
             step: n.step
         };
 }
 
 function dve(e, t) {
     if (De([ci, Ns, Os], e) && t !== "nominal")
         return "hcl";
 }
 
 function hve(e, t, n, i, r, s) {
     var o;
-    if (!((o = xs(s)) != null && o.bin || W(n) || r != null || i != null || De([ri.TIME, ri.UTC], e)))
-        return kt(t) ? !0 : void 0;
+    if (!((o = xs(s)) != null && o.bin || V(n) || r != null || i != null || De([ri.TIME, ri.UTC], e)))
+        return At(t) ? !0 : void 0;
 }
 
 function gve(e, t, n, i, r, s) {
-    if (kt(e)) {
+    if (At(e)) {
         if (Ar(t)) {
             if (n.continuousPadding !== void 0)
                 return n.continuousPadding;
             const {
                 type: o,
                 orient: a
             } = r;
-            if (o === "bar" && !(J(i) && (i.bin || i.timeUnit)) && (a === "vertical" && e === "x" || a === "horizontal" && e === "y"))
+            if (o === "bar" && !(Q(i) && (i.bin || i.timeUnit)) && (a === "vertical" && e === "x" || a === "horizontal" && e === "y"))
                 return s.continuousBandSize;
         }
         if (t === ri.POINT)
             return n.pointPadding;
     }
 }
 
 function pve(e, t, n, i, r, s = !1) {
     if (e === void 0) {
-        if (kt(t)) {
+        if (At(t)) {
             const {
                 bandPaddingInner: o,
                 barBandPaddingInner: a,
                 rectBandPaddingInner: u,
                 bandWithNestedOffsetPaddingInner: l
             } = r;
-            return s ? l : St(o, n === "bar" ? a : u);
+            return s ? l : kt(o, n === "bar" ? a : u);
         } else if (Fg(t) && i === ri.BAND)
             return r.offsetBandPaddingInner;
     }
 }
 
 function mve(e, t, n, i, r, s = !1) {
     if (e === void 0) {
-        if (kt(t)) {
+        if (At(t)) {
             const {
                 bandPaddingOuter: o,
                 bandWithNestedOffsetPaddingOuter: a
             } = r;
             if (s)
                 return a;
             if (n === ri.BAND)
-                return St(
+                return kt(
                     o,
                     /* By default, paddingOuter is paddingInner / 2. The reason is that
                       size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).
                       and we want the width/height to be integer by default.
                       Note that step (by default) and cardinality are integers.) */
                     de(i) ? {
                         signal: `${i.signal}/2`
@@ -48066,61 +48053,61 @@
         } : !i.xReverse : i.xReverse;
     if (Ni(e) && t === "descending")
         return !0;
 }
 
 function bve(e, t, n, i, r, s, o) {
     if (!!n && n !== "unaggregated" && Ni(r)) {
-        if (W(n)) {
+        if (V(n)) {
             const u = n[0],
                 l = n[n.length - 1];
             if (ze(u) && u <= 0 && ze(l) && l >= 0)
                 return !0;
         }
         return !1;
     }
     if (e === "size" && t.type === "quantitative" && !Vc(r))
         return !0;
-    if (!(J(t) && t.bin) && De([...Rs, ...pge], e)) {
+    if (!(Q(t) && t.bin) && De([...Rs, ...pge], e)) {
         const {
             orient: u,
             type: l
         } = i;
         return De(["bar", "area", "line", "trail"], l) && (u === "horizontal" && e === "y" || u === "vertical" && e === "x") ? !1 : De(["bar", "area"], l) && !o ? !0 : s == null ? void 0 : s.zero;
     }
     return !1;
 }
 
 function vve(e, t, n, i, r = !1) {
     const s = xve(t, n, i, r),
         {
             type: o
         } = e;
-    return Co(t) ? o !== void 0 ? vme(t, o) ? J(n) && !bme(o, n.type) ? (K(xpe(o, s)), s) : o : (K(vpe(t, o, s)), s) : s : null;
+    return $o(t) ? o !== void 0 ? vme(t, o) ? Q(n) && !bme(o, n.type) ? (J(xpe(o, s)), s) : o : (J(vpe(t, o, s)), s) : s : null;
 }
 
 function xve(e, t, n, i) {
     var r;
     switch (t.type) {
         case "nominal":
         case "ordinal": {
             if (bc(e) || Hv(e) === "discrete")
-                return e === "shape" && t.type === "ordinal" && K(Gv(e, "ordinal")), "ordinal";
-            if (kt(e) || Fg(e)) {
+                return e === "shape" && t.type === "ordinal" && J(Gv(e, "ordinal")), "ordinal";
+            if (At(e) || Fg(e)) {
                 if (De(["rect", "bar", "image", "rule"], n.type) || i)
                     return "band";
             } else if (n.type === "arc" && e in N5)
                 return "band";
             const s = n[di(e)];
             return nl(s) || Xc(t) && ((r = t.axis) != null && r.tickBand) ? "band" : "point";
         }
         case "temporal":
-            return bc(e) ? "time" : Hv(e) === "discrete" ? (K(Gv(e, "temporal")), "ordinal") : J(t) && t.timeUnit && Wt(t.timeUnit).utc ? "utc" : "time";
+            return bc(e) ? "time" : Hv(e) === "discrete" ? (J(Gv(e, "temporal")), "ordinal") : Q(t) && t.timeUnit && Ht(t.timeUnit).utc ? "utc" : "time";
         case "quantitative":
-            return bc(e) ? J(t) && rt(t.bin) ? "bin-ordinal" : "linear" : Hv(e) === "discrete" ? (K(Gv(e, "quantitative")), "ordinal") : "linear";
+            return bc(e) ? Q(t) && st(t.bin) ? "bin-ordinal" : "linear" : Hv(e) === "discrete" ? (J(Gv(e, "quantitative")), "ordinal") : "linear";
         case "geojson":
             return;
     }
     throw new Error(nP(t.type));
 }
 
 function wve(e, {
@@ -48129,33 +48116,33 @@
     IB(e), AB(e);
     for (const n of yme)
         DB(e, n);
     t || RB(e);
 }
 
 function IB(e) {
-    bt(e) ? e.component.scales = _ve(e) : e.component.scales = Sve(e);
+    vt(e) ? e.component.scales = _ve(e) : e.component.scales = Sve(e);
 }
 
 function _ve(e) {
     const {
         encoding: t,
         mark: n,
         markDef: i
     } = e, r = {};
     for (const s of By) {
-        const o = Ft(t[s]);
-        if (o && n === CP && s === fi && o.type === Nf)
+        const o = Nt(t[s]);
+        if (o && n === $P && s === fi && o.type === Nf)
             continue;
         let a = o && o.scale;
         if (o && a !== null && a !== !1) {
             a ?? (a = {});
             const u = QP(t, s),
                 l = vve(a, s, o, i, u);
-            r[s] = new CB(e.scaleName(`${s}`, !0), {
+            r[s] = new $B(e.scaleName(`${s}`, !0), {
                 value: l,
                 explicit: a.type === l
             });
         }
     }
     return r;
 }
@@ -48164,25 +48151,25 @@
 function Sve(e) {
     var t;
     const n = e.component.scales = {},
         i = {},
         r = e.component.resolve;
     for (const s of e.children) {
         IB(s);
-        for (const o of Y(s.component.scales))
+        for (const o of X(s.component.scales))
             if ((t = r.scale)[o] ?? (t[o] = hB(o, e)), r.scale[o] === "shared") {
                 const a = i[o],
                     u = s.component.scales[o].getWithExplicit("type");
                 a ? ame(a.value, u.value) ? i[o] = Ma(a, u, "type", "scale", Eve) : (r.scale[o] = "independent", delete i[o]) : i[o] = u;
             }
     }
-    for (const s of Y(i)) {
+    for (const s of X(i)) {
         const o = e.scaleName(s, !0),
             a = i[s];
-        n[s] = new CB(o, a);
+        n[s] = new $B(o, a);
         for (const u of e.children) {
             const l = u.component.scales[s];
             l && (u.renameScale(l.get("name"), o), l.merged = !0);
         }
     }
     return n;
 }
@@ -48199,19 +48186,19 @@
     get(t) {
         for (; this.nameMap[t] && t !== this.nameMap[t];)
             t = this.nameMap[t];
         return t;
     }
 }
 
-function bt(e) {
+function vt(e) {
     return (e == null ? void 0 : e.type) === "unit";
 }
 
-function $i(e) {
+function Ci(e) {
     return (e == null ? void 0 : e.type) === "facet";
 }
 
 function R6(e) {
     return (e == null ? void 0 : e.type) === "concat";
 }
 
@@ -48280,23 +48267,23 @@
         bB(this);
     }
     assembleEncodeFromView(t) {
         const {
             style: n,
             ...i
         } = t, r = {};
-        for (const s of Y(i)) {
+        for (const s of X(i)) {
             const o = i[s];
-            o !== void 0 && (r[s] = at(o));
+            o !== void 0 && (r[s] = ut(o));
         }
         return r;
     }
     assembleGroupEncodeEntry(t) {
         let n = {};
-        return this.view && (n = this.assembleEncodeFromView(this.view)), !t && (this.description && (n.description = at(this.description)), this.type === "unit" || this.type === "layer") ? {
+        return this.view && (n = this.assembleEncodeFromView(this.view)), !t && (this.description && (n.description = ut(this.description)), this.type === "unit" || this.type === "layer") ? {
             width: this.getSizeSignalRef("width"),
             height: this.getSizeSignalRef("height"),
             ...n
         } : Je(n) ? void 0 : n;
     }
     assembleLayout() {
         if (!this.layout)
@@ -48360,15 +48347,15 @@
      * Assemble the mark group for this model. We accept optional `signals` so that we can include concat top-level signals with the top-level model's local signals.
      */
     assembleGroup(t = []) {
         const n = {};
         t = t.concat(this.assembleSignals()), t.length > 0 && (n.signals = t);
         const i = this.assembleLayout();
         i && (n.layout = i), n.marks = [].concat(this.assembleHeaderMarks(), this.assembleMarks());
-        const r = !this.parent || $i(this.parent) ? $B(this) : [];
+        const r = !this.parent || Ci(this.parent) ? CB(this) : [];
         r.length > 0 && (n.scales = r);
         const s = this.assembleAxes();
         s.length > 0 && (n.axes = s);
         const o = this.assembleLegends();
         return o.length > 0 && (n.legends = o), n;
     }
     getName(t) {
@@ -48384,37 +48371,37 @@
      */
     requestDataName(t) {
         const n = this.getDataName(t),
             i = this.component.data.outputNodeRefCounts;
         return i[n] = (i[n] || 0) + 1, n;
     }
     getSizeSignalRef(t) {
-        if ($i(this.parent)) {
+        if (Ci(this.parent)) {
             const n = fB(t),
                 i = zy(n),
                 r = this.component.scales[i];
             if (r && !r.merged) {
                 const s = r.get("type"),
                     o = r.get("range");
-                if (Ht(s) && Ga(o)) {
+                if (Gt(s) && Ga(o)) {
                     const a = r.get("name"),
                         u = fb(this, i),
                         l = D6(u);
                     if (l) {
-                        const c = te({
+                        const c = ne({
                             aggregate: "distinct",
                             field: l
                         }, {
                             expr: "datum"
                         });
                         return {
                             signal: cB(a, r, c)
                         };
                     } else
-                        return K(R5(i)), null;
+                        return J(R5(i)), null;
                 }
             }
         }
         return {
             signal: this.signalNameMap.get(this.getName(t))
         };
     }
@@ -48441,15 +48428,15 @@
      * @return scale name for a given channel after the scale has been parsed and named.
      */
     scaleName(t, n) {
         if (n)
             return this.getName(t);
         if (
             // If there is a scale for the channel, there should be a local scale component for it
-            PI(t) && Co(t) && this.component.scales[t] || // in the scale name map (the scale get merged by its parent)
+            PI(t) && $o(t) && this.component.scales[t] || // in the scale name map (the scale get merged by its parent)
             this.scaleNameMap.has(this.getName(t))
         )
             return this.scaleNameMap.get(this.getName(t));
     }
     /**
      * @return projection name after the projection has been parsed and named.
      */
@@ -48486,15 +48473,15 @@
     }
 }
 class PB extends L6 {
     /** Get "field" reference for Vega */
     vgField(t, n = {}) {
         const i = this.fieldDef(t);
         if (i)
-            return te(i, n);
+            return ne(i, n);
     }
     reduceFieldDef(t, n) {
         return c0e(this.getMapping(), (i, r, s) => {
             const o = xs(r);
             return o ? t(i, o, s) : i;
         }, n);
     }
@@ -48577,39 +48564,39 @@
             config: i,
             mark: r,
             markDef: s
         } = n;
         if (He("invalid", s, i) !== "filter")
             return null;
         const a = n.reduceFieldDef((u, l, c) => {
-            const f = Co(c) && n.getScaleComponent(c);
+            const f = $o(c) && n.getScaleComponent(c);
             if (f) {
                 const d = f.get("type");
                 Ni(d) && l.aggregate !== "count" && !Va(r) && (u[l.field] = l);
             }
             return u;
         }, {});
-        return Y(a).length ? new Bh(t, a) : null;
+        return X(a).length ? new Bh(t, a) : null;
     }
     dependentFields() {
-        return new Set(Y(this.filter));
+        return new Set(X(this.filter));
     }
     producedFields() {
         return /* @__PURE__ */ new Set();
     }
     hash() {
         return `FilterInvalid ${Oe(this.filter)}`;
     }
     /**
      * Create the VgTransforms for each of the filtered fields.
      */
     assemble() {
-        const t = Y(this.filter).reduce((n, i) => {
+        const t = X(this.filter).reduce((n, i) => {
             const r = this.filter[i],
-                s = te(r, {
+                s = ne(r, {
                     expr: "datum"
                 });
             return r !== null && (r.type === "temporal" ? n.push(`(isDate(${s}) || (isValid(${s}) && isFinite(+${s})))`) : r.type === "quantitative" && (n.push(`isValid(${s})`), n.push(`isFinite(+${s})`))), n;
         }, []);
         return t.length > 0 ? {
             type: "filter",
             expr: t.join(" && ")
@@ -48688,16 +48675,16 @@
             return t;
         let i = 0;
         for (const r of [
                 [qr, jr],
                 [or, Wr]
             ]) {
             const s = r.map((o) => {
-                const a = Ft(n.encoding[o]);
-                return J(a) ? a.field : Ls(a) ? {
+                const a = Nt(n.encoding[o]);
+                return Q(a) ? a.field : Ls(a) ? {
                     expr: `${a.datum}`
                 } : Dr(a) ? {
                     expr: `${a.value}`
                 } : void 0;
             });
             (s[0] || s[1]) && (t = new wc(t, s, null, n.getName(`geojson_${i++}`)));
         }
@@ -48707,15 +48694,15 @@
         }
         return t;
     }
     constructor(t, n, i, r) {
         super(t), this.fields = n, this.geojson = i, this.signal = r;
     }
     dependentFields() {
-        const t = (this.fields ?? []).filter(ie);
+        const t = (this.fields ?? []).filter(se);
         return /* @__PURE__ */ new Set([...this.geojson ? [this.geojson] : [], ...t]);
     }
     producedFields() {
         return /* @__PURE__ */ new Set();
     }
     hash() {
         return `GeoJSON ${this.geojson} ${this.signal} ${Oe(this.fields)}`;
@@ -48749,31 +48736,31 @@
         if (!n.projectionName())
             return t;
         for (const i of [
                 [qr, jr],
                 [or, Wr]
             ]) {
             const r = i.map((o) => {
-                    const a = Ft(n.encoding[o]);
-                    return J(a) ? a.field : Ls(a) ? {
+                    const a = Nt(n.encoding[o]);
+                    return Q(a) ? a.field : Ls(a) ? {
                         expr: `${a.datum}`
                     } : Dr(a) ? {
                         expr: `${a.value}`
                     } : void 0;
                 }),
                 s = i[0] === or ? "2" : "";
             (r[0] || r[1]) && (t = new Uh(t, n.projectionName(), r, [
                 n.getName(`x${s}`),
                 n.getName(`y${s}`)
             ]));
         }
         return t;
     }
     dependentFields() {
-        return new Set(this.fields.filter(ie));
+        return new Set(this.fields.filter(se));
     }
     producedFields() {
         return new Set(this.as);
     }
     hash() {
         return `Geopoint ${this.projection} ${Oe(this.fields)} ${Oe(this.as)}`;
     }
@@ -48812,15 +48799,15 @@
     static makeFromTransform(t, n) {
         return new Tu(t, n);
     }
     static makeFromEncoding(t, n) {
         const i = n.encoding,
             r = i.x,
             s = i.y;
-        if (J(r) && J(s)) {
+        if (Q(r) && Q(s)) {
             const o = r.impute ? r : s.impute ? s : void 0;
             if (o === void 0)
                 return;
             const a = r.impute ? s : s.impute ? r : void 0,
                 {
                     method: u,
                     value: l,
@@ -48942,15 +48929,15 @@
                 from: o
             } = i;
         let a = null;
         if (h1e(o)) {
             let u = UB(o.data, s);
             u || (u = new ol(o.data), s.push(u));
             const l = n.getName(`lookup_${r}`);
-            a = new zn(u, l, nt.Lookup, n.component.data.outputNodeRefCounts), n.component.data.outputNodes[l] = a;
+            a = new Bn(u, l, nt.Lookup, n.component.data.outputNodeRefCounts), n.component.data.outputNodes[l] = a;
         } else if (g1e(o)) {
             const u = o.param;
             i = {
                 as: u,
                 ...i
             };
             let l;
@@ -48964,31 +48951,31 @@
         }
         return new jh(t, i, a.getSource());
     }
     dependentFields() {
         return /* @__PURE__ */ new Set([this.transform.lookup]);
     }
     producedFields() {
-        return new Set(this.transform.as ? ne(this.transform.as) : this.transform.from.fields);
+        return new Set(this.transform.as ? re(this.transform.as) : this.transform.from.fields);
     }
     hash() {
         return `Lookup ${Oe({ transform: this.transform, secondary: this.secondary })}`;
     }
     assemble() {
         let t;
         if (this.transform.from.fields)
             t = {
                 values: this.transform.from.fields,
                 ...this.transform.as ? {
-                    as: ne(this.transform.as)
+                    as: re(this.transform.as)
                 } : {}
             };
         else {
             let n = this.transform.as;
-            ie(n) || (K(Jge), n = "_lookup"), t = {
+            se(n) || (J(Jge), n = "_lookup"), t = {
                 as: [n]
             };
         }
         return {
             type: "lookup",
             from: this.secondary,
             key: this.transform.from.key,
@@ -49131,28 +49118,28 @@
     let t = 0;
 
     function n(i, r) {
         if (i instanceof ol && !i.isGenerator && !Jc(i.data) && (e.push(r), r = {
                 name: null,
                 source: r.name,
                 transform: []
-            }), i instanceof pn && (i.parent instanceof ol && !r.source ? (r.format = {
+            }), i instanceof mn && (i.parent instanceof ol && !r.source ? (r.format = {
                 ...r.format,
                 parse: i.assembleFormatParse()
             }, r.transform.push(...i.assembleTransforms(!0))) : r.transform.push(...i.assembleTransforms())), i instanceof Rf) {
             r.name || (r.name = `data_${t++}`), !r.source || r.transform.length > 0 ? (e.push(r), i.data = r.name) : i.data = r.source, e.push(...i.assemble());
             return;
         }
-        switch ((i instanceof Bg || i instanceof Ug || i instanceof Bh || i instanceof Df || i instanceof Zc || i instanceof Uh || i instanceof Tr || i instanceof jh || i instanceof Lf || i instanceof Ml || i instanceof pb || i instanceof gb || i instanceof db || i instanceof mb || i instanceof yb || i instanceof bb || i instanceof Na || i instanceof xb || i instanceof vb || i instanceof hb) && r.transform.push(i.assemble()), (i instanceof fs || i instanceof cs || i instanceof Tu || i instanceof fo || i instanceof wc) && r.transform.push(...i.assemble()), i instanceof zn && (r.source && r.transform.length === 0 ? i.setSource(r.source) : i.parent instanceof zn ? i.setSource(r.name) : (r.name || (r.name = `data_${t++}`), i.setSource(r.name), i.numChildren() === 1 && (e.push(r), r = {
+        switch ((i instanceof Bg || i instanceof Ug || i instanceof Bh || i instanceof Df || i instanceof Zc || i instanceof Uh || i instanceof Tr || i instanceof jh || i instanceof Lf || i instanceof Ml || i instanceof pb || i instanceof gb || i instanceof db || i instanceof mb || i instanceof yb || i instanceof bb || i instanceof Na || i instanceof xb || i instanceof vb || i instanceof hb) && r.transform.push(i.assemble()), (i instanceof fs || i instanceof cs || i instanceof Tu || i instanceof fo || i instanceof wc) && r.transform.push(...i.assemble()), i instanceof Bn && (r.source && r.transform.length === 0 ? i.setSource(r.source) : i.parent instanceof Bn ? i.setSource(r.name) : (r.name || (r.name = `data_${t++}`), i.setSource(r.name), i.numChildren() === 1 && (e.push(r), r = {
                 name: null,
                 source: r.name,
                 transform: []
             }))), i.numChildren()) {
             case 0:
-                i instanceof zn && (!r.source || r.transform.length > 0) && e.push(r);
+                i instanceof Bn && (!r.source || r.transform.length > 0) && e.push(r);
                 break;
             case 1:
                 n(i.children[0], r);
                 break;
             default: {
                 r.name || (r.name = `data_${t++}`);
                 let s = r.name;
@@ -49200,19 +49187,19 @@
         for (const a of o.transform ?? [])
             a.type === "lookup" && (a.from = e.outputNodes[a.from].getSource());
     for (const o of n)
         o.name in t && (o.values = t[o.name]);
     return n;
 }
 
-function $ve(e) {
+function Cve(e) {
     return e === "top" || e === "left" || de(e) ? "header" : "footer";
 }
 
-function Cve(e) {
+function $ve(e) {
     for (const t of Hi)
         Mve(e, t);
     W4(e, "x"), W4(e, "y");
 }
 
 function Mve(e, t) {
     var o;
@@ -49225,17 +49212,17 @@
     if (e.channelHasField(t)) {
         const a = n[t],
             u = tf("title", null, i, t);
         let l = vc(a, i, {
             allowDisabling: !0,
             includeDefault: u === void 0 || !!u
         });
-        r.component.layoutHeaders[t].title && (l = W(l) ? l.join(", ") : l, l += ` / ${r.component.layoutHeaders[t].title}`, r.component.layoutHeaders[t].title = null);
+        r.component.layoutHeaders[t].title && (l = V(l) ? l.join(", ") : l, l += ` / ${r.component.layoutHeaders[t].title}`, r.component.layoutHeaders[t].title = null);
         const c = tf("labelOrient", a.header, i, t),
-            f = a.header !== null ? St((o = a.header) == null ? void 0 : o.labels, i.header.labels, !0) : !1,
+            f = a.header !== null ? kt((o = a.header) == null ? void 0 : o.labels, i.header.labels, !0) : !1,
             d = De(["bottom", "right"], c) ? "footer" : "header";
         s.layoutHeaders[t] = {
             title: a.header !== null ? l : null,
             facetFieldDef: a,
             [d]: t === "facet" ? [] : [BB(e, t, f)]
         };
     }
@@ -49259,15 +49246,15 @@
             layoutHeaders: i,
             resolve: r
         } = e.component;
         if (r.axis[t] = M6(r, t), r.axis[t] === "shared") {
             const s = t === "x" ? "column" : "row",
                 o = i[s];
             for (const a of n.component.axes[t]) {
-                const u = $ve(a.get("orient"));
+                const u = Cve(a.get("orient"));
                 o[u] ?? (o[u] = [BB(e, s, !1)]);
                 const l = Id(a, "main", e.config, {
                     header: !0
                 });
                 l && o[u][0].axes.push(l), a.mainExtracted = !0;
             }
         }
@@ -49343,54 +49330,54 @@
 function Ove(e, t) {
     const n = t === "width" ? "x" : "y",
         i = e.config,
         r = e.getScaleComponent(n);
     if (r) {
         const s = r.get("type"),
             o = r.get("range");
-        if (Ht(s)) {
+        if (Gt(s)) {
             const a = Q0(i.view, t);
             return Ga(o) || ws(a) ? "step" : a;
         } else
-            return Cw(i.view, t);
+            return $w(i.view, t);
     } else {
         if (e.hasProjection || e.mark === "arc")
-            return Cw(i.view, t);
+            return $w(i.view, t);
         {
             const s = Q0(i.view, t);
             return ws(s) ? s.step : s;
         }
     }
 }
 
 function jw(e, t, n) {
-    return te(t, {
-        suffix: `by_${te(e)}`,
+    return ne(t, {
+        suffix: `by_${ne(e)}`,
         ...n
     });
 }
 class ih extends PB {
     constructor(t, n, i, r) {
         super(t, "facet", n, i, r, t.resolve), this.child = j6(t.spec, this, this.getName("child"), void 0, r), this.children = [this.child], this.facet = this.initFacet(t.facet);
     }
     initFacet(t) {
         if (!Rg(t))
             return {
                 facet: this.initFacetFieldDef(t, "facet")
             };
-        const n = Y(t),
+        const n = X(t),
             i = {};
         for (const r of n) {
             if (![uo, lo].includes(r)) {
-                K(jy(r, "facet"));
+                J(jy(r, "facet"));
                 break;
             }
             const s = t[r];
             if (s.field === void 0) {
-                K(Ew(s, r));
+                J(Ew(s, r));
                 break;
             }
             i[r] = this.initFacetFieldDef(s, r);
         }
         return i;
     }
     initFacetFieldDef(t, n) {
@@ -49412,29 +49399,29 @@
     parseSelections() {
         this.child.parseSelections(), this.component.selection = this.child.component.selection;
     }
     parseMarkGroup() {
         this.child.parseMarkGroup();
     }
     parseAxesAndHeaders() {
-        this.child.parseAxesAndHeaders(), Cve(this);
+        this.child.parseAxesAndHeaders(), $ve(this);
     }
     assembleSelectionTopLevelSignals(t) {
         return this.child.assembleSelectionTopLevelSignals(t);
     }
     assembleSignals() {
         return this.child.assembleSignals(), [];
     }
     assembleSelectionData(t) {
         return this.child.assembleSelectionData(t);
     }
     getHeaderLayoutMixins() {
         const t = {};
         for (const n of Hi)
-            for (const i of $6) {
+            for (const i of C6) {
                 const r = this.component.layoutHeaders[n],
                     s = r[i],
                     {
                         facetFieldDef: o
                     } = r;
                 if (o) {
                     const a = tf("titleOrient", o.header, this.config, n);
@@ -49480,15 +49467,15 @@
         return this.parent && this.parent instanceof ih ? {
             ...this.channelHasField("column") ? {
                 encode: {
                     update: {
                         // TODO(https://github.com/vega/vega-lite/issues/2759):
                         // Correct the signal for facet of concat of facet_column
                         columns: {
-                            field: te(this.facet.column, {
+                            field: ne(this.facet.column, {
                                 prefix: "distinct"
                             })
                         }
                     }
                 }
             } : {},
             ...super.assembleGroup(t)
@@ -49499,27 +49486,27 @@
      */
     getCardinalityAggregateForChild() {
         const t = [],
             n = [],
             i = [];
         if (this.child instanceof ih) {
             if (this.child.channelHasField("column")) {
-                const r = te(this.child.facet.column);
+                const r = ne(this.child.facet.column);
                 t.push(r), n.push("distinct"), i.push(`distinct_${r}`);
             }
         } else
             for (const r of Rs) {
                 const s = this.child.component.scales[r];
                 if (s && !s.merged) {
                     const o = s.get("type"),
                         a = s.get("range");
-                    if (Ht(o) && Ga(a)) {
+                    if (Gt(o) && Ga(a)) {
                         const u = fb(this.child, r),
                             l = D6(u);
-                        l ? (t.push(l), n.push("distinct"), i.push(`distinct_${l}`)) : K(R5(r));
+                        l ? (t.push(l), n.push("distinct"), i.push(`distinct_${l}`)) : J(R5(r));
                     }
                 }
             }
         return {
             fields: t,
             ops: n,
             as: i
@@ -49536,28 +49523,28 @@
             fields: s,
             ops: o,
             as: a
         } = this.getCardinalityAggregateForChild(), u = [];
         for (const c of Hi) {
             const f = this.facet[c];
             if (f) {
-                u.push(te(f));
+                u.push(ne(f));
                 const {
                     bin: d,
                     sort: h
                 } = f;
-                if (rt(d) && u.push(te(f, {
+                if (st(d) && u.push(ne(f, {
                         binSuffix: "end"
                     })), ls(h)) {
                     const {
                         field: g,
                         op: p = Yy
                     } = h, m = jw(f, h);
                     i && r ? (s.push(m), o.push("max"), a.push(m)) : (s.push(g), o.push(p), a.push(m));
-                } else if (W(h)) {
+                } else if (V(h)) {
                     const g = ef(f, c);
                     s.push(g), o.push("max"), a.push(g);
                 }
             }
         }
         const l = !!i && !!r;
         return {
@@ -49580,29 +49567,29 @@
     }
     facetSortFields(t) {
         const {
             facet: n
         } = this, i = n[t];
         return i ? ls(i.sort) ? [jw(i, i.sort, {
             expr: "datum"
-        })] : W(i.sort) ? [ef(i, t, {
+        })] : V(i.sort) ? [ef(i, t, {
             expr: "datum"
-        })] : [te(i, {
+        })] : [ne(i, {
             expr: "datum"
         })] : [];
     }
     facetSortOrder(t) {
         const {
             facet: n
         } = this, i = n[t];
         if (i) {
             const {
                 sort: r
             } = i;
-            return [(ls(r) ? r.order : !W(r) && r) || "ascending"];
+            return [(ls(r) ? r.order : !V(r) && r) || "ascending"];
         }
         return [];
     }
     assembleLabelTitle() {
         var r;
         const {
             facet: t,
@@ -49675,15 +49662,15 @@
                     joinaggregate: [{
                         op: a,
                         field: o,
                         as: jw(s, s.sort, {
                             forAs: !0
                         })
                     }],
-                    groupby: [te(s)]
+                    groupby: [ne(s)]
                 });
             }
         return r;
     }
     return null;
 }
 
@@ -49737,31 +49724,31 @@
 function Lve(e, t, n) {
     let i = 0;
     for (const r of t.transforms) {
         let s, o;
         if (S1e(r))
             o = e = new Zc(e, r), s = "derived";
         else if (v6(r)) {
-            const a = $be(r);
-            o = e = pn.makeWithAncestors(e, {}, a, n) ?? e, e = new Df(e, t, r.filter);
+            const a = Cbe(r);
+            o = e = mn.makeWithAncestors(e, {}, a, n) ?? e, e = new Df(e, t, r.filter);
         } else if (kz(r))
             o = e = fs.makeFromTransform(e, r, t), s = "number";
         else if (A1e(r))
-            s = "date", n.getWithExplicit(r.field).value === void 0 && (e = new pn(e, {
+            s = "date", n.getWithExplicit(r.field).value === void 0 && (e = new mn(e, {
                 [r.field]: s
             }), n.set(r.field, s, !1)), o = e = cs.makeFromTransform(e, r);
-        else if ($1e(r))
+        else if (C1e(r))
             o = e = Tr.makeFromTransform(e, r), s = "number", k6(t) && (e = new Na(e));
         else if (Sz(r))
             o = e = jh.make(e, t, r, i++), s = "derived";
         else if (w1e(r))
             o = e = new Lf(e, r), s = "number";
         else if (_1e(r))
             o = e = new Ml(e, r), s = "number";
-        else if (C1e(r))
+        else if ($1e(r))
             o = e = fo.makeFromTransform(e, r), s = "derived";
         else if (M1e(r))
             o = e = new pb(e, r), s = "derived";
         else if (T1e(r))
             o = e = new hb(e, r), s = "derived";
         else if (E1e(r))
             o = e = new gb(e, r), s = "derived";
@@ -49776,15 +49763,15 @@
         else if (y1e(r))
             o = e = new yb(e, r), s = "derived";
         else if (b1e(r))
             o = e = new bb(e, r), s = "derived";
         else if (v1e(r))
             o = e = new mb(e, r), s = "derived";
         else {
-            K(Kge(r));
+            J(Kge(r));
             continue;
         }
         if (o && s !== void 0)
             for (const a of o.producedFields() ?? [])
                 n.set(a, s, !1);
     }
     return e;
@@ -49793,35 +49780,35 @@
 function wb(e) {
     var p;
     let t = Rve(e, e.component.data.sources);
     const {
         outputNodes: n,
         outputNodeRefCounts: i
     } = e.component.data, r = e.data, o = !(r && (ua(r) || Jc(r) || zh(r))) && e.parent ? e.parent.component.data.ancestorParse.clone() : new j1e();
-    ua(r) ? (Fz(r) ? t = new Ug(t, r.sequence) : x6(r) && (t = new Bg(t, r.graticule)), o.parseNothing = !0) : ((p = r == null ? void 0 : r.format) == null ? void 0 : p.parse) === null && (o.parseNothing = !0), t = pn.makeExplicit(t, e, o) ?? t, t = new Na(t);
+    ua(r) ? (Fz(r) ? t = new Ug(t, r.sequence) : x6(r) && (t = new Bg(t, r.graticule)), o.parseNothing = !0) : ((p = r == null ? void 0 : r.format) == null ? void 0 : p.parse) === null && (o.parseNothing = !0), t = mn.makeExplicit(t, e, o) ?? t, t = new Na(t);
     const a = e.parent && If(e.parent);
-    (bt(e) || $i(e)) && a && (t = fs.makeFromEncoding(t, e) ?? t), e.transforms.length > 0 && (t = Lve(t, e, o));
+    (vt(e) || Ci(e)) && a && (t = fs.makeFromEncoding(t, e) ?? t), e.transforms.length > 0 && (t = Lve(t, e, o));
     const u = Mbe(e),
-        l = Cbe(e);
-    t = pn.makeWithAncestors(t, {}, {
+        l = $be(e);
+    t = mn.makeWithAncestors(t, {}, {
         ...u,
         ...l
-    }, o) ?? t, bt(e) && (t = wc.parseAll(t, e), t = Uh.parseAll(t, e)), (bt(e) || $i(e)) && (a || (t = fs.makeFromEncoding(t, e) ?? t), t = cs.makeFromEncoding(t, e) ?? t, t = Zc.parseAllForSortIndex(t, e));
+    }, o) ?? t, vt(e) && (t = wc.parseAll(t, e), t = Uh.parseAll(t, e)), (vt(e) || Ci(e)) && (a || (t = fs.makeFromEncoding(t, e) ?? t), t = cs.makeFromEncoding(t, e) ?? t, t = Zc.parseAllForSortIndex(t, e));
     const c = e.getDataName(nt.Raw),
-        f = new zn(t, c, nt.Raw, i);
-    if (n[c] = f, t = f, bt(e)) {
+        f = new Bn(t, c, nt.Raw, i);
+    if (n[c] = f, t = f, vt(e)) {
         const m = Tr.makeFromEncoding(t, e);
         m && (t = m, k6(e) && (t = new Na(t))), t = Tu.makeFromEncoding(t, e) ?? t, t = fo.makeFromEncoding(t, e) ?? t;
     }
-    bt(e) && (t = Bh.make(t, e) ?? t);
+    vt(e) && (t = Bh.make(t, e) ?? t);
     const d = e.getDataName(nt.Main),
-        h = new zn(t, d, nt.Main, i);
-    n[d] = h, t = h, bt(e) && Sye(e, h);
+        h = new Bn(t, d, nt.Main, i);
+    n[d] = h, t = h, vt(e) && Sye(e, h);
     let g = null;
-    if ($i(e)) {
+    if (Ci(e)) {
         const m = e.getName("facet");
         t = Dve(t, e.facet) ?? t, g = new Rf(t, e, m, h.getSource()), n[m] = g;
     }
     return {
         ...e.component.data,
         outputNodes: n,
         outputNodeRefCounts: i,
@@ -49830,26 +49817,26 @@
         facetRoot: g,
         ancestorParse: o
     };
 }
 class Ive extends L6 {
     constructor(t, n, i, r) {
         var s, o, a, u;
-        super(t, "concat", n, i, r, t.resolve), (((o = (s = t.resolve) == null ? void 0 : s.axis) == null ? void 0 : o.x) === "shared" || ((u = (a = t.resolve) == null ? void 0 : a.axis) == null ? void 0 : u.y) === "shared") && K(Vge), this.children = this.getChildren(t).map((l, c) => j6(l, this, this.getName(`concat_${c}`), void 0, r));
+        super(t, "concat", n, i, r, t.resolve), (((o = (s = t.resolve) == null ? void 0 : s.axis) == null ? void 0 : o.x) === "shared" || ((u = (a = t.resolve) == null ? void 0 : a.axis) == null ? void 0 : u.y) === "shared") && J(Vge), this.children = this.getChildren(t).map((l, c) => j6(l, this, this.getName(`concat_${c}`), void 0, r));
     }
     parseData() {
         this.component.data = wb(this);
         for (const t of this.children)
             t.parseData();
     }
     parseSelections() {
         this.component.selection = {};
         for (const t of this.children) {
             t.parseSelections();
-            for (const n of Y(t.component.selection))
+            for (const n of X(t.component.selection))
                 this.component.selection[n] = t.component.selection[n];
         }
     }
     parseMarkGroup() {
         for (const t of this.children)
             t.parseMarkGroup();
     }
@@ -49869,15 +49856,15 @@
     assembleSelectionTopLevelSignals(t) {
         return this.children.reduce((n, i) => i.assembleSelectionTopLevelSignals(n), t);
     }
     assembleSignals() {
         return this.children.forEach((t) => t.assembleSignals()), [];
     }
     assembleLayoutSignals() {
-        const t = C6(this);
+        const t = $6(this);
         for (const n of this.children)
             t.push(...n.assembleLayoutSignals());
         return t;
     }
     assembleSelectionData(t) {
         return this.children.reduce((n, i) => i.assembleSelectionData(n), t);
     }
@@ -49925,15 +49912,15 @@
         disable: 1,
         gridScale: 1,
         scale: 1,
         ...XP,
         labelExpr: 1,
         encode: 1
     },
-    jB = Y(zve);
+    jB = X(zve);
 class P6 extends To {
     constructor(t = {}, n = {}, i = !1) {
         super(), this.explicit = t, this.implicit = n, this.mainExtracted = i;
     }
     clone() {
         return new P6(ke(this.explicit), ke(this.implicit), this.mainExtracted);
     }
@@ -49945,57 +49932,57 @@
     }
 }
 
 function Bve(e, t, n) {
     const {
         encoding: i,
         config: r
-    } = e, s = Ft(i[t]) ?? Ft(i[Ds(t)]), o = e.axis(t) || {}, {
+    } = e, s = Nt(i[t]) ?? Nt(i[Ds(t)]), o = e.axis(t) || {}, {
         format: a,
         formatType: u
     } = o;
     if (il(u))
         return {
-            text: $r({
+            text: Cr({
                 fieldOrDatumDef: s,
                 field: "datum.value",
                 format: a,
                 formatType: u,
                 config: r
             }),
             ...n
         };
     if (a === void 0 && u === void 0 && r.customFormatTypes) {
         if (Yc(s) === "quantitative") {
             if (Xc(s) && s.stack === "normalize" && r.normalizedNumberFormatType)
                 return {
-                    text: $r({
+                    text: Cr({
                         fieldOrDatumDef: s,
                         field: "datum.value",
                         format: r.normalizedNumberFormat,
                         formatType: r.normalizedNumberFormatType,
                         config: r
                     }),
                     ...n
                 };
             if (r.numberFormatType)
                 return {
-                    text: $r({
+                    text: Cr({
                         fieldOrDatumDef: s,
                         field: "datum.value",
                         format: r.numberFormat,
                         formatType: r.numberFormatType,
                         config: r
                     }),
                     ...n
                 };
         }
-        if (Yc(s) === "temporal" && r.timeFormatType && J(s) && !s.timeUnit)
+        if (Yc(s) === "temporal" && r.timeFormatType && Q(s) && !s.timeUnit)
             return {
-                text: $r({
+                text: Cr({
                     fieldOrDatumDef: s,
                     field: "datum.value",
                     format: r.timeFormat,
                     formatType: r.timeFormatType,
                     config: r
                 }),
                 ...n
@@ -50022,15 +50009,15 @@
         top: 0,
         bottom: 0,
         right: 0,
         left: 0
     };
     for (const r of e.children) {
         r.parseAxesAndHeaders();
-        for (const s of Y(r.component.axes))
+        for (const s of X(r.component.axes))
             n.axis[s] = M6(e.component.resolve, s), n.axis[s] === "shared" && (t[s] = Wve(t[s], r.component.axes[s]), t[s] || (n.axis[s] = "independent", delete t[s]));
     }
     for (const r of Rs) {
         for (const s of e.children)
             if (s.component.axes[r]) {
                 if (n.axis[r] === "independent") {
                     t[r] = (t[r] ?? []).concat(s.component.axes[r]);
@@ -50091,15 +50078,15 @@
                 switch (n) {
                     case "title":
                         return eP(r, s);
                     case "gridScale":
                         return {
                             explicit: r.explicit,
                                 // keep the old explicit
-                                value: St(r.value, s.value)
+                                value: kt(r.value, s.value)
                         };
                 }
                 return rb(r, s, n, "axis");
             }
         );
         e.setWithExplicit(n, i);
     }
@@ -50138,22 +50125,22 @@
     "tickMinStep"
 ]);
 
 function Yve(e, t) {
     var y, b;
     let n = t.axis(e);
     const i = new P6(),
-        r = Ft(t.encoding[e]),
+        r = Nt(t.encoding[e]),
         {
             mark: s,
             config: o
         } = t,
         a = (n == null ? void 0 : n.orient) || ((y = o[e === "x" ? "axisX" : "axisY"]) == null ? void 0 : y.orient) || ((b = o.axis) == null ? void 0 : b.orient) || Dye(e),
         u = t.getScaleComponent(e).get("type"),
-        l = $ye(e, u, a, t.config),
+        l = Cye(e, u, a, t.config),
         c = n !== void 0 ? !n : Dw("disable", o.style, n == null ? void 0 : n.style, l).configValue;
     if (i.set("disable", c, n !== void 0), c)
         return i;
     n = n || {};
     const f = Fye(r, n, e, o.style, l),
         d = DP(n.formatType, r, u),
         h = OP(r, r.type, n.format, n.formatType, o, !0),
@@ -50169,69 +50156,69 @@
             formatType: d,
             mark: s,
             config: o
         };
     for (const v of jB) {
         const x = v in M4 ? M4[v](g) : n4(v) ? n[v] : void 0,
             w = x !== void 0,
-            S = Gve(x, v, n, t, e);
-        if (w && S)
-            i.set(v, x, S);
+            E = Gve(x, v, n, t, e);
+        if (w && E)
+            i.set(v, x, E);
         else {
             const {
                 configValue: _ = void 0,
                 configFrom: k = void 0
             } = n4(v) && v !== "values" ? Dw(v, o.style, n.style, l) : {}, A = _ !== void 0;
-            w && !A ? i.set(v, x, S) : (
+            w && !A ? i.set(v, x, E) : (
                 // Cases need implicit values
                 // 1. Axis config that aren't available in Vega
                 (k !== "vgAxisConfig" || // 2. Certain properties are always included (see `propsToAlwaysIncludeConfig`'s declaration for more details)
                     Vve.has(v) && A || // 3. Conditional axis values and signals
                     Pg(_) || de(_)) && i.set(v, _, !1)
             );
         }
     }
     const p = n.encoding ?? {},
         m = YP.reduce((v, x) => {
             if (!i.hasAxisPart(x))
                 return v;
             const w = dB(p[x] ?? {}, t),
-                S = x === "labels" ? Bve(t, e, w) : w;
-            return S !== void 0 && !Je(S) && (v[x] = {
-                update: S
+                E = x === "labels" ? Bve(t, e, w) : w;
+            return E !== void 0 && !Je(E) && (v[x] = {
+                update: E
             }), v;
         }, {});
     return Je(m) || i.set("encode", m, !!n.encoding || n.labelAngle !== void 0), i;
 }
 
 function Xve({
     encoding: e,
     size: t
 }) {
     for (const n of Rs) {
         const i = di(n);
-        ws(t[i]) && Zo(e[n]) && (delete t[i], K(sP(i)));
+        ws(t[i]) && Zo(e[n]) && (delete t[i], J(sP(i)));
     }
     return t;
 }
 const Kve = {
         vgMark: "arc",
         encodeEntry: (e) => ({
             ...cr(e, {
                 align: "ignore",
                 baseline: "ignore",
                 color: "include",
                 size: "ignore",
                 orient: "ignore",
                 theta: "ignore"
             }),
-            ...gn("x", e, {
+            ...pn("x", e, {
                 defaultPos: "mid"
             }),
-            ...gn("y", e, {
+            ...pn("y", e, {
                 defaultPos: "mid"
             }),
             // arcs are rectangles in polar coordinates
             ...Ta(e, "radius"),
             ...Ta(e, "theta")
         })
     },
@@ -50290,16 +50277,16 @@
             const {
                 encoding: t
             } = e, n = t.shape;
             return [{
                 type: "geoshape",
                 projection: e.projectionName(),
                 // as: 'shape',
-                ...n && J(n) && n.type === Nf ? {
-                    field: te(n, {
+                ...n && Q(n) && n.type === Nf ? {
+                    field: ne(n, {
                         expr: "datum"
                     })
                 } : {}
             }];
         }
     },
     e2e = {
@@ -50325,21 +50312,21 @@
                 align: "ignore",
                 baseline: "ignore",
                 color: "include",
                 size: "ignore",
                 orient: "ignore",
                 theta: "ignore"
             }),
-            ...gn("x", e, {
+            ...pn("x", e, {
                 defaultPos: "mid"
             }),
-            ...gn("y", e, {
+            ...pn("y", e, {
                 defaultPos: "mid"
             }),
-            ...Pt("size", e, {
+            ...zt("size", e, {
                 vgChannel: "strokeWidth"
                 // VL's line size is strokeWidth
             }),
             ...S6(e)
         })
     },
     n2e = {
@@ -50349,21 +50336,21 @@
                 align: "ignore",
                 baseline: "ignore",
                 color: "include",
                 size: "include",
                 orient: "ignore",
                 theta: "ignore"
             }),
-            ...gn("x", e, {
+            ...pn("x", e, {
                 defaultPos: "mid"
             }),
-            ...gn("y", e, {
+            ...pn("y", e, {
                 defaultPos: "mid"
             }),
-            ...Pt("size", e),
+            ...zt("size", e),
             ...S6(e)
         })
     };
 
 function z6(e, t) {
     const {
         config: n
@@ -50373,32 +50360,32 @@
             align: "ignore",
             baseline: "ignore",
             color: "include",
             size: "include",
             orient: "ignore",
             theta: "ignore"
         }),
-        ...gn("x", e, {
+        ...pn("x", e, {
             defaultPos: "mid"
         }),
-        ...gn("y", e, {
+        ...pn("y", e, {
             defaultPos: "mid"
         }),
-        ...Pt("size", e),
-        ...Pt("angle", e),
+        ...zt("size", e),
+        ...zt("angle", e),
         ...i2e(e, n, t)
     };
 }
 
 function i2e(e, t, n) {
     return n ? {
         shape: {
             value: n
         }
-    } : Pt("shape", e);
+    } : zt("shape", e);
 }
 const r2e = {
         vgMark: "symbol",
         encodeEntry: (e) => z6(e)
     },
     s2e = {
         vgMark: "symbol",
@@ -50446,15 +50433,15 @@
                 }),
                 ...Z0("y", e, {
                     defaultPos: n === "vertical" ? "zeroOrMax" : "mid",
                     defaultPos2: "zeroOrMin",
                     range: n !== "horizontal"
                     // include y2 for vertical or line segment rule
                 }),
-                ...Pt("size", e, {
+                ...zt("size", e, {
                     vgChannel: "strokeWidth"
                     // VL's rule size is strokeWidth
                 })
             };
         }
     },
     l2e = {
@@ -50469,32 +50456,32 @@
                     align: "include",
                     baseline: "include",
                     color: "include",
                     size: "ignore",
                     orient: "ignore",
                     theta: "include"
                 }),
-                ...gn("x", e, {
+                ...pn("x", e, {
                     defaultPos: "mid"
                 }),
-                ...gn("y", e, {
+                ...pn("y", e, {
                     defaultPos: "mid"
                 }),
                 ..._6(e),
-                ...Pt("size", e, {
+                ...zt("size", e, {
                     vgChannel: "fontSize"
                     // VL's text size is fontSize
                 }),
-                ...Pt("angle", e),
+                ...zt("angle", e),
                 ...k4("align", c2e(e.markDef, n, t)),
                 ...k4("baseline", f2e(e.markDef, n, t)),
-                ...gn("radius", e, {
+                ...pn("radius", e, {
                     defaultPos: null
                 }),
-                ...gn("theta", e, {
+                ...pn("theta", e, {
                     defaultPos: null
                 })
             };
         }
     };
 
 function c2e(e, t, n) {
@@ -50518,28 +50505,28 @@
                 align: "ignore",
                 baseline: "ignore",
                 color: "include",
                 orient: "ignore",
                 size: "ignore",
                 theta: "ignore"
             }),
-            ...gn("x", e, {
+            ...pn("x", e, {
                 defaultPos: "mid",
                 vgChannel: "xc"
             }),
-            ...gn("y", e, {
+            ...pn("y", e, {
                 defaultPos: "mid",
                 vgChannel: "yc"
             }),
             // size / thickness => width / height
-            ...Pt("size", e, {
+            ...zt("size", e, {
                 defaultValue: h2e(e),
                 vgChannel: r
             }),
-            [s]: at(He("thickness", n, t))
+            [s]: ut(He("thickness", n, t))
         };
     }
 };
 
 function h2e(e) {
     const {
         config: t,
@@ -50709,24 +50696,24 @@
             field: {
                 group: "width"
             }
         }
     });
     for (const c of _w) {
         const f = vo(c, e.markDef, e.config);
-        t.encode.update[c] ? (s[c] = t.encode.update[c], delete t.encode.update[c]) : f && (s[c] = at(f)), f && (t.encode.update[c] = {
+        t.encode.update[c] ? (s[c] = t.encode.update[c], delete t.encode.update[c]) : f && (s[c] = ut(f)), f && (t.encode.update[c] = {
             value: 0
         });
     }
     const a = [];
     if (((l = e.stack.groupbyChannels) == null ? void 0 : l.length) > 0)
         for (const c of e.stack.groupbyChannels) {
             const f = e.fieldDef(c),
-                d = te(f);
-            d && a.push(d), (f != null && f.bin || f != null && f.timeUnit) && a.push(te(f, {
+                d = ne(f);
+            d && a.push(d), (f != null && f.bin || f != null && f.timeUnit) && a.push(ne(f, {
                 binSuffix: "end"
             }));
         }
     return s = [
         "stroke",
         "strokeWidth",
         "strokeJoin",
@@ -50741,15 +50728,15 @@
                 ...c,
                 [f]: t.encode.update[f]
             };
         {
             const d = vo(f, e.markDef, e.config);
             return d !== void 0 ? {
                 ...c,
-                [f]: at(d)
+                [f]: ut(d)
             } : c;
         }
     }, s), s.stroke && (s.strokeForeground = {
         value: !0
     }, s.strokeOffset = {
         value: 0
     }), [{
@@ -50796,54 +50783,54 @@
     const {
         encoding: t,
         stack: n,
         mark: i,
         markDef: r,
         config: s
     } = e, o = t.order;
-    if (!(!W(o) && Dr(o) && xw(o.value) || !o && xw(He("order", r, s)))) {
-        if ((W(o) || J(o)) && !n)
+    if (!(!V(o) && Dr(o) && xw(o.value) || !o && xw(He("order", r, s)))) {
+        if ((V(o) || Q(o)) && !n)
             return JI(o, {
                 expr: "datum"
             });
         if (Va(i)) {
             const u = r.orient === "horizontal" ? "y" : "x",
                 l = t[u];
-            if (J(l)) {
+            if (Q(l)) {
                 const c = l.sort;
-                if (W(c))
+                if (V(c))
                     return {
-                        field: te(l, {
+                        field: ne(l, {
                             prefix: u,
                             suffix: "sort_index",
                             expr: "datum"
                         })
                     };
                 if (ls(c))
                     return {
-                        field: te({
+                        field: ne({
                             // FIXME: this op might not already exist?
                             // FIXME: what if dimensionChannel (x or y) contains custom domain?
                             aggregate: a6(e.encoding) ? c.op : void 0,
                             field: c.field
                         }, {
                             expr: "datum"
                         })
                     };
                 if (LP(c)) {
                     const f = e.fieldDef(c.encoding);
                     return {
-                        field: te(f, {
+                        field: ne(f, {
                             expr: "datum"
                         }),
                         order: c.order
                     };
                 } else
                     return c === null ? void 0 : {
-                        field: te(l, {
+                        field: ne(l, {
                             // For stack with imputation, we only have bin_mid
                             binSuffix: (a = e.stack) != null && a.impute ? "mid" : void 0,
                             expr: "datum"
                         })
                     };
             }
             return;
@@ -50855,15 +50842,15 @@
     fromPrefix: ""
 }) {
     const {
         mark: n,
         markDef: i,
         encoding: r,
         config: s
-    } = e, o = St(i.clip, b2e(e), v2e(e)), a = XI(i), u = r.key, l = y2e(e), c = x2e(e), f = He("aria", i, s), d = Fp[n].postEncodingTransform ? Fp[n].postEncodingTransform(e) : null;
+    } = e, o = kt(i.clip, b2e(e), v2e(e)), a = XI(i), u = r.key, l = y2e(e), c = x2e(e), f = He("aria", i, s), d = Fp[n].postEncodingTransform ? Fp[n].postEncodingTransform(e) : null;
     return [{
         name: e.getName("marks"),
         type: Fp[n].vgMark,
         ...o ? {
             clip: o
         } : {},
         ...a ? {
@@ -50901,19 +50888,19 @@
     const t = e.component.projection;
     return t && !t.isFit ? !0 : void 0;
 }
 
 function x2e(e) {
     if (!e.component.selection)
         return null;
-    const t = Y(e.component.selection).length;
+    const t = X(e.component.selection).length;
     let n = t,
         i = e.parent;
     for (; i && n === 0;)
-        n = Y(i.component.selection).length, i = i.parent;
+        n = X(i.component.selection).length, i = i.parent;
     return n ? {
         interactive: t > 0 || e.mark === "geoshape" || !!e.encoding.tooltip || !!e.markDef.tooltip
     } : null;
 }
 class qB extends PB {
     constructor(t, n, i, r = {}, s) {
         super(t, "unit", n, i, s, void 0, r4(t) ? t.view : void 0), this.specifiedScales = {}, this.specifiedAxes = {}, this.specifiedLegends = {}, this.specifiedProjection = {}, this.selection = [], this.children = [];
@@ -50939,15 +50926,15 @@
                 } : {}
             } : r
         }), this.stack = xz(this.markDef, u), this.specifiedScales = this.initScales(a, u), this.specifiedAxes = this.initAxes(u), this.specifiedLegends = this.initLegends(u), this.specifiedProjection = t.projection, this.selection = (t.params ?? []).filter((l) => p6(l));
     }
     get hasProjection() {
         const {
             encoding: t
-        } = this, n = this.mark === CP, i = t && oge.some((r) => Ae(t[r]));
+        } = this, n = this.mark === $P, i = t && oge.some((r) => Ae(t[r]));
         return n || i;
     }
     /**
      * Return specified Vega-Lite scale domain for a particular channel
      * @param channel
      */
     scaleDomain(t) {
@@ -50958,49 +50945,49 @@
         return this.specifiedAxes[t];
     }
     legend(t) {
         return this.specifiedLegends[t];
     }
     initScales(t, n) {
         return By.reduce((i, r) => {
-            const s = Ft(n[r]);
+            const s = Nt(n[r]);
             return s && (i[r] = this.initScale(s.scale ?? {})), i;
         }, {});
     }
     initScale(t) {
         const {
             domain: n,
             range: i
         } = t, r = Zn(t);
-        return W(n) && (r.domain = n.map(bi)), W(i) && (r.range = i.map(bi)), r;
+        return V(n) && (r.domain = n.map(bi)), V(i) && (r.range = i.map(bi)), r;
     }
     initAxes(t) {
         return Rs.reduce((n, i) => {
             const r = t[i];
-            if (Ae(r) || i === ht && Ae(t.x2) || i === Yt && Ae(t.y2)) {
+            if (Ae(r) || i === ht && Ae(t.x2) || i === Xt && Ae(t.y2)) {
                 const s = Ae(r) ? r.axis : void 0;
                 n[i] = s && this.initAxis({
                     ...s
                 });
             }
             return n;
         }, {});
     }
     initAxis(t) {
-        const n = Y(t),
+        const n = X(t),
             i = {};
         for (const r of n) {
             const s = t[r];
             i[r] = Pg(s) ? YI(s) : bi(s);
         }
         return i;
     }
     initLegends(t) {
         return mge.reduce((n, i) => {
-            const r = Ft(t[i]);
+            const r = Nt(t[i]);
             if (r && bge(i)) {
                 const s = r.legend;
                 n[i] = s && Zn(s);
             }
             return n;
         }, {});
     }
@@ -51028,15 +51015,15 @@
     assembleSelectionData(t) {
         return G1e(this, t);
     }
     assembleLayout() {
         return null;
     }
     assembleLayoutSignals() {
-        return C6(this);
+        return $6(this);
     }
     assembleMarks() {
         let t = this.component.mark ?? [];
         return (!this.parent || !If(this.parent)) && (t = Dz(this, t)), t.map(this.correctDataNames);
     }
     assembleGroupStyle() {
         const {
@@ -51047,23 +51034,23 @@
     getMapping() {
         return this.encoding;
     }
     get mark() {
         return this.markDef.type;
     }
     channelHasField(t) {
-        return Cu(this.encoding, t);
+        return $u(this.encoding, t);
     }
     fieldDef(t) {
         const n = this.encoding[t];
         return xs(n);
     }
     typedFieldDef(t) {
         const n = this.fieldDef(t);
-        return Wn(n) ? n : null;
+        return Hn(n) ? n : null;
     }
 }
 class U6 extends L6 {
     constructor(t, n, i, r, s) {
         super(t, "layer", n, i, s, t.resolve, t.view);
         const o = {
             ...r,
@@ -51090,15 +51077,15 @@
     parseLayoutSize() {
         Tve(this);
     }
     parseSelections() {
         this.component.selection = {};
         for (const t of this.children) {
             t.parseSelections();
-            for (const n of Y(t.component.selection))
+            for (const n of X(t.component.selection))
                 this.component.selection[n] = t.component.selection[n];
         }
     }
     parseMarkGroup() {
         for (const t of this.children)
             t.parseMarkGroup();
     }
@@ -51109,23 +51096,23 @@
         return this.children.reduce((n, i) => i.assembleSelectionTopLevelSignals(n), t);
     }
     // TODO: Support same named selections across children.
     assembleSignals() {
         return this.children.reduce((t, n) => t.concat(n.assembleSignals()), iB(this));
     }
     assembleLayoutSignals() {
-        return this.children.reduce((t, n) => t.concat(n.assembleLayoutSignals()), C6(this));
+        return this.children.reduce((t, n) => t.concat(n.assembleLayoutSignals()), $6(this));
     }
     assembleSelectionData(t) {
         return this.children.reduce((n, i) => i.assembleSelectionData(n), t);
     }
     assembleGroupStyle() {
         const t = /* @__PURE__ */ new Set();
         for (const i of this.children)
-            for (const r of ne(i.assembleGroupStyle()))
+            for (const r of re(i.assembleGroupStyle()))
                 t.add(r);
         const n = Array.from(t);
         return n.length > 1 ? n : n.length === 1 ? n[0] : void 0;
     }
     assembleTitle() {
         let t = super.assembleTitle();
         if (t)
@@ -51157,15 +51144,15 @@
     throw new Error(D5(e));
 }
 
 function w2e(e, t = {}) {
     t.logger && Ipe(t.logger), t.fieldTitle && HP(t.fieldTitle);
     try {
         const n = vz(ff(t.config, e.config)),
-            i = Cz(e, n),
+            i = $z(e, n),
             r = j6(i, null, "", void 0, n);
         return r.parse(), Hbe(r.component.data, r), {
             spec: E2e(r, _2e(e, i.autosize, n, r), e.datasets, e.usermeta),
             normalized: i
         };
     } finally {
         t.logger && Ppe(), t.fieldTitle && Zme();
@@ -51173,28 +51160,28 @@
 }
 
 function _2e(e, t, n, i) {
     const r = i.component.layoutSize.get("width"),
         s = i.component.layoutSize.get("height");
     if (t === void 0 ? (t = {
             type: "pad"
-        }, i.hasAxisOrientSignalRef() && (t.resize = !0)) : ie(t) && (t = {
+        }, i.hasAxisOrientSignalRef() && (t.resize = !0)) : se(t) && (t = {
             type: t
         }), r && s && z1e(t.type)) {
         if (r === "step" && s === "step")
-            K(j8()), t.type = "pad";
+            J(j8()), t.type = "pad";
         else if (r === "step" || s === "step") {
             const o = r === "step" ? "width" : "height";
-            K(j8(zy(o)));
+            J(j8(zy(o)));
             const a = o === "width" ? "height" : "width";
             t.type = B1e(a);
         }
     }
     return {
-        ...Y(t).length === 1 && t.type ? t.type === "pad" ? {} : {
+        ...X(t).length === 1 && t.type ? t.type === "pad" ? {} : {
             autosize: t.type
         } : {
             autosize: t
         },
         ...m4(n, !1),
         ...m4(e, !0)
     };
@@ -51260,61 +51247,61 @@
         contains: De,
         deepEqual: wi,
         deleteNestedProperty: U0,
         duplicate: ke,
         entries: Aa,
         every: w5,
         fieldIntersection: E5,
-        flatAccessWithDatum: CI,
-        getFirstDefined: St,
+        flatAccessWithDatum: $I,
+        getFirstDefined: kt,
         hasIntersection: _5,
         hash: Oe,
         internalField: FI,
         isBoolean: Lh,
         isEmpty: Je,
         isEqual: nge,
         isInternalField: NI,
         isNullOrFalse: xw,
         isNumeric: Oy,
-        keys: Y,
+        keys: X,
         logicalExpr: th,
         mergeDeep: AI,
         never: kI,
-        normalize: Cz,
+        normalize: $z,
         normalizeAngle: Ih,
         omit: ii,
         pick: jc,
         prefixGenerator: ww,
         removePathFromField: k5,
         replaceAll: Qu,
         replacePathInField: sr,
         resetIdCounter: rge,
-        setEqual: $I,
+        setEqual: CI,
         some: Ju,
         stringify: Qe,
-        titleCase: Cg,
+        titleCase: $g,
         unique: rs,
         uniqueId: TI,
-        vals: nn,
+        vals: rn,
         varName: ft,
         version: S2e
     }, Symbol.toStringTag, {
         value: "Module"
     }));
 
 function WB(e) {
     const [t, n] = /schema\/([\w-]+)\/([\w\.\-]+)\.json$/g.exec(e).slice(1, 3);
     return {
         library: t,
         version: n
     };
 }
 var A2e = "vega-themes",
-    $2e = "2.14.0",
-    C2e = "Themes for stylized Vega and Vega-Lite visualizations.",
+    C2e = "2.14.0",
+    $2e = "Themes for stylized Vega and Vega-Lite visualizations.",
     M2e = ["vega", "vega-lite", "themes", "style"],
     T2e = "BSD-3-Clause",
     F2e = {
         name: "UW Interactive Data Lab",
         url: "https://idl.cs.washington.edu"
     },
     N2e = [{
@@ -51387,16 +51374,16 @@
     j2e = {
         vega: "*",
         "vega-lite": "*"
     },
     q2e = {},
     W2e = {
         name: A2e,
-        version: $2e,
-        description: C2e,
+        version: C2e,
+        description: $2e,
         keywords: M2e,
         license: T2e,
         author: F2e,
         contributors: N2e,
         main: O2e,
         module: D2e,
         unpkg: R2e,
@@ -52245,51 +52232,51 @@
         urbaninstitute: axe,
         version: kxe,
         vox: nxe
     }, Symbol.toStringTag, {
         value: "Module"
     }));
 
-function $xe(e, t, n, i) {
-    if (W(e))
-        return `[${e.map((r) => t(ie(r) ? r : c7(r, n))).join(", ")}]`;
-    if (re(e)) {
+function Cxe(e, t, n, i) {
+    if (V(e))
+        return `[${e.map((r) => t(se(r) ? r : c7(r, n))).join(", ")}]`;
+    if (oe(e)) {
         let r = "";
         const {
             title: s,
             image: o,
             ...a
         } = e;
         s && (r += `<h2>${t(s)}</h2>`), o && (r += `<img src="${new URL(t(o), i || location.href).href}">`);
         const u = Object.keys(a);
         if (u.length > 0) {
             r += "<table>";
             for (const l of u) {
                 let c = a[l];
-                c !== void 0 && (re(c) && (c = c7(c, n)), r += `<tr><td class="key">${t(l)}</td><td class="value">${t(c)}</td></tr>`);
+                c !== void 0 && (oe(c) && (c = c7(c, n)), r += `<tr><td class="key">${t(l)}</td><td class="value">${t(c)}</td></tr>`);
             }
             r += "</table>";
         }
         return r || "{}";
     }
     return t(e);
 }
 
-function Cxe(e) {
+function $xe(e) {
     const t = [];
     return function(n, i) {
         if (typeof i != "object" || i === null)
             return i;
         const r = t.indexOf(this) + 1;
         return t.length = r, t.length > e ? "[Object]" : t.indexOf(i) >= 0 ? "[Circular]" : (t.push(i), i);
     };
 }
 
 function c7(e, t) {
-    return JSON.stringify(e, Cxe(t));
+    return JSON.stringify(e, $xe(t));
 }
 var Mxe = `#vg-tooltip-element {
   visibility: hidden;
   padding: 8px;
   position: fixed;
   z-index: 1000;
   font-family: sans-serif;
@@ -52383,15 +52370,15 @@
         /**
          * A function to customize the rendered HTML of the tooltip.
          * @param value A value string, or object of value strings keyed by field
          * @param sanitize The `sanitize` function from `options.sanitize`
          * @param baseURL The `baseURL` from `options.baseURL`
          * @returns {string} The returned string will become the `innerHTML` of the tooltip element
          */
-        formatTooltip: $xe,
+        formatTooltip: Cxe,
         /**
          * The baseurl to use in image paths.
          */
         baseURL: ""
     };
 
 function Fxe(e) {
@@ -52665,15 +52652,15 @@
     mu = Symbol("max"),
     Zs = Symbol("length"),
     Xl = Symbol("lengthCalculator"),
     rh = Symbol("allowStale"),
     wu = Symbol("maxAge"),
     Ks = Symbol("dispose"),
     d7 = Symbol("noDisposeOnSet"),
-    Lt = Symbol("lruList"),
+    It = Symbol("lruList"),
     mr = Symbol("cache"),
     YB = Symbol("updateAgeOnGet"),
     a2 = () => 1;
 class jxe {
     constructor(t) {
         if (typeof t == "number" && (t = {
                 max: t
@@ -52706,88 +52693,88 @@
         this[wu] = t, hd(this);
     }
     get maxAge() {
         return this[wu];
     }
     // resize the cache when the lengthCalculator changes.
     set lengthCalculator(t) {
-        typeof t != "function" && (t = a2), t !== this[Xl] && (this[Xl] = t, this[Zs] = 0, this[Lt].forEach((n) => {
+        typeof t != "function" && (t = a2), t !== this[Xl] && (this[Xl] = t, this[Zs] = 0, this[It].forEach((n) => {
             n.length = this[Xl](n.value, n.key), this[Zs] += n.length;
         })), hd(this);
     }
     get lengthCalculator() {
         return this[Xl];
     }
     get length() {
         return this[Zs];
     }
     get itemCount() {
-        return this[Lt].length;
+        return this[It].length;
     }
     rforEach(t, n) {
         n = n || this;
-        for (let i = this[Lt].tail; i !== null;) {
+        for (let i = this[It].tail; i !== null;) {
             const r = i.prev;
             h7(this, t, i, n), i = r;
         }
     }
     forEach(t, n) {
         n = n || this;
-        for (let i = this[Lt].head; i !== null;) {
+        for (let i = this[It].head; i !== null;) {
             const r = i.next;
             h7(this, t, i, n), i = r;
         }
     }
     keys() {
-        return this[Lt].toArray().map((t) => t.key);
+        return this[It].toArray().map((t) => t.key);
     }
     values() {
-        return this[Lt].toArray().map((t) => t.value);
+        return this[It].toArray().map((t) => t.value);
     }
     reset() {
-        this[Ks] && this[Lt] && this[Lt].length && this[Lt].forEach((t) => this[Ks](t.key, t.value)), this[mr] = /* @__PURE__ */ new Map(), this[Lt] = new Uxe(), this[Zs] = 0;
+        this[Ks] && this[It] && this[It].length && this[It].forEach((t) => this[Ks](t.key, t.value)), this[mr] = /* @__PURE__ */ new Map(), this[It] = new Uxe(), this[Zs] = 0;
     }
     dump() {
-        return this[Lt].map((t) => i1(this, t) ? !1 : {
+        return this[It].map((t) => i1(this, t) ? !1 : {
             k: t.key,
             v: t.value,
             e: t.now + (t.maxAge || 0)
         }).toArray().filter((t) => t);
     }
     dumpLru() {
-        return this[Lt];
+        return this[It];
     }
     set(t, n, i) {
         if (i = i || this[wu], i && typeof i != "number")
             throw new TypeError("maxAge must be a number");
         const r = i ? Date.now() : 0,
             s = this[Xl](n, t);
         if (this[mr].has(t)) {
             if (s > this[mu])
                 return _c(this, this[mr].get(t)), !1;
             const u = this[mr].get(t).value;
             return this[Ks] && (this[d7] || this[Ks](t, u.value)), u.now = r, u.maxAge = i, u.value = n, this[Zs] += s - u.length, u.length = s, this.get(t), hd(this), !0;
         }
         const o = new qxe(t, n, s, r, i);
-        return o.length > this[mu] ? (this[Ks] && this[Ks](t, n), !1) : (this[Zs] += o.length, this[Lt].unshift(o), this[mr].set(t, this[Lt].head), hd(this), !0);
+        return o.length > this[mu] ? (this[Ks] && this[Ks](t, n), !1) : (this[Zs] += o.length, this[It].unshift(o), this[mr].set(t, this[It].head), hd(this), !0);
     }
     has(t) {
         if (!this[mr].has(t))
             return !1;
         const n = this[mr].get(t).value;
         return !i1(this, n);
     }
     get(t) {
         return u2(this, t, !0);
     }
     peek(t) {
         return u2(this, t, !1);
     }
     pop() {
-        const t = this[Lt].tail;
+        const t = this[It].tail;
         return t ? (_c(this, t), t.value) : null;
     }
     del(t) {
         _c(this, this[mr].get(t));
     }
     load(t) {
         this.reset();
@@ -52811,35 +52798,35 @@
         const i = e[mr].get(t);
         if (i) {
             const r = i.value;
             if (i1(e, r)) {
                 if (_c(e, i), !e[rh])
                     return;
             } else
-                n && (e[YB] && (i.value.now = Date.now()), e[Lt].unshiftNode(i));
+                n && (e[YB] && (i.value.now = Date.now()), e[It].unshiftNode(i));
             return r.value;
         }
     },
     i1 = (e, t) => {
         if (!t || !t.maxAge && !e[wu])
             return !1;
         const n = Date.now() - t.now;
         return t.maxAge ? n > t.maxAge : e[wu] && n > e[wu];
     },
     hd = (e) => {
         if (e[Zs] > e[mu])
-            for (let t = e[Lt].tail; e[Zs] > e[mu] && t !== null;) {
+            for (let t = e[It].tail; e[Zs] > e[mu] && t !== null;) {
                 const n = t.prev;
                 _c(e, t), t = n;
             }
     },
     _c = (e, t) => {
         if (t) {
             const n = t.value;
-            e[Ks] && e[Ks](n.key, n.value), e[Zs] -= n.length, e[mr].delete(n.key), e[Lt].removeNode(t);
+            e[Ks] && e[Ks](n.key, n.value), e[Zs] -= n.length, e[mr].delete(n.key), e[It].removeNode(t);
         }
     };
 class qxe {
     constructor(t, n, i, r, s) {
         this.key = t, this.value = n, this.length = i, this.now = r, this.maxAge = s || 0;
     }
 }
@@ -53091,16 +53078,16 @@
 const xwe = Pf,
     wwe = (e, t, n) => xwe(e, t, n) <= 0;
 var _we = wwe;
 const Ewe = awe,
     Swe = cwe,
     kwe = hwe,
     Awe = mwe,
-    $we = vwe,
-    Cwe = _we,
+    Cwe = vwe,
+    $we = _we,
     Mwe = (e, t, n, i) => {
         switch (t) {
             case "===":
                 return typeof e == "object" && (e = e.version), typeof n == "object" && (n = n.version), e === n;
             case "!==":
                 return typeof e == "object" && (e = e.version), typeof n == "object" && (n = n.version), e !== n;
             case "":
@@ -53110,17 +53097,17 @@
             case "!=":
                 return Swe(e, n, i);
             case ">":
                 return kwe(e, n, i);
             case ">=":
                 return Awe(e, n, i);
             case "<":
-                return $we(e, n, i);
-            case "<=":
                 return Cwe(e, n, i);
+            case "<=":
+                return $we(e, n, i);
             default:
                 throw new TypeError(`Invalid operator: ${t}`);
         }
     };
 var Twe = Mwe,
     l2, v7;
 
@@ -53183,81 +53170,81 @@
 var c2, x7;
 
 function JB() {
     if (x7)
         return c2;
     x7 = 1;
     class e {
-        constructor(D, M) {
-            if (M = i(M), D instanceof e)
-                return D.loose === !!M.loose && D.includePrerelease === !!M.includePrerelease ? D : new e(D.raw, M);
-            if (D instanceof r)
-                return this.raw = D.value, this.set = [
-                    [D]
+        constructor(O, N) {
+            if (N = i(N), O instanceof e)
+                return O.loose === !!N.loose && O.includePrerelease === !!N.includePrerelease ? O : new e(O.raw, N);
+            if (O instanceof r)
+                return this.raw = O.value, this.set = [
+                    [O]
                 ], this.format(), this;
-            if (this.options = M, this.loose = !!M.loose, this.includePrerelease = !!M.includePrerelease, this.raw = D.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map((E) => this.parseRange(E.trim())).filter((E) => E.length), !this.set.length)
+            if (this.options = N, this.loose = !!N.loose, this.includePrerelease = !!N.includePrerelease, this.raw = O.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map((R) => this.parseRange(R.trim())).filter((R) => R.length), !this.set.length)
                 throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
             if (this.set.length > 1) {
-                const E = this.set[0];
-                if (this.set = this.set.filter(($) => !g($[0])), this.set.length === 0)
-                    this.set = [E];
+                const R = this.set[0];
+                if (this.set = this.set.filter((P) => !g(P[0])), this.set.length === 0)
+                    this.set = [R];
                 else if (this.set.length > 1) {
-                    for (const $ of this.set)
-                        if ($.length === 1 && p($[0])) {
-                            this.set = [$];
+                    for (const P of this.set)
+                        if (P.length === 1 && p(P[0])) {
+                            this.set = [P];
                             break;
                         }
                 }
             }
             this.format();
         }
         format() {
-            return this.range = this.set.map((D) => D.join(" ").trim()).join("||").trim(), this.range;
+            return this.range = this.set.map((O) => O.join(" ").trim()).join("||").trim(), this.range;
         }
         toString() {
             return this.range;
         }
-        parseRange(D) {
-            const E = ((this.options.includePrerelease && d) | (this.options.loose && h)) + ":" + D,
-                $ = n.get(E);
-            if ($)
-                return $;
-            const C = this.options.loose,
-                O = C ? a[u.HYPHENRANGELOOSE] : a[u.HYPHENRANGE];
-            D = D.replace(O, T(this.options.includePrerelease)), s("hyphen replace", D), D = D.replace(a[u.COMPARATORTRIM], l), s("comparator trim", D), D = D.replace(a[u.TILDETRIM], c), s("tilde trim", D), D = D.replace(a[u.CARETTRIM], f), s("caret trim", D);
-            let R = D.split(" ").map((V) => y(V, this.options)).join(" ").split(/\s+/).map((V) => F(V, this.options));
-            C && (R = R.filter((V) => (s("loose invalid filter", V, this.options), !!V.match(a[u.COMPARATORLOOSE])))), s("range list", R);
-            const L = /* @__PURE__ */ new Map(),
-                P = R.map((V) => new r(V, this.options));
-            for (const V of P) {
-                if (g(V))
-                    return [V];
-                L.set(V.value, V);
-            }
-            L.size > 1 && L.has("") && L.delete("");
-            const z = [...L.values()];
-            return n.set(E, z), z;
+        parseRange(O) {
+            const R = ((this.options.includePrerelease && d) | (this.options.loose && h)) + ":" + O,
+                P = n.get(R);
+            if (P)
+                return P;
+            const S = this.options.loose,
+                $ = S ? a[u.HYPHENRANGELOOSE] : a[u.HYPHENRANGE];
+            O = O.replace($, M(this.options.includePrerelease)), s("hyphen replace", O), O = O.replace(a[u.COMPARATORTRIM], l), s("comparator trim", O), O = O.replace(a[u.TILDETRIM], c), s("tilde trim", O), O = O.replace(a[u.CARETTRIM], f), s("caret trim", O);
+            let C = O.split(" ").map((H) => y(H, this.options)).join(" ").split(/\s+/).map((H) => T(H, this.options));
+            S && (C = C.filter((H) => (s("loose invalid filter", H, this.options), !!H.match(a[u.COMPARATORLOOSE])))), s("range list", C);
+            const D = /* @__PURE__ */ new Map(),
+                I = C.map((H) => new r(H, this.options));
+            for (const H of I) {
+                if (g(H))
+                    return [H];
+                D.set(H.value, H);
+            }
+            D.size > 1 && D.has("") && D.delete("");
+            const z = [...D.values()];
+            return n.set(R, z), z;
         }
-        intersects(D, M) {
-            if (!(D instanceof e))
+        intersects(O, N) {
+            if (!(O instanceof e))
                 throw new TypeError("a Range is required");
-            return this.set.some((E) => m(E, M) && D.set.some(($) => m($, M) && E.every((C) => $.every((O) => C.intersects(O, M)))));
+            return this.set.some((R) => m(R, N) && O.set.some((P) => m(P, N) && R.every((S) => P.every(($) => S.intersects($, N)))));
         }
         // if ANY of the sets match ALL of its comparators, then pass
-        test(D) {
-            if (!D)
+        test(O) {
+            if (!O)
                 return !1;
-            if (typeof D == "string")
+            if (typeof O == "string")
                 try {
-                    D = new o(D, this.options);
+                    O = new o(O, this.options);
                 } catch {
                     return !1;
                 }
-            for (let M = 0; M < this.set.length; M++)
-                if (I(this.set[M], D, this.options))
+            for (let N = 0; N < this.set.length; N++)
+                if (L(this.set[N], O, this.options))
                     return !0;
             return !1;
         }
     }
     c2 = e;
     const t = Wxe,
         n = new t({
@@ -53274,71 +53261,71 @@
             tildeTrimReplace: c,
             caretTrimReplace: f
         } = G6,
         {
             FLAG_INCLUDE_PRERELEASE: d,
             FLAG_LOOSE: h
         } = H6,
-        g = (N) => N.value === "<0.0.0-0",
-        p = (N) => N.value === "",
-        m = (N, D) => {
-            let M = !0;
-            const E = N.slice();
-            let $ = E.pop();
-            for (; M && E.length;)
-                M = E.every((C) => $.intersects(C, D)), $ = E.pop();
-            return M;
-        },
-        y = (N, D) => (s("comp", N, D), N = w(N, D), s("caret", N), N = v(N, D), s("tildes", N), N = _(N, D), s("xrange", N), N = A(N, D), s("stars", N), N),
-        b = (N) => !N || N.toLowerCase() === "x" || N === "*",
-        v = (N, D) => N.trim().split(/\s+/).map((M) => x(M, D)).join(" "),
-        x = (N, D) => {
-            const M = D.loose ? a[u.TILDELOOSE] : a[u.TILDE];
-            return N.replace(M, (E, $, C, O, R) => {
-                s("tilde", N, E, $, C, O, R);
-                let L;
-                return b($) ? L = "" : b(C) ? L = `>=${$}.0.0 <${+$ + 1}.0.0-0` : b(O) ? L = `>=${$}.${C}.0 <${$}.${+C + 1}.0-0` : R ? (s("replaceTilde pr", R), L = `>=${$}.${C}.${O}-${R} <${$}.${+C + 1}.0-0`) : L = `>=${$}.${C}.${O} <${$}.${+C + 1}.0-0`, s("tilde return", L), L;
+        g = (F) => F.value === "<0.0.0-0",
+        p = (F) => F.value === "",
+        m = (F, O) => {
+            let N = !0;
+            const R = F.slice();
+            let P = R.pop();
+            for (; N && R.length;)
+                N = R.every((S) => P.intersects(S, O)), P = R.pop();
+            return N;
+        },
+        y = (F, O) => (s("comp", F, O), F = w(F, O), s("caret", F), F = v(F, O), s("tildes", F), F = _(F, O), s("xrange", F), F = A(F, O), s("stars", F), F),
+        b = (F) => !F || F.toLowerCase() === "x" || F === "*",
+        v = (F, O) => F.trim().split(/\s+/).map((N) => x(N, O)).join(" "),
+        x = (F, O) => {
+            const N = O.loose ? a[u.TILDELOOSE] : a[u.TILDE];
+            return F.replace(N, (R, P, S, $, C) => {
+                s("tilde", F, R, P, S, $, C);
+                let D;
+                return b(P) ? D = "" : b(S) ? D = `>=${P}.0.0 <${+P + 1}.0.0-0` : b($) ? D = `>=${P}.${S}.0 <${P}.${+S + 1}.0-0` : C ? (s("replaceTilde pr", C), D = `>=${P}.${S}.${$}-${C} <${P}.${+S + 1}.0-0`) : D = `>=${P}.${S}.${$} <${P}.${+S + 1}.0-0`, s("tilde return", D), D;
             });
         },
-        w = (N, D) => N.trim().split(/\s+/).map((M) => S(M, D)).join(" "),
-        S = (N, D) => {
-            s("caret", N, D);
-            const M = D.loose ? a[u.CARETLOOSE] : a[u.CARET],
-                E = D.includePrerelease ? "-0" : "";
-            return N.replace(M, ($, C, O, R, L) => {
-                s("caret", N, $, C, O, R, L);
-                let P;
-                return b(C) ? P = "" : b(O) ? P = `>=${C}.0.0${E} <${+C + 1}.0.0-0` : b(R) ? C === "0" ? P = `>=${C}.${O}.0${E} <${C}.${+O + 1}.0-0` : P = `>=${C}.${O}.0${E} <${+C + 1}.0.0-0` : L ? (s("replaceCaret pr", L), C === "0" ? O === "0" ? P = `>=${C}.${O}.${R}-${L} <${C}.${O}.${+R + 1}-0` : P = `>=${C}.${O}.${R}-${L} <${C}.${+O + 1}.0-0` : P = `>=${C}.${O}.${R}-${L} <${+C + 1}.0.0-0`) : (s("no pr"), C === "0" ? O === "0" ? P = `>=${C}.${O}.${R}${E} <${C}.${O}.${+R + 1}-0` : P = `>=${C}.${O}.${R}${E} <${C}.${+O + 1}.0-0` : P = `>=${C}.${O}.${R} <${+C + 1}.0.0-0`), s("caret return", P), P;
+        w = (F, O) => F.trim().split(/\s+/).map((N) => E(N, O)).join(" "),
+        E = (F, O) => {
+            s("caret", F, O);
+            const N = O.loose ? a[u.CARETLOOSE] : a[u.CARET],
+                R = O.includePrerelease ? "-0" : "";
+            return F.replace(N, (P, S, $, C, D) => {
+                s("caret", F, P, S, $, C, D);
+                let I;
+                return b(S) ? I = "" : b($) ? I = `>=${S}.0.0${R} <${+S + 1}.0.0-0` : b(C) ? S === "0" ? I = `>=${S}.${$}.0${R} <${S}.${+$ + 1}.0-0` : I = `>=${S}.${$}.0${R} <${+S + 1}.0.0-0` : D ? (s("replaceCaret pr", D), S === "0" ? $ === "0" ? I = `>=${S}.${$}.${C}-${D} <${S}.${$}.${+C + 1}-0` : I = `>=${S}.${$}.${C}-${D} <${S}.${+$ + 1}.0-0` : I = `>=${S}.${$}.${C}-${D} <${+S + 1}.0.0-0`) : (s("no pr"), S === "0" ? $ === "0" ? I = `>=${S}.${$}.${C}${R} <${S}.${$}.${+C + 1}-0` : I = `>=${S}.${$}.${C}${R} <${S}.${+$ + 1}.0-0` : I = `>=${S}.${$}.${C} <${+S + 1}.0.0-0`), s("caret return", I), I;
             });
         },
-        _ = (N, D) => (s("replaceXRanges", N, D), N.split(/\s+/).map((M) => k(M, D)).join(" ")),
-        k = (N, D) => {
-            N = N.trim();
-            const M = D.loose ? a[u.XRANGELOOSE] : a[u.XRANGE];
-            return N.replace(M, (E, $, C, O, R, L) => {
-                s("xRange", N, E, $, C, O, R, L);
-                const P = b(C),
-                    z = P || b(O),
-                    V = z || b(R),
-                    X = V;
-                return $ === "=" && X && ($ = ""), L = D.includePrerelease ? "-0" : "", P ? $ === ">" || $ === "<" ? E = "<0.0.0-0" : E = "*" : $ && X ? (z && (O = 0), R = 0, $ === ">" ? ($ = ">=", z ? (C = +C + 1, O = 0, R = 0) : (O = +O + 1, R = 0)) : $ === "<=" && ($ = "<", z ? C = +C + 1 : O = +O + 1), $ === "<" && (L = "-0"), E = `${$ + C}.${O}.${R}${L}`) : z ? E = `>=${C}.0.0${L} <${+C + 1}.0.0-0` : V && (E = `>=${C}.${O}.0${L} <${C}.${+O + 1}.0-0`), s("xRange return", E), E;
+        _ = (F, O) => (s("replaceXRanges", F, O), F.split(/\s+/).map((N) => k(N, O)).join(" ")),
+        k = (F, O) => {
+            F = F.trim();
+            const N = O.loose ? a[u.XRANGELOOSE] : a[u.XRANGE];
+            return F.replace(N, (R, P, S, $, C, D) => {
+                s("xRange", F, R, P, S, $, C, D);
+                const I = b(S),
+                    z = I || b($),
+                    H = z || b(C),
+                    G = H;
+                return P === "=" && G && (P = ""), D = O.includePrerelease ? "-0" : "", I ? P === ">" || P === "<" ? R = "<0.0.0-0" : R = "*" : P && G ? (z && ($ = 0), C = 0, P === ">" ? (P = ">=", z ? (S = +S + 1, $ = 0, C = 0) : ($ = +$ + 1, C = 0)) : P === "<=" && (P = "<", z ? S = +S + 1 : $ = +$ + 1), P === "<" && (D = "-0"), R = `${P + S}.${$}.${C}${D}`) : z ? R = `>=${S}.0.0${D} <${+S + 1}.0.0-0` : H && (R = `>=${S}.${$}.0${D} <${S}.${+$ + 1}.0-0`), s("xRange return", R), R;
             });
         },
-        A = (N, D) => (s("replaceStars", N, D), N.trim().replace(a[u.STAR], "")),
-        F = (N, D) => (s("replaceGTE0", N, D), N.trim().replace(a[D.includePrerelease ? u.GTE0PRE : u.GTE0], "")),
-        T = (N) => (D, M, E, $, C, O, R, L, P, z, V, X, se) => (b(E) ? M = "" : b($) ? M = `>=${E}.0.0${N ? "-0" : ""}` : b(C) ? M = `>=${E}.${$}.0${N ? "-0" : ""}` : O ? M = `>=${M}` : M = `>=${M}${N ? "-0" : ""}`, b(P) ? L = "" : b(z) ? L = `<${+P + 1}.0.0-0` : b(V) ? L = `<${P}.${+z + 1}.0-0` : X ? L = `<=${P}.${z}.${V}-${X}` : N ? L = `<${P}.${z}.${+V + 1}-0` : L = `<=${L}`, `${M} ${L}`.trim()),
-        I = (N, D, M) => {
-            for (let E = 0; E < N.length; E++)
-                if (!N[E].test(D))
+        A = (F, O) => (s("replaceStars", F, O), F.trim().replace(a[u.STAR], "")),
+        T = (F, O) => (s("replaceGTE0", F, O), F.trim().replace(a[O.includePrerelease ? u.GTE0PRE : u.GTE0], "")),
+        M = (F) => (O, N, R, P, S, $, C, D, I, z, H, G, te) => (b(R) ? N = "" : b(P) ? N = `>=${R}.0.0${F ? "-0" : ""}` : b(S) ? N = `>=${R}.${P}.0${F ? "-0" : ""}` : $ ? N = `>=${N}` : N = `>=${N}${F ? "-0" : ""}`, b(I) ? D = "" : b(z) ? D = `<${+I + 1}.0.0-0` : b(H) ? D = `<${I}.${+z + 1}.0-0` : G ? D = `<=${I}.${z}.${H}-${G}` : F ? D = `<${I}.${z}.${+H + 1}-0` : D = `<=${D}`, `${N} ${D}`.trim()),
+        L = (F, O, N) => {
+            for (let R = 0; R < F.length; R++)
+                if (!F[R].test(O))
                     return !1;
-            if (D.prerelease.length && !M.includePrerelease) {
-                for (let E = 0; E < N.length; E++)
-                    if (s(N[E].semver), N[E].semver !== r.ANY && N[E].semver.prerelease.length > 0) {
-                        const $ = N[E].semver;
-                        if ($.major === D.major && $.minor === D.minor && $.patch === D.patch)
+            if (O.prerelease.length && !N.includePrerelease) {
+                for (let R = 0; R < F.length; R++)
+                    if (s(F[R].semver), F[R].semver !== r.ANY && F[R].semver.prerelease.length > 0) {
+                        const P = F[R].semver;
+                        if (P.major === O.major && P.minor === O.minor && P.patch === O.patch)
                             return !0;
                     }
                 return !1;
             }
             return !0;
         };
     return c2;
@@ -53576,33 +53563,33 @@
 function _7(e) {
     return eU(e) ? e : yr.loader(e);
 }
 
 function Hwe(e) {
     var n;
     const t = ((n = e.usermeta) == null ? void 0 : n.embedOptions) ?? {};
-    return ie(t.defaultStyle) && (t.defaultStyle = !1), t;
+    return se(t.defaultStyle) && (t.defaultStyle = !1), t;
 }
 async function Gwe(e, t, n = {}) {
     let i, r;
-    ie(t) ? (r = _7(n.loader), i = JSON.parse(await r.load(t))) : i = t;
+    se(t) ? (r = _7(n.loader), i = JSON.parse(await r.load(t))) : i = t;
     const s = Hwe(i),
         o = s.loader;
     (!r || o) && (r = _7(n.loader ?? o));
     const a = await E7(s, r),
         u = await E7(n, r),
         l = {
             ...ZB(u, a),
             config: ff(u.config ?? {}, a.config ?? {})
         };
     return await Ywe(e, i, l, r);
 }
 async function E7(e, t) {
-    const n = ie(e.config) ? JSON.parse(await t.load(e.config)) : e.config ?? {},
-        i = ie(e.patch) ? JSON.parse(await t.load(e.patch)) : e.patch;
+    const n = se(e.config) ? JSON.parse(await t.load(e.config)) : e.config ?? {},
+        i = se(e.patch) ? JSON.parse(await t.load(e.patch)) : e.patch;
     return {
         ...e,
         ...i ? {
             patch: i
         } : {},
         ...n ? {
             config: n
@@ -53632,18 +53619,18 @@
         l = n.downloadFileName ?? "visualization",
         c = typeof e == "string" ? document.querySelector(e) : e;
     if (!c)
         throw new Error(`${e} does not exist`);
     if (n.defaultStyle !== !1) {
         const w = "vega-embed-style",
             {
-                root: S,
+                root: E,
                 rootContainer: _
             } = Vwe(c);
-        if (!S.getElementById(w)) {
+        if (!E.getElementById(w)) {
             const k = document.createElement("style");
             k.id = w, k.innerHTML = n.defaultStyle === void 0 || n.defaultStyle === !0 ? Lwe.toString() : n.defaultStyle, _.appendChild(k);
         }
     }
     const f = Wwe(t, n.mode);
     let d = Bwe[f](t, r);
     if (f === "vega-lite" && d.$schema) {
@@ -53655,106 +53642,106 @@
     if (s) {
         const w = document.createElement("div");
         w.classList.add(jwe), c.appendChild(w), h = w;
     }
     const g = n.patch;
     if (g && (d = g instanceof Function ? g(d) : d1(d, g, !0, !1).newDocument), n.formatLocale && yr.formatLocale(n.formatLocale), n.timeFormatLocale && yr.timeFormatLocale(n.timeFormatLocale), n.expressionFunctions)
         for (const w in n.expressionFunctions) {
-            const S = n.expressionFunctions[w];
-            "fn" in S ? yr.expressionFunction(w, S.fn, S.visitor) : S instanceof Function && yr.expressionFunction(w, S);
+            const E = n.expressionFunctions[w];
+            "fn" in E ? yr.expressionFunction(w, E.fn, E.visitor) : E instanceof Function && yr.expressionFunction(w, E);
         }
     const {
         ast: p
     } = n, m = yr.parse(d, f === "vega-lite" ? {} : r, {
         ast: p
     }), y = new(n.viewClass || yr.View)(m, {
         loader: i,
         logLevel: u,
         renderer: a,
         ...p ? {
             expr: yr.expressionInterpreter ?? n.expr ?? Fhe
         } : {}
     });
-    if (y.addSignalListener("autosize", (w, S) => {
+    if (y.addSignalListener("autosize", (w, E) => {
             const {
                 type: _
-            } = S;
+            } = E;
             _ == "fit-x" ? (h.classList.add("fit-x"), h.classList.remove("fit-y")) : _ == "fit-y" ? (h.classList.remove("fit-x"), h.classList.add("fit-y")) : _ == "fit" ? h.classList.add("fit-x", "fit-y") : h.classList.remove("fit-x", "fit-y");
         }), n.tooltip !== !1) {
         const {
             loader: w,
-            tooltip: S
-        } = n, _ = w && !eU(w) ? w == null ? void 0 : w.baseURL : void 0, k = qwe(S) ? S : (
+            tooltip: E
+        } = n, _ = w && !eU(w) ? w == null ? void 0 : w.baseURL : void 0, k = qwe(E) ? E : (
             // user provided boolean true or tooltip options
             new Dxe({
                 baseURL: _,
-                ...S === !0 ? {} : S
+                ...E === !0 ? {} : E
             }).call
         );
         y.tooltip(k);
     }
     let {
         hover: b
     } = n;
     if (b === void 0 && (b = f === "vega"), b) {
         const {
             hoverSet: w,
-            updateSet: S
+            updateSet: E
         } = typeof b == "boolean" ? {} : b;
-        y.hover(w, S);
+        y.hover(w, E);
     }
     n && (n.width != null && y.width(n.width), n.height != null && y.height(n.height), n.padding != null && y.padding(n.padding)), await y.initialize(h, n.bind).runAsync();
     let v;
     if (s !== !1) {
         let w = c;
         if (n.defaultStyle !== !1 || n.forceActionsMenu) {
             const _ = document.createElement("details");
             _.title = o.CLICK_TO_VIEW_ACTIONS, c.append(_), w = _;
             const k = document.createElement("summary");
             k.innerHTML = Uwe, _.append(k), v = (A) => {
                 _.contains(A.target) || _.removeAttribute("open");
             }, document.addEventListener("click", v);
         }
-        const S = document.createElement("div");
-        if (w.append(S), S.classList.add("vega-actions"), s === !0 || s.export !== !1) {
+        const E = document.createElement("div");
+        if (w.append(E), E.classList.add("vega-actions"), s === !0 || s.export !== !1) {
             for (const _ of ["svg", "png"])
                 if (s === !0 || s.export === !0 || s.export[_]) {
                     const k = o[`${_.toUpperCase()}_ACTION`],
                         A = document.createElement("a"),
-                        F = re(n.scaleFactor) ? n.scaleFactor[_] : n.scaleFactor;
-                    A.text = k, A.href = "#", A.target = "_blank", A.download = `${l}.${_}`, A.addEventListener("mousedown", async function(T) {
-                        T.preventDefault();
-                        const I = await y.toImageURL(_, F);
-                        this.href = I;
-                    }), S.append(A);
+                        T = oe(n.scaleFactor) ? n.scaleFactor[_] : n.scaleFactor;
+                    A.text = k, A.href = "#", A.target = "_blank", A.download = `${l}.${_}`, A.addEventListener("mousedown", async function(M) {
+                        M.preventDefault();
+                        const L = await y.toImageURL(_, T);
+                        this.href = L;
+                    }), E.append(A);
                 }
         }
         if (s === !0 || s.source !== !1) {
             const _ = document.createElement("a");
             _.text = o.SOURCE_ACTION, _.href = "#", _.addEventListener("click", function(k) {
                 w7(zb(t), n.sourceHeader ?? "", n.sourceFooter ?? "", f), k.preventDefault();
-            }), S.append(_);
+            }), E.append(_);
         }
         if (f === "vega-lite" && (s === !0 || s.compiled !== !1)) {
             const _ = document.createElement("a");
             _.text = o.COMPILED_ACTION, _.href = "#", _.addEventListener("click", function(k) {
                 w7(zb(d), n.sourceHeader ?? "", n.sourceFooter ?? "", "vega"), k.preventDefault();
-            }), S.append(_);
+            }), E.append(_);
         }
         if (s === !0 || s.editor !== !1) {
             const _ = n.editorUrl ?? "https://vega.github.io/editor/",
                 k = document.createElement("a");
             k.text = o.EDITOR_ACTION, k.href = "#", k.addEventListener("click", function(A) {
                 Rwe(window, _, {
                     config: r,
                     mode: f,
                     renderer: a,
                     spec: zb(t)
                 }), A.preventDefault();
-            }), S.append(k);
+            }), E.append(k);
         }
     }
 
     function x() {
         v && document.removeEventListener("click", v), y.finalize();
     }
     return {
@@ -53871,24 +53858,24 @@
     } : e;
 }
 
 function t_e(e) {
     let t;
     return {
         c() {
-            t = ge("div");
+            t = he("div");
         },
         m(n, i) {
-            we(n, t, i), e[11](t);
+            pe(n, t, i), e[11](t);
         },
         p: dt,
         i: dt,
         o: dt,
         d(n) {
-            n && xe(t), e[11](null);
+            n && ge(t), e[11](null);
         }
     };
 }
 
 function n_e(e, t, n) {
     let {
         options: i
@@ -53949,25 +53936,25 @@
         if (e.$$.dirty & /*data, prevData*/
             1056 && (Pp(a, h) || v(), n(10, h = a)), e.$$.dirty & /*chartContainer, options, prevOptions, spec, prevSpec, signalListeners, prevSignalListeners, result, view*/
             991 && g !== void 0) {
             if (!Pp(i, c, Xwe))
                 p();
             else {
                 const w = e_e(k7(r, i), k7(d, c)),
-                    S = o,
+                    E = o,
                     _ = f;
                 if (w) {
                     if (w.isExpensive)
                         p();
                     else if (l !== void 0) {
-                        const k = !Pp(S, _);
-                        n(1, s = l.view), w.width !== !1 && s.width(w.width), w.height !== !1 && s.height(w.height), k && (_ && S7(s, _), S && f2(s, S)), s.runAsync();
+                        const k = !Pp(E, _);
+                        n(1, s = l.view), w.width !== !1 && s.width(w.width), w.height !== !1 && s.height(w.height), k && (_ && S7(s, _), E && f2(s, E)), s.runAsync();
                     }
                 } else
-                    !Pp(S, _) && l !== void 0 && (n(1, s = l.view), _ && S7(s, _), S && f2(s, S), s.runAsync());
+                    !Pp(E, _) && l !== void 0 && (n(1, s = l.view), _ && S7(s, _), E && f2(s, E), s.runAsync());
             }
             n(7, c = i), n(8, f = o), n(9, d = r);
         }
     }, [
         g,
         s,
         i,
@@ -54032,15 +54019,15 @@
             /*onError_handler*/
             e[8]
         ), {
             c() {
                 oi(t.$$.fragment);
             },
             m(o, a) {
-                Bn(t, o, a), i = !0;
+                Un(t, o, a), i = !0;
             },
             p(o, [a]) {
                 const u = {};
                 a & /*spec*/
                     2 && (u.spec = /*spec*/
                         o[1]), a & /*data*/
                     4 && (u.data = /*data*/
@@ -54049,21 +54036,21 @@
                         o[3]), a & /*vegaLiteOptions*/
                     16 && (u.options = /*vegaLiteOptions*/
                         o[4]), !n && a & /*view*/
                     1 && (n = !0, u.view = /*view*/
                         o[0], h_(() => n = !1)), t.$set(u);
             },
             i(o) {
-                i || (he(t.$$.fragment, o), i = !0);
+                i || (me(t.$$.fragment, o), i = !0);
             },
             o(o) {
                 Se(t.$$.fragment, o), i = !1;
             },
             d(o) {
-                Un(t, o);
+                jn(t, o);
             }
         }
     );
 }
 const s_e = "vega-lite";
 
 function o_e(e, t, n) {
@@ -54126,15 +54113,15 @@
     }
 }
 
 function a_e(e) {
     let t, n, i, r;
 
     function s(a) {
-        e[5](a);
+        e[6](a);
     }
     let o = {
         data: (
             /*data*/
             e[0]
         ),
         spec: (
@@ -54148,59 +54135,61 @@
     return (
         /*viewVL*/
         e[1] !== void 0 && (o.view = /*viewVL*/
             e[1]), n = new tU({
             props: o
         }), la.push(() => g_(n, "view", s)), {
             c() {
-                t = ge("div"), oi(n.$$.fragment), fe(t, "class", "chart");
+                t = he("div"), oi(n.$$.fragment), fe(t, "class", "chart");
             },
             m(a, u) {
-                we(a, t, u), Bn(n, t, null), r = !0;
+                pe(a, t, u), Un(n, t, null), r = !0;
             },
             p(a, [u]) {
                 const l = {};
                 u & /*data*/
                     1 && (l.data = /*data*/
                         a[0]), !i && u & /*viewVL*/
                     2 && (i = !0, l.view = /*viewVL*/
                         a[1], h_(() => i = !1)), n.$set(l);
             },
             i(a) {
-                r || (he(n.$$.fragment, a), r = !0);
+                r || (me(n.$$.fragment, a), r = !0);
             },
             o(a) {
                 Se(n.$$.fragment, a), r = !1;
             },
             d(a) {
-                a && xe(t), Un(n);
+                a && ge(t), jn(n);
             }
         }
     );
 }
 
 function u_e(e, t, n) {
     let {
         rows: i = []
     } = t, {
         filterItems: r
-    } = t, s, o;
+    } = t, {
+        sliceCol: s
+    } = t, o, a;
 
-    function a(c, f) {
-        c = c.filter((h) => {
-            let g = !0;
-            for (let [p, m] of Object.entries(f))
-                h[p] != m && (g = !1);
-            return g;
-        }), n(0, s = {
-            rows: c
+    function u(f, d) {
+        f = f.filter((g) => {
+            let p = !0;
+            for (let [m, y] of Object.entries(d))
+                g[m] != y && (p = !1);
+            return p;
+        }), n(0, o = {
+            rows: f
         });
     }
-    a(i, r);
-    let u = {
+    u(i, r);
+    let l = {
         $schema: "https://vega.github.io/schema/vega-lite/v5.json",
         description: "A simple bar chart with embedded data.",
         data: {
             name: "rows"
         },
         mark: {
             type: "bar"
@@ -54212,116 +54201,121 @@
             y: {
                 field: "concept_score_orig",
                 type: "quantitative",
                 aggregate: "sum",
                 // scale: {
                 //     domain: [0, 1]
                 // },
-                title: "Concept Prevalence"
+                title: "Number of documents"
             },
             x: {
                 field: "id",
                 type: "ordinal",
                 axis: {
                     labelLimit: 100,
                     labelAngle: -45
                 },
-                title: "Group",
+                title: s,
                 sort: null
             },
             tooltip: {
                 field: "concept_score_orig",
                 type: "quantitative",
                 aggregate: "sum"
             }
             // format: '.2f',
         }
     };
 
-    function l(c) {
-        o = c, n(1, o);
+    function c(f) {
+        a = f, n(1, a);
     }
-    return e.$$set = (c) => {
-        "rows" in c && n(3, i = c.rows), "filterItems" in c && n(4, r = c.filterItems);
+    return e.$$set = (f) => {
+        "rows" in f && n(3, i = f.rows), "filterItems" in f && n(4, r = f.filterItems), "sliceCol" in f && n(5, s = f.sliceCol);
     }, e.$$.update = () => {
         e.$$.dirty & /*rows, filterItems*/
-            24 && a(i, r);
-    }, [s, o, u, i, r, l];
+            24 && u(i, r);
+    }, [o, a, l, i, r, s, c];
 }
 class l_e extends ks {
     constructor(t) {
         super(), Ss(this, t, u_e, a_e, Xi, {
             rows: 3,
-            filterItems: 4
+            filterItems: 4,
+            sliceCol: 5
         });
     }
 }
 
 function A7(e, t, n) {
     const i = e.slice();
-    return i[14] = t[n][0], i[15] = t[n][1], i;
+    return i[15] = t[n][0], i[16] = t[n][1], i;
 }
 
-function $7(e) {
+function C7(e) {
     let t, n;
     return {
         c() {
-            t = ge("h2"), n = Si(
+            t = he("h2"), n = Si(
                 /*selectedTitle*/
                 e[1]
             );
         },
         m(i, r) {
-            we(i, t, r), $e(t, n);
+            pe(i, t, r), Ce(t, n);
         },
         p(i, r) {
             r & /*selectedTitle*/
                 2 && ho(
                     n,
                     /*selectedTitle*/
                     i[1]
                 );
         },
         d(i) {
-            i && xe(t);
+            i && ge(t);
         }
     };
 }
 
-function C7(e) {
+function $7(e) {
     let t, n, i, r, s, o, a, u, l = si(Object.entries(
             /*selectedMetadata*/
             e[2]
         )),
         c = [];
     for (let f = 0; f < l.length; f += 1)
         c[f] = M7(A7(e, l, f));
     return a = new l_e({
         props: {
             rows: (
                 /*rowsMatch*/
-                e[5]
+                e[6]
             ),
             filterItems: (
                 /*filterItems*/
                 e[0]
+            ),
+            sliceCol: (
+                /*sliceCol*/
+                e[3]
             )
         }
     }), {
         c() {
-            t = ge("h3"), t.textContent = "CONCEPT DETAILS", n = ct(), i = ge("div"), r = ge("div");
+            t = he("h3"), t.textContent = "CONCEPT DETAILS", n = rt(), i = he("div"), r = he("div");
             for (let f = 0; f < c.length; f += 1)
                 c[f].c();
-            s = ct(), o = ge("div"), oi(a.$$.fragment), fe(t, "class", "card-title"), fe(r, "class", "overview-card-left"), fe(o, "class", "overview-card-right"), fe(i, "class", "overview-card");
+            s = rt(), o = he("div"), oi(a.$$.fragment), fe(t, "class", "card-title"), fe(r, "class", "overview-card-left"), fe(o, "class", "overview-card-right"), fe(i, "class", "overview-card");
         },
         m(f, d) {
-            we(f, t, d), we(f, n, d), we(f, i, d), $e(i, r);
+            pe(f, t, d), pe(f, n, d), pe(f, i, d), Ce(i, r);
             for (let h = 0; h < c.length; h += 1)
                 c[h] && c[h].m(r, null);
-            $e(i, s), $e(i, o), Bn(a, o, null), u = !0;
+            Ce(i, s), Ce(i, o), Un(a, o, null), u = !0;
         },
         p(f, d) {
             if (d & /*Object, selectedMetadata*/
                 4) {
                 l = si(Object.entries(
                     /*selectedMetadata*/
                     f[2]
@@ -54333,201 +54327,203 @@
                 }
                 for (; g < c.length; g += 1)
                     c[g].d(1);
                 c.length = l.length;
             }
             const h = {};
             d & /*rowsMatch*/
-                32 && (h.rows = /*rowsMatch*/
-                    f[5]), d & /*filterItems*/
+                64 && (h.rows = /*rowsMatch*/
+                    f[6]), d & /*filterItems*/
                 1 && (h.filterItems = /*filterItems*/
-                    f[0]), a.$set(h);
+                    f[0]), d & /*sliceCol*/
+                8 && (h.sliceCol = /*sliceCol*/
+                    f[3]), a.$set(h);
         },
         i(f) {
-            u || (he(a.$$.fragment, f), u = !0);
+            u || (me(a.$$.fragment, f), u = !0);
         },
         o(f) {
             Se(a.$$.fragment, f), u = !1;
         },
         d(f) {
-            f && (xe(t), xe(n), xe(i)), cl(c, f), Un(a);
+            f && (ge(t), ge(n), ge(i)), cl(c, f), jn(a);
         }
     };
 }
 
 function M7(e) {
     let t, n, i = (
             /*key*/
-            e[14] + ""
+            e[15] + ""
         ),
         r, s, o, a = (
             /*value*/
-            e[15] + ""
+            e[16] + ""
         );
     return {
         c() {
-            t = ge("p"), n = ge("b"), r = Si(i), s = Si(": "), o = new f1(!1), o.a = null;
+            t = he("p"), n = he("b"), r = Si(i), s = Si(": "), o = new f1(!1), o.a = null;
         },
         m(u, l) {
-            we(u, t, l), $e(t, n), $e(n, r), $e(t, s), o.m(a, t);
+            pe(u, t, l), Ce(t, n), Ce(n, r), Ce(t, s), o.m(a, t);
         },
         p(u, l) {
             l & /*selectedMetadata*/
                 4 && i !== (i = /*key*/
-                    u[14] + "") && ho(r, i), l & /*selectedMetadata*/
+                    u[15] + "") && ho(r, i), l & /*selectedMetadata*/
                 4 && a !== (a = /*value*/
-                    u[15] + "") && o.p(a);
+                    u[16] + "") && o.p(a);
         },
         d(u) {
-            u && xe(t);
+            u && ge(t);
         }
     };
 }
 
 function T7(e) {
     let t, n;
     return t = new p_({
         props: {
             columns: (
                 /*columns*/
-                e[7]
+                e[8]
             ),
             rows: (
                 /*rowsMatchAll*/
-                e[3]
+                e[4]
             ),
             filterSelections: (
                 /*filterItems*/
                 e[0]
             )
         }
     }), {
         c() {
             oi(t.$$.fragment);
         },
         m(i, r) {
-            Bn(t, i, r), n = !0;
+            Un(t, i, r), n = !0;
         },
         p(i, r) {
             const s = {};
             r & /*rowsMatchAll*/
-                8 && (s.rows = /*rowsMatchAll*/
-                    i[3]), r & /*filterItems*/
+                16 && (s.rows = /*rowsMatchAll*/
+                    i[4]), r & /*filterItems*/
                 1 && (s.filterSelections = /*filterItems*/
                     i[0]), t.$set(s);
         },
         i(i) {
-            n || (he(t.$$.fragment, i), n = !0);
+            n || (me(t.$$.fragment, i), n = !0);
         },
         o(i) {
             Se(t.$$.fragment, i), n = !1;
         },
         d(i) {
-            Un(t, i);
+            jn(t, i);
         }
     };
 }
 
 function F7(e) {
     let t, n;
     return t = new p_({
         props: {
             columns: (
                 /*columns*/
-                e[7]
+                e[8]
             ),
             rows: (
                 /*rowsNonMatchAll*/
-                e[4]
+                e[5]
             ),
             filterSelections: (
                 /*filterItems*/
                 e[0]
             ),
             sortBy: f_e,
             sortOrder: (
                 /*sortOrder*/
-                e[8]
+                e[9]
             )
         }
     }), {
         c() {
             oi(t.$$.fragment);
         },
         m(i, r) {
-            Bn(t, i, r), n = !0;
+            Un(t, i, r), n = !0;
         },
         p(i, r) {
             const s = {};
             r & /*rowsNonMatchAll*/
-                16 && (s.rows = /*rowsNonMatchAll*/
-                    i[4]), r & /*filterItems*/
+                32 && (s.rows = /*rowsNonMatchAll*/
+                    i[5]), r & /*filterItems*/
                 1 && (s.filterSelections = /*filterItems*/
                     i[0]), t.$set(s);
         },
         i(i) {
-            n || (he(t.$$.fragment, i), n = !0);
+            n || (me(t.$$.fragment, i), n = !0);
         },
         o(i) {
             Se(t.$$.fragment, i), n = !1;
         },
         d(i) {
-            Un(t, i);
+            jn(t, i);
         }
     };
 }
 
 function c_e(e) {
     let t, n, i, r, s, o, a, u, l, c, f, d, h = (
             /*selectedTitle*/
-            e[1] && $7(e)
+            e[1] && C7(e)
         ),
         g = (
             /*selectedMetadata*/
-            e[2] && C7(e)
+            e[2] && $7(e)
         ),
         p = (
             /*remount*/
-            e[6] && T7(e)
+            e[7] && T7(e)
         ),
         m = (
             /*remount*/
-            e[6] && F7(e)
+            e[7] && F7(e)
         );
     return {
         c() {
-            t = ge("div"), h && h.c(), n = ct(), i = ge("div"), g && g.c(), r = ct(), s = ge("h3"), s.textContent = "POTENTIAL CONCEPT MATCHES", o = ct(), a = ge("div"), p && p.c(), u = ct(), l = ge("h3"), l.textContent = "CONCEPT NON-MATCHES", c = ct(), f = ge("div"), m && m.c(), fe(s, "class", "card-title"), fe(a, "class", "highlight-card"), fe(l, "class", "card-title"), AW(l, "margin-top", "20px"), fe(f, "class", "highlight-card"), fe(i, "class", "row");
+            t = he("div"), h && h.c(), n = rt(), i = he("div"), g && g.c(), r = rt(), s = he("h3"), s.textContent = "POTENTIAL CONCEPT MATCHES", o = rt(), a = he("div"), p && p.c(), u = rt(), l = he("h3"), l.textContent = "CONCEPT NON-MATCHES", c = rt(), f = he("div"), m && m.c(), fe(s, "class", "card-title"), fe(a, "class", "highlight-card"), fe(l, "class", "card-title"), AW(l, "margin-top", "20px"), fe(f, "class", "highlight-card"), fe(i, "class", "row");
         },
         m(y, b) {
-            we(y, t, b), h && h.m(t, null), $e(t, n), $e(t, i), g && g.m(i, null), $e(i, r), $e(i, s), $e(i, o), $e(i, a), p && p.m(a, null), $e(i, u), $e(i, l), $e(i, c), $e(i, f), m && m.m(f, null), d = !0;
+            pe(y, t, b), h && h.m(t, null), Ce(t, n), Ce(t, i), g && g.m(i, null), Ce(i, r), Ce(i, s), Ce(i, o), Ce(i, a), p && p.m(a, null), Ce(i, u), Ce(i, l), Ce(i, c), Ce(i, f), m && m.m(f, null), d = !0;
         },
         p(y, [b]) {
             /*selectedTitle*/
-            y[1] ? h ? h.p(y, b) : (h = $7(y), h.c(), h.m(t, n)) : h && (h.d(1), h = null), /*selectedMetadata*/
+            y[1] ? h ? h.p(y, b) : (h = C7(y), h.c(), h.m(t, n)) : h && (h.d(1), h = null), /*selectedMetadata*/
                 y[2] ? g ? (g.p(y, b), b & /*selectedMetadata*/
-                    4 && he(g, 1)) : (g = C7(y), g.c(), he(g, 1), g.m(i, r)) : g && (mn(), Se(g, 1, 1, () => {
+                    4 && me(g, 1)) : (g = $7(y), g.c(), me(g, 1), g.m(i, r)) : g && (yn(), Se(g, 1, 1, () => {
                     g = null;
-                }), yn()), /*remount*/
-                y[6] ? p ? (p.p(y, b), b & /*remount*/
-                    64 && he(p, 1)) : (p = T7(y), p.c(), he(p, 1), p.m(a, null)) : p && (mn(), Se(p, 1, 1, () => {
+                }), bn()), /*remount*/
+                y[7] ? p ? (p.p(y, b), b & /*remount*/
+                    128 && me(p, 1)) : (p = T7(y), p.c(), me(p, 1), p.m(a, null)) : p && (yn(), Se(p, 1, 1, () => {
                     p = null;
-                }), yn()), /*remount*/
-                y[6] ? m ? (m.p(y, b), b & /*remount*/
-                    64 && he(m, 1)) : (m = F7(y), m.c(), he(m, 1), m.m(f, null)) : m && (mn(), Se(m, 1, 1, () => {
+                }), bn()), /*remount*/
+                y[7] ? m ? (m.p(y, b), b & /*remount*/
+                    128 && me(m, 1)) : (m = F7(y), m.c(), me(m, 1), m.m(f, null)) : m && (yn(), Se(m, 1, 1, () => {
                     m = null;
-                }), yn());
+                }), bn());
         },
         i(y) {
-            d || (he(g), he(p), he(m), d = !0);
+            d || (me(g), me(p), me(m), d = !0);
         },
         o(y) {
             Se(g), Se(p), Se(m), d = !1;
         },
         d(y) {
-            y && xe(t), h && h.d(), g && g.d(), p && p.d(), m && m.d();
+            y && ge(t), h && h.d(), g && g.d(), p && p.d(), m && m.d();
         }
     };
 }
 let f_e = "concept score";
 
 function d_e(e, t, n) {
     let {
@@ -54536,60 +54532,64 @@
         el: r
     } = t, {
         filterItems: s
     } = t, {
         selectedTitle: o
     } = t, {
         selectedMetadata: a
-    } = t, u = [], l = [], c = [], f = [], d = [], h = !0, g = ["concept_score_orig"], p = -1;
+    } = t, {
+        sliceCol: u
+    } = t, l = [], c = [], f = [], d = [], h = [], g = !0, p = ["concept_score_orig"], m = -1;
     f_(() => {
-        m(i);
+        y(i);
     });
 
-    function m(y) {
-        if (y != null) {
-            let v = document.createElement("div");
-            u = JSON.parse(y);
-            for (var b = 0; b < Object.keys(u[0]).length; b++) {
-                const w = Object.keys(u[0])[b];
-                g.includes(w) || l.push({
-                    key: w,
-                    title: w,
-                    value: (S) => S[w],
+    function y(b) {
+        if (b != null) {
+            let x = document.createElement("div");
+            l = JSON.parse(b);
+            for (var v = 0; v < Object.keys(l[0]).length; v++) {
+                const E = Object.keys(l[0])[v];
+                p.includes(E) || c.push({
+                    key: E,
+                    title: E,
+                    value: (_) => _[E],
                     sortable: !0,
                     parseHTML: !0
                 });
             }
-            n(6, h = !1), setTimeout(() => n(6, h = !0), 0), r.appendChild(v), n(3, c = u.filter((w) => w.concept_score_orig == 1 && w.id == "All")), n(4, f = u.filter((w) => w.concept_score_orig < 1 && w.id == "All")), n(5, d = u.filter((w) => w.concept_score_orig == 1));
+            n(7, g = !1), setTimeout(() => n(7, g = !0), 0), r.appendChild(x), n(4, f = l.filter((E) => E.concept_score_orig == 1 && E.id == "All")), n(5, d = l.filter((E) => E.concept_score_orig < 1 && E.id == "All")), n(6, h = l.filter((E) => E.concept_score_orig == 1));
         }
     }
-    return e.$$set = (y) => {
-        "data" in y && n(9, i = y.data), "el" in y && n(10, r = y.el), "filterItems" in y && n(0, s = y.filterItems), "selectedTitle" in y && n(1, o = y.selectedTitle), "selectedMetadata" in y && n(2, a = y.selectedMetadata);
+    return e.$$set = (b) => {
+        "data" in b && n(10, i = b.data), "el" in b && n(11, r = b.el), "filterItems" in b && n(0, s = b.filterItems), "selectedTitle" in b && n(1, o = b.selectedTitle), "selectedMetadata" in b && n(2, a = b.selectedMetadata), "sliceCol" in b && n(3, u = b.sliceCol);
     }, [
         s,
         o,
         a,
-        c,
+        u,
         f,
         d,
         h,
-        l,
-        p,
+        g,
+        c,
+        m,
         i,
         r
     ];
 }
 class h_e extends ks {
     constructor(t) {
         super(), Ss(this, t, d_e, c_e, Xi, {
-            data: 9,
-            el: 10,
+            data: 10,
+            el: 11,
             filterItems: 0,
             selectedTitle: 1,
-            selectedMetadata: 2
+            selectedMetadata: 2,
+            sliceCol: 3
         });
     }
 }
 
 function g_e(e) {
     let t, n, i, r;
 
@@ -54612,35 +54612,35 @@
     return (
         /*viewVL*/
         e[1] !== void 0 && (o.view = /*viewVL*/
             e[1]), n = new tU({
             props: o
         }), la.push(() => g_(n, "view", s)), {
             c() {
-                t = ge("div"), oi(n.$$.fragment), fe(t, "class", "chart");
+                t = he("div"), oi(n.$$.fragment), fe(t, "class", "chart");
             },
             m(a, u) {
-                we(a, t, u), Bn(n, t, null), r = !0;
+                pe(a, t, u), Un(n, t, null), r = !0;
             },
             p(a, [u]) {
                 const l = {};
                 u & /*data*/
                     1 && (l.data = /*data*/
                         a[0]), !i && u & /*viewVL*/
                     2 && (i = !0, l.view = /*viewVL*/
                         a[1], h_(() => i = !1)), n.$set(l);
             },
             i(a) {
-                r || (he(n.$$.fragment, a), r = !0);
+                r || (me(n.$$.fragment, a), r = !0);
             },
             o(a) {
                 Se(n.$$.fragment, a), r = !1;
             },
             d(a) {
-                a && xe(t), Un(n);
+                a && ge(t), jn(n);
             }
         }
     );
 }
 
 function p_e(e, t, n) {
     let {
@@ -54674,15 +54674,15 @@
             x: {
                 field: "concept_score_orig",
                 type: "quantitative",
                 aggregate: "sum",
                 // scale: {
                 //     domain: [0, 1]
                 // },
-                title: "Concept Prevalence"
+                title: "Number of documents"
             },
             y: {
                 field: "concept",
                 type: "nominal",
                 axis: {
                     labelLimit: 100
                 },
@@ -54726,32 +54726,32 @@
     return i[13] = t[n][0], i[14] = t[n][1], i;
 }
 
 function O7(e) {
     let t, n;
     return {
         c() {
-            t = ge("h2"), n = Si(
+            t = he("h2"), n = Si(
                 /*selectedTitle*/
                 e[3]
             );
         },
         m(i, r) {
-            we(i, t, r), $e(t, n);
+            pe(i, t, r), Ce(t, n);
         },
         p(i, r) {
             r & /*selectedTitle*/
                 8 && ho(
                     n,
                     /*selectedTitle*/
                     i[3]
                 );
         },
         d(i) {
-            i && xe(t);
+            i && ge(t);
         }
     };
 }
 
 function D7(e) {
     let t, n, i, r, s, o, a = si(Object.entries(
             /*selectedMetadata*/
@@ -54769,24 +54769,24 @@
             filterItems: (
                 /*filterItems*/
                 e[0]
             )
         }
     }), {
         c() {
-            t = ge("h3"), t.textContent = "SLICE DETAILS", n = ct(), i = ge("div");
+            t = he("h3"), t.textContent = "SLICE DETAILS", n = rt(), i = he("div");
             for (let l = 0; l < u.length; l += 1)
                 u[l].c();
-            r = ct(), oi(s.$$.fragment), fe(t, "class", "card-title"), fe(i, "class", "overview-card");
+            r = rt(), oi(s.$$.fragment), fe(t, "class", "card-title"), fe(i, "class", "overview-card");
         },
         m(l, c) {
-            we(l, t, c), we(l, n, c), we(l, i, c);
+            pe(l, t, c), pe(l, n, c), pe(l, i, c);
             for (let f = 0; f < u.length; f += 1)
                 u[f] && u[f].m(i, null);
-            $e(i, r), Bn(s, i, null), o = !0;
+            Ce(i, r), Un(s, i, null), o = !0;
         },
         p(l, c) {
             if (c & /*Object, selectedMetadata*/
                 16) {
                 a = si(Object.entries(
                     /*selectedMetadata*/
                     l[4]
@@ -54804,21 +54804,21 @@
             c & /*rowsLong*/
                 64 && (f.rows = /*rowsLong*/
                     l[6]), c & /*filterItems*/
                 1 && (f.filterItems = /*filterItems*/
                     l[0]), s.$set(f);
         },
         i(l) {
-            o || (he(s.$$.fragment, l), o = !0);
+            o || (me(s.$$.fragment, l), o = !0);
         },
         o(l) {
             Se(s.$$.fragment, l), o = !1;
         },
         d(l) {
-            l && (xe(t), xe(n), xe(i)), cl(u, l), Un(s);
+            l && (ge(t), ge(n), ge(i)), cl(u, l), jn(s);
         }
     };
 }
 
 function R7(e) {
     let t, n, i = (
             /*key*/
@@ -54827,28 +54827,28 @@
         r, s, o = (
             /*value*/
             e[14] + ""
         ),
         a;
     return {
         c() {
-            t = ge("p"), n = ge("b"), r = Si(i), s = Si(": "), a = Si(o);
+            t = he("p"), n = he("b"), r = Si(i), s = Si(": "), a = Si(o);
         },
         m(u, l) {
-            we(u, t, l), $e(t, n), $e(n, r), $e(t, s), $e(t, a);
+            pe(u, t, l), Ce(t, n), Ce(n, r), Ce(t, s), Ce(t, a);
         },
         p(u, l) {
             l & /*selectedMetadata*/
                 16 && i !== (i = /*key*/
                     u[13] + "") && ho(r, i), l & /*selectedMetadata*/
                 16 && o !== (o = /*value*/
                     u[14] + "") && ho(a, o);
         },
         d(u) {
-            u && xe(t);
+            u && ge(t);
         }
     };
 }
 
 function L7(e) {
     let t, n;
     return t = new p_({
@@ -54875,36 +54875,36 @@
             )
         }
     }), {
         c() {
             oi(t.$$.fragment);
         },
         m(i, r) {
-            Bn(t, i, r), n = !0;
+            Un(t, i, r), n = !0;
         },
         p(i, r) {
             const s = {};
             r & /*rows*/
                 32 && (s.rows = /*rows*/
                     i[5]), r & /*sortBy*/
                 2 && (s.sortBy = /*sortBy*/
                     i[1]), r & /*sortOrder*/
                 4 && (s.sortOrder = /*sortOrder*/
                     i[2]), r & /*filterItems*/
                 1 && (s.filterSelections = /*filterItems*/
                     i[0]), t.$set(s);
         },
         i(i) {
-            n || (he(t.$$.fragment, i), n = !0);
+            n || (me(t.$$.fragment, i), n = !0);
         },
         o(i) {
             Se(t.$$.fragment, i), n = !1;
         },
         d(i) {
-            Un(t, i);
+            jn(t, i);
         }
     };
 }
 
 function y_e(e) {
     let t, n, i, r, s, o, a, u, l = (
             /*selectedTitle*/
@@ -54916,39 +54916,39 @@
         ),
         f = (
             /*remount*/
             e[7] && L7(e)
         );
     return {
         c() {
-            t = ge("div"), l && l.c(), n = ct(), i = ge("div"), c && c.c(), r = ct(), s = ge("h3"), s.textContent = "SLICE EXAMPLES", o = ct(), a = ge("div"), f && f.c(), fe(s, "class", "card-title"), fe(a, "class", "highlight-card"), fe(i, "class", "row");
+            t = he("div"), l && l.c(), n = rt(), i = he("div"), c && c.c(), r = rt(), s = he("h3"), s.textContent = "SLICE EXAMPLES", o = rt(), a = he("div"), f && f.c(), fe(s, "class", "card-title"), fe(a, "class", "highlight-card"), fe(i, "class", "row");
         },
         m(d, h) {
-            we(d, t, h), l && l.m(t, null), $e(t, n), $e(t, i), c && c.m(i, null), $e(i, r), $e(i, s), $e(i, o), $e(i, a), f && f.m(a, null), u = !0;
+            pe(d, t, h), l && l.m(t, null), Ce(t, n), Ce(t, i), c && c.m(i, null), Ce(i, r), Ce(i, s), Ce(i, o), Ce(i, a), f && f.m(a, null), u = !0;
         },
         p(d, [h]) {
             /*selectedTitle*/
             d[3] ? l ? l.p(d, h) : (l = O7(d), l.c(), l.m(t, n)) : l && (l.d(1), l = null), /*selectedMetadata*/
                 d[4] ? c ? (c.p(d, h), h & /*selectedMetadata*/
-                    16 && he(c, 1)) : (c = D7(d), c.c(), he(c, 1), c.m(i, r)) : c && (mn(), Se(c, 1, 1, () => {
+                    16 && me(c, 1)) : (c = D7(d), c.c(), me(c, 1), c.m(i, r)) : c && (yn(), Se(c, 1, 1, () => {
                     c = null;
-                }), yn()), /*remount*/
+                }), bn()), /*remount*/
                 d[7] ? f ? (f.p(d, h), h & /*remount*/
-                    128 && he(f, 1)) : (f = L7(d), f.c(), he(f, 1), f.m(a, null)) : f && (mn(), Se(f, 1, 1, () => {
+                    128 && me(f, 1)) : (f = L7(d), f.c(), me(f, 1), f.m(a, null)) : f && (yn(), Se(f, 1, 1, () => {
                     f = null;
-                }), yn());
+                }), bn());
         },
         i(d) {
-            u || (he(c), he(f), u = !0);
+            u || (me(c), me(f), u = !0);
         },
         o(d) {
             Se(c), Se(f), u = !1;
         },
         d(d) {
-            d && xe(t), l && l.d(), c && c.d(), f && f.d();
+            d && ge(t), l && l.d(), c && c.d(), f && f.d();
         }
     };
 }
 
 function b_e(e, t, n) {
     let {
         data: i
@@ -54975,19 +54975,19 @@
         if (m != null && y != null) {
             let v = document.createElement("div"),
                 x = JSON.parse(m);
             n(5, f = x);
             let w = JSON.parse(y);
             n(6, h = w);
             for (var b = 0; b < Object.keys(f[0]).length; b++) {
-                const S = Object.keys(f[0])[b];
+                const E = Object.keys(f[0])[b];
                 d.push({
-                    key: S,
-                    title: S,
-                    value: (_) => _[S],
+                    key: E,
+                    title: E,
+                    value: (_) => _[E],
                     sortable: !0,
                     parseHTML: !0
                 });
             }
             n(7, g = !1), setTimeout(() => n(7, g = !0), 0), s.appendChild(v);
         }
     }
@@ -55069,28 +55069,28 @@
             p = r ?? (t.tickFormat ? t.tickFormat.apply(t, n) : x_e),
             m = Math.max(s, 0) + a,
             y = t.range(),
             b = +y[0] + u,
             v = +y[y.length - 1] + u,
             x = (t.bandwidth ? S_e : E_e)(t.copy(), u),
             w = h.selection ? h.selection() : h,
-            S = w.selectAll(".domain").data([null]),
+            E = w.selectAll(".domain").data([null]),
             _ = w.selectAll(".tick").data(g, t).order(),
             k = _.exit(),
             A = _.enter().append("g").attr("class", "tick"),
-            F = _.select("line"),
-            T = _.select("text");
-        S = S.merge(S.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), _ = _.merge(A), F = F.merge(A.append("line").attr("stroke", "currentColor").attr(c + "2", l * s)), T = T.merge(A.append("text").attr("fill", "currentColor").attr(c, l * m).attr("dy", e === d2 ? "0em" : e === Ww ? "0.71em" : "0.32em")), h !== w && (S = S.transition(h), _ = _.transition(h), F = F.transition(h), T = T.transition(h), k = k.transition(h).attr("opacity", I7).attr("transform", function(I) {
-            return isFinite(I = x(I)) ? f(I + u) : this.getAttribute("transform");
-        }), A.attr("opacity", I7).attr("transform", function(I) {
-            var N = this.parentNode.__axis;
-            return f((N && isFinite(N = N(I)) ? N : x(I)) + u);
-        })), k.remove(), S.attr("d", e === zp || e === h2 ? o ? "M" + l * o + "," + b + "H" + u + "V" + v + "H" + l * o : "M" + u + "," + b + "V" + v : o ? "M" + b + "," + l * o + "V" + u + "H" + v + "V" + l * o : "M" + b + "," + u + "H" + v), _.attr("opacity", 1).attr("transform", function(I) {
-            return f(x(I) + u);
-        }), F.attr(c + "2", l * s), T.attr(c, l * m).text(p), w.filter(k_e).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", e === h2 ? "start" : e === zp ? "end" : "middle"), w.each(function() {
+            T = _.select("line"),
+            M = _.select("text");
+        E = E.merge(E.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), _ = _.merge(A), T = T.merge(A.append("line").attr("stroke", "currentColor").attr(c + "2", l * s)), M = M.merge(A.append("text").attr("fill", "currentColor").attr(c, l * m).attr("dy", e === d2 ? "0em" : e === Ww ? "0.71em" : "0.32em")), h !== w && (E = E.transition(h), _ = _.transition(h), T = T.transition(h), M = M.transition(h), k = k.transition(h).attr("opacity", I7).attr("transform", function(L) {
+            return isFinite(L = x(L)) ? f(L + u) : this.getAttribute("transform");
+        }), A.attr("opacity", I7).attr("transform", function(L) {
+            var F = this.parentNode.__axis;
+            return f((F && isFinite(F = F(L)) ? F : x(L)) + u);
+        })), k.remove(), E.attr("d", e === zp || e === h2 ? o ? "M" + l * o + "," + b + "H" + u + "V" + v + "H" + l * o : "M" + u + "," + b + "V" + v : o ? "M" + b + "," + l * o + "V" + u + "H" + v + "V" + l * o : "M" + b + "," + u + "H" + v), _.attr("opacity", 1).attr("transform", function(L) {
+            return f(x(L) + u);
+        }), T.attr(c + "2", l * s), M.attr(c, l * m).text(p), w.filter(k_e).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", e === h2 ? "start" : e === zp ? "end" : "middle"), w.each(function() {
             this.__axis = x;
         });
     }
     return d.scale = function(h) {
         return arguments.length ? (t = h, d) : t;
     }, d.ticks = function() {
         return n = Array.from(arguments), d;
@@ -55109,15 +55109,15 @@
     }, d.tickPadding = function(h) {
         return arguments.length ? (a = +h, d) : a;
     }, d.offset = function(h) {
         return arguments.length ? (u = +h, d) : u;
     }, d;
 }
 
-function $_e(e) {
+function C_e(e) {
     return A_e(Ww, e);
 }
 var Hw = "http://www.w3.org/1999/xhtml";
 const nf = {
     svg: "http://www.w3.org/2000/svg",
     xhtml: Hw,
     xlink: "http://www.w3.org/1999/xlink",
@@ -55130,15 +55130,15 @@
         n = t.indexOf(":");
     return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), nf.hasOwnProperty(t) ? {
         space: nf[t],
         local: e
     } : e;
 }
 
-function C_e(e) {
+function $_e(e) {
     return function() {
         var t = this.ownerDocument,
             n = this.namespaceURI;
         return n === Hw && t.documentElement.namespaceURI === Hw ? t.createElement(e) : t.createElementNS(n, e);
     };
 }
 
@@ -55146,15 +55146,15 @@
     return function() {
         return this.ownerDocument.createElementNS(e.space, e.local);
     };
 }
 
 function kb(e) {
     var t = Sb(e);
-    return (t.local ? M_e : C_e)(t);
+    return (t.local ? M_e : $_e)(t);
 }
 
 function T_e() {}
 
 function Y6(e) {
     return e == null ? T_e : function() {
         return this.querySelector(e);
@@ -55562,29 +55562,29 @@
 
 function AEe(e) {
     return function() {
         cU(this, e);
     };
 }
 
-function $Ee(e, t) {
+function CEe(e, t) {
     return function() {
         (t.apply(this, arguments) ? lU : cU)(this, e);
     };
 }
 
-function CEe(e, t) {
+function $Ee(e, t) {
     var n = aU(e + "");
     if (arguments.length < 2) {
         for (var i = X6(this.node()), r = -1, s = n.length; ++r < s;)
             if (!i.contains(n[r]))
                 return !1;
         return !0;
     }
-    return this.each((typeof t == "function" ? $Ee : t ? kEe : AEe)(n, t));
+    return this.each((typeof t == "function" ? CEe : t ? kEe : AEe)(n, t));
 }
 
 function MEe() {
     this.textContent = "";
 }
 
 function TEe(e) {
@@ -55819,15 +55819,15 @@
     node: oEe,
     size: aEe,
     empty: uEe,
     each: lEe,
     attr: mEe,
     style: xEe,
     property: SEe,
-    classed: CEe,
+    classed: $Ee,
     text: NEe,
     html: LEe,
     raise: PEe,
     lower: BEe,
     append: UEe,
     insert: qEe,
     remove: HEe,
@@ -55933,18 +55933,18 @@
     function o(l) {
         var c, f, d, h;
         if (n.state !== P7)
             return u();
         for (c in i)
             if (h = i[c], h.name === n.name) {
                 if (h.state === xm)
-                    return EC(o);
+                    return E$(o);
                 h.state === z7 ? (h.state = wm, h.timer.stop(), h.on.call("interrupt", e, e.__data__, h.index, h.group), delete i[c]) : +c < t && (h.state = wm, h.timer.stop(), h.on.call("cancel", e, e.__data__, h.index, h.group), delete i[c]);
             }
-        if (EC(function() {
+        if (E$(function() {
                 n.state === xm && (n.state = z7, n.timer.restart(a, n.delay, n.time), a(l));
             }), n.state = Gw, n.on.call("start", e, e.__data__, n.index, n.group), n.state === Gw) {
             for (n.state = xm, r = new Array(d = n.tween.length), c = 0, f = -1; c < d; ++c)
                 (h = n.tween[c].value.call(e, e.__data__, n.index, n.group)) && (r[++f] = h);
             r.length = f + 1;
         }
     }
@@ -56046,15 +56046,15 @@
         function(r) {
             return Hr(r, i).value[t];
         };
 }
 
 function gU(e, t) {
     var n;
-    return (typeof t == "number" ? Qt : t instanceof Bu ? ba : (n = Bu(t)) ? (t = n, ba) : jE)(e, t);
+    return (typeof t == "number" ? Zt : t instanceof Bu ? ba : (n = Bu(t)) ? (t = n, ba) : jE)(e, t);
 }
 
 function mSe(e) {
     return function() {
         this.removeAttribute(e);
     };
 }
@@ -56135,42 +56135,42 @@
     function r() {
         var s = t.apply(this, arguments);
         return s !== i && (n = (i = s) && ESe(e, s)), n;
     }
     return r._value = t, r;
 }
 
-function $Se(e, t) {
+function CSe(e, t) {
     var n = "attr." + e;
     if (arguments.length < 2)
         return (n = this.tween(n)) && n._value;
     if (t == null)
         return this.tween(n, null);
     if (typeof t != "function")
         throw new Error();
     var i = Sb(e);
     return this.tween(n, (i.local ? kSe : ASe)(i, t));
 }
 
-function CSe(e, t) {
+function $Se(e, t) {
     return function() {
         K6(this, e).delay = +t.apply(this, arguments);
     };
 }
 
 function MSe(e, t) {
     return t = +t,
         function() {
             K6(this, e).delay = t;
         };
 }
 
 function TSe(e) {
     var t = this._id;
-    return arguments.length ? this.each((typeof e == "function" ? CSe : MSe)(t, e)) : Hr(this.node(), t).delay;
+    return arguments.length ? this.each((typeof e == "function" ? $Se : MSe)(t, e)) : Hr(this.node(), t).delay;
 }
 
 function FSe(e, t) {
     return function() {
         Is(this, e).duration = +t.apply(this, arguments);
     };
 }
@@ -56479,15 +56479,15 @@
     nodes: qs.nodes,
     node: qs.node,
     size: qs.size,
     empty: qs.empty,
     each: qs.each,
     on: jSe,
     attr: _Se,
-    attrTween: $Se,
+    attrTween: CSe,
     style: ZSe,
     styleTween: n3e,
     text: s3e,
     textTween: u3e,
     remove: WSe,
     tween: pSe,
     delay: TSe,
@@ -56624,26 +56624,26 @@
     "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
     "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
     "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
     "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
     "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
 ).map(Te);
 const a1 = tt(Xw);
-var $U = new Array(3).concat(
+var CU = new Array(3).concat(
     "fc8d59ffffbf91cf60",
     "d7191cfdae61a6d96a1a9641",
     "d7191cfdae61ffffbfa6d96a1a9641",
     "d73027fc8d59fee08bd9ef8b91cf601a9850",
     "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
     "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
     "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
     "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
     "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
 ).map(Te);
-const CU = tt($U);
+const $U = tt(CU);
 var MU = new Array(3).concat(
     "fc8d59ffffbf99d594",
     "d7191cfdae61abdda42b83ba",
     "d7191cfdae61ffffbfabdda42b83ba",
     "d53e4ffc8d59fee08be6f59899d5943288bd",
     "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
     "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
@@ -56843,36 +56843,36 @@
 
 function yj(e) {
     (e < 0 || e > 1) && (e -= Math.floor(e));
     var t = Math.abs(e - 0.5);
     return Bp.h = 360 * e - 100, Bp.s = 1.5 - 1.5 * t, Bp.l = 0.8 - 0.9 * t, Bp + "";
 }
 var Up = nr(),
-    $3e = Math.PI / 3,
-    C3e = Math.PI * 2 / 3;
+    C3e = Math.PI / 3,
+    $3e = Math.PI * 2 / 3;
 
 function bj(e) {
     var t;
-    return e = (0.5 - e) * Math.PI, Up.r = 255 * (t = Math.sin(e)) * t, Up.g = 255 * (t = Math.sin(e + $3e)) * t, Up.b = 255 * (t = Math.sin(e + C3e)) * t, Up + "";
+    return e = (0.5 - e) * Math.PI, Up.r = 255 * (t = Math.sin(e)) * t, Up.g = 255 * (t = Math.sin(e + C3e)) * t, Up.b = 255 * (t = Math.sin(e + $3e)) * t, Up + "";
 }
 
 function vj(e) {
     return e = Math.max(0, Math.min(1, e)), "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + e * (1172.33 - e * (10793.56 - e * (33300.12 - e * (38394.49 - e * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + e * (557.33 + e * (1225.33 - e * (3574.96 - e * (1073.77 + e * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + e * (3211.1 - e * (15327.97 - e * (27814 - e * (22569.18 - e * 6838.66))))))) + ")";
 }
 
-function $b(e) {
+function Cb(e) {
     var t = e.length;
     return function(n) {
         return e[Math.max(0, Math.min(t - 1, Math.floor(n * t)))];
     };
 }
-const xj = $b(Te("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
-var wj = $b(Te("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf")),
-    _j = $b(Te("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4")),
-    Ej = $b(Te("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
+const xj = Cb(Te("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
+var wj = Cb(Te("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf")),
+    _j = Cb(Te("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4")),
+    Ej = Cb(Te("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
 
 function Bd(e, t, n) {
     this.k = e, this.x = t, this.y = n;
 }
 Bd.prototype = {
     constructor: Bd,
     scale: function(e) {
@@ -56912,15 +56912,15 @@
 Bd.prototype;
 
 function ul(e) {
     return e != null && !Number.isNaN(e);
 }
 
 function _s(e, t) {
-    return +ul(t) - +ul(e) || vn(e, t);
+    return +ul(t) - +ul(e) || xn(e, t);
 }
 
 function u1(e, t) {
     return +ul(t) - +ul(e) || Qh(e, t);
 }
 
 function Sj(e) {
@@ -56954,15 +56954,15 @@
 }
 
 function eo(e, t) {
     return `${e}`.padStart(t, "0");
 }
 const F3e = /^(?:[-+]\d{2})?\d{4}(?:-\d{2}(?:-\d{2})?)?(?:T\d{2}:\d{2}(?::\d{2}(?:\.\d{3})?)?(?:Z|[-+]\d{2}:?\d{2})?)?$/;
 
-function $j(e, t) {
+function Cj(e, t) {
     return F3e.test(e += "") ? new Date(e) : typeof t == "function" ? t(e) : t;
 }
 
 function sf(e) {
     if (e == null)
         return;
     const t = e[0],
@@ -57028,19 +57028,19 @@
         ["friday", Kr],
         ["saturday", Kr],
         ["sunday", Kr],
         ["week", Kr],
         ["month", Fu],
         ["year", Po]
     ]),
-    Cj = /* @__PURE__ */ new Map([
+    $j = /* @__PURE__ */ new Map([
         ["second", xi],
         ["minute", gf],
         ["hour", mf],
-        ["day", Cr],
+        ["day", $r],
         // https://github.com/d3/d3-time/issues/62
         ["monday", ch],
         ["tuesday", RM],
         ["wednesday", LM],
         ["thursday", Ru],
         ["friday", IM],
         ["saturday", PM],
@@ -57062,31 +57062,31 @@
         ["saturday", jM],
         ["sunday", ga],
         ["week", ga],
         ["month", Pu],
         ["year", Zi]
     ]),
     qg = Symbol("intervalDuration"),
-    Cb = Symbol("intervalType");
-for (const [e, t] of Cj)
-    t[qg] = Z6.get(e), t[Cb] = "time";
+    $b = Symbol("intervalType");
+for (const [e, t] of $j)
+    t[qg] = Z6.get(e), t[$b] = "time";
 for (const [e, t] of ek)
-    t[qg] = Z6.get(e), t[Cb] = "utc";
+    t[qg] = Z6.get(e), t[$b] = "utc";
 const Ud = [
         ["year", Zi, "utc"],
         ["month", Pu, "utc"],
         ["day", m1, "utc", 6 * Fu],
         ["hour", yf, "utc", 3 * Es],
         ["minute", pf, "utc", 6 * ta],
         ["second", xi, "utc", 30 * ea]
     ],
     _m = [
         ["year", Qi, "time"],
         ["month", Iu, "time"],
-        ["day", Cr, "time", 6 * Fu],
+        ["day", $r, "time", 6 * Fu],
         ["hour", mf, "time", 3 * Es],
         ["minute", gf, "time", 6 * ta],
         ["second", xi, "time", 30 * ea]
     ],
     N3e = [
         Ud[0],
         _m[0],
@@ -57126,26 +57126,26 @@
 }
 
 function Fj(e) {
     return Nj(Mj(e), "utc");
 }
 
 function Nj([e, t], n) {
-    let i = (n === "time" ? Cj : ek).get(e);
-    return t > 1 && (i = i.every(t), i[qg] = Z6.get(e) * t, i[Cb] = n), i;
+    let i = (n === "time" ? $j : ek).get(e);
+    return t > 1 && (i = i.every(t), i[qg] = Z6.get(e) * t, i[$b] = n), i;
 }
 
 function B7(e, t) {
     if (!(t > 1))
         return;
     const n = e[qg];
     if (!g2.some(([, r]) => r === n) || n % Es === 0 && Es < n && n < Fu)
         return;
     const [i] = g2[fl(([, r]) => Math.log(r)).center(g2, Math.log(n * t))];
-    return (e[Cb] === "time" ? Tj : Fj)(i);
+    return (e[$b] === "time" ? Tj : Fj)(i);
 }
 
 function U7(e, t, n) {
     const i = t === "time" ? b1 : xf;
     if (n == null)
         return i(
             e === "year" ? "%Y" : e === "month" ? "%Y-%m" : e === "day" ? "%Y-%m-%d" : e === "hour" || e === "minute" ? "%Y-%m-%dT%H:%M" : e === "second" ? "%Y-%m-%dT%H:%M:%S" : "%Y-%m-%dT%H:%M:%S.%L"
@@ -57179,15 +57179,15 @@
 }
 
 function D3e(e) {
     return e === "time" ? _m : e === "utc" ? Ud : N3e;
 }
 
 function R3e(e, t, n) {
-    const i = xn(aG(t, (r, s) => Math.abs(s - r)));
+    const i = wn(aG(t, (r, s) => Math.abs(s - r)));
     if (i < 1e3)
         return U7("millisecond", "utc", n);
     for (const [r, s, o, a] of D3e(e)) {
         if (i > a || r === "hour" && !i)
             break;
         if (t.every((u) => s.floor(u) >= u))
             return U7(r, o, n);
@@ -57204,23 +57204,23 @@
 }
 const Wh = Object.getPrototypeOf(Uint8Array),
     L3e = Object.prototype.toString,
     Oj = Symbol("reindex");
 
 function Yi(e, t, n) {
     const i = typeof t;
-    return i === "string" ? j7(e, Dj(t), n) : i === "function" ? j7(e, t, n) : i === "number" || t instanceof Date || i === "boolean" ? Gt(e, Wg(t), n) : typeof(t == null ? void 0 : t.transform) == "function" ? q7(t.transform(e), n) : I3e(q7(t, n), e == null ? void 0 : e[Oj]);
+    return i === "string" ? j7(e, Dj(t), n) : i === "function" ? j7(e, t, n) : i === "number" || t instanceof Date || i === "boolean" ? Vt(e, Wg(t), n) : typeof(t == null ? void 0 : t.transform) == "function" ? q7(t.transform(e), n) : I3e(q7(t, n), e == null ? void 0 : e[Oj]);
 }
 
 function I3e(e, t) {
     return t ? ik(e, t) : e;
 }
 
 function j7(e, t, n) {
-    return Gt(e, (n == null ? void 0 : n.prototype) instanceof Wh ? P3e(t) : t, n);
+    return Vt(e, (n == null ? void 0 : n.prototype) instanceof Wh ? P3e(t) : t, n);
 }
 
 function q7(e, t) {
     return t === void 0 ? Di(e) : e instanceof t ? e : t.prototype instanceof Wh && !(e instanceof Wh) ? t.from(e, tk) : t.from(e);
 }
 
 function P3e(e) {
@@ -57232,39 +57232,39 @@
         transform: Ya
     },
     fr = {
         transform: (e) => e
     },
     z3e = () => 1,
     B3e = () => !0,
-    Rn = (e) => e == null ? e : `${e}`,
-    vt = (e) => e == null ? e : +e,
+    Ln = (e) => e == null ? e : `${e}`,
+    xt = (e) => e == null ? e : +e,
     Lj = (e) => e ? e[0] : void 0,
     U3e = (e) => e ? e[1] : void 0,
     Wg = (e) => () => e;
 
 function j3e(e) {
     const t = +`${e}`.slice(1) / 100;
     return (n, i) => Sc(n, t, i);
 }
 
 function W7(e) {
-    return e instanceof Wh ? e : Gt(e, tk, Float64Array);
+    return e instanceof Wh ? e : Vt(e, tk, Float64Array);
 }
 
 function tk(e) {
     return e == null ? NaN : Number(e);
 }
 
 function q3e(e) {
-    return Gt(e, W3e);
+    return Vt(e, W3e);
 }
 
 function W3e(e) {
-    return e instanceof Date && !isNaN(e) ? e : typeof e == "string" ? $j(e) : e == null || isNaN(e = +e) ? void 0 : new Date(e);
+    return e instanceof Date && !isNaN(e) ? e : typeof e == "string" ? Cj(e) : e == null || isNaN(e = +e) ? void 0 : new Date(e);
 }
 
 function ll(e, t) {
     return e === void 0 && (e = t), e === null ? [void 0, "none"] : Tb(e) ? [void 0, e] : [e, void 0];
 }
 
 function _i(e, t) {
@@ -57283,15 +57283,15 @@
     return i;
 }
 
 function Di(e) {
     return e == null || e instanceof Array || e instanceof Wh ? e : Array.from(e);
 }
 
-function Gt(e, t, n = Array) {
+function Vt(e, t, n = Array) {
     return e == null ? e : e instanceof n ? e.map(t) : n.from(e, t);
 }
 
 function Hh(e, t = Array) {
     return e instanceof t ? e.slice() : t.from(e);
 }
 
@@ -57352,15 +57352,15 @@
         n = new Uint32Array(t);
     for (let i = 0; i < t; ++i)
         n[i] = i;
     return n;
 }
 
 function ik(e, t) {
-    return Gt(t, (n) => e[n], e.constructor);
+    return Vt(t, (n) => e[n], e.constructor);
 }
 
 function X3e(e, t, n) {
     return e.subarray ? e.subarray(t, n) : e.slice(t, n);
 }
 
 function jp(e) {
@@ -57386,23 +57386,23 @@
 }
 
 function J3e(e, t) {
     return {
         transform(n) {
             const i = e.transform(n),
                 r = t.transform(n);
-            return ar(i) || ar(r) ? Gt(i, (s, o) => new Date((+i[o] + +r[o]) / 2)) : Gt(i, (s, o) => (+i[o] + +r[o]) / 2, Float64Array);
+            return ar(i) || ar(r) ? Vt(i, (s, o) => new Date((+i[o] + +r[o]) / 2)) : Vt(i, (s, o) => (+i[o] + +r[o]) / 2, Float64Array);
         },
         label: e.label
     };
 }
 
 function Q3e(e, t) {
     const n = Bj(t == null ? void 0 : t.interval, t == null ? void 0 : t.type);
-    return n ? Gt(e, n) : e;
+    return n ? Vt(e, n) : e;
 }
 
 function Bj(e, t) {
     const n = rk(e, t);
     return n && ((i) => ul(i) ? n.floor(i) : i);
 }
 
@@ -57411,20 +57411,20 @@
         if (typeof e == "number") {
             0 < e && e < 1 && Number.isInteger(1 / e) && (e = -1 / e);
             const n = Math.abs(e);
             return e < 0 ? {
                 floor: (i) => Math.floor(i * n) / n,
                 offset: (i) => (i * n + 1) / n,
                 // note: no optional step for simplicity
-                range: (i, r) => hn(Math.ceil(i * n), r * n).map((s) => s / n)
+                range: (i, r) => gn(Math.ceil(i * n), r * n).map((s) => s / n)
             } : {
                 floor: (i) => Math.floor(i / n) * n,
                 offset: (i) => i + n,
                 // note: no optional step for simplicity
-                range: (i, r) => hn(Math.ceil(i / n), r / n).map((s) => s * n)
+                range: (i, r) => gn(Math.ceil(i / n), r / n).map((s) => s * n)
             };
         }
         if (typeof e == "string")
             return (t === "time" ? Tj : Fj)(e);
         if (typeof e.floor != "function")
             throw new Error("invalid interval; missing floor method");
         if (typeof e.offset != "function")
@@ -57486,15 +57486,15 @@
         if (t != null)
             return t instanceof Date;
 }
 
 function n5e(e) {
     for (const t of e)
         if (t != null)
-            return typeof t == "string" && isNaN(t) && $j(t);
+            return typeof t == "string" && isNaN(t) && Cj(t);
 }
 
 function i5e(e) {
     for (const t of e)
         if (t != null) {
             if (typeof t != "string")
                 return !1;
@@ -57605,15 +57605,15 @@
 const ss = Symbol("position"),
     Fo = Symbol("color"),
     Vg = Symbol("radius"),
     Yg = Symbol("length"),
     Xg = Symbol("opacity"),
     Fb = Symbol("symbol"),
     Wj = Symbol("projection"),
-    wt = /* @__PURE__ */ new Map([
+    _t = /* @__PURE__ */ new Map([
         ["x", ss],
         ["y", ss],
         ["fx", ss],
         ["fy", ss],
         ["r", Vg],
         ["color", Fo],
         ["opacity", Xg],
@@ -57844,19 +57844,19 @@
         case "deviation":
             return Vs(bM);
         case "min":
             return Vs(gs);
         case "min-index":
             return Vs(rG);
         case "max":
-            return Vs(xn);
+            return Vs(wn);
         case "max-index":
             return Vs(iG);
         case "mean":
-            return G7(CM);
+            return G7($M);
         case "median":
             return G7(lh);
         case "variance":
             return Vs(yM);
         case "mode":
             return Vs(oG);
     }
@@ -57955,28 +57955,28 @@
         value: Yi(e, i),
         label: o,
         filter: r,
         hint: s
     });
 }
 
-function $5e(e, t) {
+function C5e(e, t) {
     return Object.fromEntries(
         Object.entries(e).map(([n, i]) => [n, Yh(t, i, n)])
     );
 }
 
-function C5e(e, t) {
+function $5e(e, t) {
     const n = Object.fromEntries(
         Object.entries(e).map(([i, {
             scale: r,
             value: s
         }]) => {
             const o = r == null ? null : t[r];
-            return [i, o == null ? s : Gt(s, o)];
+            return [i, o == null ? s : Vt(s, o)];
         })
     );
     return n.channels = e, n;
 }
 
 function Jj(e, t) {
     const {
@@ -57992,36 +57992,36 @@
                 break;
             case "fillOpacity":
             case "strokeOpacity":
             case "opacity":
                 t.scale = n !== !0 && p2(i, o5e) ? null : "opacity";
                 break;
             case "symbol":
-                n !== !0 && p2(i, p5e) ? (t.scale = null, t.value = Gt(i, ok)) : t.scale = "symbol";
+                n !== !0 && p2(i, p5e) ? (t.scale = null, t.value = Vt(i, ok)) : t.scale = "symbol";
                 break;
             default:
-                t.scale = wt.has(e) ? e : null;
+                t.scale = _t.has(e) ? e : null;
                 break;
         }
     else if (n === !1)
         t.scale = null;
-    else if (n != null && !wt.has(n))
+    else if (n != null && !_t.has(n))
         throw new Error(`unknown scale: ${n}`);
     return t;
 }
 
 function M5e(e, t, n, i, r) {
     const {
         order: s,
         reverse: o,
         reduce: a = !0,
         limit: u
     } = r;
     for (const l in r) {
-        if (!wt.has(l))
+        if (!_t.has(l))
             continue;
         let {
             value: c,
             order: f = s,
             reverse: d = o,
             reduce: h = a,
             limit: g = u
@@ -58039,20 +58039,20 @@
                 let x = Array.from(new fa(y));
                 return d && (x = x.reverse()), (b !== 0 || v !== 1 / 0) && (x = x.slice(b, v)), x;
             };
         else {
             const x = c === "data" ? e : c === "height" ? X7(n, "y1", "y2") : c === "width" ? X7(n, "x1", "x2") : Zw(n, c, c === "y" ? "y2" : c === "x" ? "x2" : void 0),
                 w = b5e(h === !0 ? "max" : h, x);
             m.domain = () => {
-                let S = ZH(
+                let E = ZH(
                     Ya(y),
                     (_) => w.reduceIndex(_, x),
                     (_) => y[_]
                 );
-                return f && S.sort(f), d && S.reverse(), (b !== 0 || v !== 1 / 0) && (S = S.slice(b, v)), S.map(Lj);
+                return f && E.sort(f), d && E.reverse(), (b !== 0 || v !== 1 / 0) && (E = E.slice(b, v)), E.map(Lj);
             };
         }
     }
 }
 
 function T5e(e, t) {
     for (const n in e) {
@@ -58075,15 +58075,15 @@
     }
     return t;
 }
 
 function X7(e, t, n) {
     const i = Zw(e, t),
         r = Zw(e, n);
-    return Gt(r, (s, o) => Math.abs(s - i[o]), Float64Array);
+    return Vt(r, (s, o) => Math.abs(s - i[o]), Float64Array);
 }
 
 function Zw(e, t, n) {
     let i = e[t];
     if (!i && n !== void 0 && (i = e[n]), i)
         return i.value;
     throw new Error(`missing channel: ${t}`);
@@ -58125,15 +58125,15 @@
     } = e;
     return {
         document: t,
         clip: qj(n)
     };
 }
 
-function Vn(e, {
+function Yn(e, {
     document: t
 }) {
     return sh(kb(e).call(t.documentElement));
 }
 let e_ = 0,
     t_;
 
@@ -58197,26 +58197,26 @@
         return;
     l = R5e(l, d, g, c - h, f - p);
     let b = d + s,
         v = g + n,
         x;
     if (u != null) {
         const [
-            [w, S],
+            [w, E],
             [_, k]
-        ] = fy(e).bounds(u), A = Math.min(m / (_ - w), y / (k - S));
-        A > 0 ? (b -= (A * (w + _) - m) / 2, v -= (A * (S + k) - y) / 2, x = jx({
-            point(F, T) {
-                this.stream.point(F * A + b, T * A + v);
+        ] = fy(e).bounds(u), A = Math.min(m / (_ - w), y / (k - E));
+        A > 0 ? (b -= (A * (w + _) - m) / 2, v -= (A * (E + k) - y) / 2, x = jx({
+            point(T, M) {
+                this.stream.point(T * A + b, M * A + v);
             }
         })) : Nu("Warning: the projection could not be fit to the specified domain; using the default scale.");
     }
     return x ?? (x = b === 0 && v === 0 ? nq() : jx({
-        point(w, S) {
-            this.stream.point(w + b, S + v);
+        point(w, E) {
+            this.stream.point(w + b, E + v);
         }
     })), {
         stream: (w) => e.stream(x.stream(l(w)))
     };
 }
 
 function tq(e) {
@@ -58406,54 +58406,54 @@
     ["brbg", Hs(yU, bU)],
     ["prgn", Hs(vU, xU)],
     ["piyg", Hs(wU, _U)],
     ["puor", Hs(EU, SU)],
     ["rdbu", Hs(Yw, o1)],
     ["rdgy", Hs(kU, AU)],
     ["rdylbu", Hs(Xw, a1)],
-    ["rdylgn", Hs($U, CU)],
+    ["rdylgn", Hs(CU, $U)],
     ["spectral", Hs(MU, TU)],
     // reversed diverging (for temperature data)
     ["burd", Z7(Yw, o1)],
     ["buylrd", Z7(Xw, a1)],
     // sequential (single-hue)
-    ["blues", Rt(tj, nj)],
-    ["greens", Rt(ij, rj)],
-    ["greys", Rt(sj, oj)],
-    ["oranges", Rt(fj, dj)],
-    ["purples", Rt(aj, uj)],
-    ["reds", Rt(lj, cj)],
+    ["blues", Lt(tj, nj)],
+    ["greens", Lt(ij, rj)],
+    ["greys", Lt(sj, oj)],
+    ["oranges", Lt(fj, dj)],
+    ["purples", Lt(aj, uj)],
+    ["reds", Lt(lj, cj)],
     // sequential (multi-hue)
     ["turbo", Gs(vj)],
     ["viridis", Gs(xj)],
     ["magma", Gs(wj)],
     ["inferno", Gs(_j)],
     ["plasma", Gs(Ej)],
     ["cividis", Gs(hj)],
     ["cubehelix", Gs(gj)],
     ["warm", Gs(pj)],
     ["cool", Gs(mj)],
-    ["bugn", Rt(FU, NU)],
-    ["bupu", Rt(OU, DU)],
-    ["gnbu", Rt(RU, LU)],
-    ["orrd", Rt(IU, PU)],
-    ["pubu", Rt(UU, jU)],
-    ["pubugn", Rt(zU, BU)],
-    ["purd", Rt(qU, WU)],
-    ["rdpu", Rt(HU, GU)],
-    ["ylgn", Rt(XU, KU)],
-    ["ylgnbu", Rt(VU, YU)],
-    ["ylorbr", Rt(JU, QU)],
-    ["ylorrd", Rt(ZU, ej)],
+    ["bugn", Lt(FU, NU)],
+    ["bupu", Lt(OU, DU)],
+    ["gnbu", Lt(RU, LU)],
+    ["orrd", Lt(IU, PU)],
+    ["pubu", Lt(UU, jU)],
+    ["pubugn", Lt(zU, BU)],
+    ["purd", Lt(qU, WU)],
+    ["rdpu", Lt(HU, GU)],
+    ["ylgn", Lt(XU, KU)],
+    ["ylgnbu", Lt(VU, YU)],
+    ["ylorbr", Lt(JU, QU)],
+    ["ylorrd", Lt(ZU, ej)],
     // cyclical
     ["rainbow", e9(yj)],
     ["sinebow", e9(bj)]
 ]);
 
-function Rt(e, t) {
+function Lt(e, t) {
     return ({
         length: n
     }) => n === 1 ? [e[3][1]] : n === 2 ? [e[3][1], e[3][2]] : (n = Math.max(3, Math.floor(n)), n > 9 ? ir(t, n) : e[n]);
 }
 
 function Hs(e, t) {
     return ({
@@ -58512,15 +58512,15 @@
     ["brbg", bU],
     ["prgn", xU],
     ["piyg", _U],
     ["puor", SU],
     ["rdbu", o1],
     ["rdgy", AU],
     ["rdylbu", a1],
-    ["rdylgn", CU],
+    ["rdylgn", $U],
     ["spectral", TU],
     // reversed diverging (for temperature data)
     ["burd", (e) => o1(1 - e)],
     ["buylrd", (e) => a1(1 - e)],
     // sequential (single-hue)
     ["blues", nj],
     ["greens", rj],
@@ -58578,20 +58578,20 @@
 function W5e(e) {
     return e != null && q5e.has(`${e}`.toLowerCase());
 }
 const sq = (e) => (t) => e(1 - t),
     b2 = [0, 1],
     n9 = /* @__PURE__ */ new Map([
         // numbers
-        ["number", Qt],
+        ["number", Zt],
         // color spaces
         ["rgb", ba],
-        ["hsl", $N],
+        ["hsl", CN],
         ["hcl", TN],
-        ["lab", CN]
+        ["lab", $N]
     ]);
 
 function oq(e) {
     const t = `${e}`.toLowerCase();
     if (!n9.has(t))
         throw new Error(`unknown interpolator: ${t}`);
     return n9.get(t);
@@ -58603,16 +58603,16 @@
     clamp: s,
     zero: o,
     domain: a = uq(e, n),
     unknown: u,
     round: l,
     scheme: c,
     interval: f,
-    range: d = wt.get(e) === Vg ? t6e(n, a) : wt.get(e) === Yg ? n6e(n, a) : wt.get(e) === Xg ? b2 : void 0,
-    interpolate: h = wt.get(e) === Fo ? c == null && d !== void 0 ? ba : uk(c !== void 0 ? c : i === "cyclical" ? "rainbow" : "turbo") : l ? Ef : Qt,
+    range: d = _t.get(e) === Vg ? t6e(n, a) : _t.get(e) === Yg ? n6e(n, a) : _t.get(e) === Xg ? b2 : void 0,
+    interpolate: h = _t.get(e) === Fo ? c == null && d !== void 0 ? ba : uk(c !== void 0 ? c : i === "cyclical" ? "rainbow" : "turbo") : l ? Ef : Zt,
     reverse: g
 }) {
     if (f = Gg(f, i), (i === "cyclical" || i === "sequential") && (i = "linear"), typeof h != "function" && (h = oq(h)), g = !!g, d !== void 0) {
         const p = (a = Di(a)).length,
             m = (d = Di(d)).length;
         if (p !== m) {
             if (h.length === 1)
@@ -58684,15 +58684,15 @@
     n: r = i,
     scheme: s = "rdylbu",
     domain: o = r6e(t),
     unknown: a,
     interpolate: u,
     reverse: l
 }) {
-    return n === void 0 && (n = u !== void 0 ? ir(u, r) : wt.get(e) === Fo ? Nb(s, r) : void 0), o.length > 0 && (o = XE(o, n === void 0 ? {
+    return n === void 0 && (n = u !== void 0 ? ir(u, r) : _t.get(e) === Fo ? Nb(s, r) : void 0), o.length > 0 && (o = XE(o, n === void 0 ? {
         length: r
     } : n).quantiles()), lk(e, t, {
         domain: o,
         range: n,
         reverse: l,
         unknown: a
     });
@@ -58705,29 +58705,29 @@
     domain: s = uq(e, t),
     unknown: o,
     interpolate: a,
     reverse: u
 }) {
     const [l, c] = ia(s);
     let f;
-    return n === void 0 ? (f = Fm(l, c, i), f[0] <= l && f.splice(0, 1), f[f.length - 1] >= c && f.pop(), i = f.length + 1, n = a !== void 0 ? ir(a, i) : wt.get(e) === Fo ? Nb(r, i) : void 0) : (f = ir(Qt(l, c), i + 1).slice(1, -1), l instanceof Date && (f = f.map((d) => new Date(d)))), sf(Di(s)) < 0 && f.reverse(), lk(e, t, {
+    return n === void 0 ? (f = Fm(l, c, i), f[0] <= l && f.splice(0, 1), f[f.length - 1] >= c && f.pop(), i = f.length + 1, n = a !== void 0 ? ir(a, i) : _t.get(e) === Fo ? Nb(r, i) : void 0) : (f = ir(Zt(l, c), i + 1).slice(1, -1), l instanceof Date && (f = f.map((d) => new Date(d)))), sf(Di(s)) < 0 && f.reverse(), lk(e, t, {
         domain: f,
         range: n,
         reverse: u,
         unknown: o
     });
 }
 
 function lk(e, t, {
     domain: n = [0],
     // explicit thresholds in ascending order
     unknown: i,
     scheme: r = "rdylbu",
     interpolate: s,
-    range: o = s !== void 0 ? ir(s, n.length + 1) : wt.get(e) === Fo ? Nb(r, n.length + 1) : void 0,
+    range: o = s !== void 0 ? ir(s, n.length + 1) : _t.get(e) === Fo ? Nb(r, n.length + 1) : void 0,
     reverse: a
 }) {
     n = Di(n);
     const u = sf(n);
     if (!isNaN(u) && !Q5e(n, u))
         throw new Error(`the ${e} scale has a non-monotonic domain`);
     return a && (o = Nm(o)), {
@@ -58746,60 +58746,60 @@
     }
     return !0;
 }
 
 function Z5e(e) {
     return {
         type: "identity",
-        scale: f5e(wt.get(e)) ? qE() : (t) => t
+        scale: f5e(_t.get(e)) ? qE() : (t) => t
     };
 }
 
 function Xh(e, t = kj) {
     return e.length ? [
         gs(e, ({
             value: n
         }) => n === void 0 ? n : gs(n, t)),
-        xn(e, ({
+        wn(e, ({
             value: n
-        }) => n === void 0 ? n : xn(n, t))
+        }) => n === void 0 ? n : wn(n, t))
     ] : [0, 1];
 }
 
 function uq(e, t) {
-    const n = wt.get(e);
+    const n = _t.get(e);
     return (n === Vg || n === Xg || n === Yg ? e6e : Xh)(t);
 }
 
 function e6e(e) {
-    return [0, e.length ? xn(e, ({
+    return [0, e.length ? wn(e, ({
         value: t
-    }) => t === void 0 ? t : xn(t, kj)) : 1];
+    }) => t === void 0 ? t : wn(t, kj)) : 1];
 }
 
 function t6e(e, t) {
     const n = e.find(({
         radius: o
     }) => o !== void 0);
     if (n !== void 0)
         return [0, n.radius];
     const i = Sc(e, 0.5, ({
             value: o
         }) => o === void 0 ? NaN : Sc(o, 0.25, Q6)),
         r = t.map((o) => 3 * Math.sqrt(o / i)),
-        s = 30 / xn(r);
+        s = 30 / wn(r);
     return s < 1 ? r.map((o) => o * s) : r;
 }
 
 function n6e(e, t) {
     const n = lh(e, ({
             value: s
         }) => s === void 0 ? NaN : lh(s, Math.abs)),
         i = t.map((s) => 12 * s / n),
-        r = 60 / xn(i);
+        r = 60 / wn(i);
     return r < 1 ? i.map((s) => s * r) : i;
 }
 
 function i6e(e) {
     for (const {
             value: t
         }
@@ -58836,15 +58836,15 @@
     clamp: o,
     domain: a = Xh(i),
     unknown: u,
     pivot: l = 0,
     scheme: c,
     range: f,
     symmetric: d = !0,
-    interpolate: h = wt.get(e) === Fo ? c == null && f !== void 0 ? ba : uk(c !== void 0 ? c : "rdbu") : Qt,
+    interpolate: h = _t.get(e) === Fo ? c == null && f !== void 0 ? ba : uk(c !== void 0 ? c : "rdbu") : Zt,
     reverse: g
 }) {
     l = +l, a = Di(a);
     let [p, m] = a;
     if (a.length > 2 && Nu(`Warning: the diverging ${e} scale domain contains extra elements.`), Qh(p, m) < 0 && ([p, m] = [m, p], g = !g), p = Math.min(p, l), m = Math.max(m, l), typeof h != "function" && (h = oq(h)), f !== void 0 && (h = h.length === 1 ? ck(h)(...f) : Sf(h, f)), g && (h = sq(h)), d) {
         const y = n.apply(l),
             b = y - n.apply(p),
@@ -58987,17 +58987,17 @@
     range: s,
     scheme: o,
     unknown: a,
     ...u
 }) {
     i = Gg(i, n), r === void 0 && (r = hq(t, i, e));
     let l;
-    if (wt.get(e) === Fb)
-        l = v6e(t), s = s === void 0 ? x6e(l) : Gt(s, ok);
-    else if (wt.get(e) === Fo && (s === void 0 && (n === "ordinal" || n === Jg) && (s = j5e(r, o), s !== void 0 && (o = void 0)), o === void 0 && s === void 0 && (o = n === "ordinal" ? "turbo" : "observable10"), o !== void 0))
+    if (_t.get(e) === Fb)
+        l = v6e(t), s = s === void 0 ? x6e(l) : Vt(s, ok);
+    else if (_t.get(e) === Fo && (s === void 0 && (n === "ordinal" || n === Jg) && (s = j5e(r, o), s !== void 0 && (o = void 0)), o === void 0 && s === void 0 && (o = n === "ordinal" ? "turbo" : "observable10"), o !== void 0))
         if (s !== void 0) {
             const c = uk(o),
                 f = s[0],
                 d = s[1] - s[0];
             s = ({
                 length: h
             }) => ir((g) => c(f + d * g), h);
@@ -59057,15 +59057,15 @@
             for (const o of r)
                 i.add(o);
     }
     if (t !== void 0) {
         const [r, s] = ia(i).map(t.floor, t);
         return t.range(r, t.offset(s));
     }
-    if (i.size > 1e4 && wt.get(n) === ss)
+    if (i.size > 1e4 && _t.get(n) === ss)
         throw new Error(`implicit ordinal domain of ${n} scale has more than 10,000 values`);
     return B2(i, _s);
 }
 
 function i9(e, t) {
     let n;
     for (const {
@@ -59113,44 +59113,44 @@
     } = {},
     ...p
 } = {}) {
     const m = {};
     for (const [y, b] of e) {
         const v = p[y],
             x = k6e(y, b, {
-                round: wt.get(y) === ss ? a : void 0,
+                round: _t.get(y) === ss ? a : void 0,
                 // only for position
                 nice: u,
                 clamp: l,
                 zero: c,
                 align: f,
                 padding: d,
                 projection: h,
                 ...v
             });
         if (x) {
             let {
                 label: w = y === "fx" || y === "fy" ? g : t,
-                percent: S,
+                percent: E,
                 transform: _,
                 inset: k,
                 insetTop: A = k !== void 0 ? k : y === "y" ? i : 0,
                 // not fy
-                insetRight: F = k !== void 0 ? k : y === "x" ? r : 0,
+                insetRight: T = k !== void 0 ? k : y === "x" ? r : 0,
                 // not fx
-                insetBottom: T = k !== void 0 ? k : y === "y" ? s : 0,
+                insetBottom: M = k !== void 0 ? k : y === "y" ? s : 0,
                 // not fy
-                insetLeft: I = k !== void 0 ? k : y === "x" ? o : 0
+                insetLeft: L = k !== void 0 ? k : y === "x" ? o : 0
                 // not fx
             } = v || {};
             if (_ == null)
                 _ = void 0;
             else if (typeof _ != "function")
                 throw new Error("invalid scale transform; not a function");
-            x.percent = !!S, x.label = w === void 0 ? _6e(b, x) : w, x.transform = _, y === "x" || y === "fx" ? (x.insetLeft = +I, x.insetRight = +F) : (y === "y" || y === "fy") && (x.insetTop = +A, x.insetBottom = +T), m[y] = x;
+            x.percent = !!E, x.label = w === void 0 ? _6e(b, x) : w, x.transform = _, y === "x" || y === "fx" ? (x.insetLeft = +L, x.insetRight = +T) : (y === "y" || y === "fy") && (x.insetTop = +A, x.insetBottom = +M), m[y] = x;
         }
     }
     return m;
 }
 
 function r9(e) {
     const t = {},
@@ -59282,15 +59282,15 @@
         } = t, a = s + n, u = r - o - i;
         e.range = [Math.max(a, u), a], Nl(e) ? e.range.reverse() : e.range = mq(e), e.scale.range(e.range);
     }
     pq(e);
 }
 
 function pq(e) {
-    e.round === void 0 && $6e(e) && S6e(e) <= 30 && e.scale.round(!0);
+    e.round === void 0 && C6e(e) && S6e(e) <= 30 && e.scale.round(!0);
 }
 
 function S6e({
     scale: e
 }) {
     const t = e.domain().length,
         [n, i] = e.range(),
@@ -59353,20 +59353,20 @@
         case "quantile":
         case "pow":
         case "log":
         case "symlog":
             n = Wp(t, n, W7);
             break;
         case "identity":
-            switch (wt.get(e)) {
+            switch (_t.get(e)) {
                 case ss:
                     n = Wp(t, n, W7);
                     break;
                 case Fb:
-                    n = Wp(t, n, C6e);
+                    n = Wp(t, n, $6e);
                     break;
             }
             break;
         case "utc":
         case "time":
             n = Wp(t, n, q3e);
             break;
@@ -59456,15 +59456,15 @@
         return;
     if (n !== void 0)
         return n;
     if (i === void 0 && !t.some(({
             value: l
         }) => l !== void 0))
         return;
-    const u = wt.get(e);
+    const u = _t.get(e);
     if (u === Vg)
         return "sqrt";
     if (u === Xg || u === Yg)
         return "linear";
     if (u === Fb)
         return "ordinal";
     if ((i || r || []).length > 2)
@@ -59511,15 +59511,15 @@
 
 function yq({
     type: e
 }) {
     return e === "threshold";
 }
 
-function $6e({
+function C6e({
     type: e
 }) {
     return e === "point" || e === "band";
 }
 
 function of(e) {
     if (e === void 0)
@@ -59541,21 +59541,21 @@
         s.value !== void 0 && (t === void 0 && (t = (r = s.value) == null ? void 0 : r.domain), s.value = i(s.value));
     return {
         domain: t === void 0 ? t : i(t),
         ...n
     };
 }
 
-function C6e(e) {
-    return Gt(e, ok);
+function $6e(e) {
+    return Vt(e, ok);
 }
 
 function M6e(e) {
     return (t) => {
-        if (!wt.has(t = `${t}`))
+        if (!_t.has(t = `${t}`))
             throw new Error(`unknown scale: ${t}`);
         return e[t];
     };
 }
 
 function T6e({
     scale: e,
@@ -59656,15 +59656,15 @@
 
 function D6e(e) {
     return M3e(e, "Invalid Date");
 }
 
 function R6e(e = "en-US") {
     const t = O6e(e);
-    return (n) => (n instanceof Date ? D6e : typeof n == "number" ? t : Rn)(n);
+    return (n) => (n instanceof Date ? D6e : typeof n == "number" ? t : Ln)(n);
 }
 const af = R6e(),
     Ei = (typeof window < "u" ? window.devicePixelRatio > 1 : typeof it > "u") ? 0 : 0.5;
 let L6e = 0;
 
 function l9() {
     return `plot-clip-${++L6e}`;
@@ -59688,33 +59688,33 @@
     strokeDasharray: p,
     strokeDashoffset: m,
     opacity: y,
     mixBlendMode: b,
     imageFilter: v,
     paintOrder: x,
     pointerEvents: w,
-    shapeRendering: S,
+    shapeRendering: E,
     channels: _
 }, {
     ariaLabel: k,
     fill: A = "currentColor",
-    fillOpacity: F,
-    stroke: T = "none",
-    strokeOpacity: I,
-    strokeWidth: N,
-    strokeLinecap: D,
-    strokeLinejoin: M,
-    strokeMiterlimit: E,
-    paintOrder: $
-}) {
-    A === null && (a = null, u = null), T === null && (l = null, f = null), ti(A) ? !ti(T) && (!ti(a) || _ != null && _.fill) && (T = "none") : ti(T) && (!ti(l) || _ != null && _.stroke) && (A = "none");
-    const [C, O] = ll(a, A), [R, L] = _i(u, F), [P, z] = ll(l, T), [V, X] = _i(f, I), [se, ee] = _i(y);
-    Vh(z) || (c === void 0 && (c = N), h === void 0 && (h = D), d === void 0 && (d = M), g === void 0 && !a5e(d) && (g = E), !Vh(O) && x === void 0 && (x = $));
-    const [ue, G] = _i(c);
-    return A !== null && (e.fill = Kt(O, "currentColor"), e.fillOpacity = gd(L, 1)), T !== null && (e.stroke = Kt(z, "none"), e.strokeWidth = gd(G, 1), e.strokeOpacity = gd(X, 1), e.strokeLinejoin = Kt(d, "miter"), e.strokeLinecap = Kt(h, "butt"), e.strokeMiterlimit = gd(g, 4), e.strokeDasharray = Kt(p, "none"), e.strokeDashoffset = Kt(m, "0")), e.target = Rn(o), e.ariaLabel = Rn(k), e.ariaDescription = Rn(r), e.ariaHidden = Rn(s), e.opacity = gd(ee, 1), e.mixBlendMode = Kt(b, "normal"), e.imageFilter = Kt(v, "none"), e.paintOrder = Kt(x, "normal"), e.pointerEvents = Kt(w, "auto"), e.shapeRendering = Kt(S, "auto"), {
+    fillOpacity: T,
+    stroke: M = "none",
+    strokeOpacity: L,
+    strokeWidth: F,
+    strokeLinecap: O,
+    strokeLinejoin: N,
+    strokeMiterlimit: R,
+    paintOrder: P
+}) {
+    A === null && (a = null, u = null), M === null && (l = null, f = null), ti(A) ? !ti(M) && (!ti(a) || _ != null && _.fill) && (M = "none") : ti(M) && (!ti(l) || _ != null && _.stroke) && (A = "none");
+    const [S, $] = ll(a, A), [C, D] = _i(u, T), [I, z] = ll(l, M), [H, G] = _i(f, L), [te, K] = _i(y);
+    Vh(z) || (c === void 0 && (c = F), h === void 0 && (h = O), d === void 0 && (d = N), g === void 0 && !a5e(d) && (g = R), !Vh($) && x === void 0 && (x = P));
+    const [ae, U] = _i(c);
+    return A !== null && (e.fill = Jt($, "currentColor"), e.fillOpacity = gd(D, 1)), M !== null && (e.stroke = Jt(z, "none"), e.strokeWidth = gd(U, 1), e.strokeOpacity = gd(G, 1), e.strokeLinejoin = Jt(d, "miter"), e.strokeLinecap = Jt(h, "butt"), e.strokeMiterlimit = gd(g, 4), e.strokeDasharray = Jt(p, "none"), e.strokeDashoffset = Jt(m, "0")), e.target = Ln(o), e.ariaLabel = Ln(k), e.ariaDescription = Ln(r), e.ariaHidden = Ln(s), e.opacity = gd(K, 1), e.mixBlendMode = Jt(b, "normal"), e.imageFilter = Jt(v, "none"), e.paintOrder = Jt(x, "normal"), e.pointerEvents = Jt(w, "auto"), e.shapeRendering = Jt(E, "auto"), {
         title: {
             value: t,
             optional: !0,
             filter: null
         },
         href: {
             value: n,
@@ -59723,39 +59723,39 @@
         },
         ariaLabel: {
             value: i,
             optional: !0,
             filter: null
         },
         fill: {
-            value: C,
+            value: S,
             scale: "auto",
             optional: !0
         },
         fillOpacity: {
-            value: R,
+            value: C,
             scale: "auto",
             optional: !0
         },
         stroke: {
-            value: P,
+            value: I,
             scale: "auto",
             optional: !0
         },
         strokeOpacity: {
-            value: V,
+            value: H,
             scale: "auto",
             optional: !0
         },
         strokeWidth: {
-            value: ue,
+            value: ae,
             optional: !0
         },
         opacity: {
-            value: se,
+            value: te,
             scale: "auto",
             optional: !0
         }
     };
 }
 
 function P6e(e, t) {
@@ -59794,15 +59794,15 @@
                 width: o,
                 height: a,
                 marginLeft: u,
                 marginRight: l,
                 marginTop: c,
                 marginBottom: f
             } = n, d = l9();
-            r = `url(#${d})`, e = Vn("svg:g", i).call(
+            r = `url(#${d})`, e = Yn("svg:g", i).call(
                 (h) => h.append("svg:clipPath").attr("id", d).append("rect").attr("x", u).attr("y", c).attr("width", o - l - u).attr("height", a - c - f)
             ).each(function() {
                 this.appendChild(e.node()), e.node = () => this;
             });
             break;
         }
         case "sphere": {
@@ -59854,21 +59854,21 @@
 function Rl(e, t, {
     x: n,
     y: i
 }, r = Ei, s = Ei) {
     r += t.dx, s += t.dy, n != null && n.bandwidth && (r += n.bandwidth() / 2), i != null && i.bandwidth && (s += i.bandwidth() / 2), (r || s) && e.attr("transform", `translate(${r},${s})`);
 }
 
-function Kt(e, t) {
-    if ((e = Rn(e)) !== t)
+function Jt(e, t) {
+    if ((e = Ln(e)) !== t)
         return e;
 }
 
 function gd(e, t) {
-    if ((e = vt(e)) !== t)
+    if ((e = xt(e)) !== t)
         return e;
 }
 const q6e = /^-?([_a-z]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])([_a-z0-9-]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])*$/i;
 
 function dk(e) {
     if (e === void 0)
         return "plot-d6a7b5";
@@ -60128,15 +60128,15 @@
         return t;
     throw new Error(`invalid facet anchor: ${e}`);
 }
 const f9 = /* @__PURE__ */ new WeakMap();
 
 function i_(e) {
     let t = f9.get(e);
-    return t || f9.set(e, t = new Ou(Gt(e, (n, i) => [n, i]))), t;
+    return t || f9.set(e, t = new Ou(Vt(e, (n, i) => [n, i]))), t;
 }
 
 function Xa(e, t) {
     return i_(e).get(t);
 }
 
 function Q6e(e, t, n) {
@@ -60298,70 +60298,70 @@
         if (this.data = t, this.sort = Gh(l) ? l : null, this.initializer = l1(i).initializer, this.transform = this.initializer ? i.transform : Vj(i).transform, s === null || s === !1 ? this.facet = null : (this.facet = Gr(s === !0 ? "include" : s, "facet", ["auto", "include", "exclude", "super"]), this.fx = t === Em && typeof a == "string" ? [a] : a, this.fy = t === Em && typeof u == "string" ? [u] : u), this.facetAnchor = J6e(o), n = jj(n), b !== void 0 && (n = {
                 ...rke(b),
                 ...n
             }), r !== void 0 && (n = {
                 ...I6e(this, i, r),
                 ...n
             }), this.channels = Object.fromEntries(
-                Object.entries(n).map(([w, S]) => {
-                    if (nk(S.value)) {
+                Object.entries(n).map(([w, E]) => {
+                    if (nk(E.value)) {
                         const {
                             value: _,
-                            label: k = S.label,
-                            scale: A = S.scale
-                        } = S.value;
-                        S = {
-                            ...S,
+                            label: k = E.label,
+                            scale: A = E.scale
+                        } = E.value;
+                        E = {
+                            ...E,
                             label: k,
                             scale: A,
                             value: _
                         };
                     }
-                    if (t === Em && typeof S.value == "string") {
+                    if (t === Em && typeof E.value == "string") {
                         const {
                             value: _
-                        } = S;
-                        S = {
-                            ...S,
+                        } = E;
+                        E = {
+                            ...E,
                             value: [_]
                         };
                     }
-                    return [w, S];
+                    return [w, E];
                 }).filter(([w, {
-                    value: S,
+                    value: E,
                     optional: _
                 }]) => {
-                    if (S != null)
+                    if (E != null)
                         return !0;
                     if (_)
                         return !1;
                     throw new Error(`missing channel value: ${w}`);
                 })
             ), this.dx = +c, this.dy = +f, this.marginTop = +h, this.marginRight = +g, this.marginBottom = +p, this.marginLeft = +m, this.clip = qj(y), this.tip = ske(v), this.facet === "super") {
             if (a || u)
                 throw new Error("super-faceting cannot use fx or fy");
             for (const w in this.channels) {
                 const {
-                    scale: S
+                    scale: E
                 } = n[w];
-                if (!(S !== "x" && S !== "y"))
+                if (!(E !== "x" && E !== "y"))
                     throw new Error("super-faceting cannot use x or y");
             }
         }
         x != null && (this.render = vq(x, this.render));
     }
     initialize(t, n, i) {
         let r = Di(this.data);
         t === void 0 && r != null && (t = [Ya(r)]);
         const s = t;
         this.transform != null && ({
             facets: t,
             data: r
         } = this.transform(r, t, i), r = Di(r)), t !== void 0 && (t.original = s);
-        const o = $5e(this.channels, r);
+        const o = C5e(this.channels, r);
         return this.sort != null && M5e(r, t, o, n, this.sort), {
             data: r,
             facets: t,
             channels: o
         };
     }
     filter(t, n, i) {
@@ -60387,15 +60387,15 @@
         for (const r in t)
             if (t[r].scale === "x" && /^x|x$/.test(r)) {
                 const s = r.replace(/^x|x$/, "y");
                 s in t && t[s].scale === "y" && I5e(r, s, n, i.projection);
             }
     }
     scale(t, n, i) {
-        const r = C5e(t, n);
+        const r = $5e(t, n);
         return i.projection && this.project(t, r, i), r;
     }
 }
 
 function bq(...e) {
     return e.plot = Ps.prototype.plot, e;
 }
@@ -60489,101 +60489,101 @@
                 roots: [],
                 renders: []
             });
             let v = b.renders.push(z) - 1;
             const {
                 x,
                 y: w,
-                fx: S,
+                fx: E,
                 fy: _
             } = f;
-            let k = S ? S(c.fx) - h.marginLeft : 0,
+            let k = E ? E(c.fx) - h.marginLeft : 0,
                 A = _ ? _(c.fy) - h.marginTop : 0;
             x != null && x.bandwidth && (k += x.bandwidth() / 2), w != null && w.bandwidth && (A += w.bandwidth() / 2);
-            const F = c.fi != null;
-            let T;
-            if (F) {
-                let ee = b.facetStates;
-                ee || (b.facetStates = ee = /* @__PURE__ */ new Map()), T = ee.get(this), T || ee.set(this, T = /* @__PURE__ */ new Map());
-            }
-            const [I, N] = Db(this, h), {
-                px: D,
-                py: M
-            } = d, E = D ? (ee) => D[ee] : xq(d, I), $ = M ? (ee) => M[ee] : wq(d, N);
-            let C, O, R, L;
-
-            function P(ee, ue) {
-                if (F)
-                    if (L && (L = cancelAnimationFrame(L)), ee == null)
-                        T.delete(c.fi);
+            const T = c.fi != null;
+            let M;
+            if (T) {
+                let K = b.facetStates;
+                K || (b.facetStates = K = /* @__PURE__ */ new Map()), M = K.get(this), M || K.set(this, M = /* @__PURE__ */ new Map());
+            }
+            const [L, F] = Db(this, h), {
+                px: O,
+                py: N
+            } = d, R = O ? (K) => O[K] : xq(d, L), P = N ? (K) => N[K] : wq(d, F);
+            let S, $, C, D;
+
+            function I(K, ae) {
+                if (T)
+                    if (D && (D = cancelAnimationFrame(D)), K == null)
+                        M.delete(c.fi);
                     else {
-                        T.set(c.fi, ue), L = requestAnimationFrame(() => {
-                            L = null;
-                            for (const [G, ae] of T)
-                                if (ae < ue || ae === ue && G < c.fi) {
-                                    ee = null;
+                        M.set(c.fi, ae), D = requestAnimationFrame(() => {
+                            D = null;
+                            for (const [U, ie] of M)
+                                if (ie < ae || ie === ae && U < c.fi) {
+                                    K = null;
                                     break;
                                 }
-                            z(ee);
+                            z(K);
                         });
                         return;
                     }
-                z(ee);
+                z(K);
             }
 
-            function z(ee) {
-                if (C === ee && R === b.sticky)
+            function z(K) {
+                if (S === K && C === b.sticky)
                     return;
-                C = ee, R = g.pointerSticky = b.sticky;
-                const ue = C == null ? [] : [C];
-                F && (ue.fx = c.fx, ue.fy = c.fy, ue.fi = c.fi);
-                const G = p(ue, f, d, h, g);
-                if (O) {
-                    if (F) {
-                        const ae = O.parentNode,
-                            ce = O.getAttribute("transform"),
-                            H = G.getAttribute("transform");
-                        ce ? G.setAttribute("transform", ce) : G.removeAttribute("transform"), H ? ae.setAttribute("transform", H) : ae.removeAttribute("transform"), G.removeAttribute("aria-label"), G.removeAttribute("aria-description"), G.removeAttribute("aria-hidden");
+                S = K, C = g.pointerSticky = b.sticky;
+                const ae = S == null ? [] : [S];
+                T && (ae.fx = c.fx, ae.fy = c.fy, ae.fi = c.fi);
+                const U = p(ae, f, d, h, g);
+                if ($) {
+                    if (T) {
+                        const ie = $.parentNode,
+                            le = $.getAttribute("transform"),
+                            Y = U.getAttribute("transform");
+                        le ? U.setAttribute("transform", le) : U.removeAttribute("transform"), Y ? ie.setAttribute("transform", Y) : ie.removeAttribute("transform"), U.removeAttribute("aria-label"), U.removeAttribute("aria-description"), U.removeAttribute("aria-hidden");
                     }
-                    O.replaceWith(G);
+                    $.replaceWith(U);
                 }
-                return b.roots[v] = O = G, C == null && (T == null ? void 0 : T.size) > 1 || g.dispatchValue(C == null ? null : y[C]), G;
+                return b.roots[v] = $ = U, S == null && (M == null ? void 0 : M.size) > 1 || g.dispatchValue(S == null ? null : y[S]), U;
             }
 
-            function V(ee) {
-                if (b.sticky || ee.pointerType === "mouse" && ee.buttons === 1)
+            function H(K) {
+                if (b.sticky || K.pointerType === "mouse" && K.buttons === 1)
                     return;
-                let [ue, G] = aSe(ee);
-                ue -= k, G -= A;
-                const ae = ue < h.marginLeft || ue > h.width - h.marginRight ? 1 : e,
-                    ce = G < h.marginTop || G > h.height - h.marginBottom ? 1 : t;
-                let H = null,
+                let [ae, U] = aSe(K);
+                ae -= k, U -= A;
+                const ie = ae < h.marginLeft || ae > h.width - h.marginRight ? 1 : e,
+                    le = U < h.marginTop || U > h.height - h.marginBottom ? 1 : t;
+                let Y = null,
                     Be = o * o;
                 for (const Ee of c) {
-                    const Ve = ae * (E(Ee) - ue),
-                        st = ce * ($(Ee) - G),
-                        An = Ve * Ve + st * st;
-                    An <= Be && (H = Ee, Be = An);
-                }
-                if (H != null && (e !== 1 || t !== 1)) {
-                    const Ee = E(H) - ue,
-                        Ve = $(H) - G;
+                    const Ve = ie * (R(Ee) - ae),
+                        ot = le * (P(Ee) - U),
+                        Cn = Ve * Ve + ot * ot;
+                    Cn <= Be && (Y = Ee, Be = Cn);
+                }
+                if (Y != null && (e !== 1 || t !== 1)) {
+                    const Ee = R(Y) - ae,
+                        Ve = P(Y) - U;
                     Be = Ee * Ee + Ve * Ve;
                 }
-                P(H, Be);
+                I(Y, Be);
             }
 
-            function X(ee) {
-                ee.pointerType === "mouse" && C != null && (b.sticky && b.roots.some((ue) => ue == null ? void 0 : ue.contains(ee.target)) || (b.sticky ? (b.sticky = !1, b.renders.forEach((ue) => ue(null))) : (b.sticky = !0, z(C)), ee.stopImmediatePropagation()));
+            function G(K) {
+                K.pointerType === "mouse" && S != null && (b.sticky && b.roots.some((ae) => ae == null ? void 0 : ae.contains(K.target)) || (b.sticky ? (b.sticky = !1, b.renders.forEach((ae) => ae(null))) : (b.sticky = !0, z(S)), K.stopImmediatePropagation()));
             }
 
-            function se(ee) {
-                ee.pointerType === "mouse" && (b.sticky || P(null));
+            function te(K) {
+                K.pointerType === "mouse" && (b.sticky || I(null));
             }
-            return m.addEventListener("pointerenter", V), m.addEventListener("pointermove", V), m.addEventListener("pointerdown", X), m.addEventListener("pointerleave", se), z(null);
+            return m.addEventListener("pointerenter", H), m.addEventListener("pointermove", H), m.addEventListener("pointerdown", G), m.addEventListener("pointerleave", te), z(null);
         }, u)
     };
 }
 
 function oke(e) {
     return mk(1, 1, e);
 }
@@ -60632,67 +60632,67 @@
         fontVariant: h = _q(e),
         round: g = !0,
         opacity: p,
         className: m
     } = t;
     const y = ak(t);
     m = dk(m), p = _i(p)[1], d === null && (d = () => null);
-    const b = Vn("svg", y).attr("class", `${m}-ramp`).attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("width", r).attr("height", s).attr("viewBox", `0 0 ${r} ${s}`).call(
-        (I) => (
+    const b = Yn("svg", y).attr("class", `${m}-ramp`).attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("width", r).attr("height", s).attr("viewBox", `0 0 ${r} ${s}`).call(
+        (L) => (
             // Warning: if you edit this, change defaultClassName.
-            I.append("style").text(
+            L.append("style").text(
                 `:where(.${m}-ramp) {
   display: block;
   height: auto;
   height: intrinsic;
   max-width: 100%;
   overflow: visible;
 }
 :where(.${m}-ramp text) {
   white-space: pre;
 }`
             )
         )
     ).call(hk, c);
-    let v = (I) => I.selectAll(".tick line").attr("y1", o + u - s),
+    let v = (L) => L.selectAll(".tick line").attr("y1", o + u - s),
         x;
-    const w = g ? (I, N) => I.rangeRound(N) : (I, N) => I.range(N),
+    const w = g ? (L, F) => L.rangeRound(F) : (L, F) => L.range(F),
         {
-            type: S,
+            type: E,
             domain: _,
             range: k,
             interpolate: A,
-            scale: F,
-            pivot: T
+            scale: T,
+            pivot: M
         } = e;
     if (A) {
-        const I = k === void 0 ? A : Sf(A.length === 1 ? ck(A) : A, k);
+        const L = k === void 0 ? A : Sf(A.length === 1 ? ck(A) : A, k);
         x = w(
-            F.copy(),
+            T.copy(),
             ir(
-                Qt(l, r - a),
-                Math.min(_.length + (T !== void 0), k === void 0 ? 1 / 0 : k.length)
+                Zt(l, r - a),
+                Math.min(_.length + (M !== void 0), k === void 0 ? 1 / 0 : k.length)
             )
         );
-        const N = 256,
-            D = y.document.createElement("canvas");
-        D.width = N, D.height = 1;
-        const M = D.getContext("2d");
-        for (let E = 0, $ = N - 1; E < N; ++E)
-            M.fillStyle = I(E / $), M.fillRect(E, 0, 1, 1);
-        b.append("image").attr("opacity", p).attr("x", l).attr("y", o).attr("width", r - l - a).attr("height", s - o - u).attr("preserveAspectRatio", "none").attr("xlink:href", D.toDataURL());
-    } else if (S === "threshold") {
-        const I = _,
-            N = d === void 0 ? (D) => D : typeof d == "string" ? dl(d) : d;
-        x = w(q1().domain([-1, k.length - 1]), [l, r - a]), b.append("g").attr("fill-opacity", p).selectAll().data(k).enter().append("rect").attr("x", (D, M) => x(M - 1)).attr("y", o).attr("width", (D, M) => x(M) - x(M - 1)).attr("height", s - o - u).attr("fill", (D) => D), f = Gt(I, (D, M) => M), d = (D) => N(I[D], D);
+        const F = 256,
+            O = y.document.createElement("canvas");
+        O.width = F, O.height = 1;
+        const N = O.getContext("2d");
+        for (let R = 0, P = F - 1; R < F; ++R)
+            N.fillStyle = L(R / P), N.fillRect(R, 0, 1, 1);
+        b.append("image").attr("opacity", p).attr("x", l).attr("y", o).attr("width", r - l - a).attr("height", s - o - u).attr("preserveAspectRatio", "none").attr("xlink:href", O.toDataURL());
+    } else if (E === "threshold") {
+        const L = _,
+            F = d === void 0 ? (O) => O : typeof d == "string" ? dl(d) : d;
+        x = w(q1().domain([-1, k.length - 1]), [l, r - a]), b.append("g").attr("fill-opacity", p).selectAll().data(k).enter().append("rect").attr("x", (O, N) => x(N - 1)).attr("y", o).attr("width", (O, N) => x(N) - x(N - 1)).attr("height", s - o - u).attr("fill", (O) => O), f = Vt(L, (O, N) => N), d = (O) => F(L[O], O);
     } else
-        x = w(I1().domain(_), [l, r - a]), b.append("g").attr("fill-opacity", p).selectAll().data(_).enter().append("rect").attr("x", x).attr("y", o).attr("width", Math.max(0, x.bandwidth() - 1)).attr("height", s - o - u).attr("fill", F), v = () => {};
+        x = w(I1().domain(_), [l, r - a]), b.append("g").attr("fill-opacity", p).selectAll().data(_).enter().append("rect").attr("x", x).attr("y", o).attr("width", Math.max(0, x.bandwidth() - 1)).attr("height", s - o - u).attr("fill", T), v = () => {};
     return b.append("g").attr("transform", `translate(0,${s - u})`).call(
-        $_e(x).ticks(Array.isArray(f) ? null : f, typeof d == "string" ? d : void 0).tickFormat(typeof d == "function" ? d : void 0).tickSize(i).tickValues(Array.isArray(f) ? f : null)
-    ).attr("font-size", null).attr("font-family", null).attr("font-variant", Kt(h, "normal")).call(v).call((I) => I.select(".domain").remove()), n !== void 0 && b.append("text").attr("x", l).attr("y", o - 6).attr("fill", "currentColor").attr("font-weight", "bold").text(n), b.node();
+        C_e(x).ticks(Array.isArray(f) ? null : f, typeof d == "string" ? d : void 0).tickFormat(typeof d == "function" ? d : void 0).tickSize(i).tickValues(Array.isArray(f) ? f : null)
+    ).attr("font-size", null).attr("font-family", null).attr("font-variant", Jt(h, "normal")).call(v).call((L) => L.select(".domain").remove()), n !== void 0 && b.append("text").attr("x", l).attr("y", o - 6).attr("fill", "currentColor").attr("font-weight", "bold").text(n), b.node();
 }
 const Eq = Math.PI / 180;
 
 function Sq(e, {
     marker: t,
     markerStart: n = t,
     markerMid: i = t,
@@ -60729,31 +60729,31 @@
         case "tick-y":
             return A2(0);
     }
     throw new Error(`invalid marker: ${e}`);
 }
 
 function g9(e) {
-    return (t, n) => Vn("svg:marker", n).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("orient", e).attr("fill", "none").attr("stroke", t).attr("stroke-width", 1.5).attr("stroke-linecap", "round").attr("stroke-linejoin", "round").call((i) => i.append("path").attr("d", "M-1.5,-3l3,3l-3,3")).node();
+    return (t, n) => Yn("svg:marker", n).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("orient", e).attr("fill", "none").attr("stroke", t).attr("stroke-width", 1.5).attr("stroke-linecap", "round").attr("stroke-linejoin", "round").call((i) => i.append("path").attr("d", "M-1.5,-3l3,3l-3,3")).node();
 }
 
 function lke(e, t) {
-    return Vn("svg:marker", t).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", e).attr("stroke", "none").call((n) => n.append("circle").attr("r", 2.5)).node();
+    return Yn("svg:marker", t).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", e).attr("stroke", "none").call((n) => n.append("circle").attr("r", 2.5)).node();
 }
 
 function p9(e, t) {
-    return Vn("svg:marker", t).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", e).attr("stroke", "var(--plot-background)").attr("stroke-width", 1.5).call((n) => n.append("circle").attr("r", 3)).node();
+    return Yn("svg:marker", t).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", e).attr("stroke", "var(--plot-background)").attr("stroke-width", 1.5).call((n) => n.append("circle").attr("r", 3)).node();
 }
 
 function cke(e, t) {
-    return Vn("svg:marker", t).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", "var(--plot-background)").attr("stroke", e).attr("stroke-width", 1.5).call((n) => n.append("circle").attr("r", 3)).node();
+    return Yn("svg:marker", t).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", "var(--plot-background)").attr("stroke", e).attr("stroke-width", 1.5).call((n) => n.append("circle").attr("r", 3)).node();
 }
 
 function A2(e) {
-    return (t, n) => Vn("svg:marker", n).attr("viewBox", "-3 -3 6 6").attr("markerWidth", 6).attr("markerHeight", 6).attr("orient", e).attr("stroke", t).call((i) => i.append("path").attr("d", "M0,-3v6")).node();
+    return (t, n) => Yn("svg:marker", n).attr("viewBox", "-3 -3 6 6").attr("markerWidth", 6).attr("markerHeight", 6).attr("orient", e).attr("stroke", t).call((i) => i.append("path").attr("d", "M0,-3v6")).node();
 }
 let fke = 0;
 
 function kq(e, t, {
     stroke: n
 }, i) {
     return dke(e, t, n && ((r) => n[r]), i);
@@ -60786,37 +60786,37 @@
 
 function Aq({
     inset: e,
     insetLeft: t,
     insetRight: n,
     ...i
 } = {}) {
-    return [t, n] = Cq(e, t, n), {
+    return [t, n] = $q(e, t, n), {
         inset: e,
         insetLeft: t,
         insetRight: n,
         ...i
     };
 }
 
-function $q({
+function Cq({
     inset: e,
     insetTop: t,
     insetBottom: n,
     ...i
 } = {}) {
-    return [t, n] = Cq(e, t, n), {
+    return [t, n] = $q(e, t, n), {
         inset: e,
         insetTop: t,
         insetBottom: n,
         ...i
     };
 }
 
-function Cq(e, t, n) {
+function $q(e, t, n) {
     return e === void 0 && t === void 0 && n === void 0 ? Ei ? [1, 0] : [0.5, 0.5] : [t, n];
 }
 
 function Mq(e, {
     interval: t
 }) {
     return e = {
@@ -60846,15 +60846,15 @@
             [`${e}1`]: s === void 0 ? g : s,
             [`${e}2`]: o === void 0 && !(s === o && i) ? g : o
         };
     }
     let c, f;
 
     function d(h) {
-        return f !== void 0 && h === c ? f : f = Gt(Yi(c = h, a), (g) => u.floor(g));
+        return f !== void 0 && h === c ? f : f = Vt(Yi(c = h, a), (g) => u.floor(g));
     }
     return t({
         ...n,
         [e]: void 0,
         [`${e}1`]: s === void 0 ? {
             transform: d,
             label: l
@@ -60874,38 +60874,38 @@
         interval: s
     } = Mq(i, n);
     return r == null || s == null ? n : t({
         ...n,
         [e]: {
             label: Hg(i),
             transform: (o) => {
-                const a = Gt(Yi(o, r), (l) => s.floor(l)),
+                const a = Vt(Yi(o, r), (l) => s.floor(l)),
                     u = a.map((l) => s.offset(l));
                 return a.map(
                     ar(a) ? (l, c) => l == null || isNaN(l = +l) || (c = u[c], c == null) || isNaN(c = +c) ? void 0 : new Date((l + c) / 2) : (l, c) => l == null || (c = u[c], c == null) ? NaN : (+l + +c) / 2
                 );
             }
         }
     });
 }
 
 function hke(e = {}) {
     return Tq("x", Aq, e);
 }
 
 function Nq(e = {}) {
-    return Tq("y", $q, e);
+    return Tq("y", Cq, e);
 }
 
 function gke(e = {}) {
     return Fq("x", Aq, e);
 }
 
 function pke(e = {}) {
-    return Fq("y", $q, e);
+    return Fq("y", Cq, e);
 }
 const Oq = {
     ariaLabel: "rule",
     fill: null,
     stroke: "currentColor"
 };
 class mke extends Ps {
@@ -60934,15 +60934,15 @@
                     value: s,
                     scale: "y",
                     optional: !0
                 }
             },
             pk(n, "x"),
             Oq
-        ), this.insetTop = vt(a), this.insetBottom = vt(u), Sq(this, n);
+        ), this.insetTop = xt(a), this.insetBottom = xt(u), Sq(this, n);
     }
     render(t, n, i, r, s) {
         const {
             x: o,
             y: a
         } = n, {
             x: u,
@@ -60955,15 +60955,15 @@
             marginRight: g,
             marginLeft: p,
             marginBottom: m
         } = r, {
             insetTop: y,
             insetBottom: b
         } = this;
-        return Vn("svg:g", s).call(Ol, this, r, s).call(Rl, this, {
+        return Yn("svg:g", s).call(Ol, this, r, s).call(Rl, this, {
             x: u && o
         }, Ei, 0).call(
             (v) => v.selectAll().data(t).enter().append("line").call(Dl, this).attr("x1", u ? (x) => u[x] : (p + f - g) / 2).attr("x2", u ? (x) => u[x] : (p + f - g) / 2).attr("y1", l && !of(a) ? (x) => l[x] + y : h + y).attr(
                 "y2",
                 c && !of(a) ? a.bandwidth ? (x) => c[x] + a.bandwidth() - b : (x) => c[x] - b : d - m - b
             ).call(zf, this, i).call(kq, this, i, s)
         ).node();
@@ -60995,15 +60995,15 @@
                     value: r,
                     scale: "x",
                     optional: !0
                 }
             },
             pk(n, "y"),
             Oq
-        ), this.insetRight = vt(a), this.insetLeft = vt(u), Sq(this, n);
+        ), this.insetRight = xt(a), this.insetLeft = xt(u), Sq(this, n);
     }
     render(t, n, i, r, s) {
         const {
             x: o,
             y: a
         } = n, {
             y: u,
@@ -61016,15 +61016,15 @@
             marginRight: g,
             marginLeft: p,
             marginBottom: m
         } = r, {
             insetLeft: y,
             insetRight: b
         } = this;
-        return Vn("svg:g", s).call(Ol, this, r, s).call(Rl, this, {
+        return Yn("svg:g", s).call(Ol, this, r, s).call(Rl, this, {
             y: u && a
         }, 0, Ei).call(
             (v) => v.selectAll().data(t).enter().append("line").call(Dl, this).attr("x1", l && !of(o) ? (x) => l[x] + y : p + y).attr(
                 "x2",
                 c && !of(o) ? o.bandwidth ? (x) => c[x] + o.bandwidth() - b : (x) => c[x] - b : f - g - b
             ).attr("y1", u ? (x) => u[x] : (h + d - m) / 2).attr("y2", u ? (x) => u[x] : (h + d - m) / 2).call(zf, this, i).call(kq, this, i, s)
         ).node();
@@ -61112,15 +61112,15 @@
             monospace: d,
             fontFamily: h = d ? "ui-monospace, monospace" : void 0,
             fontSize: g,
             fontStyle: p,
             fontVariant: m,
             fontWeight: y,
             rotate: b
-        } = n, [v, x] = _i(b, 0), [w, S] = Ake(g);
+        } = n, [v, x] = _i(b, 0), [w, E] = Ake(g);
         if (super(
                 t, {
                     x: {
                         value: i,
                         scale: "x",
                         optional: !0
                     },
@@ -61141,15 +61141,15 @@
                         value: s,
                         filter: Sj,
                         optional: !0
                     }
                 },
                 n,
                 xke
-            ), this.rotate = x, this.textAnchor = Kt(a, "middle"), this.lineAnchor = Gr(u, "lineAnchor", ["top", "middle", "bottom"]), this.lineHeight = +l, this.lineWidth = +c, this.textOverflow = Iq(f), this.monospace = !!d, this.fontFamily = Rn(h), this.fontSize = S, this.fontStyle = Rn(p), this.fontVariant = Rn(m), this.fontWeight = Rn(y), this.frameAnchor = sk(o), !(this.lineWidth >= 0))
+            ), this.rotate = x, this.textAnchor = Jt(a, "middle"), this.lineAnchor = Gr(u, "lineAnchor", ["top", "middle", "bottom"]), this.lineHeight = +l, this.lineWidth = +c, this.textOverflow = Iq(f), this.monospace = !!d, this.fontFamily = Ln(h), this.fontSize = E, this.fontStyle = Ln(p), this.fontVariant = Ln(m), this.fontWeight = Ln(y), this.frameAnchor = sk(o), !(this.lineWidth >= 0))
             throw new Error(`invalid lineWidth: ${c}`);
         this.splitLines = Bq(this), this.clipLine = Uq(this);
     }
     render(t, n, i, r, s) {
         const {
             x: o,
             y: a
@@ -61159,15 +61159,15 @@
             rotate: c,
             text: f,
             title: d,
             fontSize: h
         } = i, {
             rotate: g
         } = this, [p, m] = Db(this, r);
-        return Vn("svg:g", s).call(Ol, this, r, s).call(zq, this, f, r).call(Rl, this, {
+        return Yn("svg:g", s).call(Ol, this, r, s).call(zq, this, f, r).call(Rl, this, {
             x: u && o,
             y: l && a
         }).call(
             (y) => y.selectAll().data(t).enter().append("text").call(Dl, this).call(wke, this, f, d).attr(
                 "transform",
                 Rq`translate(${u ? (b) => u[b] : p},${l ? (b) => l[b] : m})${c ? (b) => ` rotate(${c[b]})` : g ? ` rotate(${g})` : ""}`
             ).call(Re, "font-size", h && ((b) => h[b])).call(zf, this, i)
@@ -61279,28 +61279,28 @@
     "smaller"
 ]);
 
 function Ake(e) {
     return e == null || typeof e == "number" ? [void 0, e] : typeof e != "string" ? [e, void 0] : (e = e.trim().toLowerCase(), kke.has(e) || /^[+-]?\d*\.?\d+(e[+-]?\d+)?(\w*|%)$/.test(e) ? [void 0, e] : [e, void 0]);
 }
 
-function $ke(e, t, n) {
+function Cke(e, t, n) {
     const i = [];
     let r, s = 0;
-    for (const [o, a, u] of Cke(e)) {
+    for (const [o, a, u] of $ke(e)) {
         if (r === void 0 && (r = o), s > r && n(e, r, a) > t && (i.push(e.slice(r, s) + (e[s - 1] === Lq ? "-" : "")), r = o), u) {
             i.push(e.slice(r, a)), r = void 0;
             continue;
         }
         s = a;
     }
     return i;
 }
 
-function* Cke(e) {
+function* $ke(e) {
     let t = 0,
         n = 0;
     const i = e.length;
     for (; n < i;) {
         let r = 1;
         switch (e[n]) {
             case Lq:
@@ -61428,15 +61428,15 @@
     lineWidth: t,
     textOverflow: n
 }) {
     if (n != null || t == 1 / 0)
         return (s) => s.split(/\r\n?|\n/g);
     const i = e ? vk : bk,
         r = t * 100;
-    return (s) => $ke(s, r, i);
+    return (s) => Cke(s, r, i);
 }
 
 function Uq({
     monospace: e,
     lineWidth: t,
     textOverflow: n
 }) {
@@ -61621,15 +61621,15 @@
         } = i, {
             length: d,
             rotate: h,
             anchor: g,
             shape: p,
             r: m
         } = this, [y, b] = Db(this, r);
-        return Vn("svg:g", s).call(Ol, this, r, s).call(Rl, this, {
+        return Yn("svg:g", s).call(Ol, this, r, s).call(Rl, this, {
             x: u && o,
             y: l && a
         }).call(
             (v) => v.selectAll().data(t).enter().append("path").call(Dl, this).attr(
                 "transform",
                 Rq`translate(${u ? (x) => u[x] : y},${l ? (x) => l[x] : b})${f ? (x) => ` rotate(${f[x]})` : h ? ` rotate(${h})` : ""}${g === "start" ? "" : g === "end" ? c ? (x) => ` translate(0,${c[x]})` : ` translate(0,${d})` : c ? (x) => ` translate(0,${c[x] / 2})` : ` translate(0,${d / 2})`}`
             ).attr(
@@ -61730,31 +61730,31 @@
     tickPadding: p,
     tickRotate: m,
     x: y,
     margin: b,
     marginTop: v = b === void 0 ? 20 : b,
     marginRight: x = b === void 0 ? t === "right" ? 40 : 0 : b,
     marginBottom: w = b === void 0 ? 20 : b,
-    marginLeft: S = b === void 0 ? t === "left" ? 40 : 0 : b,
+    marginLeft: E = b === void 0 ? t === "left" ? 40 : 0 : b,
     label: _,
     labelAnchor: k,
     labelArrow: A,
-    labelOffset: F,
-    ...T
+    labelOffset: T,
+    ...M
 }) {
-    return g = vt(g), p = vt(p), m = vt(m), k !== void 0 && (k = Gr(k, "labelAnchor", ["center", "top", "bottom"])), A = aW(A), bq(
+    return g = xt(g), p = xt(p), m = xt(m), k !== void 0 && (k = Gr(k, "labelAnchor", ["center", "top", "bottom"])), A = aW(A), bq(
         g && !ti(s) ? qke(e, t, n, {
             stroke: s,
             strokeOpacity: o,
             strokeWidth: a,
             tickSize: g,
             tickPadding: p,
             tickRotate: m,
             x: y,
-            ...T
+            ...M
         }) : null,
         ti(u) ? null : Hke(e, t, n, {
             fill: u,
             fillOpacity: l,
             stroke: f,
             strokeOpacity: d,
             strokeWidth: h,
@@ -61762,43 +61762,43 @@
             tickSize: g,
             tickPadding: p,
             tickRotate: m,
             x: y,
             marginTop: v,
             marginRight: x,
             marginBottom: w,
-            marginLeft: S,
-            ...T
+            marginLeft: E,
+            ...M
         }),
         !ti(u) && _ !== null ? Pq(
             [],
             iW({
                 fill: u,
                 fillOpacity: l,
-                ...T
-            }, function(I, N, D, M, E) {
-                const $ = M[e],
+                ...M
+            }, function(L, F, O, N, R) {
+                const P = N[e],
                     {
-                        marginTop: C,
-                        marginRight: O,
-                        marginBottom: R,
-                        marginLeft: L
-                    } = e === "y" && E.inset || E,
-                    P = k ?? ($.bandwidth ? "center" : "top"),
-                    z = F ?? (t === "right" ? O : L) - 3;
-                return P === "center" ? (this.textAnchor = void 0, this.lineAnchor = t === "right" ? "bottom" : "top", this.frameAnchor = t, this.rotate = -90) : (this.textAnchor = t === "right" ? "end" : "start", this.lineAnchor = P, this.frameAnchor = `${P}-${t}`, this.rotate = 0), this.dy = P === "top" ? 3 - C : P === "bottom" ? R - 3 : 0, this.dx = t === "right" ? z : -z, this.ariaLabel = `${e}-axis label`, {
+                        marginTop: S,
+                        marginRight: $,
+                        marginBottom: C,
+                        marginLeft: D
+                    } = e === "y" && R.inset || R,
+                    I = k ?? (P.bandwidth ? "center" : "top"),
+                    z = T ?? (t === "right" ? $ : D) - 3;
+                return I === "center" ? (this.textAnchor = void 0, this.lineAnchor = t === "right" ? "bottom" : "top", this.frameAnchor = t, this.rotate = -90) : (this.textAnchor = t === "right" ? "end" : "start", this.lineAnchor = I, this.frameAnchor = `${I}-${t}`, this.rotate = 0), this.dy = I === "top" ? 3 - S : I === "bottom" ? C - 3 : 0, this.dx = t === "right" ? z : -z, this.ariaLabel = `${e}-axis label`, {
                     facets: [
                         [0]
                     ],
                     channels: {
                         text: {
-                            value: [oW(e, $, {
+                            value: [oW(e, P, {
                                 anchor: t,
                                 label: _,
-                                labelAnchor: P,
+                                labelAnchor: I,
                                 labelArrow: A
                             })]
                         }
                     }
                 };
             })
         ) : null
@@ -61821,31 +61821,31 @@
     tickPadding: p,
     tickRotate: m,
     y,
     margin: b,
     marginTop: v = b === void 0 ? t === "top" ? 30 : 0 : b,
     marginRight: x = b === void 0 ? 20 : b,
     marginBottom: w = b === void 0 ? t === "bottom" ? 30 : 0 : b,
-    marginLeft: S = b === void 0 ? 20 : b,
+    marginLeft: E = b === void 0 ? 20 : b,
     label: _,
     labelAnchor: k,
     labelArrow: A,
-    labelOffset: F,
-    ...T
+    labelOffset: T,
+    ...M
 }) {
-    return g = vt(g), p = vt(p), m = vt(m), k !== void 0 && (k = Gr(k, "labelAnchor", ["center", "left", "right"])), A = aW(A), bq(
+    return g = xt(g), p = xt(p), m = xt(m), k !== void 0 && (k = Gr(k, "labelAnchor", ["center", "left", "right"])), A = aW(A), bq(
         g && !ti(s) ? Wke(e, t, n, {
             stroke: s,
             strokeOpacity: o,
             strokeWidth: a,
             tickSize: g,
             tickPadding: p,
             tickRotate: m,
             y,
-            ...T
+            ...M
         }) : null,
         ti(u) ? null : Gke(e, t, n, {
             fill: u,
             fillOpacity: l,
             stroke: f,
             strokeOpacity: d,
             strokeWidth: h,
@@ -61853,43 +61853,43 @@
             tickSize: g,
             tickPadding: p,
             tickRotate: m,
             y,
             marginTop: v,
             marginRight: x,
             marginBottom: w,
-            marginLeft: S,
-            ...T
+            marginLeft: E,
+            ...M
         }),
         !ti(u) && _ !== null ? Pq(
             [],
             iW({
                 fill: u,
                 fillOpacity: l,
-                ...T
-            }, function(I, N, D, M, E) {
-                const $ = M[e],
+                ...M
+            }, function(L, F, O, N, R) {
+                const P = N[e],
                     {
-                        marginTop: C,
-                        marginRight: O,
-                        marginBottom: R,
-                        marginLeft: L
-                    } = e === "x" && E.inset || E,
-                    P = k ?? ($.bandwidth ? "center" : "right"),
-                    z = F ?? (t === "top" ? C : R) - 3;
-                return P === "center" ? (this.frameAnchor = t, this.textAnchor = void 0) : (this.frameAnchor = `${t}-${P}`, this.textAnchor = P === "right" ? "end" : "start"), this.lineAnchor = t, this.dy = t === "top" ? -z : z, this.dx = P === "right" ? O - 3 : P === "left" ? 3 - L : 0, this.ariaLabel = `${e}-axis label`, {
+                        marginTop: S,
+                        marginRight: $,
+                        marginBottom: C,
+                        marginLeft: D
+                    } = e === "x" && R.inset || R,
+                    I = k ?? (P.bandwidth ? "center" : "right"),
+                    z = T ?? (t === "top" ? S : C) - 3;
+                return I === "center" ? (this.frameAnchor = t, this.textAnchor = void 0) : (this.frameAnchor = `${t}-${I}`, this.textAnchor = I === "right" ? "end" : "start"), this.lineAnchor = t, this.dy = t === "top" ? -z : z, this.dx = I === "right" ? $ - 3 : I === "left" ? 3 - D : 0, this.ariaLabel = `${e}-axis label`, {
                     facets: [
                         [0]
                     ],
                     channels: {
                         text: {
-                            value: [oW(e, $, {
+                            value: [oW(e, P, {
                                 anchor: t,
                                 label: _,
-                                labelAnchor: P,
+                                labelAnchor: I,
                                 labelArrow: A
                             })]
                         }
                     }
                 };
             })
         ) : null
@@ -61998,16 +61998,16 @@
             lineAnchor: c,
             fontVariant: f,
             rotate: o,
             y: m,
             ...y,
             dx: t === "left" ? +p - s - a + +h : +p + +s + +a - g
         },
-        function(b, v, x, w, S) {
-            f === void 0 && (this.fontVariant = sW(b)), u === void 0 && (S.text = rW(b, v, x, w, t));
+        function(b, v, x, w, E) {
+            f === void 0 && (this.fontVariant = sW(b)), u === void 0 && (E.text = rW(b, v, x, w, t));
         }
     );
 }
 
 function Gke(e, t, n, {
     facetAnchor: i = t + (e === "x" ? "-empty" : ""),
     frameAnchor: r = t,
@@ -62038,16 +62038,16 @@
             lineAnchor: c,
             fontVariant: f,
             rotate: o,
             x: m,
             ...y,
             dy: t === "bottom" ? +p + +s + +a - g : +p - s - a + +h
         },
-        function(b, v, x, w, S) {
-            f === void 0 && (this.fontVariant = sW(b)), u === void 0 && (S.text = rW(b, v, x, w, t));
+        function(b, v, x, w, E) {
+            f === void 0 && (this.fontVariant = sW(b)), u === void 0 && (E.text = rW(b, v, x, w, t));
         }
     );
 }
 
 function Zq() {
     const [e, t] = Ka(...arguments);
     return eW("y", Vq(t), e, t);
@@ -62163,34 +62163,34 @@
         if (!y)
             throw new Error(`missing scale: ${t}`);
         const b = y.domain();
         let {
             interval: v,
             ticks: x,
             tickFormat: w,
-            tickSpacing: S = t === "x" ? 80 : 35
+            tickSpacing: E = t === "x" ? 80 : 35
         } = r;
-        if (typeof x == "string" && uW(y) && (v = x, x = void 0), x === void 0 && (x = Gg(v, y.type) ?? Kke(y, S)), c == null) {
+        if (typeof x == "string" && uW(y) && (v = x, x = void 0), x === void 0 && (x = Gg(v, y.type) ?? Kke(y, E)), c == null) {
             if (Fl(x))
                 c = Di(x);
             else if (e5e(x))
-                c = $2(x, ...ia(b));
+                c = C2(x, ...ia(b));
             else if (y.interval) {
                 let k = y.interval;
                 if (y.ticks) {
-                    const [A, F] = ia(b), T = (F - A) / k[qg];
-                    k = B7(k, T / x) ?? k, c = $2(k, A, F);
+                    const [A, T] = ia(b), M = (T - A) / k[qg];
+                    k = B7(k, M / x) ?? k, c = C2(k, A, T);
                 } else {
                     c = b;
                     const A = c.length;
-                    k = B7(k, A / x) ?? k, k !== y.interval && (c = $2(k, ...ia(c)));
+                    k = B7(k, A / x) ?? k, k !== y.interval && (c = C2(k, ...ia(c)));
                 }
                 if (k === y.interval) {
                     const A = Math.round(c.length / x);
-                    A > 1 && (c = c.filter((F, T) => T % A === 0));
+                    A > 1 && (c = c.filter((T, M) => M % A === 0));
                 }
             } else
                 y.ticks ? c = y.ticks(x) : c = b;
             if (!y.ticks && c.length && c !== b) {
                 const k = new fa(b);
                 c = c.filter((A) => k.has(A)), c.length || Nu(`Warning: the ${t}-axis ticks appear to not align with the scale domain, resulting in no ticks. Try different ticks?`);
             }
@@ -62231,15 +62231,15 @@
     };
 }
 
 function _k(e, t, n, i, r) {
     return typeof i == "function" ? i : i === void 0 && t && ar(t) ? R3e(e.type, t, r) ?? af : e.tickFormat ? e.tickFormat(typeof n == "number" ? n : null, i) : i === void 0 ? af : typeof i == "string" ? (ar(e.domain()) ? xf : dl)(i) : Wg(i);
 }
 
-function $2(e, t, n) {
+function C2(e, t, n) {
     return e.range(t, e.offset(e.floor(n)));
 }
 const Jke = {
         draw(e, t) {
             e.moveTo(0, 0), e.lineTo(0, t);
         }
     },
@@ -62329,17 +62329,17 @@
     r: o = 4.5,
     ...a
 } = {}, u) {
     const [f, d] = ll(t), [h, g] = ll(i), p = x9(u, f), m = x9(u, h), y = o * o * Math.PI;
     return n = _i(n)[1], r = _i(r)[1], s = _i(s)[1], lW(
         e,
         a,
-        (b, v, x, w) => b.append("svg").attr("viewBox", "-8 -8 16 16").attr("width", x).attr("height", w).attr("fill", f === "color" ? (S) => p.scale(S) : d).attr("fill-opacity", n).attr("stroke", h === "color" ? (S) => m.scale(S) : g).attr("stroke-opacity", r).attr("stroke-width", s).append("path").attr("d", (S) => {
+        (b, v, x, w) => b.append("svg").attr("viewBox", "-8 -8 16 16").attr("width", x).attr("height", w).attr("fill", f === "color" ? (E) => p.scale(E) : d).attr("fill-opacity", n).attr("stroke", h === "color" ? (E) => m.scale(E) : g).attr("stroke-opacity", r).attr("stroke-width", s).append("path").attr("d", (E) => {
             const _ = ex();
-            return e.scale(S).draw(_, y), _;
+            return e.scale(E).draw(_, y), _;
         })
     );
 }
 
 function lW(e, t = {}, n) {
     let {
         columns: i,
@@ -62352,15 +62352,15 @@
         marginLeft: l = 0,
         className: c,
         style: f,
         width: d
     } = t;
     const h = ak(t);
     c = dk(c), r = _k(e.scale, e.domain, void 0, r);
-    const g = Vn("div", h).attr(
+    const g = Yn("div", h).attr(
         "class",
         `${c}-swatches ${c}-swatches-${i != null ? "columns" : "wrap"}`
     );
     let p;
     return i != null ? (p = `:where(.${c}-swatches-columns .${c}-swatch) {
   display: flex;
   align-items: center;
@@ -62397,15 +62397,15 @@
 }
 :where(.${c}-swatch > svg) {
   margin-right: 0.5em;
   overflow: visible;
 }
 ${p}`
         )
-    ).style("margin-left", l ? `${+l}px` : null).style("width", d === void 0 ? null : `${+d}px`).style("font-variant", Kt(s, "normal")).call(hk, f).node();
+    ).style("margin-left", l ? `${+l}px` : null).style("width", d === void 0 ? null : `${+d}px`).style("font-variant", Jt(s, "normal")).call(hk, f).node();
 }
 const s_ = /* @__PURE__ */ new Map([
     ["symbol", nAe],
     ["color", fW],
     ["opacity", rAe]
 ]);
 
@@ -62515,15 +62515,15 @@
             insetTop: r = i,
             insetRight: s = i,
             insetBottom: o = i,
             insetLeft: a = i,
             rx: u,
             ry: l
         } = t;
-        super(Em, void 0, t, n == null ? aAe : uAe), this.anchor = Ij(n, "anchor", ["top", "right", "bottom", "left"]), this.insetTop = vt(r), this.insetRight = vt(s), this.insetBottom = vt(o), this.insetLeft = vt(a), this.rx = vt(u), this.ry = vt(l);
+        super(Em, void 0, t, n == null ? aAe : uAe), this.anchor = Ij(n, "anchor", ["top", "right", "bottom", "left"]), this.insetTop = xt(r), this.insetRight = xt(s), this.insetBottom = xt(o), this.insetLeft = xt(a), this.rx = xt(u), this.ry = xt(l);
     }
     render(t, n, i, r, s) {
         const {
             marginTop: o,
             marginRight: a,
             marginBottom: u,
             marginLeft: l,
@@ -62533,25 +62533,25 @@
             anchor: d,
             insetTop: h,
             insetRight: g,
             insetBottom: p,
             insetLeft: m,
             rx: y,
             ry: b
-        } = this, v = l + m, x = c - a - g, w = o + h, S = f - u - p;
-        return Vn(d ? "svg:line" : "svg:rect", s).datum(0).call(Ol, this, r, s).call(Dl, this).call(zf, this, i).call(Rl, this, {}).call(
-            d === "left" ? (_) => _.attr("x1", v).attr("x2", v).attr("y1", w).attr("y2", S) : d === "right" ? (_) => _.attr("x1", x).attr("x2", x).attr("y1", w).attr("y2", S) : d === "top" ? (_) => _.attr("x1", v).attr("x2", x).attr("y1", w).attr("y2", w) : d === "bottom" ? (_) => _.attr("x1", v).attr("x2", x).attr("y1", S).attr("y2", S) : (_) => _.attr("x", v).attr("y", w).attr("width", x - v).attr("height", S - w).attr("rx", y).attr("ry", b)
+        } = this, v = l + m, x = c - a - g, w = o + h, E = f - u - p;
+        return Yn(d ? "svg:line" : "svg:rect", s).datum(0).call(Ol, this, r, s).call(Dl, this).call(zf, this, i).call(Rl, this, {}).call(
+            d === "left" ? (_) => _.attr("x1", v).attr("x2", v).attr("y1", w).attr("y2", E) : d === "right" ? (_) => _.attr("x1", x).attr("x2", x).attr("y1", w).attr("y2", E) : d === "top" ? (_) => _.attr("x1", v).attr("x2", x).attr("y1", w).attr("y2", w) : d === "bottom" ? (_) => _.attr("x1", v).attr("x2", x).attr("y1", E).attr("y2", E) : (_) => _.attr("x", v).attr("y", w).attr("width", x - v).attr("height", E - w).attr("rx", y).attr("ry", b)
         ).node();
     }
 }
 
 function cAe(e) {
     return new lAe(e);
 }
-const C2 = {
+const $2 = {
         ariaLabel: "tip",
         fill: "var(--plot-background)",
         stroke: "currentColor"
     },
     fAe = /* @__PURE__ */ new Set(["geometry", "href", "src", "ariaLabel", "scales"]);
 class dAe extends Ps {
     constructor(t, n = {}) {
@@ -62578,19 +62578,19 @@
             fontVariant: p,
             fontWeight: m,
             lineHeight: y = 1,
             lineWidth: b = 20,
             frameAnchor: v,
             format: x,
             textAnchor: w = "start",
-            textOverflow: S,
+            textOverflow: E,
             textPadding: _ = 8,
             title: k,
             pointerSize: A = 12,
-            pathFilter: F = "drop-shadow(0 3px 4px rgba(0,0,0,0.2))"
+            pathFilter: T = "drop-shadow(0 3px 4px rgba(0,0,0,0.2))"
         } = n;
         super(
             t, {
                 x: {
                     value: s != null && o != null ? null : i,
                     scale: "x",
                     optional: !0
@@ -62625,18 +62625,18 @@
                 title: {
                     value: k,
                     optional: !0
                 }
                 // filter: defined
             },
             n,
-            C2
-        ), this.anchor = Qw(l, "anchor"), this.preferredAnchor = Qw(c, "preferredAnchor"), this.frameAnchor = sk(v), this.textAnchor = Kt(w, "middle"), this.textPadding = +_, this.pointerSize = +A, this.pathFilter = Rn(F), this.lineHeight = +y, this.lineWidth = +b, this.textOverflow = Iq(S), this.monospace = !!f, this.fontFamily = Rn(d), this.fontSize = vt(h), this.fontStyle = Rn(g), this.fontVariant = Rn(p), this.fontWeight = Rn(m);
-        for (const T in C2)
-            T in this.channels && (this[T] = C2[T]);
+            $2
+        ), this.anchor = Qw(l, "anchor"), this.preferredAnchor = Qw(c, "preferredAnchor"), this.frameAnchor = sk(v), this.textAnchor = Jt(w, "middle"), this.textPadding = +_, this.pointerSize = +A, this.pathFilter = Ln(T), this.lineHeight = +y, this.lineWidth = +b, this.textOverflow = Iq(E), this.monospace = !!f, this.fontFamily = Ln(d), this.fontSize = xt(h), this.fontStyle = Ln(g), this.fontVariant = Ln(p), this.fontWeight = Ln(m);
+        for (const M in $2)
+            M in this.channels && (this[M] = $2[M]);
         this.splitLines = Bq(this), this.clipLine = Uq(this), this.format = {
             ...x
         };
     }
     render(t, n, i, r, s) {
         const o = this,
             {
@@ -62661,109 +62661,109 @@
                 pathFilter: v
             } = this,
             {
                 marginTop: x,
                 marginLeft: w
             } = r,
             {
-                x1: S,
+                x1: E,
                 y1: _,
                 x2: k,
                 y2: A,
-                x: F = S ?? k,
-                y: T = _ ?? A
+                x: T = E ?? k,
+                y: M = _ ?? A
             } = i,
-            I = l ? l(t.fx) - w : 0,
-            N = c ? c(t.fy) - x : 0,
-            [D, M] = Db(this, r),
-            E = xq(i, D),
-            $ = wq(i, M),
-            C = g ? vk : bk,
-            O = C(Ec);
-        let R, L;
-        "title" in i ? (R = i.channels, L = bAe) : (R = yAe.call(this, i, n), L = vAe);
-        const P = Vn("svg:g", s).call(Ol, this, r, s).call(zq, this).call(Rl, this, {
-            x: F && a,
-            y: T && u
+            L = l ? l(t.fx) - w : 0,
+            F = c ? c(t.fy) - x : 0,
+            [O, N] = Db(this, r),
+            R = xq(i, O),
+            P = wq(i, N),
+            S = g ? vk : bk,
+            $ = S(Ec);
+        let C, D;
+        "title" in i ? (C = i.channels, D = bAe) : (C = yAe.call(this, i, n), D = vAe);
+        const I = Yn("svg:g", s).call(Ol, this, r, s).call(zq, this).call(Rl, this, {
+            x: T && a,
+            y: M && u
         }).call(
-            (X) => X.selectAll().data(t).enter().append("g").attr("transform", (se) => `translate(${Math.round(E(se))},${Math.round($(se))})`).call(Dl, this).call((se) => se.append("path").attr("filter", v)).call(
-                (se) => se.append("text").each(function(ee) {
-                    const ue = sh(this);
+            (G) => G.selectAll().data(t).enter().append("g").attr("transform", (te) => `translate(${Math.round(R(te))},${Math.round(P(te))})`).call(Dl, this).call((te) => te.append("path").attr("filter", v)).call(
+                (te) => te.append("text").each(function(K) {
+                    const ae = sh(this);
                     this.setAttribute("fill", "currentColor"), this.setAttribute("fill-opacity", 1), this.setAttribute("stroke", "none");
-                    const G = L.call(o, ee, t, R, n, i);
-                    if (typeof G == "string")
-                        for (const ae of o.splitLines(G))
-                            z(ue, {
-                                value: o.clipLine(ae)
+                    const U = D.call(o, K, t, C, n, i);
+                    if (typeof U == "string")
+                        for (const ie of o.splitLines(U))
+                            z(ae, {
+                                value: o.clipLine(ie)
                             });
                     else {
-                        const ae = /* @__PURE__ */ new Set();
-                        for (const ce of G) {
+                        const ie = /* @__PURE__ */ new Set();
+                        for (const le of U) {
                             const {
-                                label: H = ""
-                            } = ce;
-                            H && ae.has(H) || (ae.add(H), z(ue, ce));
+                                label: Y = ""
+                            } = le;
+                            Y && ie.has(Y) || (ie.add(Y), z(ae, le));
                         }
                     }
                 })
             )
         );
 
-        function z(X, {
-            label: se,
-            value: ee,
-            color: ue,
-            opacity: G
+        function z(G, {
+            label: te,
+            value: K,
+            color: ae,
+            opacity: U
         }) {
-            se ?? (se = ""), ee ?? (ee = "");
-            const ae = ue != null || G != null;
-            let ce, H = m * 100;
-            const [Be] = uf(se, H, C, O);
+            te ?? (te = ""), K ?? (K = "");
+            const ie = ae != null || U != null;
+            let le, Y = m * 100;
+            const [Be] = uf(te, Y, S, $);
             if (Be >= 0)
-                se = se.slice(0, Be).trimEnd() + Ec, ce = ee.trim(), ee = "";
+                te = te.slice(0, Be).trimEnd() + Ec, le = K.trim(), K = "";
             else {
-                (se || !ee && !ae) && (ee = " " + ee);
-                const [Ve] = uf(ee, H - C(se), C, O);
-                Ve >= 0 && (ce = ee.trim(), ee = ee.slice(0, Ve).trimEnd() + Ec);
+                (te || !K && !ie) && (K = " " + K);
+                const [Ve] = uf(K, Y - S(te), S, $);
+                Ve >= 0 && (le = K.trim(), K = K.slice(0, Ve).trimEnd() + Ec);
             }
-            const Ee = X.append("tspan").attr("x", 0).attr("dy", `${p}em`).text("​");
-            se && Ee.append("tspan").attr("font-weight", "bold").text(se), ee && Ee.append(() => d.createTextNode(ee)), ae && Ee.append("tspan").text(" ■").attr("fill", ue).attr("fill-opacity", G).style("user-select", "none"), ce && Ee.append("title").text(ce);
+            const Ee = G.append("tspan").attr("x", 0).attr("dy", `${p}em`).text("​");
+            te && Ee.append("tspan").attr("font-weight", "bold").text(te), K && Ee.append(() => d.createTextNode(K)), ie && Ee.append("tspan").text(" ■").attr("fill", ae).attr("fill-opacity", U).style("user-select", "none"), le && Ee.append("title").text(le);
         }
 
-        function V() {
+        function H() {
             const {
-                width: X,
-                height: se
+                width: G,
+                height: te
             } = r.facet ?? r;
-            P.selectChildren().each(function(ee) {
+            I.selectChildren().each(function(K) {
                 let {
-                    x: ue,
-                    width: G,
-                    height: ae
+                    x: ae,
+                    width: U,
+                    height: ie
                 } = this.getBBox();
-                G = Math.round(G), ae = Math.round(ae);
-                let ce = h;
-                if (ce === void 0) {
-                    const Ee = E(ee) + I,
-                        Ve = $(ee) + N,
-                        st = Ee + G + b + y * 2 < X,
-                        An = Ee - G - b - y * 2 > 0,
-                        No = Ve + ae + b + y * 2 < se,
-                        Ja = Ve - ae - b - y * 2 > 0;
-                    ce = st && An ? No && Ja ? o.preferredAnchor : Ja ? "bottom" : "top" : No && Ja ? st ? "left" : "right" : (st || An) && (No || Ja) ? `${Ja ? "bottom" : "top"}-${st ? "left" : "right"}` : o.preferredAnchor;
+                U = Math.round(U), ie = Math.round(ie);
+                let le = h;
+                if (le === void 0) {
+                    const Ee = R(K) + L,
+                        Ve = P(K) + F,
+                        ot = Ee + U + b + y * 2 < G,
+                        Cn = Ee - U - b - y * 2 > 0,
+                        No = Ve + ie + b + y * 2 < te,
+                        Ja = Ve - ie - b - y * 2 > 0;
+                    le = ot && Cn ? No && Ja ? o.preferredAnchor : Ja ? "bottom" : "top" : No && Ja ? ot ? "left" : "right" : (ot || Cn) && (No || Ja) ? `${Ja ? "bottom" : "top"}-${ot ? "left" : "right"}` : o.preferredAnchor;
                 }
-                const H = this.firstChild,
+                const Y = this.firstChild,
                     Be = this.lastChild;
-                if (H.setAttribute("d", mAe(ce, b, y, G, ae)), ue)
+                if (Y.setAttribute("d", mAe(le, b, y, U, ie)), ae)
                     for (const Ee of Be.childNodes)
-                        Ee.setAttribute("x", -ue);
-                Be.setAttribute("y", `${+gAe(ce, Be.childNodes.length, p).toFixed(6)}em`), Be.setAttribute("transform", `translate(${pAe(ce, b, y, G, ae)})`);
-            }), P.attr("visibility", null);
+                        Ee.setAttribute("x", -ae);
+                Be.setAttribute("y", `${+gAe(le, Be.childNodes.length, p).toFixed(6)}em`), Be.setAttribute("transform", `translate(${pAe(le, b, y, U, ie)})`);
+            }), I.attr("visibility", null);
         }
-        return t.length && (P.attr("visibility", "hidden"), f.isConnected ? Promise.resolve().then(V) : typeof requestAnimationFrame < "u" && requestAnimationFrame(V)), P.node();
+        return t.length && (I.attr("visibility", "hidden"), f.isConnected ? Promise.resolve().then(H) : typeof requestAnimationFrame < "u" && requestAnimationFrame(H)), I.node();
     }
 }
 
 function hAe(e, {
     x: t,
     y: n,
     ...i
@@ -62933,220 +62933,220 @@
 function c1(e, t, n, i = n) {
     const r = t[n],
         s = e[(r == null ? void 0 : r.scale) ?? n];
     return String((s == null ? void 0 : s.label) ?? (r == null ? void 0 : r.label) ?? i);
 }
 
 function dW(e = {}) {
-    var O;
+    var $;
     const {
         facet: t,
         style: n,
         title: i,
         subtitle: r,
         caption: s,
         ariaLabel: o,
         ariaDescription: a
     } = e, u = dk(e.className), l = e.marks === void 0 ? [] : k9(e.marks);
-    l.push(...$Ae(l));
+    l.push(...CAe(l));
     const c = kAe(t, e),
         f = /* @__PURE__ */ new Map();
-    for (const R of l) {
-        const L = A9(R, c, e);
-        L && f.set(R, L);
+    for (const C of l) {
+        const D = A9(C, c, e);
+        D && f.set(C, D);
     }
     const d = /* @__PURE__ */ new Map();
     c && pd(d, [c], e), pd(d, f, e);
-    const h = k9(CAe(l, d, e));
-    for (const R of h) {
-        const L = A9(R, c, e);
-        L && f.set(R, L);
+    const h = k9($Ae(l, d, e));
+    for (const C of h) {
+        const D = A9(C, c, e);
+        D && f.set(C, D);
     }
     l.unshift(...h);
     let g = G6e(d, e);
     if (g !== void 0) {
-        const R = c ? S2(g, c) : void 0;
-        for (const P of l) {
-            if (P.facet === null || P.facet === "super")
+        const C = c ? S2(g, c) : void 0;
+        for (const I of l) {
+            if (I.facet === null || I.facet === "super")
                 continue;
-            const z = f.get(P);
-            z !== void 0 && (z.facetsIndex = P.fx != null || P.fy != null ? S2(g, z) : R);
+            const z = f.get(I);
+            z !== void 0 && (z.facetsIndex = I.fx != null || I.fy != null ? S2(g, z) : C);
         }
-        const L = /* @__PURE__ */ new Set();
+        const D = /* @__PURE__ */ new Set();
         for (const {
-                facetsIndex: P
+                facetsIndex: I
             }
             of f.values())
-            P == null || P.forEach((z, V) => {
-                (z == null ? void 0 : z.length) > 0 && L.add(V);
+            I == null || I.forEach((z, H) => {
+                (z == null ? void 0 : z.length) > 0 && D.add(H);
             });
         g.forEach(
-            0 < L.size && L.size < g.length ? (P, z) => P.empty = !L.has(z) : (P) => P.empty = !1
+            0 < D.size && D.size < g.length ? (I, z) => I.empty = !D.has(z) : (I) => I.empty = !1
         );
-        for (const P of l)
-            if (P.facet === "exclude") {
-                const z = f.get(P);
+        for (const I of l)
+            if (I.facet === "exclude") {
+                const z = f.get(I);
                 z !== void 0 && (z.facetsIndex = X6e(z.facetsIndex));
             }
     }
-    for (const R of wt.keys())
-        Kw(e[R]) && R !== "fx" && R !== "fy" && d.set(R, []);
+    for (const C of _t.keys())
+        Kw(e[C]) && C !== "fx" && C !== "fy" && d.set(C, []);
     const p = /* @__PURE__ */ new Map();
-    for (const R of l) {
-        if (p.has(R))
+    for (const C of l) {
+        if (p.has(C))
             throw new Error("duplicate mark; each mark must be unique");
         const {
-            facetsIndex: L,
-            channels: P
-        } = f.get(R) ?? {}, {
+            facetsIndex: D,
+            channels: I
+        } = f.get(C) ?? {}, {
             data: z,
-            facets: V,
-            channels: X
-        } = R.initialize(L, P, e);
-        Ek(X, e), p.set(R, {
+            facets: H,
+            channels: G
+        } = C.initialize(D, I, e);
+        Ek(G, e), p.set(C, {
             data: z,
-            facets: V,
-            channels: X
+            facets: H,
+            channels: G
         });
     }
     const m = n_(pd(d, p, e), e),
         y = W6e(m, l, e);
     w6e(m, y);
     const b = r9(m),
         {
             fx: v,
             fy: x
         } = b,
         w = v || x ? gq(m, y) : y,
-        S = v || x ? RAe(b, y) : y,
+        E = v || x ? RAe(b, y) : y,
         _ = ak(e),
         k = _.document,
         A = kb("svg").call(k.documentElement);
-    let F = A;
-    _.ownerSVGElement = A, _.className = u, _.projection = D5e(e, w), _.filterFacets = (R, L) => S2(g, {
-        channels: L,
-        groups: gk(R, L)
-    }), _.getMarkState = (R) => {
-        const L = p.get(R),
-            P = f.get(R);
+    let T = A;
+    _.ownerSVGElement = A, _.className = u, _.projection = D5e(e, w), _.filterFacets = (C, D) => S2(g, {
+        channels: D,
+        groups: gk(C, D)
+    }), _.getMarkState = (C) => {
+        const D = p.get(C),
+            I = f.get(C);
         return {
-            ...L,
+            ...D,
             channels: {
-                ...L.channels,
-                ...P == null ? void 0 : P.channels
+                ...D.channels,
+                ...I == null ? void 0 : I.channels
             }
         };
-    }, _.dispatchValue = (R) => {
-        F.value !== R && (F.value = R, F.dispatchEvent(new Event("input", {
+    }, _.dispatchValue = (C) => {
+        T.value !== C && (T.value = C, T.dispatchEvent(new Event("input", {
             bubbles: !0
         })));
     };
-    const T = /* @__PURE__ */ new Set();
-    for (const [R, L] of p)
-        if (R.initializer != null) {
-            const P = R.facet === "super" ? S : w,
-                z = R.initializer(L.data, L.facets, L.channels, b, P, _);
-            if (z.data !== void 0 && (L.data = z.data), z.facets !== void 0 && (L.facets = z.facets), z.channels !== void 0) {
+    const M = /* @__PURE__ */ new Set();
+    for (const [C, D] of p)
+        if (C.initializer != null) {
+            const I = C.facet === "super" ? E : w,
+                z = C.initializer(D.data, D.facets, D.channels, b, I, _);
+            if (z.data !== void 0 && (D.data = z.data), z.facets !== void 0 && (D.facets = z.facets), z.channels !== void 0) {
                 const {
-                    fx: V,
-                    fy: X,
-                    ...se
+                    fx: H,
+                    fy: G,
+                    ...te
                 } = z.channels;
-                SAe(se), Object.assign(L.channels, se);
-                for (const ee of Object.values(se)) {
+                SAe(te), Object.assign(D.channels, te);
+                for (const K of Object.values(te)) {
                     const {
-                        scale: ue
-                    } = ee;
-                    ue != null && !c5e(wt.get(ue)) && (hW(ee, e), T.add(ue));
+                        scale: ae
+                    } = K;
+                    ae != null && !c5e(_t.get(ae)) && (hW(K, e), M.add(ae));
                 }
-                (V != null || X != null) && f.set(R, !0);
+                (H != null || G != null) && f.set(C, !0);
             }
         }
-    if (T.size) {
-        const R = /* @__PURE__ */ new Map();
-        pd(R, p, e, (V) => T.has(V)), pd(d, p, e, (V) => T.has(V));
-        const L = DAe(n_(R, e), m),
+    if (M.size) {
+        const C = /* @__PURE__ */ new Map();
+        pd(C, p, e, (H) => M.has(H)), pd(d, p, e, (H) => M.has(H));
+        const D = DAe(n_(C, e), m),
             {
-                scales: P,
+                scales: I,
                 ...z
-            } = r9(L);
-        Object.assign(m, L), Object.assign(b, z), Object.assign(b.scales, P);
+            } = r9(D);
+        Object.assign(m, D), Object.assign(b, z), Object.assign(b.scales, I);
     }
-    let I, N;
-    g !== void 0 && (I = {
+    let L, F;
+    g !== void 0 && (L = {
         x: v == null ? void 0 : v.domain(),
         y: x == null ? void 0 : x.domain()
-    }, g = V6e(g, I), N = Y6e(v, x, y));
-    for (const [R, L] of p)
-        L.values = R.scale(L.channels, b, _);
+    }, g = V6e(g, L), F = Y6e(v, x, y));
+    for (const [C, D] of p)
+        D.values = C.scale(D.channels, b, _);
     const {
-        width: D,
-        height: M
+        width: O,
+        height: N
     } = y;
-    sh(A).attr("class", u).attr("fill", "currentColor").attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("text-anchor", "middle").attr("width", D).attr("height", M).attr("viewBox", `0 0 ${D} ${M}`).attr("aria-label", o).attr("aria-description", a).call(
-        (R) => (
+    sh(A).attr("class", u).attr("fill", "currentColor").attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("text-anchor", "middle").attr("width", O).attr("height", N).attr("viewBox", `0 0 ${O} ${N}`).attr("aria-label", o).attr("aria-description", a).call(
+        (C) => (
             // Warning: if you edit this, change defaultClassName.
-            R.append("style").text(
+            C.append("style").text(
                 `:where(.${u}) {
   --plot-background: white;
   display: block;
   height: auto;
   height: intrinsic;
   max-width: 100%;
 }
 :where(.${u} text),
 :where(.${u} tspan) {
   white-space: pre;
 }`
             )
         )
     ).call(hk, n);
-    for (const R of l) {
+    for (const C of l) {
         const {
-            channels: L,
-            values: P,
+            channels: D,
+            values: I,
             facets: z
-        } = p.get(R);
-        if (g === void 0 || R.facet === "super") {
-            let V = null;
-            if (z && (V = z[0], V = R.filter(V, L, P), V.length === 0))
+        } = p.get(C);
+        if (g === void 0 || C.facet === "super") {
+            let H = null;
+            if (z && (H = z[0], H = C.filter(H, D, I), H.length === 0))
                 continue;
-            const X = R.render(V, b, P, S, _);
-            if (X == null)
+            const G = C.render(H, b, I, E, _);
+            if (G == null)
                 continue;
-            A.appendChild(X);
+            A.appendChild(G);
         } else {
-            let V;
-            for (const X of g) {
-                if (!(((O = R.facetAnchor) == null ? void 0 : O.call(R, g, I, X)) ?? !X.empty))
+            let H;
+            for (const G of g) {
+                if (!((($ = C.facetAnchor) == null ? void 0 : $.call(C, g, L, G)) ?? !G.empty))
                     continue;
-                let se = null;
+                let te = null;
                 if (z) {
-                    const ue = f.has(R);
-                    if (se = z[ue ? X.i : 0], se = R.filter(se, L, P), se.length === 0)
+                    const ae = f.has(C);
+                    if (te = z[ae ? G.i : 0], te = C.filter(te, D, I), te.length === 0)
                         continue;
-                    !ue && se === z[0] && (se = X3e(se)), se.fx = X.x, se.fy = X.y, se.fi = X.i;
+                    !ae && te === z[0] && (te = X3e(te)), te.fx = G.x, te.fy = G.y, te.fi = G.i;
                 }
-                const ee = R.render(se, b, P, w, _);
-                if (ee != null) {
-                    (V ?? (V = sh(A).append("g"))).append(() => ee).datum(X);
-                    for (const ue of ["aria-label", "aria-description", "aria-hidden", "transform"])
-                        ee.hasAttribute(ue) && (V.attr(ue, ee.getAttribute(ue)), ee.removeAttribute(ue));
+                const K = C.render(te, b, I, w, _);
+                if (K != null) {
+                    (H ?? (H = sh(A).append("g"))).append(() => K).datum(G);
+                    for (const ae of ["aria-label", "aria-description", "aria-hidden", "transform"])
+                        K.hasAttribute(ae) && (H.attr(ae, K.getAttribute(ae)), K.removeAttribute(ae));
                 }
             }
-            V == null || V.selectChildren().attr("transform", N);
+            H == null || H.selectChildren().attr("transform", F);
         }
     }
-    const E = oAe(m, _, e),
+    const R = oAe(m, _, e),
         {
-            figure: $ = i != null || r != null || s != null || E.length > 0
+            figure: P = i != null || r != null || s != null || R.length > 0
         } = e;
-    $ && (F = k.createElement("figure"), F.className = `${u}-figure`, F.style.maxWidth = "initial", i != null && F.append(S9(k, i, "h2")), r != null && F.append(S9(k, r, "h3")), F.append(...E, A), s != null && F.append(xAe(k, s))), F.scale = M6e(b.scales), F.legend = iAe(m, _, e);
-    const C = O5e();
-    return C > 0 && sh(A).append("text").attr("x", D).attr("y", 20).attr("dy", "-1em").attr("text-anchor", "end").attr("font-family", "initial").text("⚠️").append("title").text(`${C.toLocaleString("en-US")} warning${C === 1 ? "" : "s"}. Please check the console.`), F;
+    P && (T = k.createElement("figure"), T.className = `${u}-figure`, T.style.maxWidth = "initial", i != null && T.append(S9(k, i, "h2")), r != null && T.append(S9(k, r, "h3")), T.append(...R, A), s != null && T.append(xAe(k, s))), T.scale = M6e(b.scales), T.legend = iAe(m, _, e);
+    const S = O5e();
+    return S > 0 && sh(A).append("text").attr("x", O).attr("y", 20).attr("dy", "-1em").attr("text-anchor", "end").attr("font-family", "initial").text("⚠️").append("title").text(`${S.toLocaleString("en-US")} warning${S === 1 ? "" : "s"}. Please check the console.`), T;
 }
 
 function S9(e, t, n) {
     if (t.ownerDocument)
         return t;
     const i = e.createElement(n);
     return i.append(t), i;
@@ -63199,15 +63199,15 @@
         return;
     const {
         type: r,
         percent: s,
         interval: o,
         transform: a = s ? (u) => u * 100 : Bj(o, r)
     } = t[n] ?? {};
-    a != null && (e.value = Gt(e.value, a), e.transform = !1);
+    a != null && (e.value = Vt(e.value, a), e.transform = !1);
 }
 
 function SAe(e) {
     for (const t in e)
         Jj(t, e[t]);
 }
 
@@ -63318,15 +63318,15 @@
     return l1({
         ...t,
         x: null,
         y: null
     }, (n, i, r, s, o, a) => a.getMarkState(e));
 }
 
-function $Ae(e) {
+function CAe(e) {
     const t = [];
     for (const n of e) {
         let i = n.tip;
         if (i) {
             i === !0 ? i = {} : typeof i == "string" && (i = {
                 pointer: i
             });
@@ -63338,15 +63338,15 @@
             const o = hAe(n.data, i);
             o.facet = n.facet, o.facetAnchor = n.facetAnchor, t.push(o);
         }
     }
     return t;
 }
 
-function CAe(e, t, n) {
+function $Ae(e, t, n) {
     let {
         projection: i,
         x: r = {},
         y: s = {},
         fx: o = {},
         fy: a = {},
         axis: u,
@@ -63369,15 +63369,15 @@
             grid: b = y === null ? null : d
         } = o,
         fy: {
             axis: v = f,
             grid: x = v === null ? null : d
         } = a
     } = n;
-    (i || !Kw(r) && !$9("x", e)) && (h = g = null), (i || !Kw(s) && !$9("y", e)) && (p = m = null), t.has("fx") || (y = b = null), t.has("fy") || (v = x = null), h === void 0 && (h = !Yp(e, "x")), p === void 0 && (p = !Yp(e, "y")), y === void 0 && (y = !Yp(e, "fx")), v === void 0 && (v = !Yp(e, "fy")), h === !0 && (h = "bottom"), p === !0 && (p = "left"), y === !0 && (y = h === "top" || h === null ? "bottom" : "top"), v === !0 && (v = p === "right" || p === null ? "left" : "right");
+    (i || !Kw(r) && !C9("x", e)) && (h = g = null), (i || !Kw(s) && !C9("y", e)) && (p = m = null), t.has("fx") || (y = b = null), t.has("fy") || (v = x = null), h === void 0 && (h = !Yp(e, "x")), p === void 0 && (p = !Yp(e, "y")), y === void 0 && (y = !Yp(e, "fx")), v === void 0 && (v = !Yp(e, "fy")), h === !0 && (h = "bottom"), p === !0 && (p = "left"), y === !0 && (y = h === "top" || h === null ? "bottom" : "top"), v === !0 && (v = p === "right" || p === null ? "left" : "right");
     const w = [];
     return Vp(w, x, Vke, a), Gp(w, v, Uke, "right", "left", c, a), Vp(w, b, Xke, o), Gp(w, y, jke, "top", "bottom", c, o), Vp(w, m, Zq, s), Gp(w, p, xk, "left", "right", n, s), Vp(w, g, Yke, r), Gp(w, h, wk, "bottom", "top", n, r), w;
 }
 
 function Gp(e, t, n, i, r, s, o) {
     if (!t)
         return;
@@ -63478,15 +63478,15 @@
     const n = `${t}-axis `;
     return e.some((i) => {
         var r;
         return (r = i.ariaLabel) == null ? void 0 : r.startsWith(n);
     });
 }
 
-function $9(e, t) {
+function C9(e, t) {
     for (const n of t)
         for (const i in n.channels) {
             const {
                 scale: r
             } = n.channels[i];
             if (r === e || r === "projection")
                 return !0;
@@ -63510,15 +63510,15 @@
     const {
         marginTop: i,
         marginRight: r,
         marginBottom: s,
         marginLeft: o,
         width: a,
         height: u
-    } = fk(n), l = e && C9(e), c = t && C9(t);
+    } = fk(n), l = e && $9(e), c = t && $9(t);
     return {
         marginTop: t ? c[0] : i,
         marginRight: e ? a - l[1] : r,
         marginBottom: t ? u - c[1] : s,
         marginLeft: e ? l[0] : o,
         // Some marks, namely the x- and y-axis labels, want to know what the
         // desired (rather than actual) margins are for positioning.
@@ -63529,15 +63529,15 @@
             marginLeft: n.marginLeft
         },
         width: a,
         height: u
     };
 }
 
-function C9(e) {
+function $9(e) {
     const t = e.domain();
     let n = e(t[0]),
         i = e(t[t.length - 1]);
     return i < n && ([n, i] = [i, n]), [n, i + e.bandwidth()];
 }
 
 function LAe(e = {}) {
@@ -63648,33 +63648,33 @@
                 data: p,
                 facets: m
             } = IAe(p, m));
             const b = e == null ? void 0 : c(Q3e(Yi(p, e), y == null ? void 0 : y[n])),
                 v = Yi(p, t, Float64Array),
                 x = Yi(p, u),
                 w = s && s(p, b, v, x),
-                S = p.length,
-                _ = d(new Float64Array(S)),
-                k = g(new Float64Array(S)),
+                E = p.length,
+                _ = d(new Float64Array(E)),
+                k = g(new Float64Array(E)),
                 A = [];
-            for (const F of m) {
-                const T = b ? Array.from(_M(F, (I) => b[I]).values()) : [F];
+            for (const T of m) {
+                const M = b ? Array.from(_M(T, (L) => b[L]).values()) : [T];
                 if (w)
-                    for (const I of T)
-                        I.sort(w);
-                for (const I of T) {
-                    let N = 0,
-                        D = 0;
-                    o && I.reverse();
-                    for (const M of I) {
-                        const E = v[M];
-                        E < 0 ? N = k[M] = (_[M] = N) + E : E > 0 ? D = k[M] = (_[M] = D) + E : k[M] = _[M] = D;
+                    for (const L of M)
+                        L.sort(w);
+                for (const L of M) {
+                    let F = 0,
+                        O = 0;
+                    o && L.reverse();
+                    for (const N of L) {
+                        const R = v[N];
+                        R < 0 ? F = k[N] = (_[N] = F) + R : R > 0 ? O = k[N] = (_[N] = O) + R : k[N] = _[N] = O;
                     }
                 }
-                A.push(T);
+                A.push(M);
             }
             return r && r(A, _, k, x), {
                 data: p,
                 facets: m
             };
         }),
         l,
@@ -63768,15 +63768,15 @@
 }
 
 function yW(e, t, n) {
     const i = e.length;
     if (i === 1)
         return;
     const r = e.map((a) => a.flat()),
-        s = r.map((a) => (gs(a, (u) => t[u]) + xn(a, (u) => n[u])) / 2),
+        s = r.map((a) => (gs(a, (u) => t[u]) + wn(a, (u) => n[u])) / 2),
         o = gs(s);
     for (let a = 0; a < i; a++) {
         const u = o - s[a];
         for (const l of r[a])
             t[l] += u, n[l] += u;
     }
 }
@@ -63894,22 +63894,22 @@
             insetTop: o = s,
             insetRight: a = s,
             insetBottom: u = s,
             insetLeft: l = s,
             rx: c,
             ry: f
         } = i;
-        this.insetTop = vt(o), this.insetRight = vt(a), this.insetBottom = vt(u), this.insetLeft = vt(l), this.rx = Kt(c, "auto"), this.ry = Kt(f, "auto");
+        this.insetTop = xt(o), this.insetRight = xt(a), this.insetBottom = xt(u), this.insetLeft = xt(l), this.rx = Jt(c, "auto"), this.ry = Jt(f, "auto");
     }
     render(t, n, i, r, s) {
         const {
             rx: o,
             ry: a
         } = this;
-        return Vn("svg:g", s).call(Ol, this, r, s).call(this._transform, this, n).call(
+        return Yn("svg:g", s).call(Ol, this, r, s).call(this._transform, this, n).call(
             (u) => u.selectAll().data(t).enter().append("rect").call(Dl, this).attr("x", this._x(n, i, r)).attr("width", this._width(n, i, r)).attr("y", this._y(n, i, r)).attr("height", this._height(n, i, r)).call(Re, "rx", o).call(Re, "ry", a).call(zf, this, i)
         ).node();
     }
     _x(t, {
         x: n
     }, {
         marginLeft: i
@@ -63956,18 +63956,18 @@
         const {
             insetTop: o,
             insetBottom: a
         } = this, u = n && t ? t.bandwidth() : s - i - r;
         return Math.max(0, u - o - a);
     }
 }
-const e$e = {
+const eCe = {
     ariaLabel: "bar"
 };
-class t$e extends ZAe {
+class tCe extends ZAe {
     constructor(t, n = {}) {
         const {
             x: i,
             y1: r,
             y2: s
         } = n;
         super(
@@ -63984,15 +63984,15 @@
                     value: i,
                     scale: "x",
                     type: "band",
                     optional: !0
                 }
             },
             n,
-            e$e
+            eCe
         );
     }
     _transform(t, n, {
         y: i
     }) {
         t.call(Rl, n, {
             y: i
@@ -64025,62 +64025,62 @@
             insetTop: a,
             insetBottom: u
         } = this;
         return of(t) ? o - r - s - a - u : (l) => Math.max(0, Math.abs(i[l] - n[l]) - a - u);
     }
 }
 
-function n$e(e, t = {}) {
+function nCe(e, t = {}) {
     return G3e(t) || (t = {
         ...t,
         x: Rj,
         y2: fr
-    }), new t$e(e, zAe(Nq(LAe(t))));
+    }), new tCe(e, zAe(Nq(LAe(t))));
 }
 
-function i$e(e) {
+function iCe(e) {
     let t;
     return {
         c() {
-            t = ge("div");
+            t = he("div");
         },
         m(n, i) {
-            we(n, t, i);
+            pe(n, t, i);
         },
         p: dt,
         i: dt,
         o: dt,
         d(n) {
-            n && xe(t);
+            n && ge(t);
         }
     };
 }
 
-function r$e(e) {
+function rCe(e) {
     let t = [];
     return e = JSON.parse(e), e.forEach((n) => {
         n.id == "All" && t.push({
             name: n.concept,
             n: n.n
         });
     }), t;
 }
 
-function s$e(e, t, n) {
+function sCe(e, t, n) {
     let {
         data: i
     } = t, {
         div: r
     } = t;
-    console.log("OverviewHistogram", r), i = r$e(i);
+    i = rCe(i);
     let o = 100 * i.length;
     const a = dW({
         marks: [
             Zq(),
-            n$e(i, {
+            nCe(i, {
                 x: "name",
                 y: "n",
                 fill: "#A1D1FC",
                 tip: !0,
                 sort: {
                     x: "y",
                     reverse: !0,
@@ -64100,282 +64100,294 @@
         width: o,
         height: 200
     });
     return r.replaceChildren(a), e.$$set = (u) => {
         "data" in u && n(0, i = u.data), "div" in u && n(1, r = u.div);
     }, [i, r];
 }
-class o$e extends ks {
+class oCe extends ks {
     constructor(t) {
-        super(), Ss(this, t, s$e, i$e, Xi, {
+        super(), Ss(this, t, sCe, iCe, Xi, {
             data: 0,
             div: 1
         });
     }
 }
 
 function F9(e) {
-    let t, n, i, r = (
+    let t, n, i, r, s, o = (
             /*histDiv*/
-            e[12]
+            e[14]
         ),
-        s, o, a, u, l, c = (
+        a, u, l, c, f, d, h, g = (
             /*matrixDiv*/
-            e[13]
+            e[15]
         ),
-        f, d, h, g, p = N9(e),
-        m = O9(e);
-    const y = [d$e, f$e],
-        b = [];
+        p, m, y, b, v = N9(e),
+        x = O9(e);
+    const w = [dCe, fCe],
+        E = [];
 
-    function v(x, w) {
+    function _(k, A) {
         return (
             /*selectedMatrixElem*/
-            x[6] == "cell" || /*selectedMatrixElem*/
-            x[6] == "concept" ? 0 : (
+            k[8] == "cell" || /*selectedMatrixElem*/
+            k[8] == "concept" ? 0 : (
                 /*selectedMatrixElem*/
-                x[6] == "group" ? 1 : -1
+                k[8] == "group" ? 1 : -1
             )
         );
     }
-    return ~(d = v(e)) && (h = b[d] = y[d](e)), {
+    return ~(m = _(e)) && (y = E[m] = w[m](e)), {
         c() {
-            t = ge("h2"), t.textContent = "CONCEPT OVERVIEW", n = ct(), i = ge("div"), p.c(), s = ct(), o = ge("h2"), o.textContent = "CONCEPT MATRIX", a = ct(), u = ge("div"), l = ge("div"), m.c(), f = ct(), h && h.c(), fe(t, "class", "card-title"), fe(i, "id", "histDiv"), fe(i, "class", "overview-hist"), fe(o, "class", "card-title"), fe(l, "id", "matrixDiv"), fe(l, "class", "matrix"), fe(u, "id", "matrixWidget"), fe(u, "class", "matrix-widget");
+            t = he("h2"), t.textContent = "CONCEPT OVERVIEW", n = rt(), i = he("p"), i.innerHTML = "An overview of concepts in your dataset. <i>Outliers</i> are documents that did not match any of the concepts.", r = rt(), s = he("div"), v.c(), a = rt(), u = he("h2"), u.textContent = "CONCEPT MATRIX", l = rt(), c = he("div"), c.innerHTML = "<p>A view of concepts (rows) and slices (columns). Click on a concept or slice name to view details. <br/>The size of the circles indicates the number of documents in a given concept and slice.</p> <ul><li><b>Concepts</b> (rows): LLooM-generated concept matches</li> <li><b>Slices</b> (columns): User-specified data groupings</li> <ul><li>The default <i>All</i> slice includes all documents.</li> <li>Provide your own <code>slice_col</code> for custom slices based on a string or numeric column in your dataset.</li></ul></ul>", f = rt(), d = he("div"), h = he("div"), x.c(), p = rt(), y && y.c(), fe(t, "class", "card-title"), fe(s, "id", "histDiv"), fe(s, "class", "overview-hist"), fe(u, "class", "card-title"), fe(h, "id", "matrixDiv"), fe(h, "class", "matrix"), fe(d, "id", "matrixWidget"), fe(d, "class", "matrix-widget");
         },
-        m(x, w) {
-            we(x, t, w), we(x, n, w), we(x, i, w), p.m(i, null), e[16](i), we(x, s, w), we(x, o, w), we(x, a, w), we(x, u, w), $e(u, l), m.m(l, null), e[17](l), $e(u, f), ~d && b[d].m(u, null), g = !0;
+        m(k, A) {
+            pe(k, t, A), pe(k, n, A), pe(k, i, A), pe(k, r, A), pe(k, s, A), v.m(s, null), e[18](s), pe(k, a, A), pe(k, u, A), pe(k, l, A), pe(k, c, A), pe(k, f, A), pe(k, d, A), Ce(d, h), x.m(h, null), e[19](h), Ce(d, p), ~m && E[m].m(d, null), b = !0;
         },
-        p(x, w) {
-            w & /*histDiv*/
-                4096 && Xi(r, r = /*histDiv*/
-                    x[12]) ? (mn(), Se(p, 1, 1, dt), yn(), p = N9(x), p.c(), he(p, 1), p.m(i, null)) : p.p(x, w), w & /*matrixDiv*/
-                8192 && Xi(c, c = /*matrixDiv*/
-                    x[13]) ? (mn(), Se(m, 1, 1, dt), yn(), m = O9(x), m.c(), he(m, 1), m.m(l, null)) : m.p(x, w);
-            let S = d;
-            d = v(x), d === S ? ~d && b[d].p(x, w) : (h && (mn(), Se(b[S], 1, 1, () => {
-                b[S] = null;
-            }), yn()), ~d ? (h = b[d], h ? h.p(x, w) : (h = b[d] = y[d](x), h.c()), he(h, 1), h.m(u, null)) : h = null);
+        p(k, A) {
+            A & /*histDiv*/
+                16384 && Xi(o, o = /*histDiv*/
+                    k[14]) ? (yn(), Se(v, 1, 1, dt), bn(), v = N9(k), v.c(), me(v, 1), v.m(s, null)) : v.p(k, A), A & /*matrixDiv*/
+                32768 && Xi(g, g = /*matrixDiv*/
+                    k[15]) ? (yn(), Se(x, 1, 1, dt), bn(), x = O9(k), x.c(), me(x, 1), x.m(h, null)) : x.p(k, A);
+            let T = m;
+            m = _(k), m === T ? ~m && E[m].p(k, A) : (y && (yn(), Se(E[T], 1, 1, () => {
+                E[T] = null;
+            }), bn()), ~m ? (y = E[m], y ? y.p(k, A) : (y = E[m] = w[m](k), y.c()), me(y, 1), y.m(d, null)) : y = null);
         },
-        i(x) {
-            g || (he(p), he(m), he(h), g = !0);
+        i(k) {
+            b || (me(v), me(x), me(y), b = !0);
         },
-        o(x) {
-            Se(p), Se(m), Se(h), g = !1;
+        o(k) {
+            Se(v), Se(x), Se(y), b = !1;
         },
-        d(x) {
-            x && (xe(t), xe(n), xe(i), xe(s), xe(o), xe(a), xe(u)), p.d(x), e[16](null), m.d(x), e[17](null), ~d && b[d].d();
+        d(k) {
+            k && (ge(t), ge(n), ge(i), ge(r), ge(s), ge(a), ge(u), ge(l), ge(c), ge(f), ge(d)), v.d(k), e[18](null), x.d(k), e[19](null), ~m && E[m].d();
         }
     };
 }
 
-function a$e(e) {
+function aCe(e) {
     let t, n;
-    return t = new o$e({
+    return t = new oCe({
         props: {
             data: (
                 /*data*/
                 e[1]
             ),
             div: (
                 /*histDiv*/
-                e[12]
+                e[14]
             )
         }
     }), {
         c() {
             oi(t.$$.fragment);
         },
         m(i, r) {
-            Bn(t, i, r), n = !0;
+            Un(t, i, r), n = !0;
         },
         p(i, r) {
             const s = {};
             r & /*data*/
                 2 && (s.data = /*data*/
                     i[1]), r & /*histDiv*/
-                4096 && (s.div = /*histDiv*/
-                    i[12]), t.$set(s);
+                16384 && (s.div = /*histDiv*/
+                    i[14]), t.$set(s);
         },
         i(i) {
-            n || (he(t.$$.fragment, i), n = !0);
+            n || (me(t.$$.fragment, i), n = !0);
         },
         o(i) {
             Se(t.$$.fragment, i), n = !1;
         },
         d(i) {
-            Un(t, i);
+            jn(t, i);
         }
     };
 }
 
-function u$e(e) {
+function uCe(e) {
     let t;
     return {
         c() {
-            t = ge("p"), t.textContent = "Loading...";
+            t = he("p"), t.textContent = "Loading...";
         },
         m(n, i) {
-            we(n, t, i);
+            pe(n, t, i);
         },
         p: dt,
         i: dt,
         o: dt,
         d(n) {
-            n && xe(t);
+            n && ge(t);
         }
     };
 }
 
 function N9(e) {
     let t, n, i, r;
-    const s = [u$e, a$e],
+    const s = [uCe, aCe],
         o = [];
 
     function a(u, l) {
         return (
             /*histDiv*/
-            u[12] == null ? 0 : 1
+            u[14] == null ? 0 : 1
         );
     }
     return t = a(e), n = o[t] = s[t](e), {
         c() {
             n.c(), i = lf();
         },
         m(u, l) {
-            o[t].m(u, l), we(u, i, l), r = !0;
+            o[t].m(u, l), pe(u, i, l), r = !0;
         },
         p(u, l) {
             let c = t;
-            t = a(u), t === c ? o[t].p(u, l) : (mn(), Se(o[c], 1, 1, () => {
+            t = a(u), t === c ? o[t].p(u, l) : (yn(), Se(o[c], 1, 1, () => {
                 o[c] = null;
-            }), yn(), n = o[t], n ? n.p(u, l) : (n = o[t] = s[t](u), n.c()), he(n, 1), n.m(i.parentNode, i));
+            }), bn(), n = o[t], n ? n.p(u, l) : (n = o[t] = s[t](u), n.c()), me(n, 1), n.m(i.parentNode, i));
         },
         i(u) {
-            r || (he(n), r = !0);
+            r || (me(n), r = !0);
         },
         o(u) {
             Se(n), r = !1;
         },
         d(u) {
-            u && xe(i), o[t].d(u);
+            u && ge(i), o[t].d(u);
         }
     };
 }
 
-function l$e(e) {
+function lCe(e) {
     let t, n;
     return t = new jW({
         props: {
             data: (
                 /*data*/
                 e[1]
             ),
             div: (
                 /*matrixDiv*/
-                e[13]
+                e[15]
             ),
             numConcepts: (
                 /*numConcepts*/
-                e[4]
+                e[6]
             ),
             numSlices: (
                 /*numSlices*/
+                e[7]
+            ),
+            sliceCol: (
+                /*sliceCol*/
+                e[4]
+            ),
+            normBy: (
+                /*normBy*/
                 e[5]
             )
         }
     }), t.$on(
         "message",
         /*handleMatrixEvent*/
-        e[14]
+        e[16]
     ), {
         c() {
             oi(t.$$.fragment);
         },
         m(i, r) {
-            Bn(t, i, r), n = !0;
+            Un(t, i, r), n = !0;
         },
         p(i, r) {
             const s = {};
             r & /*data*/
                 2 && (s.data = /*data*/
                     i[1]), r & /*matrixDiv*/
-                8192 && (s.div = /*matrixDiv*/
-                    i[13]), r & /*numConcepts*/
-                16 && (s.numConcepts = /*numConcepts*/
-                    i[4]), r & /*numSlices*/
-                32 && (s.numSlices = /*numSlices*/
+                32768 && (s.div = /*matrixDiv*/
+                    i[15]), r & /*numConcepts*/
+                64 && (s.numConcepts = /*numConcepts*/
+                    i[6]), r & /*numSlices*/
+                128 && (s.numSlices = /*numSlices*/
+                    i[7]), r & /*sliceCol*/
+                16 && (s.sliceCol = /*sliceCol*/
+                    i[4]), r & /*normBy*/
+                32 && (s.normBy = /*normBy*/
                     i[5]), t.$set(s);
         },
         i(i) {
-            n || (he(t.$$.fragment, i), n = !0);
+            n || (me(t.$$.fragment, i), n = !0);
         },
         o(i) {
             Se(t.$$.fragment, i), n = !1;
         },
         d(i) {
-            Un(t, i);
+            jn(t, i);
         }
     };
 }
 
-function c$e(e) {
+function cCe(e) {
     let t;
     return {
         c() {
-            t = ge("p"), t.textContent = "Loading...";
+            t = he("p"), t.textContent = "Loading...";
         },
         m(n, i) {
-            we(n, t, i);
+            pe(n, t, i);
         },
         p: dt,
         i: dt,
         o: dt,
         d(n) {
-            n && xe(t);
+            n && ge(t);
         }
     };
 }
 
 function O9(e) {
     let t, n, i, r;
-    const s = [c$e, l$e],
+    const s = [cCe, lCe],
         o = [];
 
     function a(u, l) {
         return (
             /*matrixDiv*/
-            u[13] == null ? 0 : 1
+            u[15] == null ? 0 : 1
         );
     }
     return t = a(e), n = o[t] = s[t](e), {
         c() {
             n.c(), i = lf();
         },
         m(u, l) {
-            o[t].m(u, l), we(u, i, l), r = !0;
+            o[t].m(u, l), pe(u, i, l), r = !0;
         },
         p(u, l) {
             let c = t;
-            t = a(u), t === c ? o[t].p(u, l) : (mn(), Se(o[c], 1, 1, () => {
+            t = a(u), t === c ? o[t].p(u, l) : (yn(), Se(o[c], 1, 1, () => {
                 o[c] = null;
-            }), yn(), n = o[t], n ? n.p(u, l) : (n = o[t] = s[t](u), n.c()), he(n, 1), n.m(i.parentNode, i));
+            }), bn(), n = o[t], n ? n.p(u, l) : (n = o[t] = s[t](u), n.c()), me(n, 1), n.m(i.parentNode, i));
         },
         i(u) {
-            r || (he(n), r = !0);
+            r || (me(n), r = !0);
         },
         o(u) {
             Se(n), r = !1;
         },
         d(u) {
-            u && xe(i), o[t].d(u);
+            u && ge(i), o[t].d(u);
         }
     };
 }
 
-function f$e(e) {
+function fCe(e) {
     let t, n, i;
     return n = new v_e({
         props: {
             data: (
                 /*dataItemsWide*/
                 e[3]
             ),
@@ -64385,217 +64397,223 @@
             ),
             el: (
                 /*el*/
                 e[0]
             ),
             filterItems: (
                 /*filterItems*/
-                e[7]
+                e[9]
             ),
             sortBy: (
                 /*sortBy*/
-                e[8]
+                e[10]
             ),
             sortOrder: (
                 /*sortOrder*/
-                e[9]
+                e[11]
             ),
             selectedTitle: (
                 /*selectedTitle*/
-                e[10]
+                e[12]
             ),
             selectedMetadata: (
                 /*selectedMetadata*/
-                e[11]
+                e[13]
             )
         }
     }), {
         c() {
-            t = ge("div"), oi(n.$$.fragment), fe(t, "id", "tableDiv"), fe(t, "class", "tables");
+            t = he("div"), oi(n.$$.fragment), fe(t, "id", "tableDiv"), fe(t, "class", "tables");
         },
         m(r, s) {
-            we(r, t, s), Bn(n, t, null), i = !0;
+            pe(r, t, s), Un(n, t, null), i = !0;
         },
         p(r, s) {
             const o = {};
             s & /*dataItemsWide*/
                 8 && (o.data = /*dataItemsWide*/
                     r[3]), s & /*dataItems*/
                 4 && (o.dataLong = /*dataItems*/
                     r[2]), s & /*el*/
                 1 && (o.el = /*el*/
                     r[0]), s & /*filterItems*/
-                128 && (o.filterItems = /*filterItems*/
-                    r[7]), s & /*sortBy*/
-                256 && (o.sortBy = /*sortBy*/
-                    r[8]), s & /*sortOrder*/
-                512 && (o.sortOrder = /*sortOrder*/
-                    r[9]), s & /*selectedTitle*/
-                1024 && (o.selectedTitle = /*selectedTitle*/
-                    r[10]), s & /*selectedMetadata*/
-                2048 && (o.selectedMetadata = /*selectedMetadata*/
-                    r[11]), n.$set(o);
+                512 && (o.filterItems = /*filterItems*/
+                    r[9]), s & /*sortBy*/
+                1024 && (o.sortBy = /*sortBy*/
+                    r[10]), s & /*sortOrder*/
+                2048 && (o.sortOrder = /*sortOrder*/
+                    r[11]), s & /*selectedTitle*/
+                4096 && (o.selectedTitle = /*selectedTitle*/
+                    r[12]), s & /*selectedMetadata*/
+                8192 && (o.selectedMetadata = /*selectedMetadata*/
+                    r[13]), n.$set(o);
         },
         i(r) {
-            i || (he(n.$$.fragment, r), i = !0);
+            i || (me(n.$$.fragment, r), i = !0);
         },
         o(r) {
             Se(n.$$.fragment, r), i = !1;
         },
         d(r) {
-            r && xe(t), Un(n);
+            r && ge(t), jn(n);
         }
     };
 }
 
-function d$e(e) {
+function dCe(e) {
     let t, n, i;
     return n = new h_e({
         props: {
             data: (
                 /*dataItems*/
                 e[2]
             ),
             el: (
                 /*el*/
                 e[0]
             ),
             filterItems: (
                 /*filterItems*/
-                e[7]
+                e[9]
             ),
             selectedTitle: (
                 /*selectedTitle*/
-                e[10]
+                e[12]
             ),
             selectedMetadata: (
                 /*selectedMetadata*/
-                e[11]
+                e[13]
+            ),
+            sliceCol: (
+                /*sliceCol*/
+                e[4]
             )
         }
     }), {
         c() {
-            t = ge("div"), oi(n.$$.fragment), fe(t, "id", "tableDiv"), fe(t, "class", "tables");
+            t = he("div"), oi(n.$$.fragment), fe(t, "id", "tableDiv"), fe(t, "class", "tables");
         },
         m(r, s) {
-            we(r, t, s), Bn(n, t, null), i = !0;
+            pe(r, t, s), Un(n, t, null), i = !0;
         },
         p(r, s) {
             const o = {};
             s & /*dataItems*/
                 4 && (o.data = /*dataItems*/
                     r[2]), s & /*el*/
                 1 && (o.el = /*el*/
                     r[0]), s & /*filterItems*/
-                128 && (o.filterItems = /*filterItems*/
-                    r[7]), s & /*selectedTitle*/
-                1024 && (o.selectedTitle = /*selectedTitle*/
-                    r[10]), s & /*selectedMetadata*/
-                2048 && (o.selectedMetadata = /*selectedMetadata*/
-                    r[11]), n.$set(o);
+                512 && (o.filterItems = /*filterItems*/
+                    r[9]), s & /*selectedTitle*/
+                4096 && (o.selectedTitle = /*selectedTitle*/
+                    r[12]), s & /*selectedMetadata*/
+                8192 && (o.selectedMetadata = /*selectedMetadata*/
+                    r[13]), s & /*sliceCol*/
+                16 && (o.sliceCol = /*sliceCol*/
+                    r[4]), n.$set(o);
         },
         i(r) {
-            i || (he(n.$$.fragment, r), i = !0);
+            i || (me(n.$$.fragment, r), i = !0);
         },
         o(r) {
             Se(n.$$.fragment, r), i = !1;
         },
         d(r) {
-            r && xe(t), Un(n);
+            r && ge(t), jn(n);
         }
     };
 }
 
-function h$e(e) {
+function hCe(e) {
     let t, n, i = (
         /*numConcepts*/
-        e[4] > 0 && F9(e)
+        e[6] > 0 && F9(e)
     );
     return {
         c() {
-            t = ge("div"), i && i.c();
+            t = he("div"), i && i.c();
         },
         m(r, s) {
-            we(r, t, s), i && i.m(t, null), n = !0;
+            pe(r, t, s), i && i.m(t, null), n = !0;
         },
         p(r, [s]) {
             /*numConcepts*/
-            r[4] > 0 ? i ? (i.p(r, s), s & /*numConcepts*/
-                16 && he(i, 1)) : (i = F9(r), i.c(), he(i, 1), i.m(t, null)) : i && (mn(), Se(i, 1, 1, () => {
+            r[6] > 0 ? i ? (i.p(r, s), s & /*numConcepts*/
+                64 && me(i, 1)) : (i = F9(r), i.c(), me(i, 1), i.m(t, null)) : i && (yn(), Se(i, 1, 1, () => {
                 i = null;
-            }), yn());
+            }), bn());
         },
         i(r) {
-            n || (he(i), n = !0);
+            n || (me(i), n = !0);
         },
         o(r) {
             Se(i), n = !1;
         },
         d(r) {
-            r && xe(t), i && i.d();
+            r && ge(t), i && i.d();
         }
     };
 }
 
-function g$e(e, t, n) {
+function gCe(e, t, n) {
     let {
         model: i
     } = t, {
         el: r
-    } = t, s, o, a, u, l, c, f, d, h, g, p, m, y;
-    s = i.get("data"), o = i.get("data_items"), a = i.get("data_items_wide"), u = i.get("metadata"), l = JSON.parse(u), c = Object.keys(l.concepts).length, f = Object.keys(l.items).length;
-    let b, v;
-
-    function x() {
-        n(6, d = null), n(7, h = {}), n(10, m = null), n(11, y = null);
+    } = t, s, o, a, u, l, c, f, d, h, g, p, m, y, b, v;
+    s = i.get("data"), o = i.get("data_items"), a = i.get("data_items_wide"), u = i.get("metadata"), l = JSON.parse(u), c = i.get("slice_col"), f = i.get("norm_by"), d = Object.keys(l.concepts).length, h = Object.keys(l.items).length;
+    let x, w;
+
+    function E() {
+        n(8, g = null), n(9, p = {}), n(12, b = null), n(13, v = null);
     }
 
-    function w(k) {
-        let A = k.detail.col,
-            F = k.detail.row,
-            T = k.detail.selection_type;
-        if (T == "cell") {
-            if (A == null)
-                x();
+    function _(T) {
+        let M = T.detail.col,
+            L = T.detail.row,
+            F = T.detail.selection_type;
+        if (F == "cell") {
+            if (M == null)
+                E();
             else {
-                n(6, d = "cell"), n(7, h = {
-                    id: A,
-                    concept: F
-                }), n(10, m = "Slice: " + A + ", Concept: " + F);
-                let I = l.items[A],
-                    N = l.concepts[F];
-                n(11, y = Object.assign(I, N));
+                n(8, g = "cell"), n(9, p = {
+                    id: M,
+                    concept: L
+                }), n(12, b = "Slice: " + M + ", Concept: " + L);
+                let O = l.items[M],
+                    N = l.concepts[L];
+                n(13, v = Object.assign(O, N));
             }
-            n(8, g = null), n(9, p = 0);
-        } else if (T == "col") {
-            let I = k.detail.sortOrder;
-            A == null ? x() : (n(6, d = "group"), n(7, h = {
-                id: A
-            }), n(10, m = "Slice: " + A), n(11, y = l.items[A]), n(8, g = "concept_score"), I == 0 ? n(9, p = 0) : I == 1 ? n(9, p = 1) : I == 2 && n(9, p = -1));
-        } else if (T == "row") {
-            let I = k.detail.sortOrder;
-            F == null ? (x(), n(9, p = 0)) : (n(6, d = "concept"), n(7, h = {
-                concept: F
-            }), n(10, m = "Concept: " + F), n(11, y = l.concepts[F]), n(8, g = "concept_score"), I == 0 ? n(9, p = 0) : I == 1 ? n(9, p = 1) : I == 2 && n(9, p = -1));
+            n(10, m = null), n(11, y = 0);
+        } else if (F == "col") {
+            let O = T.detail.sortOrder;
+            M == null ? E() : (n(8, g = "group"), n(9, p = {
+                id: M
+            }), c.length > 0 ? n(12, b = "Slice: " + c + ": " + M) : n(12, b = "Slice: " + M), n(13, v = l.items[M]), n(10, m = "concept_score"), O == 0 ? n(11, y = 0) : O == 1 ? n(11, y = 1) : O == 2 && n(11, y = -1));
+        } else if (F == "row") {
+            let O = T.detail.sortOrder;
+            L == null ? (E(), n(11, y = 0)) : (n(8, g = "concept"), n(9, p = {
+                concept: L
+            }), n(12, b = "Concept: " + L), n(13, v = l.concepts[L]), n(10, m = "concept_score"), O == 0 ? n(11, y = 0) : O == 1 ? n(11, y = 1) : O == 2 && n(11, y = -1));
         }
     }
 
-    function S(k) {
-        la[k ? "unshift" : "push"](() => {
-            b = k, n(12, b);
+    function k(T) {
+        la[T ? "unshift" : "push"](() => {
+            x = T, n(14, x);
         });
     }
 
-    function _(k) {
-        la[k ? "unshift" : "push"](() => {
-            v = k, n(13, v);
+    function A(T) {
+        la[T ? "unshift" : "push"](() => {
+            w = T, n(15, w);
         });
     }
-    return e.$$set = (k) => {
-        "model" in k && n(15, i = k.model), "el" in k && n(0, r = k.el);
+    return e.$$set = (T) => {
+        "model" in T && n(17, i = T.model), "el" in T && n(0, r = T.el);
     }, [
         r,
         s,
         o,
         a,
         c,
         f,
@@ -64603,38 +64621,40 @@
         h,
         g,
         p,
         m,
         y,
         b,
         v,
+        x,
         w,
+        _,
         i,
-        S,
-        _
+        k,
+        A
     ];
 }
-class p$e extends ks {
+class pCe extends ks {
     constructor(t) {
-        super(), Ss(this, t, g$e, h$e, Xi, {
-            model: 15,
+        super(), Ss(this, t, gCe, hCe, Xi, {
+            model: 17,
             el: 0
         });
     }
 }
 
-function eCe({
+function e$e({
     model: e,
     el: t
 }) {
-    let n = new p$e({
+    let n = new pCe({
         target: t,
         props: {
             model: e,
             el: t
         }
     });
     return () => n.$destroy();
 }
 export {
-    eCe as render
+    e$e as render
 };
```

### Comparing `text_lloom-0.1/src/text_lloom/static/index_select.css` & `text_lloom-0.2/src/text_lloom/static/index_select.css`

 * *Files identical despite different names*

### Comparing `text_lloom-0.1/src/text_lloom/static/index_select.js` & `text_lloom-0.2/src/text_lloom/static/index_select.js`

 * *Files identical despite different names*

### Comparing `text_lloom-0.1/src/text_lloom/workbench.py` & `text_lloom-0.2/src/text_lloom/workbench.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,14 +3,16 @@
 
 # Imports
 import time
 import pandas as pd
 import ipywidgets as widgets
 import random
 from nltk.tokenize import sent_tokenize
+import os
+import openai
 
 
 # Local imports
 if __package__ is None or __package__ == '':
     # uses current directory visibility
     from concept_induction import *
     from concept import Concept
@@ -35,20 +37,14 @@
         self.model_name = "gpt-3.5-turbo"
         self.embed_model_name = "text-embedding-3-large"
         self.synth_model_name = "gpt-4-turbo-preview"
         self.score_model_name = "gpt-3.5-turbo"
         self.use_base_api = True
         self.debug = debug  # Whether to run in debug mode
 
-        if save_path is None:
-            # Automatically set using timestamp
-            t = time.strftime('%Y-%m-%d-%H-%M-%S', time.localtime())
-            save_path = f"./exports/{t}"
-        self.save_path = save_path
-
         # Input data
         self.doc_id_col = id_col
         self.doc_col = text_col
         df = self.preprocess_df(df)
         self.in_df = df
         self.df_to_score = df  # Default to df for concept scoring
 
@@ -64,14 +60,20 @@
         # Cost/Time tracking
         self.time = {}  # Stores time required for each step
         self.cost = {}  # Stores cost incurred by each step
         self.tokens = {
             "in_tokens": [],
             "out_tokens": [],
         }
+
+        # Set up API key
+        if "OPENAI_API_KEY" not in os.environ:
+            raise Exception("API key not found. Please set the OPENAI_API_KEY environment variable by running: `os.environ['OPENAI_API_KEY'] = 'your_key'`")
+        else:
+            openai.api_key = os.environ["OPENAI_API_KEY"]
     
     # Preprocesses input dataframe
     def preprocess_df(self, df):
         # Handle missing ID column
         if self.doc_id_col is None:
             print("No `id_col` provided. Created an ID column named 'id'.")
             df = df.copy()
@@ -85,21 +87,22 @@
             df = df.copy()
             len_orig = len(df)
             df = df.dropna(subset=main_cols)
             print(f"\tOriginally: {len_orig} rows, Now: {len(df)} rows")
         
         return df
 
-    def save(self):
+    def save(self, folder, file_name=None):
         # Saves current session to file
         select_widget = self.select_widget
         self.select_widget = None  # Remove widget before saving (can't be pickled)
 
-        t = time.strftime('%Y-%m-%d-%H-%M-%S', time.localtime())
-        cur_path = f"{self.save_path}__{t}.pkl"
+        if file_name is None:
+            file_name = time.strftime('%Y-%m-%d-%H-%M-%S', time.localtime())
+        cur_path = f"{folder}/{file_name}.pkl"
         with open(cur_path, "wb") as f:
             pickle.dump(self, f)
         print(f"Saved session to {cur_path}")
 
         self.select_widget = select_widget  # Restore widget after saving
 
     def get_save_key(self, step_name):
@@ -467,15 +470,15 @@
     # - cols_to_show: list (additional column names to show in the tables)
     # - slice_col: str (column name with which to slice data)
     # - max_slice_bins: int (Optional: for numeric columns, the maximum number of bins to create)
     # - slice_bounds: list (Optional: for numeric columns, manual bin boundaries to use)
     # - show_highlights: bool (whether to show text highlights)
     # - norm_by: str (how to normalize scores: "concept" or "slice")
     # - export_df: bool (whether to return a dataframe for export)
-    def vis(self, cols_to_show=[], slice_col=None, max_slice_bins=5, slice_bounds=None, show_highlights=True, norm_by="concept", export_df=False):
+    def vis(self, cols_to_show=[], slice_col=None, max_slice_bins=5, slice_bounds=None, show_highlights=True, norm_by=None, export_df=False):
         active_concepts = self.__get_active_concepts()
         score_df = self.get_score_df()
 
         widget, matrix_df, item_df, item_df_wide = visualize(
             in_df=self.in_df,
             score_df=score_df,
             doc_col=self.doc_col,
```

### Comparing `text_lloom-0.1/PKG-INFO` & `text_lloom-0.2/PKG-INFO`

 * *Files 10% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: text_lloom
-Version: 0.1
+Version: 0.2
 Summary: Concept Induction to analyze unstructured text
 Author: Michelle Lam
 Author-email: mlam4@cs.stanford.edu
 Requires-Python: >=3.9,<4.0
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
```

