# Comparing `tmp/iroh-0.13.0-py3-none-macosx_11_0_arm64.whl.zip` & `tmp/iroh-0.2.0-py3-none-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,8 +1,8 @@
-Zip file size: 9123119 bytes, number of entries: 6
--rw-r--r--  4.6 unx     1302 b- defN 24-Apr-04 20:54 iroh-0.13.0.dist-info/METADATA
--rw-r--r--  4.6 unx      101 b- defN 24-Apr-04 20:54 iroh-0.13.0.dist-info/WHEEL
--rw-r--r--  4.6 unx       28 b- defN 24-Apr-04 20:54 iroh/__init__.py
--rw-r--r--  4.6 unx   334831 b- defN 24-Apr-04 20:54 iroh/iroh.py
--rwxr-xr-x  4.6 unx 25308672 b- defN 24-Apr-04 20:54 iroh/libuniffi_iroh.dylib
--rw-r--r--  4.6 unx      429 b- defN 24-Apr-04 20:54 iroh-0.13.0.dist-info/RECORD
-6 files, 25645363 bytes uncompressed, 9122365 bytes compressed:  64.4%
+Zip file size: 7968936 bytes, number of entries: 6
+-rw-r--r--  4.6 unx     3572 b- defN 23-Oct-04 09:36 iroh-0.2.0.dist-info/METADATA
+-rw-r--r--  4.6 unx       93 b- defN 23-Oct-04 09:36 iroh-0.2.0.dist-info/WHEEL
+-rw-r--r--  4.6 unx       28 b- defN 23-Oct-04 09:42 iroh/__init__.py
+-rw-r--r--  4.6 unx   108423 b- defN 23-Oct-04 09:42 iroh/iroh.py
+-rwxr-xr-x  4.6 unx 22214144 b- defN 23-Oct-04 09:42 iroh/uniffi_iroh.dll
+-rw-r--r--  4.6 unx      420 b- defN 23-Oct-04 09:42 iroh-0.2.0.dist-info/RECORD
+6 files, 22326680 bytes uncompressed, 7968198 bytes compressed:  64.3%
```

## zipnote {}

```diff
@@ -1,19 +1,19 @@
-Filename: iroh-0.13.0.dist-info/METADATA
+Filename: iroh-0.2.0.dist-info/METADATA
 Comment: 
 
-Filename: iroh-0.13.0.dist-info/WHEEL
+Filename: iroh-0.2.0.dist-info/WHEEL
 Comment: 
 
 Filename: iroh/__init__.py
 Comment: 
 
 Filename: iroh/iroh.py
 Comment: 
 
-Filename: iroh/libuniffi_iroh.dylib
+Filename: iroh/uniffi_iroh.dll
 Comment: 
 
-Filename: iroh-0.13.0.dist-info/RECORD
+Filename: iroh-0.2.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## iroh/iroh.py

```diff
@@ -1,9 +1,7 @@
-
-
 # This file was autogenerated by some hot garbage in the `uniffi` crate.
 # Trust me, you don't want to mess with it!
 
 # Common helper code.
 #
 # Ideally this would live in a separate .py file where it can be unittested etc
 # in isolation, and perhaps even published as a re-useable package.
@@ -22,96 +20,96 @@
 import struct
 import contextlib
 import datetime
 import typing
 import platform
 
 # Used for default argument values
-_DEFAULT = object()
+DEFAULT = object()
 
 
-class _UniffiRustBuffer(ctypes.Structure):
+class RustBuffer(ctypes.Structure):
     _fields_ = [
         ("capacity", ctypes.c_int32),
         ("len", ctypes.c_int32),
         ("data", ctypes.POINTER(ctypes.c_char)),
     ]
 
     @staticmethod
     def alloc(size):
-        return _rust_call(_UniffiLib.ffi_iroh_rustbuffer_alloc, size)
+        return rust_call(_UniFFILib.ffi_iroh_rustbuffer_alloc, size)
 
     @staticmethod
     def reserve(rbuf, additional):
-        return _rust_call(_UniffiLib.ffi_iroh_rustbuffer_reserve, rbuf, additional)
+        return rust_call(_UniFFILib.ffi_iroh_rustbuffer_reserve, rbuf, additional)
 
     def free(self):
-        return _rust_call(_UniffiLib.ffi_iroh_rustbuffer_free, self)
+        return rust_call(_UniFFILib.ffi_iroh_rustbuffer_free, self)
 
     def __str__(self):
-        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
+        return "RustBuffer(capacity={}, len={}, data={})".format(
             self.capacity,
             self.len,
             self.data[0:self.len]
         )
 
     @contextlib.contextmanager
-    def alloc_with_builder(*args):
-        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.
+    def allocWithBuilder(*args):
+        """Context-manger to allocate a buffer using a RustBufferBuilder.
 
         The allocated buffer will be automatically freed if an error occurs, ensuring that
         we don't accidentally leak it.
         """
-        builder = _UniffiRustBufferBuilder()
+        builder = RustBufferBuilder()
         try:
             yield builder
         except:
             builder.discard()
             raise
 
     @contextlib.contextmanager
-    def consume_with_stream(self):
-        """Context-manager to consume a buffer using a _UniffiRustBufferStream.
+    def consumeWithStream(self):
+        """Context-manager to consume a buffer using a RustBufferStream.
 
-        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
+        The RustBuffer will be freed once the context-manager exits, ensuring that we don't
         leak it even if an error occurs.
         """
         try:
-            s = _UniffiRustBufferStream.from_rust_buffer(self)
+            s = RustBufferStream.from_rust_buffer(self)
             yield s
             if s.remaining() != 0:
-                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
+                raise RuntimeError("junk data left in buffer at end of consumeWithStream")
         finally:
             self.free()
 
     @contextlib.contextmanager
-    def read_with_stream(self):
-        """Context-manager to read a buffer using a _UniffiRustBufferStream.
+    def readWithStream(self):
+        """Context-manager to read a buffer using a RustBufferStream.
 
-        This is like consume_with_stream, but doesn't free the buffer afterwards.
-        It should only be used with borrowed `_UniffiRustBuffer` data.
+        This is like consumeWithStream, but doesn't free the buffer afterwards.
+        It should only be used with borrowed `RustBuffer` data.
         """
-        s = _UniffiRustBufferStream.from_rust_buffer(self)
+        s = RustBufferStream.from_rust_buffer(self)
         yield s
         if s.remaining() != 0:
-            raise RuntimeError("junk data left in buffer at end of read_with_stream")
+            raise RuntimeError("junk data left in buffer at end of readWithStream")
 
-class _UniffiForeignBytes(ctypes.Structure):
+class ForeignBytes(ctypes.Structure):
     _fields_ = [
         ("len", ctypes.c_int32),
         ("data", ctypes.POINTER(ctypes.c_char)),
     ]
 
     def __str__(self):
-        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])
+        return "ForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])
 
 
-class _UniffiRustBufferStream:
+class RustBufferStream:
     """
-    Helper for structured reading of bytes from a _UniffiRustBuffer
+    Helper for structured reading of bytes from a RustBuffer
     """
 
     def __init__(self, data, len):
         self.data = data
         self.len = len
         self.offset = 0
 
@@ -132,198 +130,213 @@
     def read(self, size):
         if self.offset + size > self.len:
             raise InternalError("read past end of rust buffer")
         data = self.data[self.offset:self.offset+size]
         self.offset += size
         return data
 
-    def read_i8(self):
+    def readI8(self):
         return self._unpack_from(1, ">b")
 
-    def read_u8(self):
+    def readU8(self):
         return self._unpack_from(1, ">B")
 
-    def read_i16(self):
+    def readI16(self):
         return self._unpack_from(2, ">h")
 
-    def read_u16(self):
+    def readU16(self):
         return self._unpack_from(2, ">H")
 
-    def read_i32(self):
+    def readI32(self):
         return self._unpack_from(4, ">i")
 
-    def read_u32(self):
+    def readU32(self):
         return self._unpack_from(4, ">I")
 
-    def read_i64(self):
+    def readI64(self):
         return self._unpack_from(8, ">q")
 
-    def read_u64(self):
+    def readU64(self):
         return self._unpack_from(8, ">Q")
 
-    def read_float(self):
+    def readFloat(self):
         v = self._unpack_from(4, ">f")
         return v
 
-    def read_double(self):
+    def readDouble(self):
         return self._unpack_from(8, ">d")
 
-    def read_c_size_t(self):
+    def readCSizeT(self):
         return self._unpack_from(ctypes.sizeof(ctypes.c_size_t) , "@N")
 
-class _UniffiRustBufferBuilder:
+class RustBufferBuilder:
     """
-    Helper for structured writing of bytes into a _UniffiRustBuffer.
+    Helper for structured writing of bytes into a RustBuffer.
     """
 
     def __init__(self):
-        self.rbuf = _UniffiRustBuffer.alloc(16)
+        self.rbuf = RustBuffer.alloc(16)
         self.rbuf.len = 0
 
     def finalize(self):
         rbuf = self.rbuf
         self.rbuf = None
         return rbuf
 
     def discard(self):
         if self.rbuf is not None:
             rbuf = self.finalize()
             rbuf.free()
 
     @contextlib.contextmanager
-    def _reserve(self, num_bytes):
-        if self.rbuf.len + num_bytes > self.rbuf.capacity:
-            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
+    def _reserve(self, numBytes):
+        if self.rbuf.len + numBytes > self.rbuf.capacity:
+            self.rbuf = RustBuffer.reserve(self.rbuf, numBytes)
         yield None
-        self.rbuf.len += num_bytes
+        self.rbuf.len += numBytes
 
     def _pack_into(self, size, format, value):
         with self._reserve(size):
             # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
             for i, byte in enumerate(struct.pack(format, value)):
                 self.rbuf.data[self.rbuf.len + i] = byte
 
     def write(self, value):
         with self._reserve(len(value)):
             for i, byte in enumerate(value):
                 self.rbuf.data[self.rbuf.len + i] = byte
 
-    def write_i8(self, v):
+    def writeI8(self, v):
         self._pack_into(1, ">b", v)
 
-    def write_u8(self, v):
+    def writeU8(self, v):
         self._pack_into(1, ">B", v)
 
-    def write_i16(self, v):
+    def writeI16(self, v):
         self._pack_into(2, ">h", v)
 
-    def write_u16(self, v):
+    def writeU16(self, v):
         self._pack_into(2, ">H", v)
 
-    def write_i32(self, v):
+    def writeI32(self, v):
         self._pack_into(4, ">i", v)
 
-    def write_u32(self, v):
+    def writeU32(self, v):
         self._pack_into(4, ">I", v)
 
-    def write_i64(self, v):
+    def writeI64(self, v):
         self._pack_into(8, ">q", v)
 
-    def write_u64(self, v):
+    def writeU64(self, v):
         self._pack_into(8, ">Q", v)
 
-    def write_float(self, v):
+    def writeFloat(self, v):
         self._pack_into(4, ">f", v)
 
-    def write_double(self, v):
+    def writeDouble(self, v):
         self._pack_into(8, ">d", v)
 
-    def write_c_size_t(self, v):
+    def writeCSizeT(self, v):
         self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
 # A handful of classes and functions to support the generated data structures.
 # This would be a good candidate for isolating in its own ffi-support lib.
 
 class InternalError(Exception):
     pass
 
-class _UniffiRustCallStatus(ctypes.Structure):
+class RustCallStatus(ctypes.Structure):
     """
     Error runtime.
     """
     _fields_ = [
         ("code", ctypes.c_int8),
-        ("error_buf", _UniffiRustBuffer),
+        ("error_buf", RustBuffer),
     ]
 
     # These match the values from the uniffi::rustcalls module
     CALL_SUCCESS = 0
     CALL_ERROR = 1
     CALL_PANIC = 2
 
     def __str__(self):
-        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
-            return "_UniffiRustCallStatus(CALL_SUCCESS)"
-        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
-            return "_UniffiRustCallStatus(CALL_ERROR)"
-        elif self.code == _UniffiRustCallStatus.CALL_PANIC:
-            return "_UniffiRustCallStatus(CALL_PANIC)"
+        if self.code == RustCallStatus.CALL_SUCCESS:
+            return "RustCallStatus(CALL_SUCCESS)"
+        elif self.code == RustCallStatus.CALL_ERROR:
+            return "RustCallStatus(CALL_ERROR)"
+        elif self.code == RustCallStatus.CALL_PANIC:
+            return "RustCallStatus(CALL_PANIC)"
         else:
-            return "_UniffiRustCallStatus(<invalid code>)"
+            return "RustCallStatus(<invalid code>)"
 
-def _rust_call(fn, *args):
+def rust_call(fn, *args):
     # Call a rust function
-    return _rust_call_with_error(None, fn, *args)
+    return rust_call_with_error(None, fn, *args)
 
-def _rust_call_with_error(error_ffi_converter, fn, *args):
+def rust_call_with_error(error_ffi_converter, fn, *args):
     # Call a rust function and handle any errors
     #
     # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
-    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
-    call_status = _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer(0, 0, None))
+    # error_ffi_converter must be set to the FfiConverter for the error class that corresponds to the result.
+    call_status = RustCallStatus(code=RustCallStatus.CALL_SUCCESS, error_buf=RustBuffer(0, 0, None))
 
     args_with_error = args + (ctypes.byref(call_status),)
     result = fn(*args_with_error)
-    _uniffi_check_call_status(error_ffi_converter, call_status)
+    uniffi_check_call_status(error_ffi_converter, call_status)
     return result
 
-def _uniffi_check_call_status(error_ffi_converter, call_status):
-    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
+def rust_call_async(scaffolding_fn, callback_fn, *args):
+    # Call the scaffolding function, passing it a callback handler for `AsyncTypes.py` and a pointer
+    # to a python Future object.  The async function then awaits the Future.
+    uniffi_eventloop = asyncio.get_running_loop()
+    uniffi_py_future = uniffi_eventloop.create_future()
+    uniffi_call_status = RustCallStatus(code=RustCallStatus.CALL_SUCCESS, error_buf=RustBuffer(0, 0, None))
+    scaffolding_fn(*args,
+       FfiConverterForeignExecutor._pointer_manager.new_pointer(uniffi_eventloop),
+       callback_fn,
+       # Note: It's tempting to skip the pointer manager and just use a `py_object` pointing to a
+       # local variable like we do in Swift.  However, Python doesn't use cooperative cancellation
+       # -- asyncio can cancel a task at anytime.  This means if we use a local variable, the Rust
+       # callback could fire with a dangling pointer.
+       UniFfiPyFuturePointerManager.new_pointer(uniffi_py_future),
+       ctypes.byref(uniffi_call_status),
+    )
+    uniffi_check_call_status(None, uniffi_call_status)
+    return uniffi_py_future
+
+def uniffi_check_call_status(error_ffi_converter, call_status):
+    if call_status.code == RustCallStatus.CALL_SUCCESS:
         pass
-    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
+    elif call_status.code == RustCallStatus.CALL_ERROR:
         if error_ffi_converter is None:
             call_status.error_buf.free()
-            raise InternalError("_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
+            raise InternalError("rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
         else:
             raise error_ffi_converter.lift(call_status.error_buf)
-    elif call_status.code == _UniffiRustCallStatus.CALL_PANIC:
-        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
+    elif call_status.code == RustCallStatus.CALL_PANIC:
+        # When the rust code sees a panic, it tries to construct a RustBuffer
         # with the message.  But if that code panics, then it just sends back
         # an empty buffer.
         if call_status.error_buf.len > 0:
-            msg = _UniffiConverterString.lift(call_status.error_buf)
+            msg = FfiConverterString.lift(call_status.error_buf)
         else:
             msg = "Unknown rust panic"
         raise InternalError(msg)
     else:
-        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
+        raise InternalError("Invalid RustCallStatus code: {}".format(
             call_status.code))
 
 # A function pointer for a callback as defined by UniFFI.
-# Rust definition `fn(handle: u64, method: u32, args: _UniffiRustBuffer, buf_ptr: *mut _UniffiRustBuffer) -> int`
-_UNIFFI_FOREIGN_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_ulonglong, ctypes.c_ulong, ctypes.POINTER(ctypes.c_char), ctypes.c_int, ctypes.POINTER(_UniffiRustBuffer))
-
-# UniFFI future continuation
-_UNIFFI_FUTURE_CONTINUATION_T = ctypes.CFUNCTYPE(None, ctypes.c_size_t, ctypes.c_int8)
-
-class _UniffiPointerManagerCPython:
+# Rust definition `fn(handle: u64, method: u32, args: RustBuffer, buf_ptr: *mut RustBuffer) -> int`
+FOREIGN_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_ulonglong, ctypes.c_ulong, ctypes.POINTER(ctypes.c_char), ctypes.c_int, ctypes.POINTER(RustBuffer))
+class UniFfiPointerManagerCPython:
     """
     Manage giving out pointers to Python objects on CPython
 
     This class is used to generate opaque pointers that reference Python objects to pass to Rust.
-    It assumes a CPython platform.  See _UniffiPointerManagerGeneral for the alternative.
+    It assumes a CPython platform.  See UniFfiPointerManagerGeneral for the alternative.
     """
 
     def new_pointer(self, obj):
         """
         Get a pointer for an object as a ctypes.c_size_t instance
 
         Each call to new_pointer() must be balanced with exactly one call to release_pointer()
@@ -342,19 +355,19 @@
         obj = py_obj.value
         ctypes.pythonapi.Py_DecRef(py_obj)
         return obj
 
     def lookup(self, address):
         return ctypes.cast(address, ctypes.py_object).value
 
-class _UniffiPointerManagerGeneral:
+class UniFfiPointerManagerGeneral:
     """
     Manage giving out pointers to Python objects on non-CPython platforms
 
-    This has the same API as _UniffiPointerManagerCPython, but doesn't assume we're running on
+    This has the same API as UniFfiPointerManagerCPython, but doesn't assume we're running on
     CPython and is slightly slower.
 
     Instead of using real pointers, it maps integer values to objects and returns the keys as
     c_size_t values.
     """
 
     def __init__(self):
@@ -375,19 +388,19 @@
 
     def lookup(self, handle):
         with self._lock:
             return self._map[handle]
 
 # Pick an pointer manager implementation based on the platform
 if platform.python_implementation() == 'CPython':
-    _UniffiPointerManager = _UniffiPointerManagerCPython # type: ignore
+    UniFfiPointerManager = UniFfiPointerManagerCPython  # type: ignore
 else:
-    _UniffiPointerManager = _UniffiPointerManagerGeneral # type: ignore
-# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
-class _UniffiConverterPrimitive:
+    UniFfiPointerManager = UniFfiPointerManagerGeneral  # type: ignore
+# Types conforming to `FfiConverterPrimitive` pass themselves directly over the FFI.
+class FfiConverterPrimitive:
     @classmethod
     def check(cls, value):
         return value
 
     @classmethod
     def lift(cls, value):
         return value
@@ -398,55 +411,56 @@
 
     @classmethod
     def lowerUnchecked(cls, value):
         return value
 
     @classmethod
     def write(cls, value, buf):
-        cls.write_unchecked(cls.check(value), buf)
+        cls.writeUnchecked(cls.check(value), buf)
 
-class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
+class FfiConverterPrimitiveInt(FfiConverterPrimitive):
     @classmethod
     def check(cls, value):
         try:
             value = value.__index__()
         except Exception:
             raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
         if not isinstance(value, int):
             raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
         if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
             raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))
         return super().check(value)
 
-class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
+class FfiConverterPrimitiveFloat(FfiConverterPrimitive):
     @classmethod
     def check(cls, value):
         try:
             value = value.__float__()
         except Exception:
             raise TypeError("must be real number, not {}".format(type(value).__name__))
         if not isinstance(value, float):
             raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))
         return super().check(value)
 
-# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
+# Helper class for wrapper types that will always go through a RustBuffer.
 # Classes should inherit from this and implement the `read` and `write` static methods.
-class _UniffiConverterRustBuffer:
+class FfiConverterRustBuffer:
     @classmethod
     def lift(cls, rbuf):
-        with rbuf.consume_with_stream() as stream:
+        with rbuf.consumeWithStream() as stream:
             return cls.read(stream)
 
     @classmethod
     def lower(cls, value):
-        with _UniffiRustBuffer.alloc_with_builder() as builder:
+        with RustBuffer.allocWithBuilder() as builder:
             cls.write(value, builder)
             return builder.finalize()
 
-# Contains loading, initialization code, and the FFI Function declarations.
+# Contains loading, initialization code,
+# and the FFI Function declarations in a com.sun.jna.Library.
 # Define some ctypes FFI types that we use in the library
 
 """
 ctypes type for the foreign executor callback.  This is a built-in interface for scheduling
 tasks
 
 Args:
@@ -455,28 +469,30 @@
   task: function pointer to the task callback
   task_data: void pointer to the task callback data
 
 Normally we should call task(task_data) after the detail.
 However, when task is NULL this indicates that Rust has dropped the ForeignExecutor and we should
 decrease the EventLoop refcount.
 """
-_UNIFFI_FOREIGN_EXECUTOR_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int8, ctypes.c_size_t, ctypes.c_uint32, ctypes.c_void_p, ctypes.c_void_p)
+UNIFFI_FOREIGN_EXECUTOR_CALLBACK_T = ctypes.CFUNCTYPE(None, ctypes.c_size_t, ctypes.c_uint32, ctypes.c_void_p, ctypes.c_void_p)
 
 """
 Function pointer for a Rust task, which a callback function that takes a opaque pointer
 """
-_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)
+UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p)
 
-def _uniffi_future_callback_t(return_type):
+def uniffi_future_callback_t(return_type):
     """
     Factory function to create callback function types for async functions
     """
-    return ctypes.CFUNCTYPE(None, ctypes.c_size_t, return_type, _UniffiRustCallStatus)
+    return ctypes.CFUNCTYPE(None, ctypes.c_size_t, return_type, RustCallStatus)
+
+from pathlib import Path
 
-def _uniffi_load_indirect():
+def loadIndirect():
     """
     This is how we find and load the dynamic library provided by the component.
     For now we just look it up by name.
     """
     if sys.platform == "darwin":
         libname = "lib{}.dylib"
     elif sys.platform.startswith("win"):
@@ -489,7663 +505,2147 @@
             "{}.dll",
         )
     else:
         # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
         libname = "lib{}.so"
 
     libname = libname.format("uniffi_iroh")
-    path = os.path.join(os.path.dirname(__file__), libname)
+    path = str(Path(__file__).parent / libname)
     lib = ctypes.cdll.LoadLibrary(path)
     return lib
 
-def _uniffi_check_contract_api_version(lib):
+def uniffi_check_contract_api_version(lib):
     # Get the bindings contract version from our ComponentInterface
-    bindings_contract_version = 24
+    bindings_contract_version = 22
     # Get the scaffolding contract version by calling the into the dylib
     scaffolding_contract_version = lib.ffi_iroh_uniffi_contract_version()
     if bindings_contract_version != scaffolding_contract_version:
         raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
 
-def _uniffi_check_api_checksums(lib):
-    if lib.uniffi_iroh_checksum_func_key_to_path() != 1201:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_func_path_to_key() != 27769:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_func_set_log_level() != 52296:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_func_start_metrics_collection() != 17691:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_addprogress_as_abort() != 64540:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_addprogress_as_all_done() != 24629:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_addprogress_as_done() != 65369:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_addprogress_as_found() != 14508:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_addprogress_as_progress() != 54075:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_addprogress_type() != 63416:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_authorid_equal() != 53671:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_authorid_to_string() != 42389:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_blobticket_as_download_request() != 22131:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_blobticket_format() != 22598:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_blobticket_hash() != 5648:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_blobticket_node_addr() != 28080:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_collection_blobs() != 26191:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_collection_is_empty() != 46151:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_collection_len() != 3727:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_collection_links() != 52333:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_collection_names() != 17514:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_collection_push() != 50200:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_connectiontype_as_direct() != 27175:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_connectiontype_as_mixed() != 41300:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_connectiontype_as_relay() != 40210:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_connectiontype_type() != 1057:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_directaddrinfo_addr() != 41252:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_directaddrinfo_last_control() != 46706:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_directaddrinfo_last_payload() != 16797:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_directaddrinfo_latency() != 62303:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_doc_close() != 23013:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_doc_del() != 22285:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_doc_export_file() != 34185:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_doc_get_download_policy() != 13666:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_doc_get_exact() != 48441:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_doc_get_many() != 58857:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_doc_get_one() != 25151:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_doc_id() != 32607:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_doc_import_file() != 33349:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_doc_leave() != 55816:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_doc_set_bytes() != 46067:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_doc_set_download_policy() != 13428:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_doc_set_hash() != 20311:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_doc_share() != 19220:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_doc_start_sync() != 54158:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_doc_status() != 59550:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_doc_subscribe() != 2866:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_docexportprogress_as_abort() != 39226:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_docexportprogress_as_found() != 11254:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_docexportprogress_as_progress() != 8859:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_docexportprogress_type() != 43844:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_docimportprogress_as_abort() != 45779:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_docimportprogress_as_all_done() != 7478:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_docimportprogress_as_found() != 55008:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_docimportprogress_as_ingest_done() != 37186:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_docimportprogress_as_progress() != 35401:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_docimportprogress_type() != 49227:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_downloadprogress_as_abort() != 13741:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_downloadprogress_as_all_done() != 51121:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_downloadprogress_as_done() != 54270:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_downloadprogress_as_found() != 13482:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_downloadprogress_as_found_hash_seq() != 64232:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_downloadprogress_as_found_local() != 2930:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_downloadprogress_as_progress() != 7204:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_downloadprogress_type() != 8349:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_entry_author() != 26124:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_entry_content_bytes() != 26896:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_entry_content_hash() != 39306:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_entry_content_len() != 60107:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_entry_key() != 19122:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_entry_namespace() != 52248:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_filterkind_matches() != 35187:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_hash_equal() != 52326:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_hash_to_bytes() != 29465:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_hash_to_hex() != 27622:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_hash_to_string() != 61408:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_author_create() != 31148:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_author_list() != 12499:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_blobs_add_bytes() != 39803:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_blobs_add_from_path() != 38440:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_blobs_create_collection() != 15721:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_blobs_delete_blob() != 24766:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_blobs_download() != 50921:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_blobs_export() != 24742:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_blobs_get_collection() != 45730:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_blobs_list() != 49039:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_blobs_list_collections() != 28497:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_blobs_list_incomplete() != 39285:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_blobs_read_at_to_bytes() != 40980:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_blobs_read_to_bytes() != 6512:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_blobs_share() != 22620:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_blobs_size() != 9420:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_blobs_write_to_path() != 9029:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_connection_info() != 31037:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_connections() != 37352:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_doc_create() != 64213:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_doc_drop() != 49858:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_doc_join() != 48292:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_doc_list() != 44252:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_doc_open() != 47317:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_node_id() != 31962:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_stats() != 16158:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_status() != 32660:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_tags_delete() != 19876:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_irohnode_tags_list() != 6726:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_liveevent_as_content_ready() != 15237:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_liveevent_as_insert_local() != 431:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_liveevent_as_insert_remote() != 17302:
+def uniffi_check_api_checksums(lib):
+    if lib.uniffi_iroh_checksum_func_set_log_level() != 20910:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_liveevent_as_neighbor_down() != 154:
+    if lib.uniffi_iroh_checksum_func_start_metrics_collection() != 30246:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_liveevent_as_neighbor_up() != 25727:
+    if lib.uniffi_iroh_checksum_method_irohnode_node_id() != 860:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_liveevent_as_sync_finished() != 14329:
+    if lib.uniffi_iroh_checksum_method_irohnode_doc_new() != 10558:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_liveevent_type() != 35533:
+    if lib.uniffi_iroh_checksum_method_irohnode_doc_join() != 34149:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_nodeaddr_direct_addresses() != 44368:
+    if lib.uniffi_iroh_checksum_method_irohnode_author_new() != 7219:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_nodeaddr_equal() != 40672:
+    if lib.uniffi_iroh_checksum_method_irohnode_author_list() != 10059:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_nodeaddr_relay_url() != 52692:
+    if lib.uniffi_iroh_checksum_method_irohnode_stats() != 12801:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_nodestatusresponse_listen_addrs() != 43813:
+    if lib.uniffi_iroh_checksum_method_irohnode_connections() != 64165:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_nodestatusresponse_node_addr() != 37017:
+    if lib.uniffi_iroh_checksum_method_irohnode_connection_info() != 27388:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_nodestatusresponse_version() != 50257:
+    if lib.uniffi_iroh_checksum_method_irohnode_blob_list_blobs() != 53280:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_publickey_equal() != 13922:
+    if lib.uniffi_iroh_checksum_method_irohnode_blob_get() != 65293:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_publickey_fmt_short() != 33947:
+    if lib.uniffi_iroh_checksum_method_doc_id() != 34918:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_publickey_to_bytes() != 54334:
+    if lib.uniffi_iroh_checksum_method_doc_share_write() != 64425:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_publickey_to_string() != 48998:
+    if lib.uniffi_iroh_checksum_method_doc_share_read() != 8947:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_query_limit() != 6405:
+    if lib.uniffi_iroh_checksum_method_doc_set_bytes() != 50064:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_query_offset() != 5309:
+    if lib.uniffi_iroh_checksum_method_doc_get_content_bytes() != 56096:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_rangespec_is_all() != 17079:
+    if lib.uniffi_iroh_checksum_method_doc_keys() != 10934:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_rangespec_is_empty() != 55537:
+    if lib.uniffi_iroh_checksum_method_doc_subscribe() != 17522:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_authorid_from_string() != 14210:
+    if lib.uniffi_iroh_checksum_method_doc_stop_sync() != 10292:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_blobdownloadrequest_new() != 40776:
+    if lib.uniffi_iroh_checksum_method_doc_status() != 11839:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_blobticket_new() != 38754:
+    if lib.uniffi_iroh_checksum_method_authorid_to_string() != 61926:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_collection_new() != 41716:
+    if lib.uniffi_iroh_checksum_method_entry_author() != 7235:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_downloadpolicy_everything() != 38497:
+    if lib.uniffi_iroh_checksum_method_entry_key() != 56754:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_downloadpolicy_everything_except() != 43304:
+    if lib.uniffi_iroh_checksum_method_entry_hash() != 38165:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_downloadpolicy_nothing() != 1427:
+    if lib.uniffi_iroh_checksum_method_hash_to_string() != 33037:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_downloadpolicy_nothing_except() != 28298:
+    if lib.uniffi_iroh_checksum_method_hash_to_bytes() != 55740:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_filterkind_exact() != 52030:
+    if lib.uniffi_iroh_checksum_method_docticket_to_string() != 32683:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_filterkind_prefix() != 40434:
+    if lib.uniffi_iroh_checksum_method_liveevent_type() != 20373:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_hash_from_bytes() != 19134:
+    if lib.uniffi_iroh_checksum_method_liveevent_as_insert_local() != 50454:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_hash_from_string() != 30790:
+    if lib.uniffi_iroh_checksum_method_liveevent_as_insert_remote() != 18845:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_hash_new() != 22809:
+    if lib.uniffi_iroh_checksum_method_liveevent_as_content_ready() != 42964:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_irohnode_new() != 22562:
+    if lib.uniffi_iroh_checksum_method_liveevent_as_neighbor_up() != 46965:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_irohnode_with_options() != 40905:
+    if lib.uniffi_iroh_checksum_method_liveevent_as_neighbor_down() != 23815:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_nodeaddr_new() != 30442:
+    if lib.uniffi_iroh_checksum_method_liveevent_as_sync_finished() != 25654:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_publickey_from_bytes() != 65104:
+    if lib.uniffi_iroh_checksum_method_namespaceid_to_string() != 63677:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_publickey_from_string() != 18975:
+    if lib.uniffi_iroh_checksum_method_publickey_to_string() != 54071:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_query_all() != 18362:
+    if lib.uniffi_iroh_checksum_method_publickey_to_bytes() != 22866:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_query_author() != 5981:
+    if lib.uniffi_iroh_checksum_constructor_irohnode_new() != 26269:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_query_author_key_exact() != 34711:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_query_author_key_prefix() != 20638:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_query_key_exact() != 32100:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_query_key_prefix() != 44412:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_query_single_latest_per_key() != 42778:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_settagoption_auto() != 13040:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_settagoption_named() != 61876:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_wrapoption_no_wrap() != 60952:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_constructor_wrapoption_wrap() != 59295:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_addcallback_progress() != 42266:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_docexportfilecallback_progress() != 20951:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_docimportfilecallback_progress() != 18783:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_downloadcallback_progress() != 64403:
-        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
-    if lib.uniffi_iroh_checksum_method_subscribecallback_event() != 18725:
+    if lib.uniffi_iroh_checksum_constructor_docticket_from_string() != 12688:
         raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
 
 # A ctypes library to expose the extern-C FFI definitions.
 # This is an implementation detail which will be called internally by the public API.
 
-_UniffiLib = _uniffi_load_indirect()
-_UniffiLib.uniffi_iroh_fn_free_addprogress.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_free_addprogress.restype = None
-_UniffiLib.uniffi_iroh_fn_method_addprogress_as_abort.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_addprogress_as_abort.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_addprogress_as_all_done.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_addprogress_as_all_done.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_addprogress_as_done.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_addprogress_as_done.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_addprogress_as_found.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_addprogress_as_found.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_addprogress_as_progress.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_addprogress_as_progress.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_addprogress_type.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_addprogress_type.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_free_authorid.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_free_authorid.restype = None
-_UniffiLib.uniffi_iroh_fn_constructor_authorid_from_string.argtypes = (
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_constructor_authorid_from_string.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_method_authorid_equal.argtypes = (
-    ctypes.c_void_p,
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_authorid_equal.restype = ctypes.c_int8
-_UniffiLib.uniffi_iroh_fn_method_authorid_to_string.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_authorid_to_string.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_free_blobdownloadrequest.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_free_blobdownloadrequest.restype = None
-_UniffiLib.uniffi_iroh_fn_constructor_blobdownloadrequest_new.argtypes = (
-    ctypes.c_void_p,
-    _UniffiRustBuffer,
-    ctypes.c_void_p,
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_constructor_blobdownloadrequest_new.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_free_blobticket.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_free_blobticket.restype = None
-_UniffiLib.uniffi_iroh_fn_constructor_blobticket_new.argtypes = (
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_constructor_blobticket_new.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_method_blobticket_as_download_request.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_blobticket_as_download_request.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_method_blobticket_format.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_blobticket_format.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_blobticket_hash.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_blobticket_hash.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_method_blobticket_node_addr.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_blobticket_node_addr.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_free_collection.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_free_collection.restype = None
-_UniffiLib.uniffi_iroh_fn_constructor_collection_new.argtypes = (
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_constructor_collection_new.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_method_collection_blobs.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_collection_blobs.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_collection_is_empty.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_collection_is_empty.restype = ctypes.c_int8
-_UniffiLib.uniffi_iroh_fn_method_collection_len.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_collection_len.restype = ctypes.c_uint64
-_UniffiLib.uniffi_iroh_fn_method_collection_links.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_collection_links.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_collection_names.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_collection_names.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_collection_push.argtypes = (
-    ctypes.c_void_p,
-    _UniffiRustBuffer,
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_collection_push.restype = None
-_UniffiLib.uniffi_iroh_fn_free_connectiontype.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_free_connectiontype.restype = None
-_UniffiLib.uniffi_iroh_fn_method_connectiontype_as_direct.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_connectiontype_as_direct.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_connectiontype_as_mixed.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_connectiontype_as_mixed.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_connectiontype_as_relay.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_connectiontype_as_relay.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_connectiontype_type.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_connectiontype_type.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_free_directaddrinfo.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_free_directaddrinfo.restype = None
-_UniffiLib.uniffi_iroh_fn_method_directaddrinfo_addr.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_directaddrinfo_addr.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_directaddrinfo_last_control.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_directaddrinfo_last_control.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_directaddrinfo_last_payload.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_directaddrinfo_last_payload.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_directaddrinfo_latency.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_directaddrinfo_latency.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_free_doc.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_free_doc.restype = None
-_UniffiLib.uniffi_iroh_fn_method_doc_close.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_doc_close.restype = None
-_UniffiLib.uniffi_iroh_fn_method_doc_del.argtypes = (
-    ctypes.c_void_p,
-    ctypes.c_void_p,
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_doc_del.restype = ctypes.c_uint64
-_UniffiLib.uniffi_iroh_fn_method_doc_export_file.argtypes = (
-    ctypes.c_void_p,
-    ctypes.c_void_p,
-    _UniffiRustBuffer,
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_doc_export_file.restype = None
-_UniffiLib.uniffi_iroh_fn_method_doc_get_download_policy.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_doc_get_download_policy.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_method_doc_get_exact.argtypes = (
-    ctypes.c_void_p,
-    ctypes.c_void_p,
-    _UniffiRustBuffer,
-    ctypes.c_int8,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_doc_get_exact.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_doc_get_many.argtypes = (
-    ctypes.c_void_p,
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_doc_get_many.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_doc_get_one.argtypes = (
-    ctypes.c_void_p,
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_doc_get_one.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_doc_id.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_doc_id.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_doc_import_file.argtypes = (
-    ctypes.c_void_p,
+_UniFFILib = loadIndirect()
+_UniFFILib.uniffi_iroh_fn_free_irohnode.argtypes = (
     ctypes.c_void_p,
-    _UniffiRustBuffer,
-    _UniffiRustBuffer,
-    ctypes.c_int8,
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_doc_import_file.restype = None
-_UniffiLib.uniffi_iroh_fn_method_doc_leave.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+_UniFFILib.uniffi_iroh_fn_free_irohnode.restype = None
+_UniFFILib.uniffi_iroh_fn_constructor_irohnode_new.argtypes = (
+    RustBuffer,
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_doc_leave.restype = None
-_UniffiLib.uniffi_iroh_fn_method_doc_set_bytes.argtypes = (
-    ctypes.c_void_p,
+_UniFFILib.uniffi_iroh_fn_constructor_irohnode_new.restype = ctypes.c_void_p
+_UniFFILib.uniffi_iroh_fn_method_irohnode_node_id.argtypes = (
     ctypes.c_void_p,
-    _UniffiRustBuffer,
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_doc_set_bytes.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_method_doc_set_download_policy.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_irohnode_node_id.restype = RustBuffer
+_UniFFILib.uniffi_iroh_fn_method_irohnode_doc_new.argtypes = (
     ctypes.c_void_p,
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_doc_set_download_policy.restype = None
-_UniffiLib.uniffi_iroh_fn_method_doc_set_hash.argtypes = (
-    ctypes.c_void_p,
+_UniFFILib.uniffi_iroh_fn_method_irohnode_doc_new.restype = ctypes.c_void_p
+_UniFFILib.uniffi_iroh_fn_method_irohnode_doc_join.argtypes = (
     ctypes.c_void_p,
-    _UniffiRustBuffer,
     ctypes.c_void_p,
-    ctypes.c_uint64,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_doc_set_hash.restype = None
-_UniffiLib.uniffi_iroh_fn_method_doc_share.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_irohnode_doc_join.restype = ctypes.c_void_p
+_UniFFILib.uniffi_iroh_fn_method_irohnode_author_new.argtypes = (
     ctypes.c_void_p,
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_doc_share.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_doc_start_sync.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_irohnode_author_new.restype = ctypes.c_void_p
+_UniFFILib.uniffi_iroh_fn_method_irohnode_author_list.argtypes = (
     ctypes.c_void_p,
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_doc_start_sync.restype = None
-_UniffiLib.uniffi_iroh_fn_method_doc_status.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_irohnode_author_list.restype = RustBuffer
+_UniFFILib.uniffi_iroh_fn_method_irohnode_stats.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_doc_status.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_doc_subscribe.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_irohnode_stats.restype = RustBuffer
+_UniFFILib.uniffi_iroh_fn_method_irohnode_connections.argtypes = (
     ctypes.c_void_p,
-    ctypes.c_uint64,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_doc_subscribe.restype = None
-_UniffiLib.uniffi_iroh_fn_free_docexportprogress.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_irohnode_connections.restype = RustBuffer
+_UniFFILib.uniffi_iroh_fn_method_irohnode_connection_info.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_free_docexportprogress.restype = None
-_UniffiLib.uniffi_iroh_fn_method_docexportprogress_as_abort.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_docexportprogress_as_abort.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_docexportprogress_as_found.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_irohnode_connection_info.restype = RustBuffer
+_UniFFILib.uniffi_iroh_fn_method_irohnode_blob_list_blobs.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_docexportprogress_as_found.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_docexportprogress_as_progress.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_irohnode_blob_list_blobs.restype = RustBuffer
+_UniFFILib.uniffi_iroh_fn_method_irohnode_blob_get.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_docexportprogress_as_progress.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_docexportprogress_type.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_docexportprogress_type.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_free_docimportprogress.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_irohnode_blob_get.restype = RustBuffer
+_UniFFILib.uniffi_iroh_fn_free_doc.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_free_docimportprogress.restype = None
-_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_abort.argtypes = (
+_UniFFILib.uniffi_iroh_fn_free_doc.restype = None
+_UniFFILib.uniffi_iroh_fn_method_doc_id.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_abort.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_all_done.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_doc_id.restype = RustBuffer
+_UniFFILib.uniffi_iroh_fn_method_doc_share_write.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_all_done.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_found.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_doc_share_write.restype = ctypes.c_void_p
+_UniFFILib.uniffi_iroh_fn_method_doc_share_read.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_found.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_ingest_done.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_doc_share_read.restype = ctypes.c_void_p
+_UniFFILib.uniffi_iroh_fn_method_doc_set_bytes.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_ingest_done.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_progress.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    RustBuffer,
+    RustBuffer,
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_progress.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_docimportprogress_type.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_doc_set_bytes.restype = ctypes.c_void_p
+_UniFFILib.uniffi_iroh_fn_method_doc_get_content_bytes.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_docimportprogress_type.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_free_downloadpolicy.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_free_downloadpolicy.restype = None
-_UniffiLib.uniffi_iroh_fn_constructor_downloadpolicy_everything.argtypes = (
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_constructor_downloadpolicy_everything.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_constructor_downloadpolicy_everything_except.argtypes = (
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_constructor_downloadpolicy_everything_except.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_constructor_downloadpolicy_nothing.argtypes = (
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_constructor_downloadpolicy_nothing.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_constructor_downloadpolicy_nothing_except.argtypes = (
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_constructor_downloadpolicy_nothing_except.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_free_downloadprogress.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_doc_get_content_bytes.restype = RustBuffer
+_UniFFILib.uniffi_iroh_fn_method_doc_keys.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_free_downloadprogress.restype = None
-_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_abort.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_abort.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_all_done.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_all_done.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_done.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_done.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_found.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_found.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_found_hash_seq.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_found_hash_seq.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_found_local.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_found_local.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_progress.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_progress.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_downloadprogress_type.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_downloadprogress_type.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_free_entry.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_free_entry.restype = None
-_UniffiLib.uniffi_iroh_fn_method_entry_author.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_entry_author.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_method_entry_content_bytes.argtypes = (
-    ctypes.c_void_p,
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_entry_content_bytes.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_entry_content_hash.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_entry_content_hash.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_method_entry_content_len.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_entry_content_len.restype = ctypes.c_uint64
-_UniffiLib.uniffi_iroh_fn_method_entry_key.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_entry_key.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_entry_namespace.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_entry_namespace.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_free_filterkind.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_free_filterkind.restype = None
-_UniffiLib.uniffi_iroh_fn_constructor_filterkind_exact.argtypes = (
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_constructor_filterkind_exact.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_constructor_filterkind_prefix.argtypes = (
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_constructor_filterkind_prefix.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_method_filterkind_matches.argtypes = (
-    ctypes.c_void_p,
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_filterkind_matches.restype = ctypes.c_int8
-_UniffiLib.uniffi_iroh_fn_free_hash.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_free_hash.restype = None
-_UniffiLib.uniffi_iroh_fn_constructor_hash_from_bytes.argtypes = (
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_constructor_hash_from_bytes.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_constructor_hash_from_string.argtypes = (
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_constructor_hash_from_string.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_constructor_hash_new.argtypes = (
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_constructor_hash_new.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_method_hash_equal.argtypes = (
-    ctypes.c_void_p,
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_hash_equal.restype = ctypes.c_int8
-_UniffiLib.uniffi_iroh_fn_method_hash_to_bytes.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_hash_to_bytes.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_hash_to_hex.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_hash_to_hex.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_hash_to_string.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_hash_to_string.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_free_irohnode.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_free_irohnode.restype = None
-_UniffiLib.uniffi_iroh_fn_constructor_irohnode_new.argtypes = (
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_constructor_irohnode_new.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_constructor_irohnode_with_options.argtypes = (
-    _UniffiRustBuffer,
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_constructor_irohnode_with_options.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_method_irohnode_author_create.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_irohnode_author_create.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_method_irohnode_author_list.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_irohnode_author_list.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_add_bytes.argtypes = (
-    ctypes.c_void_p,
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_add_bytes.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_add_from_path.argtypes = (
-    ctypes.c_void_p,
-    _UniffiRustBuffer,
-    ctypes.c_int8,
-    ctypes.c_void_p,
-    ctypes.c_void_p,
-    ctypes.c_uint64,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_add_from_path.restype = None
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_create_collection.argtypes = (
-    ctypes.c_void_p,
-    ctypes.c_void_p,
-    ctypes.c_void_p,
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_create_collection.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_delete_blob.argtypes = (
-    ctypes.c_void_p,
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_delete_blob.restype = None
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_download.argtypes = (
-    ctypes.c_void_p,
+_UniFFILib.uniffi_iroh_fn_method_doc_keys.restype = RustBuffer
+_UniFFILib.uniffi_iroh_fn_method_doc_subscribe.argtypes = (
     ctypes.c_void_p,
     ctypes.c_uint64,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_download.restype = None
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_export.argtypes = (
-    ctypes.c_void_p,
-    ctypes.c_void_p,
-    _UniffiRustBuffer,
-    _UniffiRustBuffer,
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_export.restype = None
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_get_collection.argtypes = (
-    ctypes.c_void_p,
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_get_collection.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_list.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_list.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_list_collections.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_list_collections.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_list_incomplete.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_list_incomplete.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_read_at_to_bytes.argtypes = (
-    ctypes.c_void_p,
+_UniFFILib.uniffi_iroh_fn_method_doc_subscribe.restype = None
+_UniFFILib.uniffi_iroh_fn_method_doc_stop_sync.argtypes = (
     ctypes.c_void_p,
-    ctypes.c_uint64,
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_read_at_to_bytes.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_read_to_bytes.argtypes = (
-    ctypes.c_void_p,
+_UniFFILib.uniffi_iroh_fn_method_doc_stop_sync.restype = None
+_UniFFILib.uniffi_iroh_fn_method_doc_status.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_read_to_bytes.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_share.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_doc_status.restype = RustBuffer
+_UniFFILib.uniffi_iroh_fn_free_authorid.argtypes = (
     ctypes.c_void_p,
-    ctypes.c_void_p,
-    _UniffiRustBuffer,
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_share.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_size.argtypes = (
-    ctypes.c_void_p,
+_UniFFILib.uniffi_iroh_fn_free_authorid.restype = None
+_UniFFILib.uniffi_iroh_fn_method_authorid_to_string.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_size.restype = ctypes.c_uint64
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_write_to_path.argtypes = (
-    ctypes.c_void_p,
+_UniFFILib.uniffi_iroh_fn_method_authorid_to_string.restype = RustBuffer
+_UniFFILib.uniffi_iroh_fn_free_entry.argtypes = (
     ctypes.c_void_p,
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_write_to_path.restype = None
-_UniffiLib.uniffi_iroh_fn_method_irohnode_connection_info.argtypes = (
+_UniFFILib.uniffi_iroh_fn_free_entry.restype = None
+_UniFFILib.uniffi_iroh_fn_method_entry_author.argtypes = (
     ctypes.c_void_p,
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_irohnode_connection_info.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_irohnode_connections.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_entry_author.restype = ctypes.c_void_p
+_UniFFILib.uniffi_iroh_fn_method_entry_key.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_irohnode_connections.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_create.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_entry_key.restype = RustBuffer
+_UniFFILib.uniffi_iroh_fn_method_entry_hash.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_create.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_drop.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_entry_hash.restype = ctypes.c_void_p
+_UniFFILib.uniffi_iroh_fn_free_hash.argtypes = (
     ctypes.c_void_p,
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_drop.restype = None
-_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_join.argtypes = (
+_UniFFILib.uniffi_iroh_fn_free_hash.restype = None
+_UniFFILib.uniffi_iroh_fn_method_hash_to_string.argtypes = (
     ctypes.c_void_p,
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_join.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_list.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_hash_to_string.restype = RustBuffer
+_UniFFILib.uniffi_iroh_fn_method_hash_to_bytes.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_list.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_open.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_hash_to_bytes.restype = RustBuffer
+_UniFFILib.uniffi_iroh_fn_free_docticket.argtypes = (
     ctypes.c_void_p,
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_open.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_irohnode_node_id.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+_UniFFILib.uniffi_iroh_fn_free_docticket.restype = None
+_UniFFILib.uniffi_iroh_fn_constructor_docticket_from_string.argtypes = (
+    RustBuffer,
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_irohnode_node_id.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_irohnode_stats.argtypes = (
+_UniFFILib.uniffi_iroh_fn_constructor_docticket_from_string.restype = ctypes.c_void_p
+_UniFFILib.uniffi_iroh_fn_method_docticket_to_string.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_irohnode_stats.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_irohnode_status.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_docticket_to_string.restype = RustBuffer
+_UniFFILib.uniffi_iroh_fn_free_liveevent.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_irohnode_status.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_method_irohnode_tags_delete.argtypes = (
+_UniFFILib.uniffi_iroh_fn_free_liveevent.restype = None
+_UniFFILib.uniffi_iroh_fn_method_liveevent_type.argtypes = (
     ctypes.c_void_p,
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_irohnode_tags_delete.restype = None
-_UniffiLib.uniffi_iroh_fn_method_irohnode_tags_list.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_liveevent_type.restype = RustBuffer
+_UniFFILib.uniffi_iroh_fn_method_liveevent_as_insert_local.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_irohnode_tags_list.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_free_liveevent.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_liveevent_as_insert_local.restype = ctypes.c_void_p
+_UniFFILib.uniffi_iroh_fn_method_liveevent_as_insert_remote.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_free_liveevent.restype = None
-_UniffiLib.uniffi_iroh_fn_method_liveevent_as_content_ready.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_liveevent_as_insert_remote.restype = RustBuffer
+_UniFFILib.uniffi_iroh_fn_method_liveevent_as_content_ready.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_liveevent_as_content_ready.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_method_liveevent_as_insert_local.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_liveevent_as_content_ready.restype = ctypes.c_void_p
+_UniFFILib.uniffi_iroh_fn_method_liveevent_as_neighbor_up.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_liveevent_as_insert_local.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_method_liveevent_as_insert_remote.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_liveevent_as_neighbor_up.restype = ctypes.c_void_p
+_UniFFILib.uniffi_iroh_fn_method_liveevent_as_neighbor_down.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_liveevent_as_insert_remote.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_liveevent_as_neighbor_down.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_liveevent_as_neighbor_down.restype = ctypes.c_void_p
+_UniFFILib.uniffi_iroh_fn_method_liveevent_as_sync_finished.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_liveevent_as_neighbor_down.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_method_liveevent_as_neighbor_up.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_liveevent_as_sync_finished.restype = RustBuffer
+_UniFFILib.uniffi_iroh_fn_free_namespaceid.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_liveevent_as_neighbor_up.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_method_liveevent_as_sync_finished.argtypes = (
+_UniFFILib.uniffi_iroh_fn_free_namespaceid.restype = None
+_UniFFILib.uniffi_iroh_fn_method_namespaceid_to_string.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_liveevent_as_sync_finished.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_liveevent_type.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_namespaceid_to_string.restype = RustBuffer
+_UniFFILib.uniffi_iroh_fn_free_publickey.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_liveevent_type.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_free_nodeaddr.argtypes = (
+_UniFFILib.uniffi_iroh_fn_free_publickey.restype = None
+_UniFFILib.uniffi_iroh_fn_method_publickey_to_string.argtypes = (
     ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_free_nodeaddr.restype = None
-_UniffiLib.uniffi_iroh_fn_constructor_nodeaddr_new.argtypes = (
+_UniFFILib.uniffi_iroh_fn_method_publickey_to_string.restype = RustBuffer
+_UniFFILib.uniffi_iroh_fn_method_publickey_to_bytes.argtypes = (
     ctypes.c_void_p,
-    _UniffiRustBuffer,
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_constructor_nodeaddr_new.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_method_nodeaddr_direct_addresses.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+_UniFFILib.uniffi_iroh_fn_method_publickey_to_bytes.restype = RustBuffer
+_UniFFILib.uniffi_iroh_fn_init_callback_subscribecallback.argtypes = (
+    FOREIGN_CALLBACK_T,
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_nodeaddr_direct_addresses.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_nodeaddr_equal.argtypes = (
-    ctypes.c_void_p,
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+_UniFFILib.uniffi_iroh_fn_init_callback_subscribecallback.restype = None
+_UniFFILib.uniffi_iroh_fn_func_set_log_level.argtypes = (
+    RustBuffer,
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_nodeaddr_equal.restype = ctypes.c_int8
-_UniffiLib.uniffi_iroh_fn_method_nodeaddr_relay_url.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
+_UniFFILib.uniffi_iroh_fn_func_set_log_level.restype = None
+_UniFFILib.uniffi_iroh_fn_func_start_metrics_collection.argtypes = (
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.uniffi_iroh_fn_method_nodeaddr_relay_url.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_free_nodestatusresponse.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_free_nodestatusresponse.restype = None
-_UniffiLib.uniffi_iroh_fn_method_nodestatusresponse_listen_addrs.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_nodestatusresponse_listen_addrs.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_nodestatusresponse_node_addr.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_nodestatusresponse_node_addr.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_method_nodestatusresponse_version.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_nodestatusresponse_version.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_free_publickey.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_free_publickey.restype = None
-_UniffiLib.uniffi_iroh_fn_constructor_publickey_from_bytes.argtypes = (
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_constructor_publickey_from_bytes.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_constructor_publickey_from_string.argtypes = (
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_constructor_publickey_from_string.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_method_publickey_equal.argtypes = (
-    ctypes.c_void_p,
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_publickey_equal.restype = ctypes.c_int8
-_UniffiLib.uniffi_iroh_fn_method_publickey_fmt_short.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_publickey_fmt_short.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_publickey_to_bytes.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_publickey_to_bytes.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_publickey_to_string.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_publickey_to_string.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_free_query.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_free_query.restype = None
-_UniffiLib.uniffi_iroh_fn_constructor_query_all.argtypes = (
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_constructor_query_all.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_constructor_query_author.argtypes = (
-    ctypes.c_void_p,
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_constructor_query_author.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_constructor_query_author_key_exact.argtypes = (
-    ctypes.c_void_p,
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_constructor_query_author_key_exact.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_constructor_query_author_key_prefix.argtypes = (
-    ctypes.c_void_p,
-    _UniffiRustBuffer,
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_constructor_query_author_key_prefix.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_constructor_query_key_exact.argtypes = (
-    _UniffiRustBuffer,
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_constructor_query_key_exact.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_constructor_query_key_prefix.argtypes = (
-    _UniffiRustBuffer,
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_constructor_query_key_prefix.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_constructor_query_single_latest_per_key.argtypes = (
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_constructor_query_single_latest_per_key.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_method_query_limit.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_query_limit.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_method_query_offset.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_query_offset.restype = ctypes.c_uint64
-_UniffiLib.uniffi_iroh_fn_free_rangespec.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_free_rangespec.restype = None
-_UniffiLib.uniffi_iroh_fn_method_rangespec_is_all.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_rangespec_is_all.restype = ctypes.c_int8
-_UniffiLib.uniffi_iroh_fn_method_rangespec_is_empty.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_method_rangespec_is_empty.restype = ctypes.c_int8
-_UniffiLib.uniffi_iroh_fn_free_settagoption.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_free_settagoption.restype = None
-_UniffiLib.uniffi_iroh_fn_constructor_settagoption_auto.argtypes = (
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_constructor_settagoption_auto.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_constructor_settagoption_named.argtypes = (
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_constructor_settagoption_named.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_free_wrapoption.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_free_wrapoption.restype = None
-_UniffiLib.uniffi_iroh_fn_constructor_wrapoption_no_wrap.argtypes = (
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_constructor_wrapoption_no_wrap.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_constructor_wrapoption_wrap.argtypes = (
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_constructor_wrapoption_wrap.restype = ctypes.c_void_p
-_UniffiLib.uniffi_iroh_fn_init_callback_addcallback.argtypes = (
-    _UNIFFI_FOREIGN_CALLBACK_T,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_init_callback_addcallback.restype = None
-_UniffiLib.uniffi_iroh_fn_init_callback_docexportfilecallback.argtypes = (
-    _UNIFFI_FOREIGN_CALLBACK_T,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_init_callback_docexportfilecallback.restype = None
-_UniffiLib.uniffi_iroh_fn_init_callback_docimportfilecallback.argtypes = (
-    _UNIFFI_FOREIGN_CALLBACK_T,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_init_callback_docimportfilecallback.restype = None
-_UniffiLib.uniffi_iroh_fn_init_callback_downloadcallback.argtypes = (
-    _UNIFFI_FOREIGN_CALLBACK_T,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_init_callback_downloadcallback.restype = None
-_UniffiLib.uniffi_iroh_fn_init_callback_subscribecallback.argtypes = (
-    _UNIFFI_FOREIGN_CALLBACK_T,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_init_callback_subscribecallback.restype = None
-_UniffiLib.uniffi_iroh_fn_func_key_to_path.argtypes = (
-    _UniffiRustBuffer,
-    _UniffiRustBuffer,
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_func_key_to_path.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_func_path_to_key.argtypes = (
-    _UniffiRustBuffer,
-    _UniffiRustBuffer,
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_func_path_to_key.restype = _UniffiRustBuffer
-_UniffiLib.uniffi_iroh_fn_func_set_log_level.argtypes = (
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_func_set_log_level.restype = None
-_UniffiLib.uniffi_iroh_fn_func_start_metrics_collection.argtypes = (
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.uniffi_iroh_fn_func_start_metrics_collection.restype = None
-_UniffiLib.ffi_iroh_rustbuffer_alloc.argtypes = (
+_UniFFILib.uniffi_iroh_fn_func_start_metrics_collection.restype = None
+_UniFFILib.ffi_iroh_rustbuffer_alloc.argtypes = (
     ctypes.c_int32,
-    ctypes.POINTER(_UniffiRustCallStatus),
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.ffi_iroh_rustbuffer_alloc.restype = _UniffiRustBuffer
-_UniffiLib.ffi_iroh_rustbuffer_from_bytes.argtypes = (
-    _UniffiForeignBytes,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.ffi_iroh_rustbuffer_from_bytes.restype = _UniffiRustBuffer
-_UniffiLib.ffi_iroh_rustbuffer_free.argtypes = (
-    _UniffiRustBuffer,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.ffi_iroh_rustbuffer_free.restype = None
-_UniffiLib.ffi_iroh_rustbuffer_reserve.argtypes = (
-    _UniffiRustBuffer,
+_UniFFILib.ffi_iroh_rustbuffer_alloc.restype = RustBuffer
+_UniFFILib.ffi_iroh_rustbuffer_from_bytes.argtypes = (
+    ForeignBytes,
+    ctypes.POINTER(RustCallStatus),
+)
+_UniFFILib.ffi_iroh_rustbuffer_from_bytes.restype = RustBuffer
+_UniFFILib.ffi_iroh_rustbuffer_free.argtypes = (
+    RustBuffer,
+    ctypes.POINTER(RustCallStatus),
+)
+_UniFFILib.ffi_iroh_rustbuffer_free.restype = None
+_UniFFILib.ffi_iroh_rustbuffer_reserve.argtypes = (
+    RustBuffer,
     ctypes.c_int32,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.ffi_iroh_rustbuffer_reserve.restype = _UniffiRustBuffer
-_UniffiLib.ffi_iroh_rust_future_continuation_callback_set.argtypes = (
-    _UNIFFI_FUTURE_CONTINUATION_T,
-)
-_UniffiLib.ffi_iroh_rust_future_continuation_callback_set.restype = None
-_UniffiLib.ffi_iroh_rust_future_poll_u8.argtypes = (
-    ctypes.c_void_p,
-    ctypes.c_size_t,
-)
-_UniffiLib.ffi_iroh_rust_future_poll_u8.restype = None
-_UniffiLib.ffi_iroh_rust_future_cancel_u8.argtypes = (
-    ctypes.c_void_p,
-)
-_UniffiLib.ffi_iroh_rust_future_cancel_u8.restype = None
-_UniffiLib.ffi_iroh_rust_future_free_u8.argtypes = (
-    ctypes.c_void_p,
-)
-_UniffiLib.ffi_iroh_rust_future_free_u8.restype = None
-_UniffiLib.ffi_iroh_rust_future_complete_u8.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.ffi_iroh_rust_future_complete_u8.restype = ctypes.c_uint8
-_UniffiLib.ffi_iroh_rust_future_poll_i8.argtypes = (
-    ctypes.c_void_p,
-    ctypes.c_size_t,
-)
-_UniffiLib.ffi_iroh_rust_future_poll_i8.restype = None
-_UniffiLib.ffi_iroh_rust_future_cancel_i8.argtypes = (
-    ctypes.c_void_p,
-)
-_UniffiLib.ffi_iroh_rust_future_cancel_i8.restype = None
-_UniffiLib.ffi_iroh_rust_future_free_i8.argtypes = (
-    ctypes.c_void_p,
-)
-_UniffiLib.ffi_iroh_rust_future_free_i8.restype = None
-_UniffiLib.ffi_iroh_rust_future_complete_i8.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.ffi_iroh_rust_future_complete_i8.restype = ctypes.c_int8
-_UniffiLib.ffi_iroh_rust_future_poll_u16.argtypes = (
-    ctypes.c_void_p,
-    ctypes.c_size_t,
-)
-_UniffiLib.ffi_iroh_rust_future_poll_u16.restype = None
-_UniffiLib.ffi_iroh_rust_future_cancel_u16.argtypes = (
-    ctypes.c_void_p,
-)
-_UniffiLib.ffi_iroh_rust_future_cancel_u16.restype = None
-_UniffiLib.ffi_iroh_rust_future_free_u16.argtypes = (
-    ctypes.c_void_p,
-)
-_UniffiLib.ffi_iroh_rust_future_free_u16.restype = None
-_UniffiLib.ffi_iroh_rust_future_complete_u16.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.ffi_iroh_rust_future_complete_u16.restype = ctypes.c_uint16
-_UniffiLib.ffi_iroh_rust_future_poll_i16.argtypes = (
-    ctypes.c_void_p,
-    ctypes.c_size_t,
-)
-_UniffiLib.ffi_iroh_rust_future_poll_i16.restype = None
-_UniffiLib.ffi_iroh_rust_future_cancel_i16.argtypes = (
-    ctypes.c_void_p,
-)
-_UniffiLib.ffi_iroh_rust_future_cancel_i16.restype = None
-_UniffiLib.ffi_iroh_rust_future_free_i16.argtypes = (
-    ctypes.c_void_p,
-)
-_UniffiLib.ffi_iroh_rust_future_free_i16.restype = None
-_UniffiLib.ffi_iroh_rust_future_complete_i16.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.ffi_iroh_rust_future_complete_i16.restype = ctypes.c_int16
-_UniffiLib.ffi_iroh_rust_future_poll_u32.argtypes = (
-    ctypes.c_void_p,
-    ctypes.c_size_t,
-)
-_UniffiLib.ffi_iroh_rust_future_poll_u32.restype = None
-_UniffiLib.ffi_iroh_rust_future_cancel_u32.argtypes = (
-    ctypes.c_void_p,
-)
-_UniffiLib.ffi_iroh_rust_future_cancel_u32.restype = None
-_UniffiLib.ffi_iroh_rust_future_free_u32.argtypes = (
-    ctypes.c_void_p,
-)
-_UniffiLib.ffi_iroh_rust_future_free_u32.restype = None
-_UniffiLib.ffi_iroh_rust_future_complete_u32.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.ffi_iroh_rust_future_complete_u32.restype = ctypes.c_uint32
-_UniffiLib.ffi_iroh_rust_future_poll_i32.argtypes = (
-    ctypes.c_void_p,
-    ctypes.c_size_t,
-)
-_UniffiLib.ffi_iroh_rust_future_poll_i32.restype = None
-_UniffiLib.ffi_iroh_rust_future_cancel_i32.argtypes = (
-    ctypes.c_void_p,
-)
-_UniffiLib.ffi_iroh_rust_future_cancel_i32.restype = None
-_UniffiLib.ffi_iroh_rust_future_free_i32.argtypes = (
-    ctypes.c_void_p,
-)
-_UniffiLib.ffi_iroh_rust_future_free_i32.restype = None
-_UniffiLib.ffi_iroh_rust_future_complete_i32.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.ffi_iroh_rust_future_complete_i32.restype = ctypes.c_int32
-_UniffiLib.ffi_iroh_rust_future_poll_u64.argtypes = (
-    ctypes.c_void_p,
-    ctypes.c_size_t,
-)
-_UniffiLib.ffi_iroh_rust_future_poll_u64.restype = None
-_UniffiLib.ffi_iroh_rust_future_cancel_u64.argtypes = (
-    ctypes.c_void_p,
+    ctypes.POINTER(RustCallStatus),
 )
-_UniffiLib.ffi_iroh_rust_future_cancel_u64.restype = None
-_UniffiLib.ffi_iroh_rust_future_free_u64.argtypes = (
-    ctypes.c_void_p,
-)
-_UniffiLib.ffi_iroh_rust_future_free_u64.restype = None
-_UniffiLib.ffi_iroh_rust_future_complete_u64.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.ffi_iroh_rust_future_complete_u64.restype = ctypes.c_uint64
-_UniffiLib.ffi_iroh_rust_future_poll_i64.argtypes = (
-    ctypes.c_void_p,
-    ctypes.c_size_t,
-)
-_UniffiLib.ffi_iroh_rust_future_poll_i64.restype = None
-_UniffiLib.ffi_iroh_rust_future_cancel_i64.argtypes = (
-    ctypes.c_void_p,
-)
-_UniffiLib.ffi_iroh_rust_future_cancel_i64.restype = None
-_UniffiLib.ffi_iroh_rust_future_free_i64.argtypes = (
-    ctypes.c_void_p,
-)
-_UniffiLib.ffi_iroh_rust_future_free_i64.restype = None
-_UniffiLib.ffi_iroh_rust_future_complete_i64.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.ffi_iroh_rust_future_complete_i64.restype = ctypes.c_int64
-_UniffiLib.ffi_iroh_rust_future_poll_f32.argtypes = (
-    ctypes.c_void_p,
-    ctypes.c_size_t,
-)
-_UniffiLib.ffi_iroh_rust_future_poll_f32.restype = None
-_UniffiLib.ffi_iroh_rust_future_cancel_f32.argtypes = (
-    ctypes.c_void_p,
-)
-_UniffiLib.ffi_iroh_rust_future_cancel_f32.restype = None
-_UniffiLib.ffi_iroh_rust_future_free_f32.argtypes = (
-    ctypes.c_void_p,
-)
-_UniffiLib.ffi_iroh_rust_future_free_f32.restype = None
-_UniffiLib.ffi_iroh_rust_future_complete_f32.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.ffi_iroh_rust_future_complete_f32.restype = ctypes.c_float
-_UniffiLib.ffi_iroh_rust_future_poll_f64.argtypes = (
-    ctypes.c_void_p,
-    ctypes.c_size_t,
-)
-_UniffiLib.ffi_iroh_rust_future_poll_f64.restype = None
-_UniffiLib.ffi_iroh_rust_future_cancel_f64.argtypes = (
-    ctypes.c_void_p,
-)
-_UniffiLib.ffi_iroh_rust_future_cancel_f64.restype = None
-_UniffiLib.ffi_iroh_rust_future_free_f64.argtypes = (
-    ctypes.c_void_p,
-)
-_UniffiLib.ffi_iroh_rust_future_free_f64.restype = None
-_UniffiLib.ffi_iroh_rust_future_complete_f64.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.ffi_iroh_rust_future_complete_f64.restype = ctypes.c_double
-_UniffiLib.ffi_iroh_rust_future_poll_pointer.argtypes = (
-    ctypes.c_void_p,
-    ctypes.c_size_t,
-)
-_UniffiLib.ffi_iroh_rust_future_poll_pointer.restype = None
-_UniffiLib.ffi_iroh_rust_future_cancel_pointer.argtypes = (
-    ctypes.c_void_p,
-)
-_UniffiLib.ffi_iroh_rust_future_cancel_pointer.restype = None
-_UniffiLib.ffi_iroh_rust_future_free_pointer.argtypes = (
-    ctypes.c_void_p,
-)
-_UniffiLib.ffi_iroh_rust_future_free_pointer.restype = None
-_UniffiLib.ffi_iroh_rust_future_complete_pointer.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.ffi_iroh_rust_future_complete_pointer.restype = ctypes.c_void_p
-_UniffiLib.ffi_iroh_rust_future_poll_rust_buffer.argtypes = (
-    ctypes.c_void_p,
-    ctypes.c_size_t,
-)
-_UniffiLib.ffi_iroh_rust_future_poll_rust_buffer.restype = None
-_UniffiLib.ffi_iroh_rust_future_cancel_rust_buffer.argtypes = (
-    ctypes.c_void_p,
-)
-_UniffiLib.ffi_iroh_rust_future_cancel_rust_buffer.restype = None
-_UniffiLib.ffi_iroh_rust_future_free_rust_buffer.argtypes = (
-    ctypes.c_void_p,
-)
-_UniffiLib.ffi_iroh_rust_future_free_rust_buffer.restype = None
-_UniffiLib.ffi_iroh_rust_future_complete_rust_buffer.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.ffi_iroh_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
-_UniffiLib.ffi_iroh_rust_future_poll_void.argtypes = (
-    ctypes.c_void_p,
-    ctypes.c_size_t,
-)
-_UniffiLib.ffi_iroh_rust_future_poll_void.restype = None
-_UniffiLib.ffi_iroh_rust_future_cancel_void.argtypes = (
-    ctypes.c_void_p,
-)
-_UniffiLib.ffi_iroh_rust_future_cancel_void.restype = None
-_UniffiLib.ffi_iroh_rust_future_free_void.argtypes = (
-    ctypes.c_void_p,
-)
-_UniffiLib.ffi_iroh_rust_future_free_void.restype = None
-_UniffiLib.ffi_iroh_rust_future_complete_void.argtypes = (
-    ctypes.c_void_p,
-    ctypes.POINTER(_UniffiRustCallStatus),
-)
-_UniffiLib.ffi_iroh_rust_future_complete_void.restype = None
-_UniffiLib.uniffi_iroh_checksum_func_key_to_path.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_func_key_to_path.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_func_path_to_key.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_func_path_to_key.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_func_set_log_level.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_func_set_log_level.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_func_start_metrics_collection.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_func_start_metrics_collection.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_addprogress_as_abort.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_addprogress_as_abort.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_addprogress_as_all_done.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_addprogress_as_all_done.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_addprogress_as_done.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_addprogress_as_done.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_addprogress_as_found.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_addprogress_as_found.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_addprogress_as_progress.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_addprogress_as_progress.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_addprogress_type.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_addprogress_type.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_authorid_equal.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_authorid_equal.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_authorid_to_string.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_authorid_to_string.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_blobticket_as_download_request.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_blobticket_as_download_request.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_blobticket_format.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_blobticket_format.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_blobticket_hash.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_blobticket_hash.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_blobticket_node_addr.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_blobticket_node_addr.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_collection_blobs.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_collection_blobs.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_collection_is_empty.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_collection_is_empty.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_collection_len.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_collection_len.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_collection_links.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_collection_links.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_collection_names.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_collection_names.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_collection_push.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_collection_push.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_connectiontype_as_direct.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_connectiontype_as_direct.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_connectiontype_as_mixed.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_connectiontype_as_mixed.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_connectiontype_as_relay.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_connectiontype_as_relay.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_connectiontype_type.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_connectiontype_type.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_directaddrinfo_addr.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_directaddrinfo_addr.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_directaddrinfo_last_control.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_directaddrinfo_last_control.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_directaddrinfo_last_payload.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_directaddrinfo_last_payload.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_directaddrinfo_latency.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_directaddrinfo_latency.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_doc_close.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_doc_close.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_doc_del.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_doc_del.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_doc_export_file.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_doc_export_file.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_doc_get_download_policy.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_doc_get_download_policy.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_doc_get_exact.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_doc_get_exact.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_doc_get_many.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_doc_get_many.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_doc_get_one.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_doc_get_one.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_doc_id.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_doc_id.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_doc_import_file.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_doc_import_file.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_doc_leave.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_doc_leave.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_doc_set_bytes.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_doc_set_bytes.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_doc_set_download_policy.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_doc_set_download_policy.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_doc_set_hash.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_doc_set_hash.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_doc_share.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_doc_share.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_doc_start_sync.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_doc_start_sync.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_doc_status.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_doc_status.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_doc_subscribe.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_doc_subscribe.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_docexportprogress_as_abort.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_docexportprogress_as_abort.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_docexportprogress_as_found.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_docexportprogress_as_found.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_docexportprogress_as_progress.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_docexportprogress_as_progress.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_docexportprogress_type.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_docexportprogress_type.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_docimportprogress_as_abort.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_docimportprogress_as_abort.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_docimportprogress_as_all_done.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_docimportprogress_as_all_done.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_docimportprogress_as_found.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_docimportprogress_as_found.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_docimportprogress_as_ingest_done.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_docimportprogress_as_ingest_done.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_docimportprogress_as_progress.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_docimportprogress_as_progress.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_docimportprogress_type.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_docimportprogress_type.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_abort.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_abort.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_all_done.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_all_done.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_done.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_done.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_found.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_found.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_found_hash_seq.argtypes = (
+_UniFFILib.ffi_iroh_rustbuffer_reserve.restype = RustBuffer
+_UniFFILib.uniffi_iroh_checksum_func_set_log_level.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_found_hash_seq.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_found_local.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_func_set_log_level.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_func_start_metrics_collection.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_found_local.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_progress.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_func_start_metrics_collection.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_irohnode_node_id.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_as_progress.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_type.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_irohnode_node_id.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_irohnode_doc_new.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_downloadprogress_type.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_entry_author.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_irohnode_doc_new.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_irohnode_doc_join.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_entry_author.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_entry_content_bytes.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_irohnode_doc_join.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_irohnode_author_new.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_entry_content_bytes.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_entry_content_hash.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_irohnode_author_new.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_irohnode_author_list.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_entry_content_hash.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_entry_content_len.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_irohnode_author_list.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_irohnode_stats.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_entry_content_len.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_entry_key.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_irohnode_stats.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_irohnode_connections.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_entry_key.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_entry_namespace.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_irohnode_connections.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_irohnode_connection_info.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_entry_namespace.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_filterkind_matches.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_irohnode_connection_info.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_irohnode_blob_list_blobs.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_filterkind_matches.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_hash_equal.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_irohnode_blob_list_blobs.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_irohnode_blob_get.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_hash_equal.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_hash_to_bytes.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_irohnode_blob_get.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_doc_id.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_hash_to_bytes.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_hash_to_hex.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_doc_id.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_doc_share_write.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_hash_to_hex.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_hash_to_string.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_doc_share_write.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_doc_share_read.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_hash_to_string.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_author_create.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_doc_share_read.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_doc_set_bytes.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_author_create.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_author_list.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_doc_set_bytes.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_doc_get_content_bytes.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_author_list.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_add_bytes.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_doc_get_content_bytes.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_doc_keys.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_add_bytes.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_add_from_path.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_doc_keys.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_doc_subscribe.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_add_from_path.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_create_collection.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_doc_subscribe.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_doc_stop_sync.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_create_collection.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_delete_blob.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_doc_stop_sync.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_doc_status.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_delete_blob.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_download.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_doc_status.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_authorid_to_string.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_download.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_export.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_authorid_to_string.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_entry_author.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_export.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_get_collection.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_entry_author.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_entry_key.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_get_collection.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_list.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_entry_key.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_entry_hash.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_list.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_list_collections.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_entry_hash.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_hash_to_string.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_list_collections.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_list_incomplete.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_hash_to_string.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_hash_to_bytes.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_list_incomplete.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_read_at_to_bytes.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_hash_to_bytes.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_docticket_to_string.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_read_at_to_bytes.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_read_to_bytes.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_docticket_to_string.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_liveevent_type.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_read_to_bytes.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_share.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_liveevent_type.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_liveevent_as_insert_local.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_share.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_size.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_liveevent_as_insert_local.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_liveevent_as_insert_remote.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_size.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_write_to_path.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_liveevent_as_insert_remote.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_liveevent_as_content_ready.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_blobs_write_to_path.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_connection_info.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_liveevent_as_content_ready.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_liveevent_as_neighbor_up.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_connection_info.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_connections.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_liveevent_as_neighbor_up.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_liveevent_as_neighbor_down.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_connections.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_doc_create.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_liveevent_as_neighbor_down.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_liveevent_as_sync_finished.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_doc_create.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_doc_drop.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_liveevent_as_sync_finished.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_namespaceid_to_string.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_doc_drop.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_doc_join.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_namespaceid_to_string.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_publickey_to_string.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_doc_join.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_doc_list.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_publickey_to_string.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_method_publickey_to_bytes.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_doc_list.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_doc_open.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_method_publickey_to_bytes.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_constructor_irohnode_new.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_doc_open.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_node_id.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_constructor_irohnode_new.restype = ctypes.c_uint16
+_UniFFILib.uniffi_iroh_checksum_constructor_docticket_from_string.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_node_id.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_stats.argtypes = (
+_UniFFILib.uniffi_iroh_checksum_constructor_docticket_from_string.restype = ctypes.c_uint16
+_UniFFILib.ffi_iroh_uniffi_contract_version.argtypes = (
 )
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_stats.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_status.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_status.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_tags_delete.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_tags_delete.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_tags_list.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_irohnode_tags_list.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_liveevent_as_content_ready.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_liveevent_as_content_ready.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_liveevent_as_insert_local.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_liveevent_as_insert_local.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_liveevent_as_insert_remote.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_liveevent_as_insert_remote.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_liveevent_as_neighbor_down.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_liveevent_as_neighbor_down.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_liveevent_as_neighbor_up.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_liveevent_as_neighbor_up.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_liveevent_as_sync_finished.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_liveevent_as_sync_finished.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_liveevent_type.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_liveevent_type.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_nodeaddr_direct_addresses.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_nodeaddr_direct_addresses.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_nodeaddr_equal.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_nodeaddr_equal.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_nodeaddr_relay_url.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_nodeaddr_relay_url.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_nodestatusresponse_listen_addrs.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_nodestatusresponse_listen_addrs.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_nodestatusresponse_node_addr.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_nodestatusresponse_node_addr.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_nodestatusresponse_version.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_nodestatusresponse_version.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_publickey_equal.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_publickey_equal.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_publickey_fmt_short.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_publickey_fmt_short.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_publickey_to_bytes.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_publickey_to_bytes.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_publickey_to_string.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_publickey_to_string.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_query_limit.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_query_limit.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_query_offset.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_query_offset.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_rangespec_is_all.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_rangespec_is_all.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_rangespec_is_empty.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_rangespec_is_empty.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_authorid_from_string.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_authorid_from_string.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_blobdownloadrequest_new.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_blobdownloadrequest_new.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_blobticket_new.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_blobticket_new.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_collection_new.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_collection_new.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_downloadpolicy_everything.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_downloadpolicy_everything.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_downloadpolicy_everything_except.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_downloadpolicy_everything_except.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_downloadpolicy_nothing.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_downloadpolicy_nothing.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_downloadpolicy_nothing_except.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_downloadpolicy_nothing_except.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_filterkind_exact.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_filterkind_exact.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_filterkind_prefix.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_filterkind_prefix.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_hash_from_bytes.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_hash_from_bytes.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_hash_from_string.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_hash_from_string.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_hash_new.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_hash_new.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_irohnode_new.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_irohnode_new.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_irohnode_with_options.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_irohnode_with_options.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_nodeaddr_new.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_nodeaddr_new.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_publickey_from_bytes.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_publickey_from_bytes.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_publickey_from_string.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_publickey_from_string.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_query_all.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_query_all.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_query_author.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_query_author.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_query_author_key_exact.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_query_author_key_exact.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_query_author_key_prefix.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_query_author_key_prefix.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_query_key_exact.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_query_key_exact.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_query_key_prefix.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_query_key_prefix.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_query_single_latest_per_key.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_query_single_latest_per_key.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_settagoption_auto.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_settagoption_auto.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_settagoption_named.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_settagoption_named.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_wrapoption_no_wrap.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_wrapoption_no_wrap.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_constructor_wrapoption_wrap.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_constructor_wrapoption_wrap.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_addcallback_progress.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_addcallback_progress.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_docexportfilecallback_progress.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_docexportfilecallback_progress.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_docimportfilecallback_progress.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_docimportfilecallback_progress.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_downloadcallback_progress.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_downloadcallback_progress.restype = ctypes.c_uint16
-_UniffiLib.uniffi_iroh_checksum_method_subscribecallback_event.argtypes = (
-)
-_UniffiLib.uniffi_iroh_checksum_method_subscribecallback_event.restype = ctypes.c_uint16
-_UniffiLib.ffi_iroh_uniffi_contract_version.argtypes = (
-)
-_UniffiLib.ffi_iroh_uniffi_contract_version.restype = ctypes.c_uint32
-_uniffi_check_contract_api_version(_UniffiLib)
-_uniffi_check_api_checksums(_UniffiLib)
-
-# Async support
+_UniFFILib.ffi_iroh_uniffi_contract_version.restype = ctypes.c_uint32
+uniffi_check_contract_api_version(_UniFFILib)
+uniffi_check_api_checksums(_UniFFILib)
 
 # Public interface members begin here.
 
 
-class _UniffiConverterUInt32(_UniffiConverterPrimitiveInt):
-    CLASS_NAME = "u32"
+class FfiConverterUInt8(FfiConverterPrimitiveInt):
+    CLASS_NAME = "u8"
+    VALUE_MIN = 0
+    VALUE_MAX = 2**8
+
+    @staticmethod
+    def read(buf):
+        return buf.readU8()
+
+    @staticmethod
+    def writeUnchecked(value, buf):
+        buf.writeU8(value)
+
+class FfiConverterUInt16(FfiConverterPrimitiveInt):
+    CLASS_NAME = "u16"
     VALUE_MIN = 0
-    VALUE_MAX = 2**32
+    VALUE_MAX = 2**16
 
     @staticmethod
     def read(buf):
-        return buf.read_u32()
+        return buf.readU16()
 
     @staticmethod
-    def write_unchecked(value, buf):
-        buf.write_u32(value)
+    def writeUnchecked(value, buf):
+        buf.writeU16(value)
 
-class _UniffiConverterUInt64(_UniffiConverterPrimitiveInt):
+class FfiConverterUInt64(FfiConverterPrimitiveInt):
     CLASS_NAME = "u64"
     VALUE_MIN = 0
     VALUE_MAX = 2**64
 
     @staticmethod
     def read(buf):
-        return buf.read_u64()
+        return buf.readU64()
+
+    @staticmethod
+    def writeUnchecked(value, buf):
+        buf.writeU64(value)
+
+class FfiConverterDouble(FfiConverterPrimitiveFloat):
+    @staticmethod
+    def read(buf):
+        return buf.readDouble()
 
     @staticmethod
-    def write_unchecked(value, buf):
-        buf.write_u64(value)
+    def writeUnchecked(value, buf):
+        buf.writeDouble(value)
 
-class _UniffiConverterBool(_UniffiConverterPrimitive):
+class FfiConverterBool(FfiConverterPrimitive):
     @classmethod
     def check(cls, value):
         return not not value
 
     @classmethod
     def read(cls, buf):
-        return cls.lift(buf.read_u8())
+        return cls.lift(buf.readU8())
 
     @classmethod
-    def write_unchecked(cls, value, buf):
-        buf.write_u8(value)
+    def writeUnchecked(cls, value, buf):
+        buf.writeU8(value)
 
     @staticmethod
     def lift(value):
         return value != 0
 
-class _UniffiConverterString:
+class FfiConverterString:
     @staticmethod
     def check(value):
         if not isinstance(value, str):
             raise TypeError("argument must be str, not {}".format(type(value).__name__))
         return value
 
     @staticmethod
     def read(buf):
-        size = buf.read_i32()
+        size = buf.readI32()
         if size < 0:
             raise InternalError("Unexpected negative string length")
-        utf8_bytes = buf.read(size)
-        return utf8_bytes.decode("utf-8")
+        utf8Bytes = buf.read(size)
+        return utf8Bytes.decode("utf-8")
 
     @staticmethod
     def write(value, buf):
-        value = _UniffiConverterString.check(value)
-        utf8_bytes = value.encode("utf-8")
-        buf.write_i32(len(utf8_bytes))
-        buf.write(utf8_bytes)
+        value = FfiConverterString.check(value)
+        utf8Bytes = value.encode("utf-8")
+        buf.writeI32(len(utf8Bytes))
+        buf.write(utf8Bytes)
 
     @staticmethod
     def lift(buf):
-        with buf.consume_with_stream() as stream:
+        with buf.consumeWithStream() as stream:
             return stream.read(stream.remaining()).decode("utf-8")
 
     @staticmethod
     def lower(value):
-        value = _UniffiConverterString.check(value)
-        with _UniffiRustBuffer.alloc_with_builder() as builder:
+        value = FfiConverterString.check(value)
+        with RustBuffer.allocWithBuilder() as builder:
             builder.write(value.encode("utf-8"))
             return builder.finalize()
 
-class _UniffiConverterBytes(_UniffiConverterRustBuffer):
+class FfiConverterBytes(FfiConverterRustBuffer):
     @staticmethod
     def read(buf):
-        size = buf.read_i32()
+        size = buf.readI32()
         if size < 0:
             raise InternalError("Unexpected negative byte string length")
         return buf.read(size)
 
     @staticmethod
     def write(value, buf):
         try:
             memoryview(value)
         except TypeError:
             raise TypeError("a bytes-like object is required, not {!r}".format(type(value).__name__))
-        buf.write_i32(len(value))
+        buf.writeI32(len(value))
         buf.write(value)
 
-# The Timestamp type.
-Timestamp = datetime.datetime
-
-# There is a loss of precision when converting from Rust timestamps,
-# which are accurate to the nanosecond,
-# to Python datetimes, which have a variable precision due to the use of float as representation.
-class _UniffiConverterTimestamp(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        seconds = buf.read_i64()
-        microseconds = buf.read_u32() / 1000
-        # Use fromtimestamp(0) then add the seconds using a timedelta.  This
-        # ensures that we get OverflowError rather than ValueError when
-        # seconds is too large.
-        if seconds >= 0:
-            return datetime.datetime.fromtimestamp(0, tz=datetime.timezone.utc) + datetime.timedelta(seconds=seconds, microseconds=microseconds)
-        else:
-            return datetime.datetime.fromtimestamp(0, tz=datetime.timezone.utc) - datetime.timedelta(seconds=-seconds, microseconds=microseconds)
-
-    @staticmethod
-    def write(value, buf):
-        if value >= datetime.datetime.fromtimestamp(0, datetime.timezone.utc):
-            sign = 1
-            delta = value - datetime.datetime.fromtimestamp(0, datetime.timezone.utc)
-        else:
-            sign = -1
-            delta = datetime.datetime.fromtimestamp(0, datetime.timezone.utc) - value
-
-        seconds = delta.seconds + delta.days * 24 * 3600
-        nanoseconds = delta.microseconds * 1000
-        buf.write_i64(sign * seconds)
-        buf.write_u32(nanoseconds)
-
-# The Duration type.
-Duration = datetime.timedelta
-
-# There is a loss of precision when converting from Rust durations,
-# which are accurate to the nanosecond,
-# to Python durations, which are only accurate to the microsecond.
-class _UniffiConverterDuration(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        seconds = buf.read_u64()
-        microseconds = buf.read_u32() / 1.0e3
-        return datetime.timedelta(seconds=seconds, microseconds=microseconds)
-
-    @staticmethod
-    def write(value, buf):
-        seconds = value.seconds + value.days * 24 * 3600
-        nanoseconds = value.microseconds * 1000
-        if seconds < 0:
-            raise ValueError("Invalid duration, must be non-negative")
-        buf.write_i64(seconds)
-        buf.write_u32(nanoseconds)
-
-
-
-class AddProgress:
-    '''Progress updates for the add operation.'''
-
-    _pointer: ctypes.c_void_p
-
-    def __del__(self):
-        # In case of partial initialization of instances.
-        pointer = getattr(self, "_pointer", None)
-        if pointer is not None:
-            _rust_call(_UniffiLib.uniffi_iroh_fn_free_addprogress, pointer)
-
-    # Used by alternative constructors or any methods which return this type.
-    @classmethod
-    def _make_instance_(cls, pointer):
-        # Lightly yucky way to bypass the usual __init__ logic
-        # and just create a new instance with the required pointer.
-        inst = cls.__new__(cls)
-        inst._pointer = pointer
-        return inst
-
-
-    def as_abort(self, ) -> "AddProgressAbort":
-        '''Return the `AddProgressAbort`'''
-        return _UniffiConverterTypeAddProgressAbort.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_addprogress_as_abort,self._pointer,)
-        )
-
-
-
-
-
-
-    def as_all_done(self, ) -> "AddProgressAllDone":
-        '''Return the `AddAllDone`'''
-        return _UniffiConverterTypeAddProgressAllDone.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_addprogress_as_all_done,self._pointer,)
-        )
-
-
-
-
-
-
-    def as_done(self, ) -> "AddProgressDone":
-        '''Return the `AddProgressDone` event'''
-        return _UniffiConverterTypeAddProgressDone.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_addprogress_as_done,self._pointer,)
-        )
-
-
-
-
-
-
-    def as_found(self, ) -> "AddProgressFound":
-        '''Return the `AddProgressFound` event'''
-        return _UniffiConverterTypeAddProgressFound.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_addprogress_as_found,self._pointer,)
-        )
-
-
-
-
-
-
-    def as_progress(self, ) -> "AddProgressProgress":
-        '''Return the `AddProgressProgress` event'''
-        return _UniffiConverterTypeAddProgressProgress.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_addprogress_as_progress,self._pointer,)
-        )
-
-
-
-
-
-
-    def type(self, ) -> "AddProgressType":
-        '''Get the type of event'''
-        return _UniffiConverterTypeAddProgressType.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_addprogress_type,self._pointer,)
-        )
-
-
-
-
-
-
-class _UniffiConverterTypeAddProgress:
-    @classmethod
-    def read(cls, buf):
-        ptr = buf.read_u64()
-        if ptr == 0:
-            raise InternalError("Raw pointer value was null")
-        return cls.lift(ptr)
-
-    @classmethod
-    def write(cls, value, buf):
-        if not isinstance(value, AddProgress):
-            raise TypeError("Expected AddProgress instance, {} found".format(type(value).__name__))
-        buf.write_u64(cls.lower(value))
-
-    @staticmethod
-    def lift(value):
-        return AddProgress._make_instance_(value)
-
-    @staticmethod
-    def lower(value):
-        return value._pointer
-
 
 
 class AuthorId:
-    '''Identifier for an [`Author`]'''
-
     _pointer: ctypes.c_void_p
 
     def __del__(self):
         # In case of partial initialization of instances.
         pointer = getattr(self, "_pointer", None)
         if pointer is not None:
-            _rust_call(_UniffiLib.uniffi_iroh_fn_free_authorid, pointer)
+            rust_call(_UniFFILib.uniffi_iroh_fn_free_authorid, pointer)
 
     # Used by alternative constructors or any methods which return this type.
     @classmethod
     def _make_instance_(cls, pointer):
         # Lightly yucky way to bypass the usual __init__ logic
         # and just create a new instance with the required pointer.
         inst = cls.__new__(cls)
         inst._pointer = pointer
         return inst
 
-    @classmethod
-    def from_string(cls, str: "str"):
-        '''Get an [`AuthorId`] from a String'''
-        
-        # Call the (fallible) function before creating any half-baked object instances.
-        pointer = _rust_call_with_error(_UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_constructor_authorid_from_string,
-        _UniffiConverterString.lower(str))
-        return cls._make_instance_(pointer)
-
-
-
-    def equal(self, other: "AuthorId") -> "bool":
-        '''Returns true when both AuthorId's have the same value'''
-        
-        return _UniffiConverterBool.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_authorid_equal,self._pointer,
-        _UniffiConverterTypeAuthorId.lower(other))
-        )
-
-
-
-
-
 
     def to_string(self, ) -> "str":
-        '''Return the AuthorId as a string'''
-        return _UniffiConverterString.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_authorid_to_string,self._pointer,)
+        return FfiConverterString.lift(
+            rust_call(_UniFFILib.uniffi_iroh_fn_method_authorid_to_string,self._pointer,)
         )
 
 
 
 
 
 
-class _UniffiConverterTypeAuthorId:
+class FfiConverterTypeAuthorId:
     @classmethod
     def read(cls, buf):
-        ptr = buf.read_u64()
+        ptr = buf.readU64()
         if ptr == 0:
             raise InternalError("Raw pointer value was null")
         return cls.lift(ptr)
 
     @classmethod
     def write(cls, value, buf):
         if not isinstance(value, AuthorId):
-            raise TypeError("Expected AuthorId instance, {} found".format(type(value).__name__))
-        buf.write_u64(cls.lower(value))
+            raise TypeError("Expected AuthorId instance, {} found".format(value.__class__.__name__))
+        buf.writeU64(cls.lower(value))
 
     @staticmethod
     def lift(value):
         return AuthorId._make_instance_(value)
 
     @staticmethod
     def lower(value):
         return value._pointer
 
 
 
-class BlobDownloadRequest:
-    '''A request to the node to download and share the data specified by the hash.'''
-
-    _pointer: ctypes.c_void_p
-    def __init__(self, hash: "Hash",format: "BlobFormat",node: "NodeAddr",tag: "SetTagOption"):
-        
-        
-        
-        
-        self._pointer = _rust_call_with_error(_UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_constructor_blobdownloadrequest_new,
-        _UniffiConverterTypeHash.lower(hash),
-        _UniffiConverterTypeBlobFormat.lower(format),
-        _UniffiConverterTypeNodeAddr.lower(node),
-        _UniffiConverterTypeSetTagOption.lower(tag))
-
-    def __del__(self):
-        # In case of partial initialization of instances.
-        pointer = getattr(self, "_pointer", None)
-        if pointer is not None:
-            _rust_call(_UniffiLib.uniffi_iroh_fn_free_blobdownloadrequest, pointer)
-
-    # Used by alternative constructors or any methods which return this type.
-    @classmethod
-    def _make_instance_(cls, pointer):
-        # Lightly yucky way to bypass the usual __init__ logic
-        # and just create a new instance with the required pointer.
-        inst = cls.__new__(cls)
-        inst._pointer = pointer
-        return inst
-
-
-class _UniffiConverterTypeBlobDownloadRequest:
-    @classmethod
-    def read(cls, buf):
-        ptr = buf.read_u64()
-        if ptr == 0:
-            raise InternalError("Raw pointer value was null")
-        return cls.lift(ptr)
-
-    @classmethod
-    def write(cls, value, buf):
-        if not isinstance(value, BlobDownloadRequest):
-            raise TypeError("Expected BlobDownloadRequest instance, {} found".format(type(value).__name__))
-        buf.write_u64(cls.lower(value))
-
-    @staticmethod
-    def lift(value):
-        return BlobDownloadRequest._make_instance_(value)
-
-    @staticmethod
-    def lower(value):
-        return value._pointer
-
-
-
-class BlobTicket:
-    '''
-    A token containing everything to get a file from the provider.
-
-    It is a single item which can be easily serialized and deserialized.
-    '''
-
-    _pointer: ctypes.c_void_p
-    def __init__(self, ticket: "str"):
-        
-        self._pointer = _rust_call_with_error(_UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_constructor_blobticket_new,
-        _UniffiConverterString.lower(ticket))
-
-    def __del__(self):
-        # In case of partial initialization of instances.
-        pointer = getattr(self, "_pointer", None)
-        if pointer is not None:
-            _rust_call(_UniffiLib.uniffi_iroh_fn_free_blobticket, pointer)
-
-    # Used by alternative constructors or any methods which return this type.
-    @classmethod
-    def _make_instance_(cls, pointer):
-        # Lightly yucky way to bypass the usual __init__ logic
-        # and just create a new instance with the required pointer.
-        inst = cls.__new__(cls)
-        inst._pointer = pointer
-        return inst
-
-
-    def as_download_request(self, ) -> "BlobDownloadRequest":
-        '''Turn this ticket into parameters for blobs_download.'''
-        return _UniffiConverterTypeBlobDownloadRequest.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_blobticket_as_download_request,self._pointer,)
-        )
-
-
-
-
-
-
-    def format(self, ) -> "BlobFormat":
-        '''The format of the blob.'''
-        return _UniffiConverterTypeBlobFormat.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_blobticket_format,self._pointer,)
-        )
-
-
-
-
-
-
-    def hash(self, ) -> "Hash":
-        '''The hash to retrieve.'''
-        return _UniffiConverterTypeHash.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_blobticket_hash,self._pointer,)
-        )
-
-
-
-
-
-
-    def node_addr(self, ) -> "NodeAddr":
-        '''The provider to get a file from.'''
-        return _UniffiConverterTypeNodeAddr.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_blobticket_node_addr,self._pointer,)
-        )
-
-
-
-
-
-
-class _UniffiConverterTypeBlobTicket:
-    @classmethod
-    def read(cls, buf):
-        ptr = buf.read_u64()
-        if ptr == 0:
-            raise InternalError("Raw pointer value was null")
-        return cls.lift(ptr)
-
-    @classmethod
-    def write(cls, value, buf):
-        if not isinstance(value, BlobTicket):
-            raise TypeError("Expected BlobTicket instance, {} found".format(type(value).__name__))
-        buf.write_u64(cls.lower(value))
-
-    @staticmethod
-    def lift(value):
-        return BlobTicket._make_instance_(value)
-
-    @staticmethod
-    def lower(value):
-        return value._pointer
-
-
-
-class Collection:
-    '''
-    A collection of blobs
-
-    Note that the format is subject to change.
-    '''
-
-    _pointer: ctypes.c_void_p
-    def __init__(self, ):
-        '''Create a new empty collection'''
-        self._pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_collection_new,)
-
-    def __del__(self):
-        # In case of partial initialization of instances.
-        pointer = getattr(self, "_pointer", None)
-        if pointer is not None:
-            _rust_call(_UniffiLib.uniffi_iroh_fn_free_collection, pointer)
-
-    # Used by alternative constructors or any methods which return this type.
-    @classmethod
-    def _make_instance_(cls, pointer):
-        # Lightly yucky way to bypass the usual __init__ logic
-        # and just create a new instance with the required pointer.
-        inst = cls.__new__(cls)
-        inst._pointer = pointer
-        return inst
-
-
-    def blobs(self, ) -> "typing.List[LinkAndName]":
-        '''Returns a [`Link`] (the name and the hash), for each blob in the collection.'''
-        return _UniffiConverterSequenceTypeLinkAndName.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_collection_blobs,self._pointer,)
-        )
-
-
-
-
-
-
-    def is_empty(self, ) -> "bool":
-        '''Check if the collection is empty'''
-        return _UniffiConverterBool.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_collection_is_empty,self._pointer,)
-        )
-
-
-
-
-
-
-    def len(self, ) -> "int":
-        '''Returns the number of blobs in this collection'''
-        return _UniffiConverterUInt64.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_collection_len,self._pointer,)
-        )
-
-
-
-
-
-
-    def links(self, ) -> "typing.List[Hash]":
-        '''Get the links to the blobs in this collection'''
-        return _UniffiConverterSequenceTypeHash.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_collection_links,self._pointer,)
-        )
-
-
-
-
-
-
-    def names(self, ) -> "typing.List[str]":
-        '''Get the names of the blobs in this collection'''
-        return _UniffiConverterSequenceString.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_collection_names,self._pointer,)
-        )
-
-
-
-
-
-
-    def push(self, name: "str",hash: "Hash"):
-        '''Add the given blob to the collection'''
-        
-        
-        _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_collection_push,self._pointer,
-        _UniffiConverterString.lower(name),
-        _UniffiConverterTypeHash.lower(hash))
-
-
-
-
-
-
-
-class _UniffiConverterTypeCollection:
-    @classmethod
-    def read(cls, buf):
-        ptr = buf.read_u64()
-        if ptr == 0:
-            raise InternalError("Raw pointer value was null")
-        return cls.lift(ptr)
-
-    @classmethod
-    def write(cls, value, buf):
-        if not isinstance(value, Collection):
-            raise TypeError("Expected Collection instance, {} found".format(type(value).__name__))
-        buf.write_u64(cls.lower(value))
-
-    @staticmethod
-    def lift(value):
-        return Collection._make_instance_(value)
-
-    @staticmethod
-    def lower(value):
-        return value._pointer
-
-
-
-class ConnectionType:
-    '''The type of connection we have to the node'''
-
-    _pointer: ctypes.c_void_p
-
-    def __del__(self):
-        # In case of partial initialization of instances.
-        pointer = getattr(self, "_pointer", None)
-        if pointer is not None:
-            _rust_call(_UniffiLib.uniffi_iroh_fn_free_connectiontype, pointer)
-
-    # Used by alternative constructors or any methods which return this type.
-    @classmethod
-    def _make_instance_(cls, pointer):
-        # Lightly yucky way to bypass the usual __init__ logic
-        # and just create a new instance with the required pointer.
-        inst = cls.__new__(cls)
-        inst._pointer = pointer
-        return inst
-
-
-    def as_direct(self, ) -> "str":
-        '''Return the socket address if this is a direct connection'''
-        return _UniffiConverterString.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_connectiontype_as_direct,self._pointer,)
-        )
-
-
-
-
-
-
-    def as_mixed(self, ) -> "ConnectionTypeMixed":
-        '''Return the socket address and relay url if this is a mixed connection'''
-        return _UniffiConverterTypeConnectionTypeMixed.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_connectiontype_as_mixed,self._pointer,)
-        )
-
-
-
-
-
-
-    def as_relay(self, ) -> "str":
-        '''Return the relay url if this is a relay connection'''
-        return _UniffiConverterString.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_connectiontype_as_relay,self._pointer,)
-        )
-
-
-
-
-
-
-    def type(self, ) -> "ConnType":
-        '''Whether connection is direct, relay, mixed, or none'''
-        return _UniffiConverterTypeConnType.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_connectiontype_type,self._pointer,)
-        )
-
-
-
-
-
-
-class _UniffiConverterTypeConnectionType:
-    @classmethod
-    def read(cls, buf):
-        ptr = buf.read_u64()
-        if ptr == 0:
-            raise InternalError("Raw pointer value was null")
-        return cls.lift(ptr)
-
-    @classmethod
-    def write(cls, value, buf):
-        if not isinstance(value, ConnectionType):
-            raise TypeError("Expected ConnectionType instance, {} found".format(type(value).__name__))
-        buf.write_u64(cls.lower(value))
-
-    @staticmethod
-    def lift(value):
-        return ConnectionType._make_instance_(value)
-
-    @staticmethod
-    def lower(value):
-        return value._pointer
-
-
-
-class DirectAddrInfo:
-    '''Information about a direct address.'''
-
-    _pointer: ctypes.c_void_p
-
-    def __del__(self):
-        # In case of partial initialization of instances.
-        pointer = getattr(self, "_pointer", None)
-        if pointer is not None:
-            _rust_call(_UniffiLib.uniffi_iroh_fn_free_directaddrinfo, pointer)
-
-    # Used by alternative constructors or any methods which return this type.
-    @classmethod
-    def _make_instance_(cls, pointer):
-        # Lightly yucky way to bypass the usual __init__ logic
-        # and just create a new instance with the required pointer.
-        inst = cls.__new__(cls)
-        inst._pointer = pointer
-        return inst
-
-
-    def addr(self, ) -> "str":
-        '''Get the reported address'''
-        return _UniffiConverterString.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_directaddrinfo_addr,self._pointer,)
-        )
-
-
-
-
-
-
-    def last_control(self, ) -> "typing.Optional[LatencyAndControlMsg]":
-        '''Get the last control message received by this node'''
-        return _UniffiConverterOptionalTypeLatencyAndControlMsg.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_directaddrinfo_last_control,self._pointer,)
-        )
-
-
-
-
-
-
-    def last_payload(self, ) -> "typing.Optional[Duration]":
-        '''Get how long ago the last payload message was received for this node'''
-        return _UniffiConverterOptionalDuration.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_directaddrinfo_last_payload,self._pointer,)
-        )
-
-
-
-
-
-
-    def latency(self, ) -> "typing.Optional[Duration]":
-        '''Get the reported latency, if it exists'''
-        return _UniffiConverterOptionalDuration.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_directaddrinfo_latency,self._pointer,)
-        )
-
-
-
-
-
-
-class _UniffiConverterTypeDirectAddrInfo:
-    @classmethod
-    def read(cls, buf):
-        ptr = buf.read_u64()
-        if ptr == 0:
-            raise InternalError("Raw pointer value was null")
-        return cls.lift(ptr)
-
-    @classmethod
-    def write(cls, value, buf):
-        if not isinstance(value, DirectAddrInfo):
-            raise TypeError("Expected DirectAddrInfo instance, {} found".format(type(value).__name__))
-        buf.write_u64(cls.lower(value))
-
-    @staticmethod
-    def lift(value):
-        return DirectAddrInfo._make_instance_(value)
-
-    @staticmethod
-    def lower(value):
-        return value._pointer
-
-
-
 class Doc:
-    '''A representation of a mutable, synchronizable key-value store.'''
-
     _pointer: ctypes.c_void_p
 
     def __del__(self):
         # In case of partial initialization of instances.
         pointer = getattr(self, "_pointer", None)
         if pointer is not None:
-            _rust_call(_UniffiLib.uniffi_iroh_fn_free_doc, pointer)
+            rust_call(_UniFFILib.uniffi_iroh_fn_free_doc, pointer)
 
     # Used by alternative constructors or any methods which return this type.
     @classmethod
     def _make_instance_(cls, pointer):
         # Lightly yucky way to bypass the usual __init__ logic
         # and just create a new instance with the required pointer.
         inst = cls.__new__(cls)
         inst._pointer = pointer
         return inst
 
 
-    def close(self, ):
-        '''Close the document.'''
-        _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_close,self._pointer,)
-
-
-
-
-
-
-
-    def _del(self, author_id: "AuthorId",prefix: "bytes") -> "int":
-        '''
-        Delete entries that match the given `author` and key `prefix`.
-
-        This inserts an empty entry with the key set to `prefix`, effectively clearing all other
-        entries whose key starts with or is equal to the given `prefix`.
-
-        Returns the number of entries deleted.
-        '''
-        
-        
-        return _UniffiConverterUInt64.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_del,self._pointer,
-        _UniffiConverterTypeAuthorId.lower(author_id),
-        _UniffiConverterBytes.lower(prefix))
-        )
-
-
-
-
-
-
-    def export_file(self, entry: "Entry",path: "str",cb: "typing.Optional[DocExportFileCallback]"):
-        '''Export an entry as a file to a given absolute path'''
-        
-        
-        
-        _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_export_file,self._pointer,
-        _UniffiConverterTypeEntry.lower(entry),
-        _UniffiConverterString.lower(path),
-        _UniffiConverterOptionalCallbackInterfaceDocExportFileCallback.lower(cb))
-
-
-
-
-
-
-
-    def get_download_policy(self, ) -> "DownloadPolicy":
-        '''Get the download policy for this document'''
-        return _UniffiConverterTypeDownloadPolicy.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_get_download_policy,self._pointer,)
-        )
-
-
-
-
-
-
-    def get_exact(self, author: "AuthorId",key: "bytes",include_empty: "bool") -> "typing.Optional[Entry]":
-        '''
-        Get an entry for a key and author.
-
-        Optionally also get the entry if it is empty (i.e. a deletion marker)
-        '''
-        
-        
-        
-        return _UniffiConverterOptionalTypeEntry.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_get_exact,self._pointer,
-        _UniffiConverterTypeAuthorId.lower(author),
-        _UniffiConverterBytes.lower(key),
-        _UniffiConverterBool.lower(include_empty))
-        )
-
-
-
-
-
-
-    def get_many(self, query: "Query") -> "typing.List[Entry]":
-        '''
-        Get entries.
-
-        Note: this allocates for each `Entry`, if you have many `Entry`s this may be a prohibitively large list.
-        Please file an [issue](https://github.com/n0-computer/iroh-ffi/issues/new) if you run into this issue
-        '''
-        
-        return _UniffiConverterSequenceTypeEntry.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_get_many,self._pointer,
-        _UniffiConverterTypeQuery.lower(query))
+    def id(self, ) -> "str":
+        return FfiConverterString.lift(
+            rust_call(_UniFFILib.uniffi_iroh_fn_method_doc_id,self._pointer,)
         )
 
 
 
 
 
 
-    def get_one(self, query: "Query") -> "typing.Optional[Entry]":
-        '''Get the latest entry for a key and author.'''
-        
-        return _UniffiConverterOptionalTypeEntry.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_get_one,self._pointer,
-        _UniffiConverterTypeQuery.lower(query))
+    def share_write(self, ) -> "DocTicket":
+        return FfiConverterTypeDocTicket.lift(
+            rust_call_with_error(
+    FfiConverterTypeIrohError,_UniFFILib.uniffi_iroh_fn_method_doc_share_write,self._pointer,)
         )
 
 
 
 
 
 
-    def id(self, ) -> "str":
-        '''Get the document id of this doc.'''
-        return _UniffiConverterString.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_doc_id,self._pointer,)
+    def share_read(self, ) -> "DocTicket":
+        return FfiConverterTypeDocTicket.lift(
+            rust_call_with_error(
+    FfiConverterTypeIrohError,_UniFFILib.uniffi_iroh_fn_method_doc_share_read,self._pointer,)
         )
 
 
 
 
 
 
-    def import_file(self, author: "AuthorId",key: "bytes",path: "str",in_place: "bool",cb: "typing.Optional[DocImportFileCallback]"):
-        '''Add an entry from an absolute file path'''
-        
-        
-        
-        
-        
-        _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_import_file,self._pointer,
-        _UniffiConverterTypeAuthorId.lower(author),
-        _UniffiConverterBytes.lower(key),
-        _UniffiConverterString.lower(path),
-        _UniffiConverterBool.lower(in_place),
-        _UniffiConverterOptionalCallbackInterfaceDocImportFileCallback.lower(cb))
-
-
-
-
-
-
-
-    def leave(self, ):
-        '''Stop the live sync for this document.'''
-        _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_leave,self._pointer,)
-
-
-
-
-
-
-
     def set_bytes(self, author: "AuthorId",key: "bytes",value: "bytes") -> "Hash":
-        '''Set the content of a key to a byte array.'''
         
         
         
-        return _UniffiConverterTypeHash.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_set_bytes,self._pointer,
-        _UniffiConverterTypeAuthorId.lower(author),
-        _UniffiConverterBytes.lower(key),
-        _UniffiConverterBytes.lower(value))
+        return FfiConverterTypeHash.lift(
+            rust_call_with_error(
+    FfiConverterTypeIrohError,_UniFFILib.uniffi_iroh_fn_method_doc_set_bytes,self._pointer,
+        FfiConverterTypeAuthorId.lower(author),
+        FfiConverterBytes.lower(key),
+        FfiConverterBytes.lower(value))
         )
 
 
 
 
 
 
-    def set_download_policy(self, policy: "DownloadPolicy"):
-        '''Set the download policy for this document'''
-        
-        _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_set_download_policy,self._pointer,
-        _UniffiConverterTypeDownloadPolicy.lower(policy))
-
-
-
-
-
-
-
-    def set_hash(self, author: "AuthorId",key: "bytes",hash: "Hash",size: "int"):
-        '''Set an entries on the doc via its key, hash, and size.'''
-        
+    def get_content_bytes(self, entry: "Entry") -> "bytes":
         
-        
-        
-        _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_set_hash,self._pointer,
-        _UniffiConverterTypeAuthorId.lower(author),
-        _UniffiConverterBytes.lower(key),
-        _UniffiConverterTypeHash.lower(hash),
-        _UniffiConverterUInt64.lower(size))
-
-
-
-
-
-
-
-    def share(self, mode: "ShareMode") -> "str":
-        '''Share this document with peers over a ticket.'''
-        
-        return _UniffiConverterString.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_share,self._pointer,
-        _UniffiConverterTypeShareMode.lower(mode))
+        return FfiConverterBytes.lift(
+            rust_call_with_error(
+    FfiConverterTypeIrohError,_UniFFILib.uniffi_iroh_fn_method_doc_get_content_bytes,self._pointer,
+        FfiConverterTypeEntry.lower(entry))
         )
 
 
 
 
 
 
-    def start_sync(self, peers: "typing.List[NodeAddr]"):
-        '''Start to sync this document with a list of peers.'''
-        
-        _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_start_sync,self._pointer,
-        _UniffiConverterSequenceTypeNodeAddr.lower(peers))
-
-
-
-
-
-
-
-    def status(self, ) -> "OpenState":
-        '''Get status info for this document'''
-        return _UniffiConverterTypeOpenState.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_status,self._pointer,)
+    def keys(self, ) -> "typing.List[Entry]":
+        return FfiConverterSequenceTypeEntry.lift(
+            rust_call_with_error(
+    FfiConverterTypeIrohError,_UniFFILib.uniffi_iroh_fn_method_doc_keys,self._pointer,)
         )
 
 
 
 
 
 
     def subscribe(self, cb: "SubscribeCallback"):
-        '''Subscribe to events for this document.'''
         
-        _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_doc_subscribe,self._pointer,
-        _UniffiConverterCallbackInterfaceSubscribeCallback.lower(cb))
+        rust_call_with_error(
+    FfiConverterTypeIrohError,_UniFFILib.uniffi_iroh_fn_method_doc_subscribe,self._pointer,
+        FfiConverterCallbackInterfaceSubscribeCallback.lower(cb))
 
 
 
 
 
 
 
-class _UniffiConverterTypeDoc:
-    @classmethod
-    def read(cls, buf):
-        ptr = buf.read_u64()
-        if ptr == 0:
-            raise InternalError("Raw pointer value was null")
-        return cls.lift(ptr)
-
-    @classmethod
-    def write(cls, value, buf):
-        if not isinstance(value, Doc):
-            raise TypeError("Expected Doc instance, {} found".format(type(value).__name__))
-        buf.write_u64(cls.lower(value))
-
-    @staticmethod
-    def lift(value):
-        return Doc._make_instance_(value)
+    def stop_sync(self, ):
+        rust_call_with_error(
+    FfiConverterTypeIrohError,_UniFFILib.uniffi_iroh_fn_method_doc_stop_sync,self._pointer,)
 
-    @staticmethod
-    def lower(value):
-        return value._pointer
 
 
 
-class DocExportProgress:
-    '''Progress updates for the doc import file operation.'''
 
-    _pointer: ctypes.c_void_p
 
-    def __del__(self):
-        # In case of partial initialization of instances.
-        pointer = getattr(self, "_pointer", None)
-        if pointer is not None:
-            _rust_call(_UniffiLib.uniffi_iroh_fn_free_docexportprogress, pointer)
 
-    # Used by alternative constructors or any methods which return this type.
-    @classmethod
-    def _make_instance_(cls, pointer):
-        # Lightly yucky way to bypass the usual __init__ logic
-        # and just create a new instance with the required pointer.
-        inst = cls.__new__(cls)
-        inst._pointer = pointer
-        return inst
-
-
-    def as_abort(self, ) -> "DocExportProgressAbort":
-        '''Return the `DocExportProgressAbort`'''
-        return _UniffiConverterTypeDocExportProgressAbort.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_docexportprogress_as_abort,self._pointer,)
-        )
-
-
-
-
-
-
-    def as_found(self, ) -> "DocExportProgressFound":
-        '''Return the `DocExportProgressFound` event'''
-        return _UniffiConverterTypeDocExportProgressFound.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_docexportprogress_as_found,self._pointer,)
-        )
-
-
-
-
-
-
-    def as_progress(self, ) -> "DocExportProgressProgress":
-        '''Return the `DocExportProgressProgress` event'''
-        return _UniffiConverterTypeDocExportProgressProgress.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_docexportprogress_as_progress,self._pointer,)
-        )
-
-
-
-
-
-
-    def type(self, ) -> "DocExportProgressType":
-        '''Get the type of event'''
-        return _UniffiConverterTypeDocExportProgressType.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_docexportprogress_type,self._pointer,)
+    def status(self, ) -> "LiveStatus":
+        return FfiConverterTypeLiveStatus.lift(
+            rust_call_with_error(
+    FfiConverterTypeIrohError,_UniFFILib.uniffi_iroh_fn_method_doc_status,self._pointer,)
         )
 
 
 
 
 
 
-class _UniffiConverterTypeDocExportProgress:
+class FfiConverterTypeDoc:
     @classmethod
     def read(cls, buf):
-        ptr = buf.read_u64()
+        ptr = buf.readU64()
         if ptr == 0:
             raise InternalError("Raw pointer value was null")
         return cls.lift(ptr)
 
     @classmethod
     def write(cls, value, buf):
-        if not isinstance(value, DocExportProgress):
-            raise TypeError("Expected DocExportProgress instance, {} found".format(type(value).__name__))
-        buf.write_u64(cls.lower(value))
-
-    @staticmethod
-    def lift(value):
-        return DocExportProgress._make_instance_(value)
-
-    @staticmethod
-    def lower(value):
-        return value._pointer
-
-
-
-class DocImportProgress:
-    '''Progress updates for the doc import file operation.'''
-
-    _pointer: ctypes.c_void_p
-
-    def __del__(self):
-        # In case of partial initialization of instances.
-        pointer = getattr(self, "_pointer", None)
-        if pointer is not None:
-            _rust_call(_UniffiLib.uniffi_iroh_fn_free_docimportprogress, pointer)
-
-    # Used by alternative constructors or any methods which return this type.
-    @classmethod
-    def _make_instance_(cls, pointer):
-        # Lightly yucky way to bypass the usual __init__ logic
-        # and just create a new instance with the required pointer.
-        inst = cls.__new__(cls)
-        inst._pointer = pointer
-        return inst
-
-
-    def as_abort(self, ) -> "DocImportProgressAbort":
-        '''Return the `DocImportProgressAbort`'''
-        return _UniffiConverterTypeDocImportProgressAbort.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_abort,self._pointer,)
-        )
-
-
-
-
-
-
-    def as_all_done(self, ) -> "DocImportProgressAllDone":
-        '''Return the `DocImportProgressAllDone`'''
-        return _UniffiConverterTypeDocImportProgressAllDone.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_all_done,self._pointer,)
-        )
-
-
-
-
-
-
-    def as_found(self, ) -> "DocImportProgressFound":
-        '''Return the `DocImportProgressFound` event'''
-        return _UniffiConverterTypeDocImportProgressFound.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_found,self._pointer,)
-        )
-
-
-
-
-
-
-    def as_ingest_done(self, ) -> "DocImportProgressIngestDone":
-        '''Return the `DocImportProgressDone` event'''
-        return _UniffiConverterTypeDocImportProgressIngestDone.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_ingest_done,self._pointer,)
-        )
-
-
-
-
-
-
-    def as_progress(self, ) -> "DocImportProgressProgress":
-        '''Return the `DocImportProgressProgress` event'''
-        return _UniffiConverterTypeDocImportProgressProgress.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_docimportprogress_as_progress,self._pointer,)
-        )
-
-
-
-
-
-
-    def type(self, ) -> "DocImportProgressType":
-        '''Get the type of event'''
-        return _UniffiConverterTypeDocImportProgressType.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_docimportprogress_type,self._pointer,)
-        )
-
-
-
-
-
-
-class _UniffiConverterTypeDocImportProgress:
-    @classmethod
-    def read(cls, buf):
-        ptr = buf.read_u64()
-        if ptr == 0:
-            raise InternalError("Raw pointer value was null")
-        return cls.lift(ptr)
-
-    @classmethod
-    def write(cls, value, buf):
-        if not isinstance(value, DocImportProgress):
-            raise TypeError("Expected DocImportProgress instance, {} found".format(type(value).__name__))
-        buf.write_u64(cls.lower(value))
+        if not isinstance(value, Doc):
+            raise TypeError("Expected Doc instance, {} found".format(value.__class__.__name__))
+        buf.writeU64(cls.lower(value))
 
     @staticmethod
     def lift(value):
-        return DocImportProgress._make_instance_(value)
+        return Doc._make_instance_(value)
 
     @staticmethod
     def lower(value):
         return value._pointer
 
 
 
-class DownloadPolicy:
-    '''Download policy to decide which content blobs shall be downloaded.'''
-
+class DocTicket:
     _pointer: ctypes.c_void_p
 
     def __del__(self):
         # In case of partial initialization of instances.
         pointer = getattr(self, "_pointer", None)
         if pointer is not None:
-            _rust_call(_UniffiLib.uniffi_iroh_fn_free_downloadpolicy, pointer)
+            rust_call(_UniFFILib.uniffi_iroh_fn_free_docticket, pointer)
 
     # Used by alternative constructors or any methods which return this type.
     @classmethod
     def _make_instance_(cls, pointer):
         # Lightly yucky way to bypass the usual __init__ logic
         # and just create a new instance with the required pointer.
         inst = cls.__new__(cls)
         inst._pointer = pointer
         return inst
 
     @classmethod
-    def everything(cls, ):
-        '''Download everything'''
-        # Call the (fallible) function before creating any half-baked object instances.
-        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_downloadpolicy_everything,)
-        return cls._make_instance_(pointer)
-
-
-    @classmethod
-    def everything_except(cls, filters: "typing.List[FilterKind]"):
-        '''Download everything except keys that match the given filters'''
-        
-        # Call the (fallible) function before creating any half-baked object instances.
-        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_downloadpolicy_everything_except,
-        _UniffiConverterSequenceTypeFilterKind.lower(filters))
-        return cls._make_instance_(pointer)
-
-
-    @classmethod
-    def nothing(cls, ):
-        '''Download nothing'''
-        # Call the (fallible) function before creating any half-baked object instances.
-        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_downloadpolicy_nothing,)
-        return cls._make_instance_(pointer)
-
-
-    @classmethod
-    def nothing_except(cls, filters: "typing.List[FilterKind]"):
-        '''Download nothing except keys that match the given filters'''
+    def from_string(cls, content: "str"):
         
         # Call the (fallible) function before creating any half-baked object instances.
-        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_downloadpolicy_nothing_except,
-        _UniffiConverterSequenceTypeFilterKind.lower(filters))
+        pointer = rust_call_with_error(FfiConverterTypeIrohError,_UniFFILib.uniffi_iroh_fn_constructor_docticket_from_string,
+        FfiConverterString.lower(content))
         return cls._make_instance_(pointer)
 
 
 
-class _UniffiConverterTypeDownloadPolicy:
-    @classmethod
-    def read(cls, buf):
-        ptr = buf.read_u64()
-        if ptr == 0:
-            raise InternalError("Raw pointer value was null")
-        return cls.lift(ptr)
-
-    @classmethod
-    def write(cls, value, buf):
-        if not isinstance(value, DownloadPolicy):
-            raise TypeError("Expected DownloadPolicy instance, {} found".format(type(value).__name__))
-        buf.write_u64(cls.lower(value))
-
-    @staticmethod
-    def lift(value):
-        return DownloadPolicy._make_instance_(value)
-
-    @staticmethod
-    def lower(value):
-        return value._pointer
-
-
-
-class DownloadProgress:
-    '''Progress updates for the get operation.'''
-
-    _pointer: ctypes.c_void_p
-
-    def __del__(self):
-        # In case of partial initialization of instances.
-        pointer = getattr(self, "_pointer", None)
-        if pointer is not None:
-            _rust_call(_UniffiLib.uniffi_iroh_fn_free_downloadprogress, pointer)
-
-    # Used by alternative constructors or any methods which return this type.
-    @classmethod
-    def _make_instance_(cls, pointer):
-        # Lightly yucky way to bypass the usual __init__ logic
-        # and just create a new instance with the required pointer.
-        inst = cls.__new__(cls)
-        inst._pointer = pointer
-        return inst
-
-
-    def as_abort(self, ) -> "DownloadProgressAbort":
-        '''Return the `DownloadProgressAbort`'''
-        return _UniffiConverterTypeDownloadProgressAbort.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_abort,self._pointer,)
-        )
-
-
-
-
-
-
-    def as_all_done(self, ) -> "DownloadProgressAllDone":
-        '''Return the `DownloadProgressAllDone` event'''
-        return _UniffiConverterTypeDownloadProgressAllDone.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_all_done,self._pointer,)
-        )
-
-
-
-
-
-
-    def as_done(self, ) -> "DownloadProgressDone":
-        '''Return the `DownloadProgressDone` event'''
-        return _UniffiConverterTypeDownloadProgressDone.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_done,self._pointer,)
-        )
-
-
-
-
-
-
-    def as_found(self, ) -> "DownloadProgressFound":
-        '''Return the `DownloadProgressFound` event'''
-        return _UniffiConverterTypeDownloadProgressFound.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_found,self._pointer,)
-        )
-
-
-
-
-
-
-    def as_found_hash_seq(self, ) -> "DownloadProgressFoundHashSeq":
-        '''Return the `DownloadProgressFoundHashSeq` event'''
-        return _UniffiConverterTypeDownloadProgressFoundHashSeq.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_found_hash_seq,self._pointer,)
-        )
-
-
-
-
-
-
-    def as_found_local(self, ) -> "DownloadProgressFoundLocal":
-        '''Return the `DownloadProgressFoundLocal` event'''
-        return _UniffiConverterTypeDownloadProgressFoundLocal.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_found_local,self._pointer,)
-        )
-
-
-
-
-
-
-    def as_progress(self, ) -> "DownloadProgressProgress":
-        '''Return the `DownloadProgressProgress` event'''
-        return _UniffiConverterTypeDownloadProgressProgress.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_downloadprogress_as_progress,self._pointer,)
-        )
-
-
-
-
-
-
-    def type(self, ) -> "DownloadProgressType":
-        '''
-        Get the type of event
-        note that there is no `as_connected` method, as the `Connected` event has no associated data
-        '''
-        return _UniffiConverterTypeDownloadProgressType.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_downloadprogress_type,self._pointer,)
+    def to_string(self, ) -> "str":
+        return FfiConverterString.lift(
+            rust_call(_UniFFILib.uniffi_iroh_fn_method_docticket_to_string,self._pointer,)
         )
 
 
 
 
 
 
-class _UniffiConverterTypeDownloadProgress:
+class FfiConverterTypeDocTicket:
     @classmethod
     def read(cls, buf):
-        ptr = buf.read_u64()
+        ptr = buf.readU64()
         if ptr == 0:
             raise InternalError("Raw pointer value was null")
         return cls.lift(ptr)
 
     @classmethod
     def write(cls, value, buf):
-        if not isinstance(value, DownloadProgress):
-            raise TypeError("Expected DownloadProgress instance, {} found".format(type(value).__name__))
-        buf.write_u64(cls.lower(value))
+        if not isinstance(value, DocTicket):
+            raise TypeError("Expected DocTicket instance, {} found".format(value.__class__.__name__))
+        buf.writeU64(cls.lower(value))
 
     @staticmethod
     def lift(value):
-        return DownloadProgress._make_instance_(value)
+        return DocTicket._make_instance_(value)
 
     @staticmethod
     def lower(value):
         return value._pointer
 
 
 
 class Entry:
-    '''
-    A single entry in a [`Doc`]
-
-    An entry is identified by a key, its [`AuthorId`], and the [`Doc`]'s
-    namespace id. Its value is the 32-byte BLAKE3 [`hash`]
-    of the entry's content data, the size of this content data, and a timestamp.
-    '''
-
     _pointer: ctypes.c_void_p
 
     def __del__(self):
         # In case of partial initialization of instances.
         pointer = getattr(self, "_pointer", None)
         if pointer is not None:
-            _rust_call(_UniffiLib.uniffi_iroh_fn_free_entry, pointer)
+            rust_call(_UniFFILib.uniffi_iroh_fn_free_entry, pointer)
 
     # Used by alternative constructors or any methods which return this type.
     @classmethod
     def _make_instance_(cls, pointer):
         # Lightly yucky way to bypass the usual __init__ logic
         # and just create a new instance with the required pointer.
         inst = cls.__new__(cls)
         inst._pointer = pointer
         return inst
 
 
     def author(self, ) -> "AuthorId":
-        '''Get the [`AuthorId`] of this entry.'''
-        return _UniffiConverterTypeAuthorId.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_entry_author,self._pointer,)
-        )
-
-
-
-
-
-
-    def content_bytes(self, doc: "Doc") -> "bytes":
-        '''
-        Read all content of an [`Entry`] into a buffer.
-        This allocates a buffer for the full entry. Use only if you know that the entry you're
-        reading is small. If not sure, use [`Self::content_len`] and check the size with
-        before calling [`Self::content_bytes`].
-        '''
-        
-        return _UniffiConverterBytes.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_entry_content_bytes,self._pointer,
-        _UniffiConverterTypeDoc.lower(doc))
-        )
-
-
-
-
-
-
-    def content_hash(self, ) -> "Hash":
-        '''Get the content_hash of this entry.'''
-        return _UniffiConverterTypeHash.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_entry_content_hash,self._pointer,)
-        )
-
-
-
-
-
-
-    def content_len(self, ) -> "int":
-        '''Get the content_length of this entry.'''
-        return _UniffiConverterUInt64.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_entry_content_len,self._pointer,)
+        return FfiConverterTypeAuthorId.lift(
+            rust_call(_UniFFILib.uniffi_iroh_fn_method_entry_author,self._pointer,)
         )
 
 
 
 
 
 
     def key(self, ) -> "bytes":
-        '''Get the key of this entry.'''
-        return _UniffiConverterBytes.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_entry_key,self._pointer,)
+        return FfiConverterBytes.lift(
+            rust_call(_UniFFILib.uniffi_iroh_fn_method_entry_key,self._pointer,)
         )
 
 
 
 
 
 
-    def namespace(self, ) -> "str":
-        '''Get the namespace id of this entry.'''
-        return _UniffiConverterString.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_entry_namespace,self._pointer,)
+    def hash(self, ) -> "Hash":
+        return FfiConverterTypeHash.lift(
+            rust_call(_UniFFILib.uniffi_iroh_fn_method_entry_hash,self._pointer,)
         )
 
 
 
 
 
 
-class _UniffiConverterTypeEntry:
+class FfiConverterTypeEntry:
     @classmethod
     def read(cls, buf):
-        ptr = buf.read_u64()
+        ptr = buf.readU64()
         if ptr == 0:
             raise InternalError("Raw pointer value was null")
         return cls.lift(ptr)
 
     @classmethod
     def write(cls, value, buf):
         if not isinstance(value, Entry):
-            raise TypeError("Expected Entry instance, {} found".format(type(value).__name__))
-        buf.write_u64(cls.lower(value))
+            raise TypeError("Expected Entry instance, {} found".format(value.__class__.__name__))
+        buf.writeU64(cls.lower(value))
 
     @staticmethod
     def lift(value):
         return Entry._make_instance_(value)
 
     @staticmethod
     def lower(value):
         return value._pointer
 
 
 
-class FilterKind:
-    '''Filter strategy used in download policies.'''
-
-    _pointer: ctypes.c_void_p
-
-    def __del__(self):
-        # In case of partial initialization of instances.
-        pointer = getattr(self, "_pointer", None)
-        if pointer is not None:
-            _rust_call(_UniffiLib.uniffi_iroh_fn_free_filterkind, pointer)
-
-    # Used by alternative constructors or any methods which return this type.
-    @classmethod
-    def _make_instance_(cls, pointer):
-        # Lightly yucky way to bypass the usual __init__ logic
-        # and just create a new instance with the required pointer.
-        inst = cls.__new__(cls)
-        inst._pointer = pointer
-        return inst
-
-    @classmethod
-    def exact(cls, key: "bytes"):
-        '''Returns a FilterKind that matches if the contained bytes and the key are the same.'''
-        
-        # Call the (fallible) function before creating any half-baked object instances.
-        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_filterkind_exact,
-        _UniffiConverterBytes.lower(key))
-        return cls._make_instance_(pointer)
-
-
-    @classmethod
-    def prefix(cls, prefix: "bytes"):
-        '''Returns a FilterKind that matches if the contained bytes are a prefix of the key.'''
-        
-        # Call the (fallible) function before creating any half-baked object instances.
-        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_filterkind_prefix,
-        _UniffiConverterBytes.lower(prefix))
-        return cls._make_instance_(pointer)
-
-
-
-    def matches(self, key: "bytes") -> "bool":
-        '''Verifies whether this filter matches a given key'''
-        
-        return _UniffiConverterBool.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_filterkind_matches,self._pointer,
-        _UniffiConverterBytes.lower(key))
-        )
-
-
-
-
-
-
-class _UniffiConverterTypeFilterKind:
-    @classmethod
-    def read(cls, buf):
-        ptr = buf.read_u64()
-        if ptr == 0:
-            raise InternalError("Raw pointer value was null")
-        return cls.lift(ptr)
-
-    @classmethod
-    def write(cls, value, buf):
-        if not isinstance(value, FilterKind):
-            raise TypeError("Expected FilterKind instance, {} found".format(type(value).__name__))
-        buf.write_u64(cls.lower(value))
-
-    @staticmethod
-    def lift(value):
-        return FilterKind._make_instance_(value)
-
-    @staticmethod
-    def lower(value):
-        return value._pointer
-
-
-
 class Hash:
-    '''Hash type used throughout Iroh. A blake3 hash.'''
-
     _pointer: ctypes.c_void_p
-    def __init__(self, buf: "bytes"):
-        '''Calculate the hash of the provide bytes.'''
-        
-        self._pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_hash_new,
-        _UniffiConverterBytes.lower(buf))
 
     def __del__(self):
         # In case of partial initialization of instances.
         pointer = getattr(self, "_pointer", None)
         if pointer is not None:
-            _rust_call(_UniffiLib.uniffi_iroh_fn_free_hash, pointer)
+            rust_call(_UniFFILib.uniffi_iroh_fn_free_hash, pointer)
 
     # Used by alternative constructors or any methods which return this type.
     @classmethod
     def _make_instance_(cls, pointer):
         # Lightly yucky way to bypass the usual __init__ logic
         # and just create a new instance with the required pointer.
         inst = cls.__new__(cls)
         inst._pointer = pointer
         return inst
 
-    @classmethod
-    def from_bytes(cls, bytes: "bytes"):
-        '''Create a Hash from its raw bytes representation.'''
-        
-        # Call the (fallible) function before creating any half-baked object instances.
-        pointer = _rust_call_with_error(_UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_constructor_hash_from_bytes,
-        _UniffiConverterBytes.lower(bytes))
-        return cls._make_instance_(pointer)
-
-
-    @classmethod
-    def from_string(cls, s: "str"):
-        '''Make a Hash from hex string'''
-        
-        # Call the (fallible) function before creating any half-baked object instances.
-        pointer = _rust_call_with_error(_UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_constructor_hash_from_string,
-        _UniffiConverterString.lower(s))
-        return cls._make_instance_(pointer)
-
-
 
-    def equal(self, other: "Hash") -> "bool":
-        '''Returns true if the Hash's have the same value'''
-        
-        return _UniffiConverterBool.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_hash_equal,self._pointer,
-        _UniffiConverterTypeHash.lower(other))
+    def to_string(self, ) -> "str":
+        return FfiConverterString.lift(
+            rust_call(_UniFFILib.uniffi_iroh_fn_method_hash_to_string,self._pointer,)
         )
 
 
 
 
 
 
     def to_bytes(self, ) -> "bytes":
-        '''Bytes of the hash.'''
-        return _UniffiConverterBytes.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_hash_to_bytes,self._pointer,)
-        )
-
-
-
-
-
-
-    def to_hex(self, ) -> "str":
-        '''Convert the hash to a hex string.'''
-        return _UniffiConverterString.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_hash_to_hex,self._pointer,)
-        )
-
-
-
-
-
-
-    def to_string(self, ) -> "str":
-        '''Write the hash to a string'''
-        return _UniffiConverterString.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_hash_to_string,self._pointer,)
+        return FfiConverterBytes.lift(
+            rust_call(_UniFFILib.uniffi_iroh_fn_method_hash_to_bytes,self._pointer,)
         )
 
 
 
 
 
 
-class _UniffiConverterTypeHash:
+class FfiConverterTypeHash:
     @classmethod
     def read(cls, buf):
-        ptr = buf.read_u64()
+        ptr = buf.readU64()
         if ptr == 0:
             raise InternalError("Raw pointer value was null")
         return cls.lift(ptr)
 
     @classmethod
     def write(cls, value, buf):
         if not isinstance(value, Hash):
-            raise TypeError("Expected Hash instance, {} found".format(type(value).__name__))
-        buf.write_u64(cls.lower(value))
+            raise TypeError("Expected Hash instance, {} found".format(value.__class__.__name__))
+        buf.writeU64(cls.lower(value))
 
     @staticmethod
     def lift(value):
         return Hash._make_instance_(value)
 
     @staticmethod
     def lower(value):
         return value._pointer
 
 
 
 class IrohNode:
-    '''An Iroh node. Allows you to sync, store, and transfer data.'''
-
     _pointer: ctypes.c_void_p
     def __init__(self, path: "str"):
-        '''
-        Create a new iroh node. The `path` param should be a directory where we can store or load
-        iroh data from a previous session.
-        '''
         
-        self._pointer = _rust_call_with_error(_UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_constructor_irohnode_new,
-        _UniffiConverterString.lower(path))
+        self._pointer = rust_call_with_error(FfiConverterTypeIrohError,_UniFFILib.uniffi_iroh_fn_constructor_irohnode_new,
+        FfiConverterString.lower(path))
 
     def __del__(self):
         # In case of partial initialization of instances.
         pointer = getattr(self, "_pointer", None)
         if pointer is not None:
-            _rust_call(_UniffiLib.uniffi_iroh_fn_free_irohnode, pointer)
+            rust_call(_UniFFILib.uniffi_iroh_fn_free_irohnode, pointer)
 
     # Used by alternative constructors or any methods which return this type.
     @classmethod
     def _make_instance_(cls, pointer):
         # Lightly yucky way to bypass the usual __init__ logic
         # and just create a new instance with the required pointer.
         inst = cls.__new__(cls)
         inst._pointer = pointer
         return inst
 
-    @classmethod
-    def with_options(cls, path: "str",opts: "NodeOptions"):
-        '''Create a new iroh node with options.'''
-        
-        
-        # Call the (fallible) function before creating any half-baked object instances.
-        pointer = _rust_call_with_error(_UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_constructor_irohnode_with_options,
-        _UniffiConverterString.lower(path),
-        _UniffiConverterTypeNodeOptions.lower(opts))
-        return cls._make_instance_(pointer)
-
-
-
-    def author_create(self, ) -> "AuthorId":
-        '''Create a new author.'''
-        return _UniffiConverterTypeAuthorId.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_author_create,self._pointer,)
-        )
-
-
-
-
-
-
-    def author_list(self, ) -> "typing.List[AuthorId]":
-        '''List all the AuthorIds that exist on this node.'''
-        return _UniffiConverterSequenceTypeAuthorId.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_author_list,self._pointer,)
-        )
-
-
-
-
-
-
-    def blobs_add_bytes(self, bytes: "bytes") -> "BlobAddOutcome":
-        '''Write a blob by passing bytes.'''
-        
-        return _UniffiConverterTypeBlobAddOutcome.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_add_bytes,self._pointer,
-        _UniffiConverterBytes.lower(bytes))
-        )
-
-
-
-
-
-
-    def blobs_add_from_path(self, path: "str",in_place: "bool",tag: "SetTagOption",wrap: "WrapOption",cb: "AddCallback"):
-        '''
-        Import a blob from a filesystem path.
-
-        `path` should be an absolute path valid for the file system on which
-        the node runs.
-        If `in_place` is true, Iroh will assume that the data will not change and will share it in
-        place without copying to the Iroh data directory.
-        '''
-        
-        
-        
-        
-        
-        _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_add_from_path,self._pointer,
-        _UniffiConverterString.lower(path),
-        _UniffiConverterBool.lower(in_place),
-        _UniffiConverterTypeSetTagOption.lower(tag),
-        _UniffiConverterTypeWrapOption.lower(wrap),
-        _UniffiConverterCallbackInterfaceAddCallback.lower(cb))
-
-
-
-
-
-
-
-    def blobs_create_collection(self, collection: "Collection",tag: "SetTagOption",tags_to_delete: "typing.List[str]") -> "HashAndTag":
-        '''
-        Create a collection from already existing blobs.
-
-        To automatically clear the tags for the passed in blobs you can set
-        `tags_to_delete` on those tags, and they will be deleted once the collection is created.
-        '''
-        
-        
-        
-        return _UniffiConverterTypeHashAndTag.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_create_collection,self._pointer,
-        _UniffiConverterTypeCollection.lower(collection),
-        _UniffiConverterTypeSetTagOption.lower(tag),
-        _UniffiConverterSequenceString.lower(tags_to_delete))
-        )
-
-
-
-
-
-
-    def blobs_delete_blob(self, hash: "Hash"):
-        '''Delete a blob.'''
-        
-        _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_delete_blob,self._pointer,
-        _UniffiConverterTypeHash.lower(hash))
-
-
-
-
-
-
-
-    def blobs_download(self, req: "BlobDownloadRequest",cb: "DownloadCallback"):
-        '''Download a blob from another node and add it to the local database.'''
-        
-        
-        _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_download,self._pointer,
-        _UniffiConverterTypeBlobDownloadRequest.lower(req),
-        _UniffiConverterCallbackInterfaceDownloadCallback.lower(cb))
-
-
-
-
 
-
-
-    def blobs_export(self, hash: "Hash",destination: "str",format: "BlobExportFormat",mode: "BlobExportMode"):
-        '''Download a blob from another node and add it to the local database.'''
-        
-        
-        
-        
-        _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_export,self._pointer,
-        _UniffiConverterTypeHash.lower(hash),
-        _UniffiConverterString.lower(destination),
-        _UniffiConverterTypeBlobExportFormat.lower(format),
-        _UniffiConverterTypeBlobExportMode.lower(mode))
-
-
-
-
-
-
-
-    def blobs_get_collection(self, hash: "Hash") -> "Collection":
-        '''Read the content of a collection'''
-        
-        return _UniffiConverterTypeCollection.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_get_collection,self._pointer,
-        _UniffiConverterTypeHash.lower(hash))
-        )
-
-
-
-
-
-
-    def blobs_list(self, ) -> "typing.List[Hash]":
-        '''
-        List all complete blobs.
-
-        Note: this allocates for each `BlobListResponse`, if you have many `BlobListReponse`s this may be a prohibitively large list.
-        Please file an [issue](https://github.com/n0-computer/iroh-ffi/issues/new) if you run into this issue
-        '''
-        return _UniffiConverterSequenceTypeHash.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_list,self._pointer,)
-        )
-
-
-
-
-
-
-    def blobs_list_collections(self, ) -> "typing.List[BlobListCollectionsResponse]":
-        '''
-        List all collections.
-
-        Note: this allocates for each `BlobListCollectionsResponse`, if you have many `BlobListCollectionsResponse`s this may be a prohibitively large list.
-        Please file an [issue](https://github.com/n0-computer/iroh-ffi/issues/new) if you run into this issue
-        '''
-        return _UniffiConverterSequenceTypeBlobListCollectionsResponse.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_list_collections,self._pointer,)
-        )
-
-
-
-
-
-
-    def blobs_list_incomplete(self, ) -> "typing.List[BlobListIncompleteResponse]":
-        '''
-        List all incomplete (partial) blobs.
-
-        Note: this allocates for each `BlobListIncompleteResponse`, if you have many `BlobListIncompleteResponse`s this may be a prohibitively large list.
-        Please file an [issue](https://github.com/n0-computer/iroh-ffi/issues/new) if you run into this issue
-        '''
-        return _UniffiConverterSequenceTypeBlobListIncompleteResponse.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_list_incomplete,self._pointer,)
+    def node_id(self, ) -> "str":
+        return FfiConverterString.lift(
+            rust_call(_UniFFILib.uniffi_iroh_fn_method_irohnode_node_id,self._pointer,)
         )
 
 
 
 
 
 
-    def blobs_read_at_to_bytes(self, hash: "Hash",offset: "int",len: "typing.Optional[int]") -> "bytes":
-        '''
-        Read all bytes of single blob at `offset` for length `len`.
-
-        This allocates a buffer for the full length `len`. Use only if you know that the blob you're
-        reading is small. If not sure, use [`Self::blobs_size`] and check the size with
-        before calling [`Self::blobs_read_at_to_bytes`].
-        '''
-        
-        
-        
-        return _UniffiConverterBytes.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_read_at_to_bytes,self._pointer,
-        _UniffiConverterTypeHash.lower(hash),
-        _UniffiConverterUInt64.lower(offset),
-        _UniffiConverterOptionalUInt64.lower(len))
+    def doc_new(self, ) -> "Doc":
+        return FfiConverterTypeDoc.lift(
+            rust_call_with_error(
+    FfiConverterTypeIrohError,_UniFFILib.uniffi_iroh_fn_method_irohnode_doc_new,self._pointer,)
         )
 
 
 
 
 
 
-    def blobs_read_to_bytes(self, hash: "Hash") -> "bytes":
-        '''
-        Read all bytes of single blob.
-
-        This allocates a buffer for the full blob. Use only if you know that the blob you're
-        reading is small. If not sure, use [`Self::blobs_size`] and check the size with
-        before calling [`Self::blobs_read_to_bytes`].
-        '''
+    def doc_join(self, ticket: "DocTicket") -> "Doc":
         
-        return _UniffiConverterBytes.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_read_to_bytes,self._pointer,
-        _UniffiConverterTypeHash.lower(hash))
+        return FfiConverterTypeDoc.lift(
+            rust_call_with_error(
+    FfiConverterTypeIrohError,_UniFFILib.uniffi_iroh_fn_method_irohnode_doc_join,self._pointer,
+        FfiConverterTypeDocTicket.lower(ticket))
         )
 
 
 
 
 
 
-    def blobs_share(self, hash: "Hash",blob_format: "BlobFormat",ticket_options: "ShareTicketOptions") -> "str":
-        '''Create a ticket for sharing a blob or collection from this node.'''
-        
-        
-        
-        return _UniffiConverterString.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_share,self._pointer,
-        _UniffiConverterTypeHash.lower(hash),
-        _UniffiConverterTypeBlobFormat.lower(blob_format),
-        _UniffiConverterTypeShareTicketOptions.lower(ticket_options))
+    def author_new(self, ) -> "AuthorId":
+        return FfiConverterTypeAuthorId.lift(
+            rust_call_with_error(
+    FfiConverterTypeIrohError,_UniFFILib.uniffi_iroh_fn_method_irohnode_author_new,self._pointer,)
         )
 
 
 
 
 
 
-    def blobs_size(self, hash: "Hash") -> "int":
-        '''Get the size information on a single blob.'''
-        
-        return _UniffiConverterUInt64.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_size,self._pointer,
-        _UniffiConverterTypeHash.lower(hash))
+    def author_list(self, ) -> "typing.List[AuthorId]":
+        return FfiConverterSequenceTypeAuthorId.lift(
+            rust_call_with_error(
+    FfiConverterTypeIrohError,_UniFFILib.uniffi_iroh_fn_method_irohnode_author_list,self._pointer,)
         )
 
 
 
 
 
 
-    def blobs_write_to_path(self, hash: "Hash",path: "str"):
-        '''
-        Export the blob contents to a file path
-        The `path` field is expected to be the absolute path.
-        '''
-        
-        
-        _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_blobs_write_to_path,self._pointer,
-        _UniffiConverterTypeHash.lower(hash),
-        _UniffiConverterString.lower(path))
-
-
-
-
-
-
-
-    def connection_info(self, node_id: "PublicKey") -> "typing.Optional[ConnectionInfo]":
-        
-        return _UniffiConverterOptionalTypeConnectionInfo.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_connection_info,self._pointer,
-        _UniffiConverterTypePublicKey.lower(node_id))
+    def stats(self, ) -> "dict":
+        return FfiConverterMapStringTypeCounterStats.lift(
+            rust_call_with_error(
+    FfiConverterTypeIrohError,_UniFFILib.uniffi_iroh_fn_method_irohnode_stats,self._pointer,)
         )
 
 
 
 
 
 
     def connections(self, ) -> "typing.List[ConnectionInfo]":
-        '''Return `ConnectionInfo`s for each connection we have to another iroh node.'''
-        return _UniffiConverterSequenceTypeConnectionInfo.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_connections,self._pointer,)
-        )
-
-
-
-
-
-
-    def doc_create(self, ) -> "Doc":
-        '''Create a new doc.'''
-        return _UniffiConverterTypeDoc.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_create,self._pointer,)
-        )
-
-
-
-
-
-
-    def doc_drop(self, doc_id: "str"):
-        '''
-        Delete a document from the local node.
-
-        This is a destructive operation. Both the document secret key and all entries in the
-        document will be permanently deleted from the node's storage. Content blobs will be
-        deleted through garbage collection unless they are referenced from another document or tag.
-        '''
-        
-        _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_drop,self._pointer,
-        _UniffiConverterString.lower(doc_id))
-
-
-
-
-
-
-
-    def doc_join(self, ticket: "str") -> "Doc":
-        '''Join and sync with an already existing document.'''
-        
-        return _UniffiConverterTypeDoc.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_join,self._pointer,
-        _UniffiConverterString.lower(ticket))
-        )
-
-
-
-
-
-
-    def doc_list(self, ) -> "typing.List[NamespaceAndCapability]":
-        '''List all the docs we have access to on this node.'''
-        return _UniffiConverterSequenceTypeNamespaceAndCapability.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_list,self._pointer,)
+        return FfiConverterSequenceTypeConnectionInfo.lift(
+            rust_call_with_error(
+    FfiConverterTypeIrohError,_UniFFILib.uniffi_iroh_fn_method_irohnode_connections,self._pointer,)
         )
 
 
 
 
 
 
-    def doc_open(self, id: "str") -> "typing.Optional[Doc]":
-        '''
-        Get a [`Doc`].
-
-        Returns None if the document cannot be found.
-        '''
+    def connection_info(self, node_id: "PublicKey") -> "typing.Optional[ConnectionInfo]":
         
-        return _UniffiConverterOptionalTypeDoc.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_doc_open,self._pointer,
-        _UniffiConverterString.lower(id))
-        )
-
-
-
-
-
-
-    def node_id(self, ) -> "str":
-        '''The string representation of the PublicKey of this node.'''
-        return _UniffiConverterString.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_irohnode_node_id,self._pointer,)
-        )
-
-
-
-
-
-
-    def stats(self, ) -> "dict":
-        '''Get statistics of the running node.'''
-        return _UniffiConverterMapStringTypeCounterStats.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_stats,self._pointer,)
+        return FfiConverterOptionalTypeConnectionInfo.lift(
+            rust_call_with_error(
+    FfiConverterTypeIrohError,_UniFFILib.uniffi_iroh_fn_method_irohnode_connection_info,self._pointer,
+        FfiConverterTypePublicKey.lower(node_id))
         )
 
 
 
 
 
 
-    def status(self, ) -> "NodeStatusResponse":
-        '''Get status information about a node'''
-        return _UniffiConverterTypeNodeStatusResponse.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_status,self._pointer,)
+    def blob_list_blobs(self, ) -> "typing.List[Hash]":
+        return FfiConverterSequenceTypeHash.lift(
+            rust_call_with_error(
+    FfiConverterTypeIrohError,_UniFFILib.uniffi_iroh_fn_method_irohnode_blob_list_blobs,self._pointer,)
         )
 
 
 
 
 
 
-    def tags_delete(self, name: "bytes"):
-        '''Delete a tag.'''
+    def blob_get(self, hash: "Hash") -> "bytes":
         
-        _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_tags_delete,self._pointer,
-        _UniffiConverterBytes.lower(name))
-
-
-
-
-
-
-
-    def tags_list(self, ) -> "typing.List[ListTagsResponse]":
-        '''
-        List all tags
-
-        Note: this allocates for each `ListTagsResponse`, if you have many `Tags`s this may be a prohibitively large list.
-        Please file an [issue](https://github.com/n0-computer/iroh-ffi/issues/new) if you run into this issue
-        '''
-        return _UniffiConverterSequenceTypeListTagsResponse.lift(
-            _rust_call_with_error(
-    _UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_method_irohnode_tags_list,self._pointer,)
+        return FfiConverterBytes.lift(
+            rust_call_with_error(
+    FfiConverterTypeIrohError,_UniFFILib.uniffi_iroh_fn_method_irohnode_blob_get,self._pointer,
+        FfiConverterTypeHash.lower(hash))
         )
 
 
 
 
 
 
-class _UniffiConverterTypeIrohNode:
+class FfiConverterTypeIrohNode:
     @classmethod
     def read(cls, buf):
-        ptr = buf.read_u64()
+        ptr = buf.readU64()
         if ptr == 0:
             raise InternalError("Raw pointer value was null")
         return cls.lift(ptr)
 
     @classmethod
     def write(cls, value, buf):
         if not isinstance(value, IrohNode):
-            raise TypeError("Expected IrohNode instance, {} found".format(type(value).__name__))
-        buf.write_u64(cls.lower(value))
+            raise TypeError("Expected IrohNode instance, {} found".format(value.__class__.__name__))
+        buf.writeU64(cls.lower(value))
 
     @staticmethod
     def lift(value):
         return IrohNode._make_instance_(value)
 
     @staticmethod
     def lower(value):
         return value._pointer
 
 
 
 class LiveEvent:
-    '''Events informing about actions of the live sync progress'''
-
     _pointer: ctypes.c_void_p
 
     def __del__(self):
         # In case of partial initialization of instances.
         pointer = getattr(self, "_pointer", None)
         if pointer is not None:
-            _rust_call(_UniffiLib.uniffi_iroh_fn_free_liveevent, pointer)
+            rust_call(_UniFFILib.uniffi_iroh_fn_free_liveevent, pointer)
 
     # Used by alternative constructors or any methods which return this type.
     @classmethod
     def _make_instance_(cls, pointer):
         # Lightly yucky way to bypass the usual __init__ logic
         # and just create a new instance with the required pointer.
         inst = cls.__new__(cls)
         inst._pointer = pointer
         return inst
 
 
-    def as_content_ready(self, ) -> "Hash":
-        '''For `LiveEventType::ContentReady`, returns a Hash'''
-        return _UniffiConverterTypeHash.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_liveevent_as_content_ready,self._pointer,)
+    def type(self, ) -> "LiveEventType":
+        return FfiConverterTypeLiveEventType.lift(
+            rust_call(_UniFFILib.uniffi_iroh_fn_method_liveevent_type,self._pointer,)
         )
 
 
 
 
 
 
     def as_insert_local(self, ) -> "Entry":
-        '''For `LiveEventType::InsertLocal`, returns an Entry'''
-        return _UniffiConverterTypeEntry.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_liveevent_as_insert_local,self._pointer,)
+        return FfiConverterTypeEntry.lift(
+            rust_call(_UniFFILib.uniffi_iroh_fn_method_liveevent_as_insert_local,self._pointer,)
         )
 
 
 
 
 
 
     def as_insert_remote(self, ) -> "InsertRemoteEvent":
-        '''For `LiveEventType::InsertRemote`, returns an InsertRemoteEvent'''
-        return _UniffiConverterTypeInsertRemoteEvent.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_liveevent_as_insert_remote,self._pointer,)
+        return FfiConverterTypeInsertRemoteEvent.lift(
+            rust_call(_UniFFILib.uniffi_iroh_fn_method_liveevent_as_insert_remote,self._pointer,)
         )
 
 
 
 
 
 
-    def as_neighbor_down(self, ) -> "PublicKey":
-        '''For `LiveEventType::NeighborDown`, returns a PublicKey'''
-        return _UniffiConverterTypePublicKey.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_liveevent_as_neighbor_down,self._pointer,)
+    def as_content_ready(self, ) -> "Hash":
+        return FfiConverterTypeHash.lift(
+            rust_call(_UniFFILib.uniffi_iroh_fn_method_liveevent_as_content_ready,self._pointer,)
         )
 
 
 
 
 
 
     def as_neighbor_up(self, ) -> "PublicKey":
-        '''For `LiveEventType::NeighborUp`, returns a PublicKey'''
-        return _UniffiConverterTypePublicKey.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_liveevent_as_neighbor_up,self._pointer,)
+        return FfiConverterTypePublicKey.lift(
+            rust_call(_UniFFILib.uniffi_iroh_fn_method_liveevent_as_neighbor_up,self._pointer,)
         )
 
 
 
 
 
 
-    def as_sync_finished(self, ) -> "SyncEvent":
-        '''For `LiveEventType::SyncFinished`, returns a SyncEvent'''
-        return _UniffiConverterTypeSyncEvent.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_liveevent_as_sync_finished,self._pointer,)
+    def as_neighbor_down(self, ) -> "PublicKey":
+        return FfiConverterTypePublicKey.lift(
+            rust_call(_UniFFILib.uniffi_iroh_fn_method_liveevent_as_neighbor_down,self._pointer,)
         )
 
 
 
 
 
 
-    def type(self, ) -> "LiveEventType":
-        '''The type LiveEvent'''
-        return _UniffiConverterTypeLiveEventType.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_liveevent_type,self._pointer,)
+    def as_sync_finished(self, ) -> "SyncEvent":
+        return FfiConverterTypeSyncEvent.lift(
+            rust_call(_UniFFILib.uniffi_iroh_fn_method_liveevent_as_sync_finished,self._pointer,)
         )
 
 
 
 
 
 
-class _UniffiConverterTypeLiveEvent:
+class FfiConverterTypeLiveEvent:
     @classmethod
     def read(cls, buf):
-        ptr = buf.read_u64()
+        ptr = buf.readU64()
         if ptr == 0:
             raise InternalError("Raw pointer value was null")
         return cls.lift(ptr)
 
     @classmethod
     def write(cls, value, buf):
         if not isinstance(value, LiveEvent):
-            raise TypeError("Expected LiveEvent instance, {} found".format(type(value).__name__))
-        buf.write_u64(cls.lower(value))
+            raise TypeError("Expected LiveEvent instance, {} found".format(value.__class__.__name__))
+        buf.writeU64(cls.lower(value))
 
     @staticmethod
     def lift(value):
         return LiveEvent._make_instance_(value)
 
     @staticmethod
     def lower(value):
         return value._pointer
 
 
 
-class NodeAddr:
-    '''A peer and it's addressing information.'''
-
-    _pointer: ctypes.c_void_p
-    def __init__(self, node_id: "PublicKey",relay_url: "typing.Optional[str]",addresses: "typing.List[str]"):
-        '''Create a new [`NodeAddr`] with empty [`AddrInfo`].'''
-        
-        
-        
-        self._pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_nodeaddr_new,
-        _UniffiConverterTypePublicKey.lower(node_id),
-        _UniffiConverterOptionalString.lower(relay_url),
-        _UniffiConverterSequenceString.lower(addresses))
-
-    def __del__(self):
-        # In case of partial initialization of instances.
-        pointer = getattr(self, "_pointer", None)
-        if pointer is not None:
-            _rust_call(_UniffiLib.uniffi_iroh_fn_free_nodeaddr, pointer)
-
-    # Used by alternative constructors or any methods which return this type.
-    @classmethod
-    def _make_instance_(cls, pointer):
-        # Lightly yucky way to bypass the usual __init__ logic
-        # and just create a new instance with the required pointer.
-        inst = cls.__new__(cls)
-        inst._pointer = pointer
-        return inst
-
-
-    def direct_addresses(self, ) -> "typing.List[str]":
-        '''Get the direct addresses of this peer.'''
-        return _UniffiConverterSequenceString.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_nodeaddr_direct_addresses,self._pointer,)
-        )
-
-
-
-
-
-
-    def equal(self, other: "NodeAddr") -> "bool":
-        '''Returns true if both NodeAddr's have the same values'''
-        
-        return _UniffiConverterBool.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_nodeaddr_equal,self._pointer,
-        _UniffiConverterTypeNodeAddr.lower(other))
-        )
-
-
-
-
-
-
-    def relay_url(self, ) -> "typing.Optional[str]":
-        '''Get the relay url of this peer.'''
-        return _UniffiConverterOptionalString.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_nodeaddr_relay_url,self._pointer,)
-        )
-
-
-
-
-
-
-class _UniffiConverterTypeNodeAddr:
-    @classmethod
-    def read(cls, buf):
-        ptr = buf.read_u64()
-        if ptr == 0:
-            raise InternalError("Raw pointer value was null")
-        return cls.lift(ptr)
-
-    @classmethod
-    def write(cls, value, buf):
-        if not isinstance(value, NodeAddr):
-            raise TypeError("Expected NodeAddr instance, {} found".format(type(value).__name__))
-        buf.write_u64(cls.lower(value))
-
-    @staticmethod
-    def lift(value):
-        return NodeAddr._make_instance_(value)
-
-    @staticmethod
-    def lower(value):
-        return value._pointer
-
-
-
-class NodeStatusResponse:
-
+class NamespaceId:
     _pointer: ctypes.c_void_p
 
     def __del__(self):
         # In case of partial initialization of instances.
         pointer = getattr(self, "_pointer", None)
         if pointer is not None:
-            _rust_call(_UniffiLib.uniffi_iroh_fn_free_nodestatusresponse, pointer)
+            rust_call(_UniFFILib.uniffi_iroh_fn_free_namespaceid, pointer)
 
     # Used by alternative constructors or any methods which return this type.
     @classmethod
     def _make_instance_(cls, pointer):
         # Lightly yucky way to bypass the usual __init__ logic
         # and just create a new instance with the required pointer.
         inst = cls.__new__(cls)
         inst._pointer = pointer
         return inst
 
 
-    def listen_addrs(self, ) -> "typing.List[str]":
-        '''The bound listening addresses of the node'''
-        return _UniffiConverterSequenceString.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_nodestatusresponse_listen_addrs,self._pointer,)
-        )
-
-
-
-
-
-
-    def node_addr(self, ) -> "NodeAddr":
-        '''The node id and socket addresses of this node.'''
-        return _UniffiConverterTypeNodeAddr.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_nodestatusresponse_node_addr,self._pointer,)
-        )
-
-
-
-
-
-
-    def version(self, ) -> "str":
-        '''The version of the node'''
-        return _UniffiConverterString.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_nodestatusresponse_version,self._pointer,)
+    def to_string(self, ) -> "str":
+        return FfiConverterString.lift(
+            rust_call(_UniFFILib.uniffi_iroh_fn_method_namespaceid_to_string,self._pointer,)
         )
 
 
 
 
 
 
-class _UniffiConverterTypeNodeStatusResponse:
+class FfiConverterTypeNamespaceId:
     @classmethod
     def read(cls, buf):
-        ptr = buf.read_u64()
+        ptr = buf.readU64()
         if ptr == 0:
             raise InternalError("Raw pointer value was null")
         return cls.lift(ptr)
 
     @classmethod
     def write(cls, value, buf):
-        if not isinstance(value, NodeStatusResponse):
-            raise TypeError("Expected NodeStatusResponse instance, {} found".format(type(value).__name__))
-        buf.write_u64(cls.lower(value))
+        if not isinstance(value, NamespaceId):
+            raise TypeError("Expected NamespaceId instance, {} found".format(value.__class__.__name__))
+        buf.writeU64(cls.lower(value))
 
     @staticmethod
     def lift(value):
-        return NodeStatusResponse._make_instance_(value)
+        return NamespaceId._make_instance_(value)
 
     @staticmethod
     def lower(value):
         return value._pointer
 
 
 
 class PublicKey:
-    '''A public key'''
-
     _pointer: ctypes.c_void_p
 
     def __del__(self):
         # In case of partial initialization of instances.
         pointer = getattr(self, "_pointer", None)
         if pointer is not None:
-            _rust_call(_UniffiLib.uniffi_iroh_fn_free_publickey, pointer)
+            rust_call(_UniFFILib.uniffi_iroh_fn_free_publickey, pointer)
 
     # Used by alternative constructors or any methods which return this type.
     @classmethod
     def _make_instance_(cls, pointer):
         # Lightly yucky way to bypass the usual __init__ logic
         # and just create a new instance with the required pointer.
         inst = cls.__new__(cls)
         inst._pointer = pointer
         return inst
 
-    @classmethod
-    def from_bytes(cls, bytes: "bytes"):
-        '''Get a PublicKey from a byte slice'''
-        
-        # Call the (fallible) function before creating any half-baked object instances.
-        pointer = _rust_call_with_error(_UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_constructor_publickey_from_bytes,
-        _UniffiConverterBytes.lower(bytes))
-        return cls._make_instance_(pointer)
-
-
-    @classmethod
-    def from_string(cls, s: "str"):
-        '''Get a PublicKey from a string'''
-        
-        # Call the (fallible) function before creating any half-baked object instances.
-        pointer = _rust_call_with_error(_UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_constructor_publickey_from_string,
-        _UniffiConverterString.lower(s))
-        return cls._make_instance_(pointer)
-
-
-
-    def equal(self, other: "PublicKey") -> "bool":
-        '''Returns true when both PublicKeys have the same value'''
-        
-        return _UniffiConverterBool.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_publickey_equal,self._pointer,
-        _UniffiConverterTypePublicKey.lower(other))
-        )
-
-
-
-
 
-
-    def fmt_short(self, ) -> "str":
-        '''The first 10 bytes of the PublicKey represented as a string'''
-        return _UniffiConverterString.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_publickey_fmt_short,self._pointer,)
+    def to_string(self, ) -> "str":
+        return FfiConverterString.lift(
+            rust_call(_UniFFILib.uniffi_iroh_fn_method_publickey_to_string,self._pointer,)
         )
 
 
 
 
 
 
     def to_bytes(self, ) -> "bytes":
-        '''Represent a PublicKey as a byte slice'''
-        return _UniffiConverterBytes.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_publickey_to_bytes,self._pointer,)
+        return FfiConverterBytes.lift(
+            rust_call(_UniFFILib.uniffi_iroh_fn_method_publickey_to_bytes,self._pointer,)
         )
 
 
 
 
 
 
-    def to_string(self, ) -> "str":
-        '''Represent a PublicKey as a string'''
-        return _UniffiConverterString.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_publickey_to_string,self._pointer,)
-        )
-
-
-
-
-
-
-class _UniffiConverterTypePublicKey:
+class FfiConverterTypePublicKey:
     @classmethod
     def read(cls, buf):
-        ptr = buf.read_u64()
+        ptr = buf.readU64()
         if ptr == 0:
             raise InternalError("Raw pointer value was null")
         return cls.lift(ptr)
 
     @classmethod
     def write(cls, value, buf):
         if not isinstance(value, PublicKey):
-            raise TypeError("Expected PublicKey instance, {} found".format(type(value).__name__))
-        buf.write_u64(cls.lower(value))
+            raise TypeError("Expected PublicKey instance, {} found".format(value.__class__.__name__))
+        buf.writeU64(cls.lower(value))
 
     @staticmethod
     def lift(value):
         return PublicKey._make_instance_(value)
 
     @staticmethod
     def lower(value):
         return value._pointer
 
 
-
-class Query:
-    '''
-    Build a Query to search for an entry or entries in a doc.
-
-    Use this with `QueryOptions` to determine sorting, grouping, and pagination.
-    '''
-
-    _pointer: ctypes.c_void_p
-
-    def __del__(self):
-        # In case of partial initialization of instances.
-        pointer = getattr(self, "_pointer", None)
-        if pointer is not None:
-            _rust_call(_UniffiLib.uniffi_iroh_fn_free_query, pointer)
-
-    # Used by alternative constructors or any methods which return this type.
-    @classmethod
-    def _make_instance_(cls, pointer):
-        # Lightly yucky way to bypass the usual __init__ logic
-        # and just create a new instance with the required pointer.
-        inst = cls.__new__(cls)
-        inst._pointer = pointer
-        return inst
-
-    @classmethod
-    def all(cls, opts: "typing.Optional[QueryOptions]"):
-        '''
-        Query all records.
-
-        If `opts` is `None`, the default values will be used:
-            sort_by: SortBy::AuthorKey
-            direction: SortDirection::Asc
-            offset: None
-            limit: None
-        '''
-        
-        # Call the (fallible) function before creating any half-baked object instances.
-        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_query_all,
-        _UniffiConverterOptionalTypeQueryOptions.lower(opts))
-        return cls._make_instance_(pointer)
-
-
-    @classmethod
-    def author(cls, author: "AuthorId",opts: "typing.Optional[QueryOptions]"):
-        '''
-        Query all entries for by a single author.
-
-        If `opts` is `None`, the default values will be used:
-            sort_by: SortBy::AuthorKey
-            direction: SortDirection::Asc
-            offset: None
-            limit: None
-        '''
-        
-        
-        # Call the (fallible) function before creating any half-baked object instances.
-        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_query_author,
-        _UniffiConverterTypeAuthorId.lower(author),
-        _UniffiConverterOptionalTypeQueryOptions.lower(opts))
-        return cls._make_instance_(pointer)
-
-
-    @classmethod
-    def author_key_exact(cls, author: "AuthorId",key: "bytes"):
-        '''Create a Query for a single key and author.'''
-        
-        
-        # Call the (fallible) function before creating any half-baked object instances.
-        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_query_author_key_exact,
-        _UniffiConverterTypeAuthorId.lower(author),
-        _UniffiConverterBytes.lower(key))
-        return cls._make_instance_(pointer)
-
-
-    @classmethod
-    def author_key_prefix(cls, author: "AuthorId",prefix: "bytes",opts: "typing.Optional[QueryOptions]"):
-        '''
-        Create a query for all entries of a single author with a given key prefix.
-
-        If `opts` is `None`, the default values will be used:
-            direction: SortDirection::Asc
-            offset: None
-            limit: None
-        '''
-        
-        
-        
-        # Call the (fallible) function before creating any half-baked object instances.
-        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_query_author_key_prefix,
-        _UniffiConverterTypeAuthorId.lower(author),
-        _UniffiConverterBytes.lower(prefix),
-        _UniffiConverterOptionalTypeQueryOptions.lower(opts))
-        return cls._make_instance_(pointer)
-
-
-    @classmethod
-    def key_exact(cls, key: "bytes",opts: "typing.Optional[QueryOptions]"):
-        '''
-        Query all entries that have an exact key.
-
-        If `opts` is `None`, the default values will be used:
-            sort_by: SortBy::AuthorKey
-            direction: SortDirection::Asc
-            offset: None
-            limit: None
-        '''
-        
-        
-        # Call the (fallible) function before creating any half-baked object instances.
-        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_query_key_exact,
-        _UniffiConverterBytes.lower(key),
-        _UniffiConverterOptionalTypeQueryOptions.lower(opts))
-        return cls._make_instance_(pointer)
-
-
-    @classmethod
-    def key_prefix(cls, prefix: "bytes",opts: "typing.Optional[QueryOptions]"):
-        '''
-        Create a query for all entries with a given key prefix.
-
-        If `opts` is `None`, the default values will be used:
-            sort_by: SortBy::AuthorKey
-            direction: SortDirection::Asc
-            offset: None
-            limit: None
-        '''
-        
-        
-        # Call the (fallible) function before creating any half-baked object instances.
-        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_query_key_prefix,
-        _UniffiConverterBytes.lower(prefix),
-        _UniffiConverterOptionalTypeQueryOptions.lower(opts))
-        return cls._make_instance_(pointer)
-
-
-    @classmethod
-    def single_latest_per_key(cls, opts: "typing.Optional[QueryOptions]"):
-        '''
-        Query only the latest entry for each key, omitting older entries if the entry was written
-        to by multiple authors.
-
-        If `opts` is `None`, the default values will be used:
-            direction: SortDirection::Asc
-            offset: None
-            limit: None
-        '''
-        
-        # Call the (fallible) function before creating any half-baked object instances.
-        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_query_single_latest_per_key,
-        _UniffiConverterOptionalTypeQueryOptions.lower(opts))
-        return cls._make_instance_(pointer)
-
-
-
-    def limit(self, ) -> "typing.Optional[int]":
-        '''Get the limit for this query (max. number of entries to emit).'''
-        return _UniffiConverterOptionalUInt64.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_query_limit,self._pointer,)
-        )
-
-
-
-
-
-
-    def offset(self, ) -> "int":
-        '''Get the offset for this query (number of entries to skip at the beginning).'''
-        return _UniffiConverterUInt64.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_query_offset,self._pointer,)
-        )
-
-
-
-
-
-
-class _UniffiConverterTypeQuery:
-    @classmethod
-    def read(cls, buf):
-        ptr = buf.read_u64()
-        if ptr == 0:
-            raise InternalError("Raw pointer value was null")
-        return cls.lift(ptr)
-
-    @classmethod
-    def write(cls, value, buf):
-        if not isinstance(value, Query):
-            raise TypeError("Expected Query instance, {} found".format(type(value).__name__))
-        buf.write_u64(cls.lower(value))
-
-    @staticmethod
-    def lift(value):
-        return Query._make_instance_(value)
-
-    @staticmethod
-    def lower(value):
-        return value._pointer
-
-
-
-class RangeSpec:
-    '''A chunk range specification as a sequence of chunk offsets'''
-
-    _pointer: ctypes.c_void_p
-
-    def __del__(self):
-        # In case of partial initialization of instances.
-        pointer = getattr(self, "_pointer", None)
-        if pointer is not None:
-            _rust_call(_UniffiLib.uniffi_iroh_fn_free_rangespec, pointer)
-
-    # Used by alternative constructors or any methods which return this type.
-    @classmethod
-    def _make_instance_(cls, pointer):
-        # Lightly yucky way to bypass the usual __init__ logic
-        # and just create a new instance with the required pointer.
-        inst = cls.__new__(cls)
-        inst._pointer = pointer
-        return inst
-
-
-    def is_all(self, ) -> "bool":
-        '''Check if this [`RangeSpec`] selects all chunks in the blob'''
-        return _UniffiConverterBool.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_rangespec_is_all,self._pointer,)
-        )
-
-
-
-
-
-
-    def is_empty(self, ) -> "bool":
-        '''Checks if this [`RangeSpec`] does not select any chunks in the blob'''
-        return _UniffiConverterBool.lift(
-            _rust_call(_UniffiLib.uniffi_iroh_fn_method_rangespec_is_empty,self._pointer,)
-        )
-
-
-
-
-
-
-class _UniffiConverterTypeRangeSpec:
-    @classmethod
-    def read(cls, buf):
-        ptr = buf.read_u64()
-        if ptr == 0:
-            raise InternalError("Raw pointer value was null")
-        return cls.lift(ptr)
-
-    @classmethod
-    def write(cls, value, buf):
-        if not isinstance(value, RangeSpec):
-            raise TypeError("Expected RangeSpec instance, {} found".format(type(value).__name__))
-        buf.write_u64(cls.lower(value))
-
-    @staticmethod
-    def lift(value):
-        return RangeSpec._make_instance_(value)
-
-    @staticmethod
-    def lower(value):
-        return value._pointer
-
-
-
-class SetTagOption:
-    '''An option for commands that allow setting a tag'''
-
-    _pointer: ctypes.c_void_p
-
-    def __del__(self):
-        # In case of partial initialization of instances.
-        pointer = getattr(self, "_pointer", None)
-        if pointer is not None:
-            _rust_call(_UniffiLib.uniffi_iroh_fn_free_settagoption, pointer)
-
-    # Used by alternative constructors or any methods which return this type.
-    @classmethod
-    def _make_instance_(cls, pointer):
-        # Lightly yucky way to bypass the usual __init__ logic
-        # and just create a new instance with the required pointer.
-        inst = cls.__new__(cls)
-        inst._pointer = pointer
-        return inst
-
-    @classmethod
-    def auto(cls, ):
-        '''Indicate you want an automatically generated tag'''
-        # Call the (fallible) function before creating any half-baked object instances.
-        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_settagoption_auto,)
-        return cls._make_instance_(pointer)
-
-
-    @classmethod
-    def named(cls, tag: "bytes"):
-        '''Indicate you want a named tag'''
-        
-        # Call the (fallible) function before creating any half-baked object instances.
-        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_settagoption_named,
-        _UniffiConverterBytes.lower(tag))
-        return cls._make_instance_(pointer)
-
-
-
-class _UniffiConverterTypeSetTagOption:
-    @classmethod
-    def read(cls, buf):
-        ptr = buf.read_u64()
-        if ptr == 0:
-            raise InternalError("Raw pointer value was null")
-        return cls.lift(ptr)
-
-    @classmethod
-    def write(cls, value, buf):
-        if not isinstance(value, SetTagOption):
-            raise TypeError("Expected SetTagOption instance, {} found".format(type(value).__name__))
-        buf.write_u64(cls.lower(value))
-
-    @staticmethod
-    def lift(value):
-        return SetTagOption._make_instance_(value)
-
-    @staticmethod
-    def lower(value):
-        return value._pointer
-
-
-
-class WrapOption:
-    '''Whether to wrap the added data in a collection.'''
-
-    _pointer: ctypes.c_void_p
-
-    def __del__(self):
-        # In case of partial initialization of instances.
-        pointer = getattr(self, "_pointer", None)
-        if pointer is not None:
-            _rust_call(_UniffiLib.uniffi_iroh_fn_free_wrapoption, pointer)
-
-    # Used by alternative constructors or any methods which return this type.
-    @classmethod
-    def _make_instance_(cls, pointer):
-        # Lightly yucky way to bypass the usual __init__ logic
-        # and just create a new instance with the required pointer.
-        inst = cls.__new__(cls)
-        inst._pointer = pointer
-        return inst
-
-    @classmethod
-    def no_wrap(cls, ):
-        '''Indicate you do not wrap the file or directory.'''
-        # Call the (fallible) function before creating any half-baked object instances.
-        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_wrapoption_no_wrap,)
-        return cls._make_instance_(pointer)
-
-
-    @classmethod
-    def wrap(cls, name: "typing.Optional[str]"):
-        '''Indicate you want to wrap the file or directory in a colletion, with an optional name'''
-        
-        # Call the (fallible) function before creating any half-baked object instances.
-        pointer = _rust_call(_UniffiLib.uniffi_iroh_fn_constructor_wrapoption_wrap,
-        _UniffiConverterOptionalString.lower(name))
-        return cls._make_instance_(pointer)
-
-
-
-class _UniffiConverterTypeWrapOption:
-    @classmethod
-    def read(cls, buf):
-        ptr = buf.read_u64()
-        if ptr == 0:
-            raise InternalError("Raw pointer value was null")
-        return cls.lift(ptr)
-
-    @classmethod
-    def write(cls, value, buf):
-        if not isinstance(value, WrapOption):
-            raise TypeError("Expected WrapOption instance, {} found".format(type(value).__name__))
-        buf.write_u64(cls.lower(value))
-
-    @staticmethod
-    def lift(value):
-        return WrapOption._make_instance_(value)
-
-    @staticmethod
-    def lower(value):
-        return value._pointer
-
-
-class AddProgressAbort:
-    '''An AddProgress event indicating we got an error and need to abort'''
-
-    error: "str";
-
-    @typing.no_type_check
-    def __init__(self, error: "str"):
-        self.error = error
-        '''The error message'''
-
-    def __str__(self):
-        return "AddProgressAbort(error={})".format(self.error)
-
-    def __eq__(self, other):
-        if self.error != other.error:
-            return False
-        return True
-
-class _UniffiConverterTypeAddProgressAbort(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return AddProgressAbort(
-            error=_UniffiConverterString.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterString.write(value.error, buf)
-
-
-class AddProgressAllDone:
-    '''An AddProgress event indicating we are done with the the whole operation'''
-
-    hash: "Hash";format: "BlobFormat";tag: "bytes";
-
-    @typing.no_type_check
-    def __init__(self, hash: "Hash", format: "BlobFormat", tag: "bytes"):
-        self.hash = hash
-        '''The hash of the created data.'''
-        self.format = format
-        '''The format of the added data.'''
-        self.tag = tag
-        '''The tag of the added data.'''
-
-    def __str__(self):
-        return "AddProgressAllDone(hash={}, format={}, tag={})".format(self.hash, self.format, self.tag)
-
-    def __eq__(self, other):
-        if self.hash != other.hash:
-            return False
-        if self.format != other.format:
-            return False
-        if self.tag != other.tag:
-            return False
-        return True
-
-class _UniffiConverterTypeAddProgressAllDone(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return AddProgressAllDone(
-            hash=_UniffiConverterTypeHash.read(buf),
-            format=_UniffiConverterTypeBlobFormat.read(buf),
-            tag=_UniffiConverterBytes.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterTypeHash.write(value.hash, buf)
-        _UniffiConverterTypeBlobFormat.write(value.format, buf)
-        _UniffiConverterBytes.write(value.tag, buf)
-
-
-class AddProgressDone:
-    '''An AddProgress event indicated we are done with `id` and now have a hash `hash`'''
-
-    id: "int";hash: "Hash";
-
-    @typing.no_type_check
-    def __init__(self, id: "int", hash: "Hash"):
-        self.id = id
-        '''The unique id of the entry.'''
-        self.hash = hash
-        '''The hash of the entry.'''
-
-    def __str__(self):
-        return "AddProgressDone(id={}, hash={})".format(self.id, self.hash)
-
-    def __eq__(self, other):
-        if self.id != other.id:
-            return False
-        if self.hash != other.hash:
-            return False
-        return True
-
-class _UniffiConverterTypeAddProgressDone(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return AddProgressDone(
-            id=_UniffiConverterUInt64.read(buf),
-            hash=_UniffiConverterTypeHash.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterUInt64.write(value.id, buf)
-        _UniffiConverterTypeHash.write(value.hash, buf)
-
-
-class AddProgressFound:
-    '''An AddProgress event indicating an item was found with name `name`, that can be referred to by `id`'''
-
-    id: "int";name: "str";size: "int";
-
-    @typing.no_type_check
-    def __init__(self, id: "int", name: "str", size: "int"):
-        self.id = id
-        '''A new unique id for this entry.'''
-        self.name = name
-        '''The name of the entry.'''
-        self.size = size
-        '''The size of the entry in bytes.'''
-
-    def __str__(self):
-        return "AddProgressFound(id={}, name={}, size={})".format(self.id, self.name, self.size)
-
-    def __eq__(self, other):
-        if self.id != other.id:
-            return False
-        if self.name != other.name:
-            return False
-        if self.size != other.size:
-            return False
-        return True
-
-class _UniffiConverterTypeAddProgressFound(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return AddProgressFound(
-            id=_UniffiConverterUInt64.read(buf),
-            name=_UniffiConverterString.read(buf),
-            size=_UniffiConverterUInt64.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterUInt64.write(value.id, buf)
-        _UniffiConverterString.write(value.name, buf)
-        _UniffiConverterUInt64.write(value.size, buf)
-
-
-class AddProgressProgress:
-    '''An AddProgress event indicating we got progress ingesting item `id`.'''
-
-    id: "int";offset: "int";
-
-    @typing.no_type_check
-    def __init__(self, id: "int", offset: "int"):
-        self.id = id
-        '''The unique id of the entry.'''
-        self.offset = offset
-        '''The offset of the progress, in bytes.'''
-
-    def __str__(self):
-        return "AddProgressProgress(id={}, offset={})".format(self.id, self.offset)
-
-    def __eq__(self, other):
-        if self.id != other.id:
-            return False
-        if self.offset != other.offset:
-            return False
-        return True
-
-class _UniffiConverterTypeAddProgressProgress(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return AddProgressProgress(
-            id=_UniffiConverterUInt64.read(buf),
-            offset=_UniffiConverterUInt64.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterUInt64.write(value.id, buf)
-        _UniffiConverterUInt64.write(value.offset, buf)
-
-
-class BlobAddOutcome:
-    '''Outcome of a blob add operation.'''
-
-    hash: "Hash";format: "BlobFormat";size: "int";tag: "bytes";
-
-    @typing.no_type_check
-    def __init__(self, hash: "Hash", format: "BlobFormat", size: "int", tag: "bytes"):
-        self.hash = hash
-        '''The hash of the blob'''
-        self.format = format
-        '''The format the blob'''
-        self.size = size
-        '''The size of the blob'''
-        self.tag = tag
-        '''The tag of the blob'''
-
-    def __str__(self):
-        return "BlobAddOutcome(hash={}, format={}, size={}, tag={})".format(self.hash, self.format, self.size, self.tag)
-
-    def __eq__(self, other):
-        if self.hash != other.hash:
-            return False
-        if self.format != other.format:
-            return False
-        if self.size != other.size:
-            return False
-        if self.tag != other.tag:
-            return False
-        return True
-
-class _UniffiConverterTypeBlobAddOutcome(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return BlobAddOutcome(
-            hash=_UniffiConverterTypeHash.read(buf),
-            format=_UniffiConverterTypeBlobFormat.read(buf),
-            size=_UniffiConverterUInt64.read(buf),
-            tag=_UniffiConverterBytes.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterTypeHash.write(value.hash, buf)
-        _UniffiConverterTypeBlobFormat.write(value.format, buf)
-        _UniffiConverterUInt64.write(value.size, buf)
-        _UniffiConverterBytes.write(value.tag, buf)
-
-
-class BlobListCollectionsResponse:
-    '''A response to a list collections request'''
-
-    tag: "bytes";hash: "Hash";total_blobs_count: "typing.Optional[int]";total_blobs_size: "typing.Optional[int]";
-
-    @typing.no_type_check
-    def __init__(self, tag: "bytes", hash: "Hash", total_blobs_count: "typing.Optional[int]", total_blobs_size: "typing.Optional[int]"):
-        self.tag = tag
-        '''Tag of the collection'''
-        self.hash = hash
-        '''Hash of the collection'''
-        self.total_blobs_count = total_blobs_count
-        '''
-        Number of children in the collection
-
-        This is an optional field, because the data is not always available.
-        '''
-        self.total_blobs_size = total_blobs_size
-        '''
-        Total size of the raw data referred to by all links
-
-        This is an optional field, because the data is not always available.
-        '''
-
-    def __str__(self):
-        return "BlobListCollectionsResponse(tag={}, hash={}, total_blobs_count={}, total_blobs_size={})".format(self.tag, self.hash, self.total_blobs_count, self.total_blobs_size)
-
-    def __eq__(self, other):
-        if self.tag != other.tag:
-            return False
-        if self.hash != other.hash:
-            return False
-        if self.total_blobs_count != other.total_blobs_count:
-            return False
-        if self.total_blobs_size != other.total_blobs_size:
-            return False
-        return True
-
-class _UniffiConverterTypeBlobListCollectionsResponse(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return BlobListCollectionsResponse(
-            tag=_UniffiConverterBytes.read(buf),
-            hash=_UniffiConverterTypeHash.read(buf),
-            total_blobs_count=_UniffiConverterOptionalUInt64.read(buf),
-            total_blobs_size=_UniffiConverterOptionalUInt64.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterBytes.write(value.tag, buf)
-        _UniffiConverterTypeHash.write(value.hash, buf)
-        _UniffiConverterOptionalUInt64.write(value.total_blobs_count, buf)
-        _UniffiConverterOptionalUInt64.write(value.total_blobs_size, buf)
-
-
-class BlobListIncompleteResponse:
-    '''A response to a list blobs request'''
-
-    size: "int";expected_size: "int";hash: "Hash";
-
-    @typing.no_type_check
-    def __init__(self, size: "int", expected_size: "int", hash: "Hash"):
-        self.size = size
-        '''The size we got'''
-        self.expected_size = expected_size
-        '''The size we expect'''
-        self.hash = hash
-        '''The hash of the blob'''
-
-    def __str__(self):
-        return "BlobListIncompleteResponse(size={}, expected_size={}, hash={})".format(self.size, self.expected_size, self.hash)
-
-    def __eq__(self, other):
-        if self.size != other.size:
-            return False
-        if self.expected_size != other.expected_size:
-            return False
-        if self.hash != other.hash:
-            return False
-        return True
-
-class _UniffiConverterTypeBlobListIncompleteResponse(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return BlobListIncompleteResponse(
-            size=_UniffiConverterUInt64.read(buf),
-            expected_size=_UniffiConverterUInt64.read(buf),
-            hash=_UniffiConverterTypeHash.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterUInt64.write(value.size, buf)
-        _UniffiConverterUInt64.write(value.expected_size, buf)
-        _UniffiConverterTypeHash.write(value.hash, buf)
-
-
-class BlobListResponse:
-    '''A response to a list blobs request'''
-
-    path: "str";hash: "Hash";size: "int";
-
-    @typing.no_type_check
-    def __init__(self, path: "str", hash: "Hash", size: "int"):
-        self.path = path
-        '''Location of the blob'''
-        self.hash = hash
-        '''The hash of the blob'''
-        self.size = size
-        '''The size of the blob'''
-
-    def __str__(self):
-        return "BlobListResponse(path={}, hash={}, size={})".format(self.path, self.hash, self.size)
-
-    def __eq__(self, other):
-        if self.path != other.path:
-            return False
-        if self.hash != other.hash:
-            return False
-        if self.size != other.size:
-            return False
-        return True
-
-class _UniffiConverterTypeBlobListResponse(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return BlobListResponse(
-            path=_UniffiConverterString.read(buf),
-            hash=_UniffiConverterTypeHash.read(buf),
-            size=_UniffiConverterUInt64.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterString.write(value.path, buf)
-        _UniffiConverterTypeHash.write(value.hash, buf)
-        _UniffiConverterUInt64.write(value.size, buf)
-
-
 class ConnectionInfo:
-    '''Information about a connection'''
 
-    node_id: "PublicKey";relay_url: "typing.Optional[str]";addrs: "typing.List[DirectAddrInfo]";conn_type: "ConnectionType";latency: "typing.Optional[Duration]";last_used: "typing.Optional[Duration]";
-
-    @typing.no_type_check
-    def __init__(self, node_id: "PublicKey", relay_url: "typing.Optional[str]", addrs: "typing.List[DirectAddrInfo]", conn_type: "ConnectionType", latency: "typing.Optional[Duration]", last_used: "typing.Optional[Duration]"):
-        self.node_id = node_id
-        '''The node identifier of the endpoint. Also a public key.'''
-        self.relay_url = relay_url
-        '''Relay url, if available.'''
+    def __init__(self, id, public_key, derp_region, addrs, latencies, conn_type, latency):
+        self.id = id
+        self.public_key = public_key
+        self.derp_region = derp_region
         self.addrs = addrs
-        '''
-        List of addresses at which this node might be reachable, plus any latency information we
-        have about that address and the last time the address was used.
-        '''
+        self.latencies = latencies
         self.conn_type = conn_type
-        '''The type of connection we have to the peer, either direct or over relay.'''
         self.latency = latency
-        '''The latency of the `conn_type`.'''
-        self.last_used = last_used
-        '''Duration since the last time this peer was used.'''
 
     def __str__(self):
-        return "ConnectionInfo(node_id={}, relay_url={}, addrs={}, conn_type={}, latency={}, last_used={})".format(self.node_id, self.relay_url, self.addrs, self.conn_type, self.latency, self.last_used)
+        return "ConnectionInfo(id={}, public_key={}, derp_region={}, addrs={}, latencies={}, conn_type={}, latency={})".format(self.id, self.public_key, self.derp_region, self.addrs, self.latencies, self.conn_type, self.latency)
 
     def __eq__(self, other):
-        if self.node_id != other.node_id:
+        if self.id != other.id:
+            return False
+        if self.public_key != other.public_key:
             return False
-        if self.relay_url != other.relay_url:
+        if self.derp_region != other.derp_region:
             return False
         if self.addrs != other.addrs:
             return False
+        if self.latencies != other.latencies:
+            return False
         if self.conn_type != other.conn_type:
             return False
         if self.latency != other.latency:
             return False
-        if self.last_used != other.last_used:
-            return False
         return True
 
-class _UniffiConverterTypeConnectionInfo(_UniffiConverterRustBuffer):
+class FfiConverterTypeConnectionInfo(FfiConverterRustBuffer):
     @staticmethod
     def read(buf):
         return ConnectionInfo(
-            node_id=_UniffiConverterTypePublicKey.read(buf),
-            relay_url=_UniffiConverterOptionalString.read(buf),
-            addrs=_UniffiConverterSequenceTypeDirectAddrInfo.read(buf),
-            conn_type=_UniffiConverterTypeConnectionType.read(buf),
-            latency=_UniffiConverterOptionalDuration.read(buf),
-            last_used=_UniffiConverterOptionalDuration.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterTypePublicKey.write(value.node_id, buf)
-        _UniffiConverterOptionalString.write(value.relay_url, buf)
-        _UniffiConverterSequenceTypeDirectAddrInfo.write(value.addrs, buf)
-        _UniffiConverterTypeConnectionType.write(value.conn_type, buf)
-        _UniffiConverterOptionalDuration.write(value.latency, buf)
-        _UniffiConverterOptionalDuration.write(value.last_used, buf)
-
-
-class ConnectionTypeMixed:
-    '''The socket address and url id of the mixed connection'''
-
-    addr: "str";relay_url: "str";
-
-    @typing.no_type_check
-    def __init__(self, addr: "str", relay_url: "str"):
-        self.addr = addr
-        '''Address of the node'''
-        self.relay_url = relay_url
-        '''Url of the relay node to which the node is connected'''
-
-    def __str__(self):
-        return "ConnectionTypeMixed(addr={}, relay_url={})".format(self.addr, self.relay_url)
-
-    def __eq__(self, other):
-        if self.addr != other.addr:
-            return False
-        if self.relay_url != other.relay_url:
-            return False
-        return True
-
-class _UniffiConverterTypeConnectionTypeMixed(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return ConnectionTypeMixed(
-            addr=_UniffiConverterString.read(buf),
-            relay_url=_UniffiConverterString.read(buf),
+            id=FfiConverterUInt64.read(buf),
+            public_key=FfiConverterTypePublicKey.read(buf),
+            derp_region=FfiConverterOptionalUInt16.read(buf),
+            addrs=FfiConverterSequenceTypeSocketAddr.read(buf),
+            latencies=FfiConverterSequenceOptionalDouble.read(buf),
+            conn_type=FfiConverterTypeConnectionType.read(buf),
+            latency=FfiConverterOptionalDouble.read(buf),
         )
 
     @staticmethod
     def write(value, buf):
-        _UniffiConverterString.write(value.addr, buf)
-        _UniffiConverterString.write(value.relay_url, buf)
+        FfiConverterUInt64.write(value.id, buf)
+        FfiConverterTypePublicKey.write(value.public_key, buf)
+        FfiConverterOptionalUInt16.write(value.derp_region, buf)
+        FfiConverterSequenceTypeSocketAddr.write(value.addrs, buf)
+        FfiConverterSequenceOptionalDouble.write(value.latencies, buf)
+        FfiConverterTypeConnectionType.write(value.conn_type, buf)
+        FfiConverterOptionalDouble.write(value.latency, buf)
 
 
 class CounterStats:
-    '''Stats counter'''
-
-    value: "int";description: "str";
 
-    @typing.no_type_check
-    def __init__(self, value: "int", description: "str"):
+    def __init__(self, value, description):
         self.value = value
-        '''The counter value'''
         self.description = description
-        '''The counter description'''
 
     def __str__(self):
         return "CounterStats(value={}, description={})".format(self.value, self.description)
 
     def __eq__(self, other):
         if self.value != other.value:
             return False
         if self.description != other.description:
             return False
         return True
 
-class _UniffiConverterTypeCounterStats(_UniffiConverterRustBuffer):
+class FfiConverterTypeCounterStats(FfiConverterRustBuffer):
     @staticmethod
     def read(buf):
         return CounterStats(
-            value=_UniffiConverterUInt32.read(buf),
-            description=_UniffiConverterString.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterUInt32.write(value.value, buf)
-        _UniffiConverterString.write(value.description, buf)
-
-
-class DocExportProgressAbort:
-    '''A DocExportProgress event indicating we got an error and need to abort'''
-
-    error: "str";
-
-    @typing.no_type_check
-    def __init__(self, error: "str"):
-        self.error = error
-        '''The error message'''
-
-    def __str__(self):
-        return "DocExportProgressAbort(error={})".format(self.error)
-
-    def __eq__(self, other):
-        if self.error != other.error:
-            return False
-        return True
-
-class _UniffiConverterTypeDocExportProgressAbort(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return DocExportProgressAbort(
-            error=_UniffiConverterString.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterString.write(value.error, buf)
-
-
-class DocExportProgressFound:
-    '''A DocExportProgress event indicating a file was found with name `name`, from now on referred to via `id`'''
-
-    id: "int";hash: "Hash";size: "int";outpath: "str";
-
-    @typing.no_type_check
-    def __init__(self, id: "int", hash: "Hash", size: "int", outpath: "str"):
-        self.id = id
-        '''A new unique id for this entry.'''
-        self.hash = hash
-        '''The hash of the entry.'''
-        self.size = size
-        '''The size of the entry in bytes.'''
-        self.outpath = outpath
-        '''The path where we are writing the entry'''
-
-    def __str__(self):
-        return "DocExportProgressFound(id={}, hash={}, size={}, outpath={})".format(self.id, self.hash, self.size, self.outpath)
-
-    def __eq__(self, other):
-        if self.id != other.id:
-            return False
-        if self.hash != other.hash:
-            return False
-        if self.size != other.size:
-            return False
-        if self.outpath != other.outpath:
-            return False
-        return True
-
-class _UniffiConverterTypeDocExportProgressFound(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return DocExportProgressFound(
-            id=_UniffiConverterUInt64.read(buf),
-            hash=_UniffiConverterTypeHash.read(buf),
-            size=_UniffiConverterUInt64.read(buf),
-            outpath=_UniffiConverterString.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterUInt64.write(value.id, buf)
-        _UniffiConverterTypeHash.write(value.hash, buf)
-        _UniffiConverterUInt64.write(value.size, buf)
-        _UniffiConverterString.write(value.outpath, buf)
-
-
-class DocExportProgressProgress:
-    '''A DocExportProgress event indicating we've made progress exporting item `id`.'''
-
-    id: "int";offset: "int";
-
-    @typing.no_type_check
-    def __init__(self, id: "int", offset: "int"):
-        self.id = id
-        '''The unique id of the entry.'''
-        self.offset = offset
-        '''The offset of the progress, in bytes.'''
-
-    def __str__(self):
-        return "DocExportProgressProgress(id={}, offset={})".format(self.id, self.offset)
-
-    def __eq__(self, other):
-        if self.id != other.id:
-            return False
-        if self.offset != other.offset:
-            return False
-        return True
-
-class _UniffiConverterTypeDocExportProgressProgress(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return DocExportProgressProgress(
-            id=_UniffiConverterUInt64.read(buf),
-            offset=_UniffiConverterUInt64.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterUInt64.write(value.id, buf)
-        _UniffiConverterUInt64.write(value.offset, buf)
-
-
-class DocImportProgressAbort:
-    '''A DocImportProgress event indicating we got an error and need to abort'''
-
-    error: "str";
-
-    @typing.no_type_check
-    def __init__(self, error: "str"):
-        self.error = error
-        '''The error message'''
-
-    def __str__(self):
-        return "DocImportProgressAbort(error={})".format(self.error)
-
-    def __eq__(self, other):
-        if self.error != other.error:
-            return False
-        return True
-
-class _UniffiConverterTypeDocImportProgressAbort(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return DocImportProgressAbort(
-            error=_UniffiConverterString.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterString.write(value.error, buf)
-
-
-class DocImportProgressAllDone:
-    '''A DocImportProgress event indicating we are done setting the entry to the doc'''
-
-    key: "bytes";
-
-    @typing.no_type_check
-    def __init__(self, key: "bytes"):
-        self.key = key
-        '''The key of the entry'''
-
-    def __str__(self):
-        return "DocImportProgressAllDone(key={})".format(self.key)
-
-    def __eq__(self, other):
-        if self.key != other.key:
-            return False
-        return True
-
-class _UniffiConverterTypeDocImportProgressAllDone(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return DocImportProgressAllDone(
-            key=_UniffiConverterBytes.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterBytes.write(value.key, buf)
-
-
-class DocImportProgressFound:
-    '''A DocImportProgress event indicating a file was found with name `name`, from now on referred to via `id`'''
-
-    id: "int";name: "str";size: "int";
-
-    @typing.no_type_check
-    def __init__(self, id: "int", name: "str", size: "int"):
-        self.id = id
-        '''A new unique id for this entry.'''
-        self.name = name
-        '''The name of the entry.'''
-        self.size = size
-        '''The size of the entry in bytes.'''
-
-    def __str__(self):
-        return "DocImportProgressFound(id={}, name={}, size={})".format(self.id, self.name, self.size)
-
-    def __eq__(self, other):
-        if self.id != other.id:
-            return False
-        if self.name != other.name:
-            return False
-        if self.size != other.size:
-            return False
-        return True
-
-class _UniffiConverterTypeDocImportProgressFound(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return DocImportProgressFound(
-            id=_UniffiConverterUInt64.read(buf),
-            name=_UniffiConverterString.read(buf),
-            size=_UniffiConverterUInt64.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterUInt64.write(value.id, buf)
-        _UniffiConverterString.write(value.name, buf)
-        _UniffiConverterUInt64.write(value.size, buf)
-
-
-class DocImportProgressIngestDone:
-    '''A DocImportProgress event indicating we are finished adding `id` to the data store and the hash is `hash`.'''
-
-    id: "int";hash: "Hash";
-
-    @typing.no_type_check
-    def __init__(self, id: "int", hash: "Hash"):
-        self.id = id
-        '''The unique id of the entry.'''
-        self.hash = hash
-        '''The hash of the entry.'''
-
-    def __str__(self):
-        return "DocImportProgressIngestDone(id={}, hash={})".format(self.id, self.hash)
-
-    def __eq__(self, other):
-        if self.id != other.id:
-            return False
-        if self.hash != other.hash:
-            return False
-        return True
-
-class _UniffiConverterTypeDocImportProgressIngestDone(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return DocImportProgressIngestDone(
-            id=_UniffiConverterUInt64.read(buf),
-            hash=_UniffiConverterTypeHash.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterUInt64.write(value.id, buf)
-        _UniffiConverterTypeHash.write(value.hash, buf)
-
-
-class DocImportProgressProgress:
-    '''A DocImportProgress event indicating we've made progress ingesting item `id`.'''
-
-    id: "int";offset: "int";
-
-    @typing.no_type_check
-    def __init__(self, id: "int", offset: "int"):
-        self.id = id
-        '''The unique id of the entry.'''
-        self.offset = offset
-        '''The offset of the progress, in bytes.'''
-
-    def __str__(self):
-        return "DocImportProgressProgress(id={}, offset={})".format(self.id, self.offset)
-
-    def __eq__(self, other):
-        if self.id != other.id:
-            return False
-        if self.offset != other.offset:
-            return False
-        return True
-
-class _UniffiConverterTypeDocImportProgressProgress(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return DocImportProgressProgress(
-            id=_UniffiConverterUInt64.read(buf),
-            offset=_UniffiConverterUInt64.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterUInt64.write(value.id, buf)
-        _UniffiConverterUInt64.write(value.offset, buf)
-
-
-class DownloadProgressAbort:
-    '''A DownloadProgress event indicating we got an error and need to abort'''
-
-    error: "str";
-
-    @typing.no_type_check
-    def __init__(self, error: "str"):
-        self.error = error
-        '''The error message'''
-
-    def __str__(self):
-        return "DownloadProgressAbort(error={})".format(self.error)
-
-    def __eq__(self, other):
-        if self.error != other.error:
-            return False
-        return True
-
-class _UniffiConverterTypeDownloadProgressAbort(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return DownloadProgressAbort(
-            error=_UniffiConverterString.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterString.write(value.error, buf)
-
-
-class DownloadProgressAllDone:
-    '''A DownloadProgress event indicating we are done with the whole operation'''
-
-    bytes_written: "int";bytes_read: "int";elapsed: "Duration";
-
-    @typing.no_type_check
-    def __init__(self, bytes_written: "int", bytes_read: "int", elapsed: "Duration"):
-        self.bytes_written = bytes_written
-        '''The number of bytes written'''
-        self.bytes_read = bytes_read
-        '''The number of bytes read'''
-        self.elapsed = elapsed
-        '''The time it took to transfer the data'''
-
-    def __str__(self):
-        return "DownloadProgressAllDone(bytes_written={}, bytes_read={}, elapsed={})".format(self.bytes_written, self.bytes_read, self.elapsed)
-
-    def __eq__(self, other):
-        if self.bytes_written != other.bytes_written:
-            return False
-        if self.bytes_read != other.bytes_read:
-            return False
-        if self.elapsed != other.elapsed:
-            return False
-        return True
-
-class _UniffiConverterTypeDownloadProgressAllDone(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return DownloadProgressAllDone(
-            bytes_written=_UniffiConverterUInt64.read(buf),
-            bytes_read=_UniffiConverterUInt64.read(buf),
-            elapsed=_UniffiConverterDuration.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterUInt64.write(value.bytes_written, buf)
-        _UniffiConverterUInt64.write(value.bytes_read, buf)
-        _UniffiConverterDuration.write(value.elapsed, buf)
-
-
-class DownloadProgressDone:
-    '''A DownloadProgress event indicated we are done with `id`'''
-
-    id: "int";
-
-    @typing.no_type_check
-    def __init__(self, id: "int"):
-        self.id = id
-        '''The unique id of the entry.'''
-
-    def __str__(self):
-        return "DownloadProgressDone(id={})".format(self.id)
-
-    def __eq__(self, other):
-        if self.id != other.id:
-            return False
-        return True
-
-class _UniffiConverterTypeDownloadProgressDone(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return DownloadProgressDone(
-            id=_UniffiConverterUInt64.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterUInt64.write(value.id, buf)
-
-
-class DownloadProgressFound:
-    '''A DownloadProgress event indicating an item was found with hash `hash`, that can be referred to by `id`'''
-
-    id: "int";child: "int";hash: "Hash";size: "int";
-
-    @typing.no_type_check
-    def __init__(self, id: "int", child: "int", hash: "Hash", size: "int"):
-        self.id = id
-        '''A new unique id for this entry.'''
-        self.child = child
-        '''child offset'''
-        self.hash = hash
-        '''The hash of the entry.'''
-        self.size = size
-        '''The size of the entry in bytes.'''
-
-    def __str__(self):
-        return "DownloadProgressFound(id={}, child={}, hash={}, size={})".format(self.id, self.child, self.hash, self.size)
-
-    def __eq__(self, other):
-        if self.id != other.id:
-            return False
-        if self.child != other.child:
-            return False
-        if self.hash != other.hash:
-            return False
-        if self.size != other.size:
-            return False
-        return True
-
-class _UniffiConverterTypeDownloadProgressFound(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return DownloadProgressFound(
-            id=_UniffiConverterUInt64.read(buf),
-            child=_UniffiConverterUInt64.read(buf),
-            hash=_UniffiConverterTypeHash.read(buf),
-            size=_UniffiConverterUInt64.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterUInt64.write(value.id, buf)
-        _UniffiConverterUInt64.write(value.child, buf)
-        _UniffiConverterTypeHash.write(value.hash, buf)
-        _UniffiConverterUInt64.write(value.size, buf)
-
-
-class DownloadProgressFoundHashSeq:
-    '''A DownloadProgress event indicating an item was found with hash `hash`, that can be referred to by `id`'''
-
-    children: "int";hash: "Hash";
-
-    @typing.no_type_check
-    def __init__(self, children: "int", hash: "Hash"):
-        self.children = children
-        '''Number of children in the collection, if known.'''
-        self.hash = hash
-        '''The hash of the entry.'''
-
-    def __str__(self):
-        return "DownloadProgressFoundHashSeq(children={}, hash={})".format(self.children, self.hash)
-
-    def __eq__(self, other):
-        if self.children != other.children:
-            return False
-        if self.hash != other.hash:
-            return False
-        return True
-
-class _UniffiConverterTypeDownloadProgressFoundHashSeq(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return DownloadProgressFoundHashSeq(
-            children=_UniffiConverterUInt64.read(buf),
-            hash=_UniffiConverterTypeHash.read(buf),
+            value=FfiConverterUInt64.read(buf),
+            description=FfiConverterString.read(buf),
         )
 
     @staticmethod
     def write(value, buf):
-        _UniffiConverterUInt64.write(value.children, buf)
-        _UniffiConverterTypeHash.write(value.hash, buf)
-
-
-class DownloadProgressFoundLocal:
-    '''A DownloadProgress event indicating an entry was found locally'''
-
-    child: "int";hash: "Hash";size: "int";valid_ranges: "RangeSpec";
-
-    @typing.no_type_check
-    def __init__(self, child: "int", hash: "Hash", size: "int", valid_ranges: "RangeSpec"):
-        self.child = child
-        '''child offset'''
-        self.hash = hash
-        '''The hash of the entry.'''
-        self.size = size
-        '''The size of the entry in bytes.'''
-        self.valid_ranges = valid_ranges
-        '''The ranges that are available locally.'''
-
-    def __str__(self):
-        return "DownloadProgressFoundLocal(child={}, hash={}, size={}, valid_ranges={})".format(self.child, self.hash, self.size, self.valid_ranges)
-
-    def __eq__(self, other):
-        if self.child != other.child:
-            return False
-        if self.hash != other.hash:
-            return False
-        if self.size != other.size:
-            return False
-        if self.valid_ranges != other.valid_ranges:
-            return False
-        return True
-
-class _UniffiConverterTypeDownloadProgressFoundLocal(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return DownloadProgressFoundLocal(
-            child=_UniffiConverterUInt64.read(buf),
-            hash=_UniffiConverterTypeHash.read(buf),
-            size=_UniffiConverterUInt64.read(buf),
-            valid_ranges=_UniffiConverterTypeRangeSpec.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterUInt64.write(value.child, buf)
-        _UniffiConverterTypeHash.write(value.hash, buf)
-        _UniffiConverterUInt64.write(value.size, buf)
-        _UniffiConverterTypeRangeSpec.write(value.valid_ranges, buf)
-
-
-class DownloadProgressProgress:
-    '''A DownloadProgress event indicating we got progress ingesting item `id`.'''
-
-    id: "int";offset: "int";
-
-    @typing.no_type_check
-    def __init__(self, id: "int", offset: "int"):
-        self.id = id
-        '''The unique id of the entry.'''
-        self.offset = offset
-        '''The offset of the progress, in bytes.'''
-
-    def __str__(self):
-        return "DownloadProgressProgress(id={}, offset={})".format(self.id, self.offset)
-
-    def __eq__(self, other):
-        if self.id != other.id:
-            return False
-        if self.offset != other.offset:
-            return False
-        return True
-
-class _UniffiConverterTypeDownloadProgressProgress(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return DownloadProgressProgress(
-            id=_UniffiConverterUInt64.read(buf),
-            offset=_UniffiConverterUInt64.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterUInt64.write(value.id, buf)
-        _UniffiConverterUInt64.write(value.offset, buf)
-
-
-class HashAndTag:
-    '''The Hash and associated tag of a newly created collection'''
-
-    hash: "Hash";tag: "bytes";
-
-    @typing.no_type_check
-    def __init__(self, hash: "Hash", tag: "bytes"):
-        self.hash = hash
-        '''The hash of the collection'''
-        self.tag = tag
-        '''The tag of the collection'''
-
-    def __str__(self):
-        return "HashAndTag(hash={}, tag={})".format(self.hash, self.tag)
-
-    def __eq__(self, other):
-        if self.hash != other.hash:
-            return False
-        if self.tag != other.tag:
-            return False
-        return True
-
-class _UniffiConverterTypeHashAndTag(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return HashAndTag(
-            hash=_UniffiConverterTypeHash.read(buf),
-            tag=_UniffiConverterBytes.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterTypeHash.write(value.hash, buf)
-        _UniffiConverterBytes.write(value.tag, buf)
+        FfiConverterUInt64.write(value.value, buf)
+        FfiConverterString.write(value.description, buf)
 
 
 class InsertRemoteEvent:
-    '''Outcome of an InsertRemove event.'''
 
-    _from: "PublicKey";entry: "Entry";content_status: "ContentStatus";
-
-    @typing.no_type_check
-    def __init__(self, _from: "PublicKey", entry: "Entry", content_status: "ContentStatus"):
+    def __init__(self, _from, entry, content_status):
         self._from = _from
-        '''The peer that sent us the entry.'''
         self.entry = entry
-        '''The inserted entry.'''
         self.content_status = content_status
-        '''If the content is available at the local node'''
 
     def __str__(self):
         return "InsertRemoteEvent(_from={}, entry={}, content_status={})".format(self._from, self.entry, self.content_status)
 
     def __eq__(self, other):
         if self._from != other._from:
             return False
         if self.entry != other.entry:
             return False
         if self.content_status != other.content_status:
             return False
         return True
 
-class _UniffiConverterTypeInsertRemoteEvent(_UniffiConverterRustBuffer):
+class FfiConverterTypeInsertRemoteEvent(FfiConverterRustBuffer):
     @staticmethod
     def read(buf):
         return InsertRemoteEvent(
-            _from=_UniffiConverterTypePublicKey.read(buf),
-            entry=_UniffiConverterTypeEntry.read(buf),
-            content_status=_UniffiConverterTypeContentStatus.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterTypePublicKey.write(value._from, buf)
-        _UniffiConverterTypeEntry.write(value.entry, buf)
-        _UniffiConverterTypeContentStatus.write(value.content_status, buf)
-
-
-class LatencyAndControlMsg:
-    '''The latency and type of the control message'''
-
-    latency: "Duration";control_msg: "str";
-
-    @typing.no_type_check
-    def __init__(self, latency: "Duration", control_msg: "str"):
-        self.latency = latency
-        '''The latency of the control message'''
-        self.control_msg = control_msg
-        '''The type of control message, represented as a string'''
-
-    def __str__(self):
-        return "LatencyAndControlMsg(latency={}, control_msg={})".format(self.latency, self.control_msg)
-
-    def __eq__(self, other):
-        if self.latency != other.latency:
-            return False
-        if self.control_msg != other.control_msg:
-            return False
-        return True
-
-class _UniffiConverterTypeLatencyAndControlMsg(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return LatencyAndControlMsg(
-            latency=_UniffiConverterDuration.read(buf),
-            control_msg=_UniffiConverterString.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterDuration.write(value.latency, buf)
-        _UniffiConverterString.write(value.control_msg, buf)
-
-
-class LinkAndName:
-    '''A `Link` includes a name and a hash for a blob in a collection'''
-
-    name: "str";link: "Hash";
-
-    @typing.no_type_check
-    def __init__(self, name: "str", link: "Hash"):
-        self.name = name
-        '''The name associated with this [`Hash`]'''
-        self.link = link
-        '''The [`Hash`] of the blob'''
-
-    def __str__(self):
-        return "LinkAndName(name={}, link={})".format(self.name, self.link)
-
-    def __eq__(self, other):
-        if self.name != other.name:
-            return False
-        if self.link != other.link:
-            return False
-        return True
-
-class _UniffiConverterTypeLinkAndName(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return LinkAndName(
-            name=_UniffiConverterString.read(buf),
-            link=_UniffiConverterTypeHash.read(buf),
+            _from=FfiConverterTypePublicKey.read(buf),
+            entry=FfiConverterTypeEntry.read(buf),
+            content_status=FfiConverterTypeContentStatus.read(buf),
         )
 
     @staticmethod
     def write(value, buf):
-        _UniffiConverterString.write(value.name, buf)
-        _UniffiConverterTypeHash.write(value.link, buf)
-
+        FfiConverterTypePublicKey.write(value._from, buf)
+        FfiConverterTypeEntry.write(value.entry, buf)
+        FfiConverterTypeContentStatus.write(value.content_status, buf)
 
-class ListTagsResponse:
-    '''A response to a list collections request'''
 
-    name: "bytes";format: "BlobFormat";hash: "Hash";
+class LiveStatus:
 
-    @typing.no_type_check
-    def __init__(self, name: "bytes", format: "BlobFormat", hash: "Hash"):
-        self.name = name
-        '''The tag'''
-        self.format = format
-        '''The format of the associated blob'''
-        self.hash = hash
-        '''The hash of the associated blob'''
+    def __init__(self, active, subscriptions):
+        self.active = active
+        self.subscriptions = subscriptions
 
     def __str__(self):
-        return "ListTagsResponse(name={}, format={}, hash={})".format(self.name, self.format, self.hash)
+        return "LiveStatus(active={}, subscriptions={})".format(self.active, self.subscriptions)
 
     def __eq__(self, other):
-        if self.name != other.name:
+        if self.active != other.active:
             return False
-        if self.format != other.format:
-            return False
-        if self.hash != other.hash:
+        if self.subscriptions != other.subscriptions:
             return False
         return True
 
-class _UniffiConverterTypeListTagsResponse(_UniffiConverterRustBuffer):
+class FfiConverterTypeLiveStatus(FfiConverterRustBuffer):
     @staticmethod
     def read(buf):
-        return ListTagsResponse(
-            name=_UniffiConverterBytes.read(buf),
-            format=_UniffiConverterTypeBlobFormat.read(buf),
-            hash=_UniffiConverterTypeHash.read(buf),
+        return LiveStatus(
+            active=FfiConverterBool.read(buf),
+            subscriptions=FfiConverterUInt64.read(buf),
         )
 
     @staticmethod
     def write(value, buf):
-        _UniffiConverterBytes.write(value.name, buf)
-        _UniffiConverterTypeBlobFormat.write(value.format, buf)
-        _UniffiConverterTypeHash.write(value.hash, buf)
-
-
-class NamespaceAndCapability:
-    '''The namespace id and CapabilityKind (read/write) of the doc'''
-
-    namespace: "str";capability: "CapabilityKind";
-
-    @typing.no_type_check
-    def __init__(self, namespace: "str", capability: "CapabilityKind"):
-        self.namespace = namespace
-        '''The namespace id of the doc'''
-        self.capability = capability
-        '''The capability you have for the doc (read/write)'''
-
-    def __str__(self):
-        return "NamespaceAndCapability(namespace={}, capability={})".format(self.namespace, self.capability)
-
-    def __eq__(self, other):
-        if self.namespace != other.namespace:
-            return False
-        if self.capability != other.capability:
-            return False
-        return True
-
-class _UniffiConverterTypeNamespaceAndCapability(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return NamespaceAndCapability(
-            namespace=_UniffiConverterString.read(buf),
-            capability=_UniffiConverterTypeCapabilityKind.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterString.write(value.namespace, buf)
-        _UniffiConverterTypeCapabilityKind.write(value.capability, buf)
-
-
-class NodeOptions:
-    '''Options passed to [`IrohNode.new`]. Controls the behaviour of an iroh node.'''
-
-    gc_interval_millis: "typing.Optional[int]";
-
-    @typing.no_type_check
-    def __init__(self, gc_interval_millis: "typing.Optional[int]"):
-        self.gc_interval_millis = gc_interval_millis
-        '''
-        How frequently the blob store should clean up unreferenced blobs, in milliseconds.
-        Set to 0 to disable gc
-        '''
-
-    def __str__(self):
-        return "NodeOptions(gc_interval_millis={})".format(self.gc_interval_millis)
-
-    def __eq__(self, other):
-        if self.gc_interval_millis != other.gc_interval_millis:
-            return False
-        return True
-
-class _UniffiConverterTypeNodeOptions(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return NodeOptions(
-            gc_interval_millis=_UniffiConverterOptionalUInt64.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterOptionalUInt64.write(value.gc_interval_millis, buf)
-
-
-class OpenState:
-    '''The state for an open replica.'''
-
-    sync: "bool";subscribers: "int";handles: "int";
-
-    @typing.no_type_check
-    def __init__(self, sync: "bool", subscribers: "int", handles: "int"):
-        self.sync = sync
-        '''Whether to accept sync requests for this replica.'''
-        self.subscribers = subscribers
-        '''How many event subscriptions are open'''
-        self.handles = handles
-        '''By how many handles the replica is currently held open'''
-
-    def __str__(self):
-        return "OpenState(sync={}, subscribers={}, handles={})".format(self.sync, self.subscribers, self.handles)
-
-    def __eq__(self, other):
-        if self.sync != other.sync:
-            return False
-        if self.subscribers != other.subscribers:
-            return False
-        if self.handles != other.handles:
-            return False
-        return True
-
-class _UniffiConverterTypeOpenState(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return OpenState(
-            sync=_UniffiConverterBool.read(buf),
-            subscribers=_UniffiConverterUInt64.read(buf),
-            handles=_UniffiConverterUInt64.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterBool.write(value.sync, buf)
-        _UniffiConverterUInt64.write(value.subscribers, buf)
-        _UniffiConverterUInt64.write(value.handles, buf)
-
-
-class QueryOptions:
-    '''Options for sorting and pagination for using [`Query`]s.'''
-
-    sort_by: "SortBy";direction: "SortDirection";offset: "int";limit: "int";
-
-    @typing.no_type_check
-    def __init__(self, sort_by: "SortBy", direction: "SortDirection", offset: "int", limit: "int"):
-        self.sort_by = sort_by
-        '''
-        Sort by author or key first.
-
-        Default is [`SortBy::AuthorKey`], so sorting first by author and then by key.
-        '''
-        self.direction = direction
-        '''
-        Direction by which to sort the entries
-
-        Default is [`SortDirection::Asc`]
-        '''
-        self.offset = offset
-        '''Offset'''
-        self.limit = limit
-        '''
-        Limit to limit the pagination.
-
-        When the limit is 0, the limit does not exist.
-        '''
-
-    def __str__(self):
-        return "QueryOptions(sort_by={}, direction={}, offset={}, limit={})".format(self.sort_by, self.direction, self.offset, self.limit)
-
-    def __eq__(self, other):
-        if self.sort_by != other.sort_by:
-            return False
-        if self.direction != other.direction:
-            return False
-        if self.offset != other.offset:
-            return False
-        if self.limit != other.limit:
-            return False
-        return True
-
-class _UniffiConverterTypeQueryOptions(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        return QueryOptions(
-            sort_by=_UniffiConverterTypeSortBy.read(buf),
-            direction=_UniffiConverterTypeSortDirection.read(buf),
-            offset=_UniffiConverterUInt64.read(buf),
-            limit=_UniffiConverterUInt64.read(buf),
-        )
-
-    @staticmethod
-    def write(value, buf):
-        _UniffiConverterTypeSortBy.write(value.sort_by, buf)
-        _UniffiConverterTypeSortDirection.write(value.direction, buf)
-        _UniffiConverterUInt64.write(value.offset, buf)
-        _UniffiConverterUInt64.write(value.limit, buf)
+        FfiConverterBool.write(value.active, buf)
+        FfiConverterUInt64.write(value.subscriptions, buf)
 
 
 class SyncEvent:
-    '''Outcome of a sync operation'''
 
-    peer: "PublicKey";origin: "Origin";started: "Timestamp";finished: "Timestamp";result: "typing.Optional[str]";
-
-    @typing.no_type_check
-    def __init__(self, peer: "PublicKey", origin: "Origin", started: "Timestamp", finished: "Timestamp", result: "typing.Optional[str]"):
+    def __init__(self, namespace, peer, origin, finished, result):
+        self.namespace = namespace
         self.peer = peer
-        '''Peer we synced with'''
         self.origin = origin
-        '''Origin of the sync exchange'''
-        self.started = started
-        '''Timestamp when the sync finished'''
         self.finished = finished
-        '''Timestamp when the sync started'''
         self.result = result
-        '''Result of the sync operation. `None` if successfull.'''
 
     def __str__(self):
-        return "SyncEvent(peer={}, origin={}, started={}, finished={}, result={})".format(self.peer, self.origin, self.started, self.finished, self.result)
+        return "SyncEvent(namespace={}, peer={}, origin={}, finished={}, result={})".format(self.namespace, self.peer, self.origin, self.finished, self.result)
 
     def __eq__(self, other):
+        if self.namespace != other.namespace:
+            return False
         if self.peer != other.peer:
             return False
         if self.origin != other.origin:
             return False
-        if self.started != other.started:
-            return False
         if self.finished != other.finished:
             return False
         if self.result != other.result:
             return False
         return True
 
-class _UniffiConverterTypeSyncEvent(_UniffiConverterRustBuffer):
+class FfiConverterTypeSyncEvent(FfiConverterRustBuffer):
     @staticmethod
     def read(buf):
         return SyncEvent(
-            peer=_UniffiConverterTypePublicKey.read(buf),
-            origin=_UniffiConverterTypeOrigin.read(buf),
-            started=_UniffiConverterTimestamp.read(buf),
-            finished=_UniffiConverterTimestamp.read(buf),
-            result=_UniffiConverterOptionalString.read(buf),
+            namespace=FfiConverterTypeNamespaceId.read(buf),
+            peer=FfiConverterTypePublicKey.read(buf),
+            origin=FfiConverterTypeOrigin.read(buf),
+            finished=FfiConverterDouble.read(buf),
+            result=FfiConverterOptionalString.read(buf),
         )
 
     @staticmethod
     def write(value, buf):
-        _UniffiConverterTypePublicKey.write(value.peer, buf)
-        _UniffiConverterTypeOrigin.write(value.origin, buf)
-        _UniffiConverterTimestamp.write(value.started, buf)
-        _UniffiConverterTimestamp.write(value.finished, buf)
-        _UniffiConverterOptionalString.write(value.result, buf)
-
-
-
-
-
-class AddProgressType(enum.Enum):
-    '''The different types of AddProgress events'''
-    FOUND = 1
-    '''An item was found with name `name`, from now on referred to via `id`'''
-    PROGRESS = 2
-    '''We got progress ingesting item `id`.'''
-    DONE = 3
-    '''We are done with `id`, and the hash is `hash`.'''
-    ALL_DONE = 4
-    '''We are done with the whole operation.'''
-    ABORT = 5
-    '''
-    We got an error and need to abort.
-
-    This will be the last message in the stream.
-    '''
-    
-
-
-class _UniffiConverterTypeAddProgressType(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        variant = buf.read_i32()
-        if variant == 1:
-            return AddProgressType.FOUND
-        if variant == 2:
-            return AddProgressType.PROGRESS
-        if variant == 3:
-            return AddProgressType.DONE
-        if variant == 4:
-            return AddProgressType.ALL_DONE
-        if variant == 5:
-            return AddProgressType.ABORT
-        raise InternalError("Raw enum value doesn't match any cases")
-
-    def write(value, buf):
-        if value == AddProgressType.FOUND:
-            buf.write_i32(1)
-        if value == AddProgressType.PROGRESS:
-            buf.write_i32(2)
-        if value == AddProgressType.DONE:
-            buf.write_i32(3)
-        if value == AddProgressType.ALL_DONE:
-            buf.write_i32(4)
-        if value == AddProgressType.ABORT:
-            buf.write_i32(5)
-
-
-
-
-
-
-
-class BlobExportFormat(enum.Enum):
-    '''The expected format of a hash being exported.'''
-    BLOB = 1
-    '''The hash refers to any blob and will be exported to a single file.'''
-    COLLECTION = 2
-    '''
-    The hash refers to a [`crate::format::collection::Collection`] blob
-    and all children of the collection shall be exported to one file per child.
-
-    If the blob can be parsed as a [`BlobFormat::HashSeq`], and the first child contains
-    collection metadata, all other children of the collection will be exported to
-    a file each, with their collection name treated as a relative path to the export
-    destination path.
-
-    If the blob cannot be parsed as a collection, the operation will fail.
-    '''
-    
-
-
-class _UniffiConverterTypeBlobExportFormat(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        variant = buf.read_i32()
-        if variant == 1:
-            return BlobExportFormat.BLOB
-        if variant == 2:
-            return BlobExportFormat.COLLECTION
-        raise InternalError("Raw enum value doesn't match any cases")
-
-    def write(value, buf):
-        if value == BlobExportFormat.BLOB:
-            buf.write_i32(1)
-        if value == BlobExportFormat.COLLECTION:
-            buf.write_i32(2)
-
-
+        FfiConverterTypeNamespaceId.write(value.namespace, buf)
+        FfiConverterTypePublicKey.write(value.peer, buf)
+        FfiConverterTypeOrigin.write(value.origin, buf)
+        FfiConverterDouble.write(value.finished, buf)
+        FfiConverterOptionalString.write(value.result, buf)
 
 
 
 
 
-class BlobExportMode(enum.Enum):
-    '''
-    The export mode describes how files will be exported.
-
-    This is a hint to the import trait method. For some implementations, this
-    does not make any sense. E.g. an in memory implementation will always have
-    to copy the file into memory. Also, a disk based implementation might choose
-    to copy small files even if the mode is `Reference`.
-    '''
-    COPY = 1
-    '''
-    This mode will copy the file to the target directory.
-
-    This is the safe default because the file can not be accidentally modified
-    after it has been exported.
-    '''
-    TRY_REFERENCE = 2
-    '''
-    This mode will try to move the file to the target directory and then reference it from
-    the database.
-
-    This has a large performance and storage benefit, but it is less safe since
-    the file might be modified in the target directory after it has been exported.
-
-    Stores are allowed to ignore this mode and always copy the file, e.g.
-    if the file is very small or if the store does not support referencing files.
-    '''
-    
-
-
-class _UniffiConverterTypeBlobExportMode(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        variant = buf.read_i32()
-        if variant == 1:
-            return BlobExportMode.COPY
-        if variant == 2:
-            return BlobExportMode.TRY_REFERENCE
-        raise InternalError("Raw enum value doesn't match any cases")
-
-    def write(value, buf):
-        if value == BlobExportMode.COPY:
-            buf.write_i32(1)
-        if value == BlobExportMode.TRY_REFERENCE:
-            buf.write_i32(2)
+class ConnectionType:
+    def __init__(self):
+        raise RuntimeError("ConnectionType cannot be instantiated directly")
 
+    # Each enum variant is a nested class of the enum itself.
+    class DIRECT:
+        def __init__(self,addr):
+            
+            self.addr = addr
+            
 
+        def __str__(self):
+            return "ConnectionType.DIRECT(addr={})".format(self.addr)
 
+        def __eq__(self, other):
+            if not other.is_direct():
+                return False
+            if self.addr != other.addr:
+                return False
+            return True
+    class RELAY:
+        def __init__(self,port):
+            
+            self.port = port
+            
 
+        def __str__(self):
+            return "ConnectionType.RELAY(port={})".format(self.port)
 
+        def __eq__(self, other):
+            if not other.is_relay():
+                return False
+            if self.port != other.port:
+                return False
+            return True
+    class NONE:
+        def __init__(self,):
+            
+            pass
+            
 
+        def __str__(self):
+            return "ConnectionType.NONE()".format()
 
-class BlobFormat(enum.Enum):
-    '''A format identifier'''
-    RAW = 1
-    '''Raw blob'''
-    HASH_SEQ = 2
-    '''A sequence of BLAKE3 hashes'''
+        def __eq__(self, other):
+            if not other.is_none():
+                return False
+            return True
     
 
-
-class _UniffiConverterTypeBlobFormat(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        variant = buf.read_i32()
-        if variant == 1:
-            return BlobFormat.RAW
-        if variant == 2:
-            return BlobFormat.HASH_SEQ
-        raise InternalError("Raw enum value doesn't match any cases")
-
-    def write(value, buf):
-        if value == BlobFormat.RAW:
-            buf.write_i32(1)
-        if value == BlobFormat.HASH_SEQ:
-            buf.write_i32(2)
-
-
-
-
-
-
-
-class CapabilityKind(enum.Enum):
-    '''Kind of capability of the doc.'''
-    WRITE = 1
-    '''A writable doc'''
-    READ = 2
-    '''A readable doc'''
+    # For each variant, we have an `is_NAME` method for easily checking
+    # whether an instance is that variant.
+    def is_direct(self) -> bool:
+        return isinstance(self, ConnectionType.DIRECT)
+    def is_relay(self) -> bool:
+        return isinstance(self, ConnectionType.RELAY)
+    def is_none(self) -> bool:
+        return isinstance(self, ConnectionType.NONE)
     
 
-
-class _UniffiConverterTypeCapabilityKind(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        variant = buf.read_i32()
-        if variant == 1:
-            return CapabilityKind.WRITE
-        if variant == 2:
-            return CapabilityKind.READ
-        raise InternalError("Raw enum value doesn't match any cases")
-
-    def write(value, buf):
-        if value == CapabilityKind.WRITE:
-            buf.write_i32(1)
-        if value == CapabilityKind.READ:
-            buf.write_i32(2)
-
-
-
-
-
+# Now, a little trick - we make each nested variant class be a subclass of the main
+# enum class, so that method calls and instance checks etc will work intuitively.
+# We might be able to do this a little more neatly with a metaclass, but this'll do.
+ConnectionType.DIRECT = type("ConnectionType.DIRECT", (ConnectionType.DIRECT, ConnectionType,), {})  # type: ignore
+ConnectionType.RELAY = type("ConnectionType.RELAY", (ConnectionType.RELAY, ConnectionType,), {})  # type: ignore
+ConnectionType.NONE = type("ConnectionType.NONE", (ConnectionType.NONE, ConnectionType,), {})  # type: ignore
 
 
-class ConnType(enum.Enum):
-    '''The type of the connection'''
-    DIRECT = 1
-    '''Indicates you have a UDP connection.'''
-    RELAY = 2
-    '''Indicates you have a relayed connection.'''
-    MIXED = 3
-    '''Indicates you have an unverified UDP connection, and a relay connection for backup.'''
-    NONE = 4
-    '''Indicates you have no proof of connection.'''
-    
 
 
-class _UniffiConverterTypeConnType(_UniffiConverterRustBuffer):
+class FfiConverterTypeConnectionType(FfiConverterRustBuffer):
     @staticmethod
     def read(buf):
-        variant = buf.read_i32()
+        variant = buf.readI32()
         if variant == 1:
-            return ConnType.DIRECT
+            return ConnectionType.DIRECT(
+                FfiConverterTypeSocketAddr.read(buf),
+            )
         if variant == 2:
-            return ConnType.RELAY
+            return ConnectionType.RELAY(
+                FfiConverterUInt16.read(buf),
+            )
         if variant == 3:
-            return ConnType.MIXED
-        if variant == 4:
-            return ConnType.NONE
+            return ConnectionType.NONE(
+            )
         raise InternalError("Raw enum value doesn't match any cases")
 
     def write(value, buf):
-        if value == ConnType.DIRECT:
-            buf.write_i32(1)
-        if value == ConnType.RELAY:
-            buf.write_i32(2)
-        if value == ConnType.MIXED:
-            buf.write_i32(3)
-        if value == ConnType.NONE:
-            buf.write_i32(4)
-
+        if value.is_direct():
+            buf.writeI32(1)
+            FfiConverterTypeSocketAddr.write(value.addr, buf)
+        if value.is_relay():
+            buf.writeI32(2)
+            FfiConverterUInt16.write(value.port, buf)
+        if value.is_none():
+            buf.writeI32(3)
 
 
 
 
 
 
-class ContentStatus(enum.Enum):
-    '''Whether the content status is available on a node.'''
-    COMPLETE = 1
-    '''The content is completely available.'''
-    INCOMPLETE = 2
-    '''The content is partially available.'''
-    MISSING = 3
-    '''The content is missing.'''
-    
-
-
-class _UniffiConverterTypeContentStatus(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        variant = buf.read_i32()
-        if variant == 1:
-            return ContentStatus.COMPLETE
-        if variant == 2:
-            return ContentStatus.INCOMPLETE
-        if variant == 3:
-            return ContentStatus.MISSING
-        raise InternalError("Raw enum value doesn't match any cases")
-
-    def write(value, buf):
-        if value == ContentStatus.COMPLETE:
-            buf.write_i32(1)
-        if value == ContentStatus.INCOMPLETE:
-            buf.write_i32(2)
-        if value == ContentStatus.MISSING:
-            buf.write_i32(3)
-
+class ContentStatus:
+    def __init__(self):
+        raise RuntimeError("ContentStatus cannot be instantiated directly")
 
+    # Each enum variant is a nested class of the enum itself.
+    class COMPLETE:
+        def __init__(self,):
+            
+            pass
+            
 
+        def __str__(self):
+            return "ContentStatus.COMPLETE()".format()
 
+        def __eq__(self, other):
+            if not other.is_complete():
+                return False
+            return True
+    class INCOMPLETE:
+        def __init__(self,):
+            
+            pass
+            
 
+        def __str__(self):
+            return "ContentStatus.INCOMPLETE()".format()
 
+        def __eq__(self, other):
+            if not other.is_incomplete():
+                return False
+            return True
+    class MISSING:
+        def __init__(self,):
+            
+            pass
+            
 
-class DocExportProgressType(enum.Enum):
-    '''The type of `DocExportProgress` event'''
-    FOUND = 1
-    '''An item was found with name `name`, from now on referred to via `id`'''
-    PROGRESS = 2
-    '''We got progress exporting item `id`.'''
-    DONE = 3
-    '''We are finished writing item `id`.'''
-    ALL_DONE = 4
-    '''We are done writing the entry to the filesystem'''
-    ABORT = 5
-    '''
-    We got an error and need to abort.
+        def __str__(self):
+            return "ContentStatus.MISSING()".format()
 
-    This will be the last message in the stream.
-    '''
+        def __eq__(self, other):
+            if not other.is_missing():
+                return False
+            return True
     
 
-
-class _UniffiConverterTypeDocExportProgressType(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        variant = buf.read_i32()
-        if variant == 1:
-            return DocExportProgressType.FOUND
-        if variant == 2:
-            return DocExportProgressType.PROGRESS
-        if variant == 3:
-            return DocExportProgressType.DONE
-        if variant == 4:
-            return DocExportProgressType.ALL_DONE
-        if variant == 5:
-            return DocExportProgressType.ABORT
-        raise InternalError("Raw enum value doesn't match any cases")
-
-    def write(value, buf):
-        if value == DocExportProgressType.FOUND:
-            buf.write_i32(1)
-        if value == DocExportProgressType.PROGRESS:
-            buf.write_i32(2)
-        if value == DocExportProgressType.DONE:
-            buf.write_i32(3)
-        if value == DocExportProgressType.ALL_DONE:
-            buf.write_i32(4)
-        if value == DocExportProgressType.ABORT:
-            buf.write_i32(5)
-
-
-
-
-
-
-
-class DocImportProgressType(enum.Enum):
-    '''The type of `DocImportProgress` event'''
-    FOUND = 1
-    '''An item was found with name `name`, from now on referred to via `id`'''
-    PROGRESS = 2
-    '''We got progress ingesting item `id`.'''
-    INGEST_DONE = 3
-    '''We are done ingesting `id`, and the hash is `hash`.'''
-    ALL_DONE = 4
-    '''We are done with the whole operation.'''
-    ABORT = 5
-    '''
-    We got an error and need to abort.
-
-    This will be the last message in the stream.
-    '''
+    # For each variant, we have an `is_NAME` method for easily checking
+    # whether an instance is that variant.
+    def is_complete(self) -> bool:
+        return isinstance(self, ContentStatus.COMPLETE)
+    def is_incomplete(self) -> bool:
+        return isinstance(self, ContentStatus.INCOMPLETE)
+    def is_missing(self) -> bool:
+        return isinstance(self, ContentStatus.MISSING)
     
 
+# Now, a little trick - we make each nested variant class be a subclass of the main
+# enum class, so that method calls and instance checks etc will work intuitively.
+# We might be able to do this a little more neatly with a metaclass, but this'll do.
+ContentStatus.COMPLETE = type("ContentStatus.COMPLETE", (ContentStatus.COMPLETE, ContentStatus,), {})  # type: ignore
+ContentStatus.INCOMPLETE = type("ContentStatus.INCOMPLETE", (ContentStatus.INCOMPLETE, ContentStatus,), {})  # type: ignore
+ContentStatus.MISSING = type("ContentStatus.MISSING", (ContentStatus.MISSING, ContentStatus,), {})  # type: ignore
 
-class _UniffiConverterTypeDocImportProgressType(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        variant = buf.read_i32()
-        if variant == 1:
-            return DocImportProgressType.FOUND
-        if variant == 2:
-            return DocImportProgressType.PROGRESS
-        if variant == 3:
-            return DocImportProgressType.INGEST_DONE
-        if variant == 4:
-            return DocImportProgressType.ALL_DONE
-        if variant == 5:
-            return DocImportProgressType.ABORT
-        raise InternalError("Raw enum value doesn't match any cases")
-
-    def write(value, buf):
-        if value == DocImportProgressType.FOUND:
-            buf.write_i32(1)
-        if value == DocImportProgressType.PROGRESS:
-            buf.write_i32(2)
-        if value == DocImportProgressType.INGEST_DONE:
-            buf.write_i32(3)
-        if value == DocImportProgressType.ALL_DONE:
-            buf.write_i32(4)
-        if value == DocImportProgressType.ABORT:
-            buf.write_i32(5)
-
-
-
-
-
-
-
-class DownloadProgressType(enum.Enum):
-    '''The kinds of progress events that can occur in a `DownloadProgress`'''
-    FOUND_LOCAL = 1
-    '''Data was found locally'''
-    CONNECTED = 2
-    '''A new connection was established.'''
-    FOUND = 3
-    '''An item was found with hash `hash`, from now on referred to via `id`'''
-    FOUND_HASH_SEQ = 4
-    '''An item was found with hash `hash`, from now on referred to via `id`'''
-    PROGRESS = 5
-    '''We got progress ingesting item `id`.'''
-    DONE = 6
-    '''We are done with `id`, and the hash is `hash`.'''
-    ALL_DONE = 7
-    '''We are done with the whole operation.'''
-    ABORT = 8
-    '''
-    We got an error and need to abort.
 
-    This will be the last message in the stream.
-    '''
-    
 
 
-class _UniffiConverterTypeDownloadProgressType(_UniffiConverterRustBuffer):
+class FfiConverterTypeContentStatus(FfiConverterRustBuffer):
     @staticmethod
     def read(buf):
-        variant = buf.read_i32()
+        variant = buf.readI32()
         if variant == 1:
-            return DownloadProgressType.FOUND_LOCAL
+            return ContentStatus.COMPLETE(
+            )
         if variant == 2:
-            return DownloadProgressType.CONNECTED
+            return ContentStatus.INCOMPLETE(
+            )
         if variant == 3:
-            return DownloadProgressType.FOUND
-        if variant == 4:
-            return DownloadProgressType.FOUND_HASH_SEQ
-        if variant == 5:
-            return DownloadProgressType.PROGRESS
-        if variant == 6:
-            return DownloadProgressType.DONE
-        if variant == 7:
-            return DownloadProgressType.ALL_DONE
-        if variant == 8:
-            return DownloadProgressType.ABORT
+            return ContentStatus.MISSING(
+            )
         raise InternalError("Raw enum value doesn't match any cases")
 
     def write(value, buf):
-        if value == DownloadProgressType.FOUND_LOCAL:
-            buf.write_i32(1)
-        if value == DownloadProgressType.CONNECTED:
-            buf.write_i32(2)
-        if value == DownloadProgressType.FOUND:
-            buf.write_i32(3)
-        if value == DownloadProgressType.FOUND_HASH_SEQ:
-            buf.write_i32(4)
-        if value == DownloadProgressType.PROGRESS:
-            buf.write_i32(5)
-        if value == DownloadProgressType.DONE:
-            buf.write_i32(6)
-        if value == DownloadProgressType.ALL_DONE:
-            buf.write_i32(7)
-        if value == DownloadProgressType.ABORT:
-            buf.write_i32(8)
-
+        if value.is_complete():
+            buf.writeI32(1)
+        if value.is_incomplete():
+            buf.writeI32(2)
+        if value.is_missing():
+            buf.writeI32(3)
 
 
 
 # IrohError
 # We want to define each variant as a nested class that's also a subclass,
 # which is tricky in Python.  To accomplish this we're going to create each
 # class separately, then manually add the child classes to the base class's
 # __dict__.  All of this happens in dummy class to avoid polluting the module
 # namespace.
 class IrohError(Exception):
-    '''An iroh error. Each IrohError contains a string description.'''
     pass
 
-_UniffiTempIrohError = IrohError
+UniFFITempIrohError = IrohError
 
 class IrohError:  # type: ignore
-    class Runtime(_UniffiTempIrohError):
-
+    class Runtime(UniFFITempIrohError):
         def __init__(self, description):
             super().__init__(", ".join([
                 "description={!r}".format(description),
             ]))
             self.description = description
         def __repr__(self):
             return "IrohError.Runtime({})".format(str(self))
-    _UniffiTempIrohError.Runtime = Runtime # type: ignore
-    class NodeCreate(_UniffiTempIrohError):
-
+    UniFFITempIrohError.Runtime = Runtime  # type: ignore
+    class NodeCreate(UniFFITempIrohError):
         def __init__(self, description):
             super().__init__(", ".join([
                 "description={!r}".format(description),
             ]))
             self.description = description
         def __repr__(self):
             return "IrohError.NodeCreate({})".format(str(self))
-    _UniffiTempIrohError.NodeCreate = NodeCreate # type: ignore
-    class Doc(_UniffiTempIrohError):
-
+    UniFFITempIrohError.NodeCreate = NodeCreate  # type: ignore
+    class Doc(UniFFITempIrohError):
         def __init__(self, description):
             super().__init__(", ".join([
                 "description={!r}".format(description),
             ]))
             self.description = description
         def __repr__(self):
             return "IrohError.Doc({})".format(str(self))
-    _UniffiTempIrohError.Doc = Doc # type: ignore
-    class Author(_UniffiTempIrohError):
-
+    UniFFITempIrohError.Doc = Doc  # type: ignore
+    class Author(UniFFITempIrohError):
         def __init__(self, description):
             super().__init__(", ".join([
                 "description={!r}".format(description),
             ]))
             self.description = description
         def __repr__(self):
             return "IrohError.Author({})".format(str(self))
-    _UniffiTempIrohError.Author = Author # type: ignore
-    class Namespace(_UniffiTempIrohError):
-
-        def __init__(self, description):
-            super().__init__(", ".join([
-                "description={!r}".format(description),
-            ]))
-            self.description = description
-        def __repr__(self):
-            return "IrohError.Namespace({})".format(str(self))
-    _UniffiTempIrohError.Namespace = Namespace # type: ignore
-    class DocTicket(_UniffiTempIrohError):
-
+    UniFFITempIrohError.Author = Author  # type: ignore
+    class DocTicket(UniFFITempIrohError):
         def __init__(self, description):
             super().__init__(", ".join([
                 "description={!r}".format(description),
             ]))
             self.description = description
         def __repr__(self):
             return "IrohError.DocTicket({})".format(str(self))
-    _UniffiTempIrohError.DocTicket = DocTicket # type: ignore
-    class BlobTicket(_UniffiTempIrohError):
-
-        def __init__(self, description):
-            super().__init__(", ".join([
-                "description={!r}".format(description),
-            ]))
-            self.description = description
-        def __repr__(self):
-            return "IrohError.BlobTicket({})".format(str(self))
-    _UniffiTempIrohError.BlobTicket = BlobTicket # type: ignore
-    class Uniffi(_UniffiTempIrohError):
-
+    UniFFITempIrohError.DocTicket = DocTicket  # type: ignore
+    class Uniffi(UniFFITempIrohError):
         def __init__(self, description):
             super().__init__(", ".join([
                 "description={!r}".format(description),
             ]))
             self.description = description
         def __repr__(self):
             return "IrohError.Uniffi({})".format(str(self))
-    _UniffiTempIrohError.Uniffi = Uniffi # type: ignore
-    class Connection(_UniffiTempIrohError):
-
+    UniFFITempIrohError.Uniffi = Uniffi  # type: ignore
+    class Connection(UniFFITempIrohError):
         def __init__(self, description):
             super().__init__(", ".join([
                 "description={!r}".format(description),
             ]))
             self.description = description
         def __repr__(self):
             return "IrohError.Connection({})".format(str(self))
-    _UniffiTempIrohError.Connection = Connection # type: ignore
-    class Blobs(_UniffiTempIrohError):
-
-        def __init__(self, description):
-            super().__init__(", ".join([
-                "description={!r}".format(description),
-            ]))
-            self.description = description
-        def __repr__(self):
-            return "IrohError.Blobs({})".format(str(self))
-    _UniffiTempIrohError.Blobs = Blobs # type: ignore
-    class Collection(_UniffiTempIrohError):
-
-        def __init__(self, description):
-            super().__init__(", ".join([
-                "description={!r}".format(description),
-            ]))
-            self.description = description
-        def __repr__(self):
-            return "IrohError.Collection({})".format(str(self))
-    _UniffiTempIrohError.Collection = Collection # type: ignore
-    class Ipv4Addr(_UniffiTempIrohError):
-
-        def __init__(self, description):
-            super().__init__(", ".join([
-                "description={!r}".format(description),
-            ]))
-            self.description = description
-        def __repr__(self):
-            return "IrohError.Ipv4Addr({})".format(str(self))
-    _UniffiTempIrohError.Ipv4Addr = Ipv4Addr # type: ignore
-    class Ipv6Addr(_UniffiTempIrohError):
-
-        def __init__(self, description):
-            super().__init__(", ".join([
-                "description={!r}".format(description),
-            ]))
-            self.description = description
-        def __repr__(self):
-            return "IrohError.Ipv6Addr({})".format(str(self))
-    _UniffiTempIrohError.Ipv6Addr = Ipv6Addr # type: ignore
-    class SocketAddr(_UniffiTempIrohError):
-
-        def __init__(self, description):
-            super().__init__(", ".join([
-                "description={!r}".format(description),
-            ]))
-            self.description = description
-        def __repr__(self):
-            return "IrohError.SocketAddr({})".format(str(self))
-    _UniffiTempIrohError.SocketAddr = SocketAddr # type: ignore
-    class PublicKey(_UniffiTempIrohError):
-
-        def __init__(self, description):
-            super().__init__(", ".join([
-                "description={!r}".format(description),
-            ]))
-            self.description = description
-        def __repr__(self):
-            return "IrohError.PublicKey({})".format(str(self))
-    _UniffiTempIrohError.PublicKey = PublicKey # type: ignore
-    class NodeAddr(_UniffiTempIrohError):
-
+    UniFFITempIrohError.Connection = Connection  # type: ignore
+    class Blob(UniFFITempIrohError):
         def __init__(self, description):
             super().__init__(", ".join([
                 "description={!r}".format(description),
             ]))
             self.description = description
         def __repr__(self):
-            return "IrohError.NodeAddr({})".format(str(self))
-    _UniffiTempIrohError.NodeAddr = NodeAddr # type: ignore
-    class Hash(_UniffiTempIrohError):
+            return "IrohError.Blob({})".format(str(self))
+    UniFFITempIrohError.Blob = Blob  # type: ignore
 
-        def __init__(self, description):
-            super().__init__(", ".join([
-                "description={!r}".format(description),
-            ]))
-            self.description = description
-        def __repr__(self):
-            return "IrohError.Hash({})".format(str(self))
-    _UniffiTempIrohError.Hash = Hash # type: ignore
-    class FsUtil(_UniffiTempIrohError):
+IrohError = UniFFITempIrohError  # type: ignore
+del UniFFITempIrohError
 
-        def __init__(self, description):
-            super().__init__(", ".join([
-                "description={!r}".format(description),
-            ]))
-            self.description = description
-        def __repr__(self):
-            return "IrohError.FsUtil({})".format(str(self))
-    _UniffiTempIrohError.FsUtil = FsUtil # type: ignore
-    class Tags(_UniffiTempIrohError):
-
-        def __init__(self, description):
-            super().__init__(", ".join([
-                "description={!r}".format(description),
-            ]))
-            self.description = description
-        def __repr__(self):
-            return "IrohError.Tags({})".format(str(self))
-    _UniffiTempIrohError.Tags = Tags # type: ignore
-    class Url(_UniffiTempIrohError):
 
-        def __init__(self, description):
-            super().__init__(", ".join([
-                "description={!r}".format(description),
-            ]))
-            self.description = description
-        def __repr__(self):
-            return "IrohError.Url({})".format(str(self))
-    _UniffiTempIrohError.Url = Url # type: ignore
-    class Entry(_UniffiTempIrohError):
-
-        def __init__(self, description):
-            super().__init__(", ".join([
-                "description={!r}".format(description),
-            ]))
-            self.description = description
-        def __repr__(self):
-            return "IrohError.Entry({})".format(str(self))
-    _UniffiTempIrohError.Entry = Entry # type: ignore
-
-IrohError = _UniffiTempIrohError # type: ignore
-del _UniffiTempIrohError
-
-
-class _UniffiConverterTypeIrohError(_UniffiConverterRustBuffer):
+class FfiConverterTypeIrohError(FfiConverterRustBuffer):
     @staticmethod
     def read(buf):
-        variant = buf.read_i32()
+        variant = buf.readI32()
         if variant == 1:
             return IrohError.Runtime(
-                description=_UniffiConverterString.read(buf),
+                description=FfiConverterString.read(buf),
             )
         if variant == 2:
             return IrohError.NodeCreate(
-                description=_UniffiConverterString.read(buf),
+                description=FfiConverterString.read(buf),
             )
         if variant == 3:
             return IrohError.Doc(
-                description=_UniffiConverterString.read(buf),
+                description=FfiConverterString.read(buf),
             )
         if variant == 4:
             return IrohError.Author(
-                description=_UniffiConverterString.read(buf),
+                description=FfiConverterString.read(buf),
             )
         if variant == 5:
-            return IrohError.Namespace(
-                description=_UniffiConverterString.read(buf),
-            )
-        if variant == 6:
             return IrohError.DocTicket(
-                description=_UniffiConverterString.read(buf),
+                description=FfiConverterString.read(buf),
             )
-        if variant == 7:
-            return IrohError.BlobTicket(
-                description=_UniffiConverterString.read(buf),
-            )
-        if variant == 8:
+        if variant == 6:
             return IrohError.Uniffi(
-                description=_UniffiConverterString.read(buf),
+                description=FfiConverterString.read(buf),
             )
-        if variant == 9:
+        if variant == 7:
             return IrohError.Connection(
-                description=_UniffiConverterString.read(buf),
-            )
-        if variant == 10:
-            return IrohError.Blobs(
-                description=_UniffiConverterString.read(buf),
-            )
-        if variant == 11:
-            return IrohError.Collection(
-                description=_UniffiConverterString.read(buf),
-            )
-        if variant == 12:
-            return IrohError.Ipv4Addr(
-                description=_UniffiConverterString.read(buf),
-            )
-        if variant == 13:
-            return IrohError.Ipv6Addr(
-                description=_UniffiConverterString.read(buf),
-            )
-        if variant == 14:
-            return IrohError.SocketAddr(
-                description=_UniffiConverterString.read(buf),
-            )
-        if variant == 15:
-            return IrohError.PublicKey(
-                description=_UniffiConverterString.read(buf),
-            )
-        if variant == 16:
-            return IrohError.NodeAddr(
-                description=_UniffiConverterString.read(buf),
-            )
-        if variant == 17:
-            return IrohError.Hash(
-                description=_UniffiConverterString.read(buf),
-            )
-        if variant == 18:
-            return IrohError.FsUtil(
-                description=_UniffiConverterString.read(buf),
+                description=FfiConverterString.read(buf),
             )
-        if variant == 19:
-            return IrohError.Tags(
-                description=_UniffiConverterString.read(buf),
-            )
-        if variant == 20:
-            return IrohError.Url(
-                description=_UniffiConverterString.read(buf),
-            )
-        if variant == 21:
-            return IrohError.Entry(
-                description=_UniffiConverterString.read(buf),
+        if variant == 8:
+            return IrohError.Blob(
+                description=FfiConverterString.read(buf),
             )
         raise InternalError("Raw enum value doesn't match any cases")
 
     @staticmethod
     def write(value, buf):
         if isinstance(value, IrohError.Runtime):
-            buf.write_i32(1)
-            _UniffiConverterString.write(value.description, buf)
+            buf.writeI32(1)
+            FfiConverterString.write(value.description, buf)
         if isinstance(value, IrohError.NodeCreate):
-            buf.write_i32(2)
-            _UniffiConverterString.write(value.description, buf)
+            buf.writeI32(2)
+            FfiConverterString.write(value.description, buf)
         if isinstance(value, IrohError.Doc):
-            buf.write_i32(3)
-            _UniffiConverterString.write(value.description, buf)
+            buf.writeI32(3)
+            FfiConverterString.write(value.description, buf)
         if isinstance(value, IrohError.Author):
-            buf.write_i32(4)
-            _UniffiConverterString.write(value.description, buf)
-        if isinstance(value, IrohError.Namespace):
-            buf.write_i32(5)
-            _UniffiConverterString.write(value.description, buf)
+            buf.writeI32(4)
+            FfiConverterString.write(value.description, buf)
         if isinstance(value, IrohError.DocTicket):
-            buf.write_i32(6)
-            _UniffiConverterString.write(value.description, buf)
-        if isinstance(value, IrohError.BlobTicket):
-            buf.write_i32(7)
-            _UniffiConverterString.write(value.description, buf)
+            buf.writeI32(5)
+            FfiConverterString.write(value.description, buf)
         if isinstance(value, IrohError.Uniffi):
-            buf.write_i32(8)
-            _UniffiConverterString.write(value.description, buf)
+            buf.writeI32(6)
+            FfiConverterString.write(value.description, buf)
         if isinstance(value, IrohError.Connection):
-            buf.write_i32(9)
-            _UniffiConverterString.write(value.description, buf)
-        if isinstance(value, IrohError.Blobs):
-            buf.write_i32(10)
-            _UniffiConverterString.write(value.description, buf)
-        if isinstance(value, IrohError.Collection):
-            buf.write_i32(11)
-            _UniffiConverterString.write(value.description, buf)
-        if isinstance(value, IrohError.Ipv4Addr):
-            buf.write_i32(12)
-            _UniffiConverterString.write(value.description, buf)
-        if isinstance(value, IrohError.Ipv6Addr):
-            buf.write_i32(13)
-            _UniffiConverterString.write(value.description, buf)
-        if isinstance(value, IrohError.SocketAddr):
-            buf.write_i32(14)
-            _UniffiConverterString.write(value.description, buf)
-        if isinstance(value, IrohError.PublicKey):
-            buf.write_i32(15)
-            _UniffiConverterString.write(value.description, buf)
-        if isinstance(value, IrohError.NodeAddr):
-            buf.write_i32(16)
-            _UniffiConverterString.write(value.description, buf)
-        if isinstance(value, IrohError.Hash):
-            buf.write_i32(17)
-            _UniffiConverterString.write(value.description, buf)
-        if isinstance(value, IrohError.FsUtil):
-            buf.write_i32(18)
-            _UniffiConverterString.write(value.description, buf)
-        if isinstance(value, IrohError.Tags):
-            buf.write_i32(19)
-            _UniffiConverterString.write(value.description, buf)
-        if isinstance(value, IrohError.Url):
-            buf.write_i32(20)
-            _UniffiConverterString.write(value.description, buf)
-        if isinstance(value, IrohError.Entry):
-            buf.write_i32(21)
-            _UniffiConverterString.write(value.description, buf)
+            buf.writeI32(7)
+            FfiConverterString.write(value.description, buf)
+        if isinstance(value, IrohError.Blob):
+            buf.writeI32(8)
+            FfiConverterString.write(value.description, buf)
+
+
+
+
+
+class LiveEventType:
+    def __init__(self):
+        raise RuntimeError("LiveEventType cannot be instantiated directly")
+
+    # Each enum variant is a nested class of the enum itself.
+    class INSERT_LOCAL:
+        def __init__(self,):
+            
+            pass
+            
+
+        def __str__(self):
+            return "LiveEventType.INSERT_LOCAL()".format()
+
+        def __eq__(self, other):
+            if not other.is_insert_local():
+                return False
+            return True
+    class INSERT_REMOTE:
+        def __init__(self,):
+            
+            pass
+            
+
+        def __str__(self):
+            return "LiveEventType.INSERT_REMOTE()".format()
+
+        def __eq__(self, other):
+            if not other.is_insert_remote():
+                return False
+            return True
+    class CONTENT_READY:
+        def __init__(self,):
+            
+            pass
+            
 
+        def __str__(self):
+            return "LiveEventType.CONTENT_READY()".format()
+
+        def __eq__(self, other):
+            if not other.is_content_ready():
+                return False
+            return True
+    class NEIGHBOR_UP:
+        def __init__(self,):
+            
+            pass
+            
 
+        def __str__(self):
+            return "LiveEventType.NEIGHBOR_UP()".format()
 
+        def __eq__(self, other):
+            if not other.is_neighbor_up():
+                return False
+            return True
+    class NEIGHBOR_DOWN:
+        def __init__(self,):
+            
+            pass
+            
 
+        def __str__(self):
+            return "LiveEventType.NEIGHBOR_DOWN()".format()
 
-class LiveEventType(enum.Enum):
-    '''The type of events that can be emitted during the live sync progress'''
-    INSERT_LOCAL = 1
-    '''A local insertion.'''
-    INSERT_REMOTE = 2
-    '''Received a remote insert.'''
-    CONTENT_READY = 3
-    '''The content of an entry was downloaded and is now available at the local node'''
-    NEIGHBOR_UP = 4
-    '''We have a new neighbor in the swarm.'''
-    NEIGHBOR_DOWN = 5
-    '''We lost a neighbor in the swarm.'''
-    SYNC_FINISHED = 6
-    '''A set-reconciliation sync finished.'''
+        def __eq__(self, other):
+            if not other.is_neighbor_down():
+                return False
+            return True
+    class SYNC_FINISHED:
+        def __init__(self,):
+            
+            pass
+            
+
+        def __str__(self):
+            return "LiveEventType.SYNC_FINISHED()".format()
+
+        def __eq__(self, other):
+            if not other.is_sync_finished():
+                return False
+            return True
+    
+
+    # For each variant, we have an `is_NAME` method for easily checking
+    # whether an instance is that variant.
+    def is_insert_local(self) -> bool:
+        return isinstance(self, LiveEventType.INSERT_LOCAL)
+    def is_insert_remote(self) -> bool:
+        return isinstance(self, LiveEventType.INSERT_REMOTE)
+    def is_content_ready(self) -> bool:
+        return isinstance(self, LiveEventType.CONTENT_READY)
+    def is_neighbor_up(self) -> bool:
+        return isinstance(self, LiveEventType.NEIGHBOR_UP)
+    def is_neighbor_down(self) -> bool:
+        return isinstance(self, LiveEventType.NEIGHBOR_DOWN)
+    def is_sync_finished(self) -> bool:
+        return isinstance(self, LiveEventType.SYNC_FINISHED)
     
 
+# Now, a little trick - we make each nested variant class be a subclass of the main
+# enum class, so that method calls and instance checks etc will work intuitively.
+# We might be able to do this a little more neatly with a metaclass, but this'll do.
+LiveEventType.INSERT_LOCAL = type("LiveEventType.INSERT_LOCAL", (LiveEventType.INSERT_LOCAL, LiveEventType,), {})  # type: ignore
+LiveEventType.INSERT_REMOTE = type("LiveEventType.INSERT_REMOTE", (LiveEventType.INSERT_REMOTE, LiveEventType,), {})  # type: ignore
+LiveEventType.CONTENT_READY = type("LiveEventType.CONTENT_READY", (LiveEventType.CONTENT_READY, LiveEventType,), {})  # type: ignore
+LiveEventType.NEIGHBOR_UP = type("LiveEventType.NEIGHBOR_UP", (LiveEventType.NEIGHBOR_UP, LiveEventType,), {})  # type: ignore
+LiveEventType.NEIGHBOR_DOWN = type("LiveEventType.NEIGHBOR_DOWN", (LiveEventType.NEIGHBOR_DOWN, LiveEventType,), {})  # type: ignore
+LiveEventType.SYNC_FINISHED = type("LiveEventType.SYNC_FINISHED", (LiveEventType.SYNC_FINISHED, LiveEventType,), {})  # type: ignore
+
 
-class _UniffiConverterTypeLiveEventType(_UniffiConverterRustBuffer):
+
+
+class FfiConverterTypeLiveEventType(FfiConverterRustBuffer):
     @staticmethod
     def read(buf):
-        variant = buf.read_i32()
+        variant = buf.readI32()
         if variant == 1:
-            return LiveEventType.INSERT_LOCAL
+            return LiveEventType.INSERT_LOCAL(
+            )
         if variant == 2:
-            return LiveEventType.INSERT_REMOTE
+            return LiveEventType.INSERT_REMOTE(
+            )
         if variant == 3:
-            return LiveEventType.CONTENT_READY
+            return LiveEventType.CONTENT_READY(
+            )
         if variant == 4:
-            return LiveEventType.NEIGHBOR_UP
+            return LiveEventType.NEIGHBOR_UP(
+            )
         if variant == 5:
-            return LiveEventType.NEIGHBOR_DOWN
+            return LiveEventType.NEIGHBOR_DOWN(
+            )
         if variant == 6:
-            return LiveEventType.SYNC_FINISHED
+            return LiveEventType.SYNC_FINISHED(
+            )
         raise InternalError("Raw enum value doesn't match any cases")
 
     def write(value, buf):
-        if value == LiveEventType.INSERT_LOCAL:
-            buf.write_i32(1)
-        if value == LiveEventType.INSERT_REMOTE:
-            buf.write_i32(2)
-        if value == LiveEventType.CONTENT_READY:
-            buf.write_i32(3)
-        if value == LiveEventType.NEIGHBOR_UP:
-            buf.write_i32(4)
-        if value == LiveEventType.NEIGHBOR_DOWN:
-            buf.write_i32(5)
-        if value == LiveEventType.SYNC_FINISHED:
-            buf.write_i32(6)
-
+        if value.is_insert_local():
+            buf.writeI32(1)
+        if value.is_insert_remote():
+            buf.writeI32(2)
+        if value.is_content_ready():
+            buf.writeI32(3)
+        if value.is_neighbor_up():
+            buf.writeI32(4)
+        if value.is_neighbor_down():
+            buf.writeI32(5)
+        if value.is_sync_finished():
+            buf.writeI32(6)
 
 
 
 
 
 
 class LogLevel(enum.Enum):
-    '''The logging level. See the rust (log crate)[https://docs.rs/log] for more information.'''
     TRACE = 1
     DEBUG = 2
     INFO = 3
     WARN = 4
     ERROR = 5
     OFF = 6
     
 
 
-class _UniffiConverterTypeLogLevel(_UniffiConverterRustBuffer):
+class FfiConverterTypeLogLevel(FfiConverterRustBuffer):
     @staticmethod
     def read(buf):
-        variant = buf.read_i32()
+        variant = buf.readI32()
         if variant == 1:
             return LogLevel.TRACE
         if variant == 2:
             return LogLevel.DEBUG
         if variant == 3:
             return LogLevel.INFO
         if variant == 4:
@@ -8154,64 +2654,52 @@
             return LogLevel.ERROR
         if variant == 6:
             return LogLevel.OFF
         raise InternalError("Raw enum value doesn't match any cases")
 
     def write(value, buf):
         if value == LogLevel.TRACE:
-            buf.write_i32(1)
+            buf.writeI32(1)
         if value == LogLevel.DEBUG:
-            buf.write_i32(2)
+            buf.writeI32(2)
         if value == LogLevel.INFO:
-            buf.write_i32(3)
+            buf.writeI32(3)
         if value == LogLevel.WARN:
-            buf.write_i32(4)
+            buf.writeI32(4)
         if value == LogLevel.ERROR:
-            buf.write_i32(5)
+            buf.writeI32(5)
         if value == LogLevel.OFF:
-            buf.write_i32(6)
-
+            buf.writeI32(6)
 
 
 
 
 
 
 class Origin:
-    '''Why we performed a sync exchange'''
     def __init__(self):
         raise RuntimeError("Origin cannot be instantiated directly")
 
     # Each enum variant is a nested class of the enum itself.
     class CONNECT:
-        '''public, use a unit variant'''
-
-        reason: "SyncReason";
-
-        @typing.no_type_check
-        def __init__(self,reason: "SyncReason"):
+        def __init__(self,reason):
             
             self.reason = reason
             
 
         def __str__(self):
             return "Origin.CONNECT(reason={})".format(self.reason)
 
         def __eq__(self, other):
             if not other.is_connect():
                 return False
             if self.reason != other.reason:
                 return False
             return True
     class ACCEPT:
-        '''A peer connected to us and we accepted the exchange'''
-
-        
-
-        @typing.no_type_check
         def __init__(self,):
             
             pass
             
 
         def __str__(self):
             return "Origin.ACCEPT()".format()
@@ -8235,207 +2723,202 @@
 # We might be able to do this a little more neatly with a metaclass, but this'll do.
 Origin.CONNECT = type("Origin.CONNECT", (Origin.CONNECT, Origin,), {})  # type: ignore
 Origin.ACCEPT = type("Origin.ACCEPT", (Origin.ACCEPT, Origin,), {})  # type: ignore
 
 
 
 
-class _UniffiConverterTypeOrigin(_UniffiConverterRustBuffer):
+class FfiConverterTypeOrigin(FfiConverterRustBuffer):
     @staticmethod
     def read(buf):
-        variant = buf.read_i32()
+        variant = buf.readI32()
         if variant == 1:
             return Origin.CONNECT(
-                _UniffiConverterTypeSyncReason.read(buf),
+                FfiConverterTypeSyncReason.read(buf),
             )
         if variant == 2:
             return Origin.ACCEPT(
             )
         raise InternalError("Raw enum value doesn't match any cases")
 
     def write(value, buf):
         if value.is_connect():
-            buf.write_i32(1)
-            _UniffiConverterTypeSyncReason.write(value.reason, buf)
+            buf.writeI32(1)
+            FfiConverterTypeSyncReason.write(value.reason, buf)
         if value.is_accept():
-            buf.write_i32(2)
-
-
+            buf.writeI32(2)
 
 
 
 
 
-class ShareMode(enum.Enum):
-    '''Intended capability for document share tickets'''
-    READ = 1
-    '''Read-only access'''
-    WRITE = 2
-    '''Write access'''
-    
-
-
-class _UniffiConverterTypeShareMode(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        variant = buf.read_i32()
-        if variant == 1:
-            return ShareMode.READ
-        if variant == 2:
-            return ShareMode.WRITE
-        raise InternalError("Raw enum value doesn't match any cases")
-
-    def write(value, buf):
-        if value == ShareMode.READ:
-            buf.write_i32(1)
-        if value == ShareMode.WRITE:
-            buf.write_i32(2)
-
 
+class SocketAddr:
+    def __init__(self):
+        raise RuntimeError("SocketAddr cannot be instantiated directly")
 
+    # Each enum variant is a nested class of the enum itself.
+    class V4:
+        def __init__(self,a, b, c, d):
+            
+            self.a = a
+            self.b = b
+            self.c = c
+            self.d = d
+            
 
+        def __str__(self):
+            return "SocketAddr.V4(a={}, b={}, c={}, d={})".format(self.a, self.b, self.c, self.d)
 
+        def __eq__(self, other):
+            if not other.is_v4():
+                return False
+            if self.a != other.a:
+                return False
+            if self.b != other.b:
+                return False
+            if self.c != other.c:
+                return False
+            if self.d != other.d:
+                return False
+            return True
+    class V6:
+        def __init__(self,addr):
+            
+            self.addr = addr
+            
 
+        def __str__(self):
+            return "SocketAddr.V6(addr={})".format(self.addr)
 
-class ShareTicketOptions(enum.Enum):
-    '''Options when creating a ticket'''
-    RELAY_AND_ADDRESSES = 1
-    '''Include both the relay URL and the direct addresses.'''
-    RELAY = 2
-    '''Only include the relay URL.'''
-    ADDRESSES = 3
-    '''Only include the direct addresses.'''
+        def __eq__(self, other):
+            if not other.is_v6():
+                return False
+            if self.addr != other.addr:
+                return False
+            return True
     
 
+    # For each variant, we have an `is_NAME` method for easily checking
+    # whether an instance is that variant.
+    def is_v4(self) -> bool:
+        return isinstance(self, SocketAddr.V4)
+    def is_v6(self) -> bool:
+        return isinstance(self, SocketAddr.V6)
+    
 
-class _UniffiConverterTypeShareTicketOptions(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        variant = buf.read_i32()
-        if variant == 1:
-            return ShareTicketOptions.RELAY_AND_ADDRESSES
-        if variant == 2:
-            return ShareTicketOptions.RELAY
-        if variant == 3:
-            return ShareTicketOptions.ADDRESSES
-        raise InternalError("Raw enum value doesn't match any cases")
-
-    def write(value, buf):
-        if value == ShareTicketOptions.RELAY_AND_ADDRESSES:
-            buf.write_i32(1)
-        if value == ShareTicketOptions.RELAY:
-            buf.write_i32(2)
-        if value == ShareTicketOptions.ADDRESSES:
-            buf.write_i32(3)
-
-
-
-
-
+# Now, a little trick - we make each nested variant class be a subclass of the main
+# enum class, so that method calls and instance checks etc will work intuitively.
+# We might be able to do this a little more neatly with a metaclass, but this'll do.
+SocketAddr.V4 = type("SocketAddr.V4", (SocketAddr.V4, SocketAddr,), {})  # type: ignore
+SocketAddr.V6 = type("SocketAddr.V6", (SocketAddr.V6, SocketAddr,), {})  # type: ignore
 
 
-class SortBy(enum.Enum):
-    '''Fields by which the query can be sorted'''
-    KEY_AUTHOR = 1
-    '''Fields by which the query can be sorted'''
-    AUTHOR_KEY = 2
-    '''Fields by which the query can be sorted'''
-    
 
 
-class _UniffiConverterTypeSortBy(_UniffiConverterRustBuffer):
+class FfiConverterTypeSocketAddr(FfiConverterRustBuffer):
     @staticmethod
     def read(buf):
-        variant = buf.read_i32()
+        variant = buf.readI32()
         if variant == 1:
-            return SortBy.KEY_AUTHOR
+            return SocketAddr.V4(
+                FfiConverterUInt8.read(buf),
+                FfiConverterUInt8.read(buf),
+                FfiConverterUInt8.read(buf),
+                FfiConverterUInt8.read(buf),
+            )
         if variant == 2:
-            return SortBy.AUTHOR_KEY
+            return SocketAddr.V6(
+                FfiConverterBytes.read(buf),
+            )
         raise InternalError("Raw enum value doesn't match any cases")
 
     def write(value, buf):
-        if value == SortBy.KEY_AUTHOR:
-            buf.write_i32(1)
-        if value == SortBy.AUTHOR_KEY:
-            buf.write_i32(2)
-
+        if value.is_v4():
+            buf.writeI32(1)
+            FfiConverterUInt8.write(value.a, buf)
+            FfiConverterUInt8.write(value.b, buf)
+            FfiConverterUInt8.write(value.c, buf)
+            FfiConverterUInt8.write(value.d, buf)
+        if value.is_v6():
+            buf.writeI32(2)
+            FfiConverterBytes.write(value.addr, buf)
 
 
 
 
 
 
-class SortDirection(enum.Enum):
-    '''Sort direction'''
-    ASC = 1
-    '''Sort ascending'''
-    DESC = 2
-    '''Sort descending'''
-    
-
+class SyncReason:
+    def __init__(self):
+        raise RuntimeError("SyncReason cannot be instantiated directly")
 
-class _UniffiConverterTypeSortDirection(_UniffiConverterRustBuffer):
-    @staticmethod
-    def read(buf):
-        variant = buf.read_i32()
-        if variant == 1:
-            return SortDirection.ASC
-        if variant == 2:
-            return SortDirection.DESC
-        raise InternalError("Raw enum value doesn't match any cases")
+    # Each enum variant is a nested class of the enum itself.
+    class DIRECT_JOIN:
+        def __init__(self,):
+            
+            pass
+            
 
-    def write(value, buf):
-        if value == SortDirection.ASC:
-            buf.write_i32(1)
-        if value == SortDirection.DESC:
-            buf.write_i32(2)
+        def __str__(self):
+            return "SyncReason.DIRECT_JOIN()".format()
 
+        def __eq__(self, other):
+            if not other.is_direct_join():
+                return False
+            return True
+    class NEW_NEIGHBOR:
+        def __init__(self,):
+            
+            pass
+            
 
+        def __str__(self):
+            return "SyncReason.NEW_NEIGHBOR()".format()
 
+        def __eq__(self, other):
+            if not other.is_new_neighbor():
+                return False
+            return True
+    
 
+    # For each variant, we have an `is_NAME` method for easily checking
+    # whether an instance is that variant.
+    def is_direct_join(self) -> bool:
+        return isinstance(self, SyncReason.DIRECT_JOIN)
+    def is_new_neighbor(self) -> bool:
+        return isinstance(self, SyncReason.NEW_NEIGHBOR)
+    
 
+# Now, a little trick - we make each nested variant class be a subclass of the main
+# enum class, so that method calls and instance checks etc will work intuitively.
+# We might be able to do this a little more neatly with a metaclass, but this'll do.
+SyncReason.DIRECT_JOIN = type("SyncReason.DIRECT_JOIN", (SyncReason.DIRECT_JOIN, SyncReason,), {})  # type: ignore
+SyncReason.NEW_NEIGHBOR = type("SyncReason.NEW_NEIGHBOR", (SyncReason.NEW_NEIGHBOR, SyncReason,), {})  # type: ignore
 
 
-class SyncReason(enum.Enum):
-    '''Why we started a sync request'''
-    DIRECT_JOIN = 1
-    '''Direct join request via API'''
-    NEW_NEIGHBOR = 2
-    '''Peer showed up as new neighbor in the gossip swarm'''
-    SYNC_REPORT = 3
-    '''We synced after receiving a sync report that indicated news for us'''
-    RESYNC = 4
-    '''We received a sync report while a sync was running, so run again afterwars'''
-    
 
 
-class _UniffiConverterTypeSyncReason(_UniffiConverterRustBuffer):
+class FfiConverterTypeSyncReason(FfiConverterRustBuffer):
     @staticmethod
     def read(buf):
-        variant = buf.read_i32()
+        variant = buf.readI32()
         if variant == 1:
-            return SyncReason.DIRECT_JOIN
+            return SyncReason.DIRECT_JOIN(
+            )
         if variant == 2:
-            return SyncReason.NEW_NEIGHBOR
-        if variant == 3:
-            return SyncReason.SYNC_REPORT
-        if variant == 4:
-            return SyncReason.RESYNC
+            return SyncReason.NEW_NEIGHBOR(
+            )
         raise InternalError("Raw enum value doesn't match any cases")
 
     def write(value, buf):
-        if value == SyncReason.DIRECT_JOIN:
-            buf.write_i32(1)
-        if value == SyncReason.NEW_NEIGHBOR:
-            buf.write_i32(2)
-        if value == SyncReason.SYNC_REPORT:
-            buf.write_i32(3)
-        if value == SyncReason.RESYNC:
-            buf.write_i32(4)
-
+        if value.is_direct_join():
+            buf.writeI32(1)
+        if value.is_new_neighbor():
+            buf.writeI32(2)
 
 
 
 
 import threading
 
 class ConcurrentHandleMap:
@@ -8475,19 +2958,19 @@
                 del self._right_map[obj]
                 return obj
 
 # Magic number for the Rust proxy to call using the same mechanism as every other method,
 # to free the callback once it's dropped by Rust.
 IDX_CALLBACK_FREE = 0
 # Return codes for callback calls
-_UNIFFI_CALLBACK_SUCCESS = 0
-_UNIFFI_CALLBACK_ERROR = 1
-_UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2
+UNIFFI_CALLBACK_SUCCESS = 0
+UNIFFI_CALLBACK_ERROR = 1
+UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2
 
-class _UniffiConverterCallbackInterface:
+class FfiConverterCallbackInterface:
     _handle_map = ConcurrentHandleMap()
 
     def __init__(self, cb):
         self._foreign_callback = cb
 
     def drop(self, handle):
         self.__class__._handle_map.remove(handle)
@@ -8498,1070 +2981,366 @@
         if not obj:
             raise InternalError("The object in the handle map has been dropped already")
 
         return obj
 
     @classmethod
     def read(cls, buf):
-        handle = buf.read_u64()
+        handle = buf.readU64()
         cls.lift(handle)
 
     @classmethod
     def lower(cls, cb):
         handle = cls._handle_map.insert(cb)
         return handle
 
     @classmethod
     def write(cls, cb, buf):
-        buf.write_u64(cls.lower(cb))
-
-# Declaration and _UniffiConverters for AddCallback Callback Interface
-
-class AddCallback:
-    '''
-    The `progress` method will be called for each `AddProgress` event that is
-    emitted during a `node.blobs_add_from_path`. Use the `AddProgress.type()`
-    method to check the `AddProgressType`
-    '''
-    def progress(self, progress: "AddProgress"):
-        raise NotImplementedError
-
-    
-
-def py_foreignCallbackCallbackInterfaceAddCallback(handle, method, args_data, args_len, buf_ptr):
-    
-    def invoke_progress(python_callback, args_stream, buf_ptr):
-        def makeCall():return python_callback.progress(
-                _UniffiConverterTypeAddProgress.read(args_stream)
-                )
-
-        def makeCallAndHandleReturn():
-            makeCall()
-            return _UNIFFI_CALLBACK_SUCCESS
-        try:
-            return makeCallAndHandleReturn()
-        except IrohError as e:
-            # Catch errors declared in the UDL file
-            with _UniffiRustBuffer.alloc_with_builder() as builder:
-                _UniffiConverterTypeIrohError.write(e, builder)
-                buf_ptr[0] = builder.finalize()
-            return _UNIFFI_CALLBACK_ERROR
-
-    
-
-    cb = _UniffiConverterCallbackInterfaceAddCallback.lift(handle)
-    if not cb:
-        raise InternalError("No callback in handlemap; this is a uniffi bug")
-
-    if method == IDX_CALLBACK_FREE:
-        _UniffiConverterCallbackInterfaceAddCallback.drop(handle)
-        # Successfull return
-        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
-        return _UNIFFI_CALLBACK_SUCCESS
-
-    if method == 1:
-        # Call the method and handle any errors
-        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for details
-        try:
-            return invoke_progress(cb, _UniffiRustBufferStream(args_data, args_len), buf_ptr)
-        except BaseException as e:
-            # Catch unexpected errors
-            try:
-                # Try to serialize the exception into a String
-                buf_ptr[0] = _UniffiConverterString.lower(repr(e))
-            except:
-                # If that fails, just give up
-                pass
-            return _UNIFFI_CALLBACK_UNEXPECTED_ERROR
-    
-
-    # This should never happen, because an out of bounds method index won't
-    # ever be used. Once we can catch errors, we should return an InternalException.
-    # https://github.com/mozilla/uniffi-rs/issues/351
-
-    # An unexpected error happened.
-    # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
-    return _UNIFFI_CALLBACK_UNEXPECTED_ERROR
-
-# We need to keep this function reference alive:
-# if they get GC'd while in use then UniFFI internals could attempt to call a function
-# that is in freed memory.
-# That would be...uh...bad. Yeah, that's the word. Bad.
-foreignCallbackCallbackInterfaceAddCallback = _UNIFFI_FOREIGN_CALLBACK_T(py_foreignCallbackCallbackInterfaceAddCallback)
-_rust_call(lambda err: _UniffiLib.uniffi_iroh_fn_init_callback_addcallback(foreignCallbackCallbackInterfaceAddCallback, err))
-
-# The _UniffiConverter which transforms the Callbacks in to Handles to pass to Rust.
-_UniffiConverterCallbackInterfaceAddCallback = _UniffiConverterCallbackInterface(foreignCallbackCallbackInterfaceAddCallback)
-
-
-
-
-
-# Declaration and _UniffiConverters for DocExportFileCallback Callback Interface
-
-class DocExportFileCallback:
-    '''
-    The `progress` method will be called for each `DocExportProgress` event that is
-    emitted during a `doc.export_file()` call. Use the `DocExportProgress.type()`
-    method to check the `DocExportProgressType`
-    '''
-    def progress(self, progress: "DocExportProgress"):
-        raise NotImplementedError
-
-    
-
-def py_foreignCallbackCallbackInterfaceDocExportFileCallback(handle, method, args_data, args_len, buf_ptr):
-    
-    def invoke_progress(python_callback, args_stream, buf_ptr):
-        def makeCall():return python_callback.progress(
-                _UniffiConverterTypeDocExportProgress.read(args_stream)
-                )
-
-        def makeCallAndHandleReturn():
-            makeCall()
-            return _UNIFFI_CALLBACK_SUCCESS
-        try:
-            return makeCallAndHandleReturn()
-        except IrohError as e:
-            # Catch errors declared in the UDL file
-            with _UniffiRustBuffer.alloc_with_builder() as builder:
-                _UniffiConverterTypeIrohError.write(e, builder)
-                buf_ptr[0] = builder.finalize()
-            return _UNIFFI_CALLBACK_ERROR
-
-    
-
-    cb = _UniffiConverterCallbackInterfaceDocExportFileCallback.lift(handle)
-    if not cb:
-        raise InternalError("No callback in handlemap; this is a uniffi bug")
-
-    if method == IDX_CALLBACK_FREE:
-        _UniffiConverterCallbackInterfaceDocExportFileCallback.drop(handle)
-        # Successfull return
-        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
-        return _UNIFFI_CALLBACK_SUCCESS
-
-    if method == 1:
-        # Call the method and handle any errors
-        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for details
-        try:
-            return invoke_progress(cb, _UniffiRustBufferStream(args_data, args_len), buf_ptr)
-        except BaseException as e:
-            # Catch unexpected errors
-            try:
-                # Try to serialize the exception into a String
-                buf_ptr[0] = _UniffiConverterString.lower(repr(e))
-            except:
-                # If that fails, just give up
-                pass
-            return _UNIFFI_CALLBACK_UNEXPECTED_ERROR
-    
-
-    # This should never happen, because an out of bounds method index won't
-    # ever be used. Once we can catch errors, we should return an InternalException.
-    # https://github.com/mozilla/uniffi-rs/issues/351
-
-    # An unexpected error happened.
-    # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
-    return _UNIFFI_CALLBACK_UNEXPECTED_ERROR
+        buf.writeU64(cls.lower(cb))
 
-# We need to keep this function reference alive:
-# if they get GC'd while in use then UniFFI internals could attempt to call a function
-# that is in freed memory.
-# That would be...uh...bad. Yeah, that's the word. Bad.
-foreignCallbackCallbackInterfaceDocExportFileCallback = _UNIFFI_FOREIGN_CALLBACK_T(py_foreignCallbackCallbackInterfaceDocExportFileCallback)
-_rust_call(lambda err: _UniffiLib.uniffi_iroh_fn_init_callback_docexportfilecallback(foreignCallbackCallbackInterfaceDocExportFileCallback, err))
-
-# The _UniffiConverter which transforms the Callbacks in to Handles to pass to Rust.
-_UniffiConverterCallbackInterfaceDocExportFileCallback = _UniffiConverterCallbackInterface(foreignCallbackCallbackInterfaceDocExportFileCallback)
-
-
-
-
-
-# Declaration and _UniffiConverters for DocImportFileCallback Callback Interface
-
-class DocImportFileCallback:
-    '''
-    The `progress` method will be called for each `DocImportProgress` event that is
-    emitted during a `doc.import_file()` call. Use the `DocImportProgress.type()`
-    method to check the `DocImportProgressType`
-    '''
-    def progress(self, progress: "DocImportProgress"):
-        raise NotImplementedError
-
-    
-
-def py_foreignCallbackCallbackInterfaceDocImportFileCallback(handle, method, args_data, args_len, buf_ptr):
-    
-    def invoke_progress(python_callback, args_stream, buf_ptr):
-        def makeCall():return python_callback.progress(
-                _UniffiConverterTypeDocImportProgress.read(args_stream)
-                )
-
-        def makeCallAndHandleReturn():
-            makeCall()
-            return _UNIFFI_CALLBACK_SUCCESS
-        try:
-            return makeCallAndHandleReturn()
-        except IrohError as e:
-            # Catch errors declared in the UDL file
-            with _UniffiRustBuffer.alloc_with_builder() as builder:
-                _UniffiConverterTypeIrohError.write(e, builder)
-                buf_ptr[0] = builder.finalize()
-            return _UNIFFI_CALLBACK_ERROR
-
-    
-
-    cb = _UniffiConverterCallbackInterfaceDocImportFileCallback.lift(handle)
-    if not cb:
-        raise InternalError("No callback in handlemap; this is a uniffi bug")
-
-    if method == IDX_CALLBACK_FREE:
-        _UniffiConverterCallbackInterfaceDocImportFileCallback.drop(handle)
-        # Successfull return
-        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
-        return _UNIFFI_CALLBACK_SUCCESS
-
-    if method == 1:
-        # Call the method and handle any errors
-        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for details
-        try:
-            return invoke_progress(cb, _UniffiRustBufferStream(args_data, args_len), buf_ptr)
-        except BaseException as e:
-            # Catch unexpected errors
-            try:
-                # Try to serialize the exception into a String
-                buf_ptr[0] = _UniffiConverterString.lower(repr(e))
-            except:
-                # If that fails, just give up
-                pass
-            return _UNIFFI_CALLBACK_UNEXPECTED_ERROR
-    
-
-    # This should never happen, because an out of bounds method index won't
-    # ever be used. Once we can catch errors, we should return an InternalException.
-    # https://github.com/mozilla/uniffi-rs/issues/351
-
-    # An unexpected error happened.
-    # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
-    return _UNIFFI_CALLBACK_UNEXPECTED_ERROR
-
-# We need to keep this function reference alive:
-# if they get GC'd while in use then UniFFI internals could attempt to call a function
-# that is in freed memory.
-# That would be...uh...bad. Yeah, that's the word. Bad.
-foreignCallbackCallbackInterfaceDocImportFileCallback = _UNIFFI_FOREIGN_CALLBACK_T(py_foreignCallbackCallbackInterfaceDocImportFileCallback)
-_rust_call(lambda err: _UniffiLib.uniffi_iroh_fn_init_callback_docimportfilecallback(foreignCallbackCallbackInterfaceDocImportFileCallback, err))
-
-# The _UniffiConverter which transforms the Callbacks in to Handles to pass to Rust.
-_UniffiConverterCallbackInterfaceDocImportFileCallback = _UniffiConverterCallbackInterface(foreignCallbackCallbackInterfaceDocImportFileCallback)
-
-
-
-
-
-# Declaration and _UniffiConverters for DownloadCallback Callback Interface
-
-class DownloadCallback:
-    '''
-    The `progress` method will be called for each `DownloadProgress` event that is emitted during
-    a `node.blobs_download`. Use the `DownloadProgress.type()` method to check the
-    `DownloadProgressType` of the event.
-    '''
-    def progress(self, progress: "DownloadProgress"):
-        raise NotImplementedError
-
-    
-
-def py_foreignCallbackCallbackInterfaceDownloadCallback(handle, method, args_data, args_len, buf_ptr):
-    
-    def invoke_progress(python_callback, args_stream, buf_ptr):
-        def makeCall():return python_callback.progress(
-                _UniffiConverterTypeDownloadProgress.read(args_stream)
-                )
-
-        def makeCallAndHandleReturn():
-            makeCall()
-            return _UNIFFI_CALLBACK_SUCCESS
-        try:
-            return makeCallAndHandleReturn()
-        except IrohError as e:
-            # Catch errors declared in the UDL file
-            with _UniffiRustBuffer.alloc_with_builder() as builder:
-                _UniffiConverterTypeIrohError.write(e, builder)
-                buf_ptr[0] = builder.finalize()
-            return _UNIFFI_CALLBACK_ERROR
-
-    
-
-    cb = _UniffiConverterCallbackInterfaceDownloadCallback.lift(handle)
-    if not cb:
-        raise InternalError("No callback in handlemap; this is a uniffi bug")
-
-    if method == IDX_CALLBACK_FREE:
-        _UniffiConverterCallbackInterfaceDownloadCallback.drop(handle)
-        # Successfull return
-        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
-        return _UNIFFI_CALLBACK_SUCCESS
-
-    if method == 1:
-        # Call the method and handle any errors
-        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for details
-        try:
-            return invoke_progress(cb, _UniffiRustBufferStream(args_data, args_len), buf_ptr)
-        except BaseException as e:
-            # Catch unexpected errors
-            try:
-                # Try to serialize the exception into a String
-                buf_ptr[0] = _UniffiConverterString.lower(repr(e))
-            except:
-                # If that fails, just give up
-                pass
-            return _UNIFFI_CALLBACK_UNEXPECTED_ERROR
-    
-
-    # This should never happen, because an out of bounds method index won't
-    # ever be used. Once we can catch errors, we should return an InternalException.
-    # https://github.com/mozilla/uniffi-rs/issues/351
-
-    # An unexpected error happened.
-    # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
-    return _UNIFFI_CALLBACK_UNEXPECTED_ERROR
-
-# We need to keep this function reference alive:
-# if they get GC'd while in use then UniFFI internals could attempt to call a function
-# that is in freed memory.
-# That would be...uh...bad. Yeah, that's the word. Bad.
-foreignCallbackCallbackInterfaceDownloadCallback = _UNIFFI_FOREIGN_CALLBACK_T(py_foreignCallbackCallbackInterfaceDownloadCallback)
-_rust_call(lambda err: _UniffiLib.uniffi_iroh_fn_init_callback_downloadcallback(foreignCallbackCallbackInterfaceDownloadCallback, err))
-
-# The _UniffiConverter which transforms the Callbacks in to Handles to pass to Rust.
-_UniffiConverterCallbackInterfaceDownloadCallback = _UniffiConverterCallbackInterface(foreignCallbackCallbackInterfaceDownloadCallback)
-
-
-
-
-
-# Declaration and _UniffiConverters for SubscribeCallback Callback Interface
+# Declaration and FfiConverters for SubscribeCallback Callback Interface
 
 class SubscribeCallback:
-    '''
-    The `progress` method will be called for each `SubscribeProgress` event that is
-    emitted during a `node.doc_subscribe`. Use the `SubscribeProgress.type()`
-    method to check the `LiveEvent`
-    '''
     def event(self, event: "LiveEvent"):
         raise NotImplementedError
 
     
 
 def py_foreignCallbackCallbackInterfaceSubscribeCallback(handle, method, args_data, args_len, buf_ptr):
     
     def invoke_event(python_callback, args_stream, buf_ptr):
         def makeCall():return python_callback.event(
-                _UniffiConverterTypeLiveEvent.read(args_stream)
+                FfiConverterTypeLiveEvent.read(args_stream)
                 )
 
         def makeCallAndHandleReturn():
             makeCall()
-            return _UNIFFI_CALLBACK_SUCCESS
+            return UNIFFI_CALLBACK_SUCCESS
         try:
             return makeCallAndHandleReturn()
         except IrohError as e:
             # Catch errors declared in the UDL file
-            with _UniffiRustBuffer.alloc_with_builder() as builder:
-                _UniffiConverterTypeIrohError.write(e, builder)
+            with RustBuffer.allocWithBuilder() as builder:
+                FfiConverterTypeIrohError.write(e, builder)
                 buf_ptr[0] = builder.finalize()
-            return _UNIFFI_CALLBACK_ERROR
+            return UNIFFI_CALLBACK_ERROR
 
     
 
-    cb = _UniffiConverterCallbackInterfaceSubscribeCallback.lift(handle)
+    cb = FfiConverterCallbackInterfaceSubscribeCallback.lift(handle)
     if not cb:
-        raise InternalError("No callback in handlemap; this is a uniffi bug")
+        raise InternalError("No callback in handlemap; this is a Uniffi bug")
 
     if method == IDX_CALLBACK_FREE:
-        _UniffiConverterCallbackInterfaceSubscribeCallback.drop(handle)
+        FfiConverterCallbackInterfaceSubscribeCallback.drop(handle)
         # Successfull return
         # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
-        return _UNIFFI_CALLBACK_SUCCESS
+        return UNIFFI_CALLBACK_SUCCESS
 
     if method == 1:
         # Call the method and handle any errors
         # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for details
         try:
-            return invoke_event(cb, _UniffiRustBufferStream(args_data, args_len), buf_ptr)
+            return invoke_event(cb, RustBufferStream(args_data, args_len), buf_ptr)
         except BaseException as e:
             # Catch unexpected errors
             try:
                 # Try to serialize the exception into a String
-                buf_ptr[0] = _UniffiConverterString.lower(repr(e))
+                buf_ptr[0] = FfiConverterString.lower(repr(e))
             except:
                 # If that fails, just give up
                 pass
-            return _UNIFFI_CALLBACK_UNEXPECTED_ERROR
+            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
     
 
     # This should never happen, because an out of bounds method index won't
     # ever be used. Once we can catch errors, we should return an InternalException.
     # https://github.com/mozilla/uniffi-rs/issues/351
 
     # An unexpected error happened.
     # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
-    return _UNIFFI_CALLBACK_UNEXPECTED_ERROR
+    return UNIFFI_CALLBACK_UNEXPECTED_ERROR
 
 # We need to keep this function reference alive:
 # if they get GC'd while in use then UniFFI internals could attempt to call a function
 # that is in freed memory.
 # That would be...uh...bad. Yeah, that's the word. Bad.
-foreignCallbackCallbackInterfaceSubscribeCallback = _UNIFFI_FOREIGN_CALLBACK_T(py_foreignCallbackCallbackInterfaceSubscribeCallback)
-_rust_call(lambda err: _UniffiLib.uniffi_iroh_fn_init_callback_subscribecallback(foreignCallbackCallbackInterfaceSubscribeCallback, err))
-
-# The _UniffiConverter which transforms the Callbacks in to Handles to pass to Rust.
-_UniffiConverterCallbackInterfaceSubscribeCallback = _UniffiConverterCallbackInterface(foreignCallbackCallbackInterfaceSubscribeCallback)
-
-
-
-class _UniffiConverterOptionalUInt64(_UniffiConverterRustBuffer):
-    @classmethod
-    def write(cls, value, buf):
-        if value is None:
-            buf.write_u8(0)
-            return
-
-        buf.write_u8(1)
-        _UniffiConverterUInt64.write(value, buf)
-
-    @classmethod
-    def read(cls, buf):
-        flag = buf.read_u8()
-        if flag == 0:
-            return None
-        elif flag == 1:
-            return _UniffiConverterUInt64.read(buf)
-        else:
-            raise InternalError("Unexpected flag byte for optional type")
-
-
-
-class _UniffiConverterOptionalString(_UniffiConverterRustBuffer):
-    @classmethod
-    def write(cls, value, buf):
-        if value is None:
-            buf.write_u8(0)
-            return
-
-        buf.write_u8(1)
-        _UniffiConverterString.write(value, buf)
-
-    @classmethod
-    def read(cls, buf):
-        flag = buf.read_u8()
-        if flag == 0:
-            return None
-        elif flag == 1:
-            return _UniffiConverterString.read(buf)
-        else:
-            raise InternalError("Unexpected flag byte for optional type")
-
-
-
-class _UniffiConverterOptionalDuration(_UniffiConverterRustBuffer):
-    @classmethod
-    def write(cls, value, buf):
-        if value is None:
-            buf.write_u8(0)
-            return
-
-        buf.write_u8(1)
-        _UniffiConverterDuration.write(value, buf)
-
-    @classmethod
-    def read(cls, buf):
-        flag = buf.read_u8()
-        if flag == 0:
-            return None
-        elif flag == 1:
-            return _UniffiConverterDuration.read(buf)
-        else:
-            raise InternalError("Unexpected flag byte for optional type")
-
+foreignCallbackCallbackInterfaceSubscribeCallback = FOREIGN_CALLBACK_T(py_foreignCallbackCallbackInterfaceSubscribeCallback)
+rust_call(lambda err: _UniFFILib.uniffi_iroh_fn_init_callback_subscribecallback(foreignCallbackCallbackInterfaceSubscribeCallback, err))
 
-
-class _UniffiConverterOptionalTypeDoc(_UniffiConverterRustBuffer):
-    @classmethod
-    def write(cls, value, buf):
-        if value is None:
-            buf.write_u8(0)
-            return
-
-        buf.write_u8(1)
-        _UniffiConverterTypeDoc.write(value, buf)
-
-    @classmethod
-    def read(cls, buf):
-        flag = buf.read_u8()
-        if flag == 0:
-            return None
-        elif flag == 1:
-            return _UniffiConverterTypeDoc.read(buf)
-        else:
-            raise InternalError("Unexpected flag byte for optional type")
-
-
-
-class _UniffiConverterOptionalTypeEntry(_UniffiConverterRustBuffer):
-    @classmethod
-    def write(cls, value, buf):
-        if value is None:
-            buf.write_u8(0)
-            return
-
-        buf.write_u8(1)
-        _UniffiConverterTypeEntry.write(value, buf)
-
-    @classmethod
-    def read(cls, buf):
-        flag = buf.read_u8()
-        if flag == 0:
-            return None
-        elif flag == 1:
-            return _UniffiConverterTypeEntry.read(buf)
-        else:
-            raise InternalError("Unexpected flag byte for optional type")
-
-
-
-class _UniffiConverterOptionalTypeConnectionInfo(_UniffiConverterRustBuffer):
-    @classmethod
-    def write(cls, value, buf):
-        if value is None:
-            buf.write_u8(0)
-            return
-
-        buf.write_u8(1)
-        _UniffiConverterTypeConnectionInfo.write(value, buf)
-
-    @classmethod
-    def read(cls, buf):
-        flag = buf.read_u8()
-        if flag == 0:
-            return None
-        elif flag == 1:
-            return _UniffiConverterTypeConnectionInfo.read(buf)
-        else:
-            raise InternalError("Unexpected flag byte for optional type")
+# The FfiConverter which transforms the Callbacks in to Handles to pass to Rust.
+FfiConverterCallbackInterfaceSubscribeCallback = FfiConverterCallbackInterface(foreignCallbackCallbackInterfaceSubscribeCallback)
 
 
 
-class _UniffiConverterOptionalTypeLatencyAndControlMsg(_UniffiConverterRustBuffer):
+class FfiConverterOptionalUInt16(FfiConverterRustBuffer):
     @classmethod
     def write(cls, value, buf):
         if value is None:
-            buf.write_u8(0)
+            buf.writeU8(0)
             return
 
-        buf.write_u8(1)
-        _UniffiConverterTypeLatencyAndControlMsg.write(value, buf)
+        buf.writeU8(1)
+        FfiConverterUInt16.write(value, buf)
 
     @classmethod
     def read(cls, buf):
-        flag = buf.read_u8()
+        flag = buf.readU8()
         if flag == 0:
             return None
         elif flag == 1:
-            return _UniffiConverterTypeLatencyAndControlMsg.read(buf)
+            return FfiConverterUInt16.read(buf)
         else:
             raise InternalError("Unexpected flag byte for optional type")
 
 
 
-class _UniffiConverterOptionalTypeQueryOptions(_UniffiConverterRustBuffer):
+class FfiConverterOptionalDouble(FfiConverterRustBuffer):
     @classmethod
     def write(cls, value, buf):
         if value is None:
-            buf.write_u8(0)
+            buf.writeU8(0)
             return
 
-        buf.write_u8(1)
-        _UniffiConverterTypeQueryOptions.write(value, buf)
+        buf.writeU8(1)
+        FfiConverterDouble.write(value, buf)
 
     @classmethod
     def read(cls, buf):
-        flag = buf.read_u8()
+        flag = buf.readU8()
         if flag == 0:
             return None
         elif flag == 1:
-            return _UniffiConverterTypeQueryOptions.read(buf)
+            return FfiConverterDouble.read(buf)
         else:
             raise InternalError("Unexpected flag byte for optional type")
 
 
 
-class _UniffiConverterOptionalCallbackInterfaceDocExportFileCallback(_UniffiConverterRustBuffer):
+class FfiConverterOptionalString(FfiConverterRustBuffer):
     @classmethod
     def write(cls, value, buf):
         if value is None:
-            buf.write_u8(0)
+            buf.writeU8(0)
             return
 
-        buf.write_u8(1)
-        _UniffiConverterCallbackInterfaceDocExportFileCallback.write(value, buf)
+        buf.writeU8(1)
+        FfiConverterString.write(value, buf)
 
     @classmethod
     def read(cls, buf):
-        flag = buf.read_u8()
+        flag = buf.readU8()
         if flag == 0:
             return None
         elif flag == 1:
-            return _UniffiConverterCallbackInterfaceDocExportFileCallback.read(buf)
+            return FfiConverterString.read(buf)
         else:
             raise InternalError("Unexpected flag byte for optional type")
 
 
 
-class _UniffiConverterOptionalCallbackInterfaceDocImportFileCallback(_UniffiConverterRustBuffer):
+class FfiConverterOptionalTypeConnectionInfo(FfiConverterRustBuffer):
     @classmethod
     def write(cls, value, buf):
         if value is None:
-            buf.write_u8(0)
+            buf.writeU8(0)
             return
 
-        buf.write_u8(1)
-        _UniffiConverterCallbackInterfaceDocImportFileCallback.write(value, buf)
+        buf.writeU8(1)
+        FfiConverterTypeConnectionInfo.write(value, buf)
 
     @classmethod
     def read(cls, buf):
-        flag = buf.read_u8()
+        flag = buf.readU8()
         if flag == 0:
             return None
         elif flag == 1:
-            return _UniffiConverterCallbackInterfaceDocImportFileCallback.read(buf)
+            return FfiConverterTypeConnectionInfo.read(buf)
         else:
             raise InternalError("Unexpected flag byte for optional type")
 
 
 
-class _UniffiConverterSequenceString(_UniffiConverterRustBuffer):
-    @classmethod
-    def write(cls, value, buf):
-        items = len(value)
-        buf.write_i32(items)
-        for item in value:
-            _UniffiConverterString.write(item, buf)
-
-    @classmethod
-    def read(cls, buf):
-        count = buf.read_i32()
-        if count < 0:
-            raise InternalError("Unexpected negative sequence length")
-
-        return [
-            _UniffiConverterString.read(buf) for i in range(count)
-        ]
-
-
-
-class _UniffiConverterSequenceTypeAuthorId(_UniffiConverterRustBuffer):
-    @classmethod
-    def write(cls, value, buf):
-        items = len(value)
-        buf.write_i32(items)
-        for item in value:
-            _UniffiConverterTypeAuthorId.write(item, buf)
-
-    @classmethod
-    def read(cls, buf):
-        count = buf.read_i32()
-        if count < 0:
-            raise InternalError("Unexpected negative sequence length")
-
-        return [
-            _UniffiConverterTypeAuthorId.read(buf) for i in range(count)
-        ]
-
-
-
-class _UniffiConverterSequenceTypeDirectAddrInfo(_UniffiConverterRustBuffer):
-    @classmethod
-    def write(cls, value, buf):
-        items = len(value)
-        buf.write_i32(items)
-        for item in value:
-            _UniffiConverterTypeDirectAddrInfo.write(item, buf)
-
-    @classmethod
-    def read(cls, buf):
-        count = buf.read_i32()
-        if count < 0:
-            raise InternalError("Unexpected negative sequence length")
-
-        return [
-            _UniffiConverterTypeDirectAddrInfo.read(buf) for i in range(count)
-        ]
-
-
-
-class _UniffiConverterSequenceTypeEntry(_UniffiConverterRustBuffer):
-    @classmethod
-    def write(cls, value, buf):
-        items = len(value)
-        buf.write_i32(items)
-        for item in value:
-            _UniffiConverterTypeEntry.write(item, buf)
-
-    @classmethod
-    def read(cls, buf):
-        count = buf.read_i32()
-        if count < 0:
-            raise InternalError("Unexpected negative sequence length")
-
-        return [
-            _UniffiConverterTypeEntry.read(buf) for i in range(count)
-        ]
-
-
-
-class _UniffiConverterSequenceTypeFilterKind(_UniffiConverterRustBuffer):
-    @classmethod
-    def write(cls, value, buf):
-        items = len(value)
-        buf.write_i32(items)
-        for item in value:
-            _UniffiConverterTypeFilterKind.write(item, buf)
-
-    @classmethod
-    def read(cls, buf):
-        count = buf.read_i32()
-        if count < 0:
-            raise InternalError("Unexpected negative sequence length")
-
-        return [
-            _UniffiConverterTypeFilterKind.read(buf) for i in range(count)
-        ]
-
-
-
-class _UniffiConverterSequenceTypeHash(_UniffiConverterRustBuffer):
-    @classmethod
-    def write(cls, value, buf):
-        items = len(value)
-        buf.write_i32(items)
-        for item in value:
-            _UniffiConverterTypeHash.write(item, buf)
-
-    @classmethod
-    def read(cls, buf):
-        count = buf.read_i32()
-        if count < 0:
-            raise InternalError("Unexpected negative sequence length")
-
-        return [
-            _UniffiConverterTypeHash.read(buf) for i in range(count)
-        ]
-
-
-
-class _UniffiConverterSequenceTypeNodeAddr(_UniffiConverterRustBuffer):
-    @classmethod
-    def write(cls, value, buf):
-        items = len(value)
-        buf.write_i32(items)
-        for item in value:
-            _UniffiConverterTypeNodeAddr.write(item, buf)
-
-    @classmethod
-    def read(cls, buf):
-        count = buf.read_i32()
-        if count < 0:
-            raise InternalError("Unexpected negative sequence length")
-
-        return [
-            _UniffiConverterTypeNodeAddr.read(buf) for i in range(count)
-        ]
-
-
-
-class _UniffiConverterSequenceTypeBlobListCollectionsResponse(_UniffiConverterRustBuffer):
+class FfiConverterSequenceTypeAuthorId(FfiConverterRustBuffer):
     @classmethod
     def write(cls, value, buf):
         items = len(value)
-        buf.write_i32(items)
+        buf.writeI32(items)
         for item in value:
-            _UniffiConverterTypeBlobListCollectionsResponse.write(item, buf)
+            FfiConverterTypeAuthorId.write(item, buf)
 
     @classmethod
     def read(cls, buf):
-        count = buf.read_i32()
+        count = buf.readI32()
         if count < 0:
             raise InternalError("Unexpected negative sequence length")
 
         return [
-            _UniffiConverterTypeBlobListCollectionsResponse.read(buf) for i in range(count)
+            FfiConverterTypeAuthorId.read(buf) for i in range(count)
         ]
 
 
 
-class _UniffiConverterSequenceTypeBlobListIncompleteResponse(_UniffiConverterRustBuffer):
+class FfiConverterSequenceTypeEntry(FfiConverterRustBuffer):
     @classmethod
     def write(cls, value, buf):
         items = len(value)
-        buf.write_i32(items)
+        buf.writeI32(items)
         for item in value:
-            _UniffiConverterTypeBlobListIncompleteResponse.write(item, buf)
+            FfiConverterTypeEntry.write(item, buf)
 
     @classmethod
     def read(cls, buf):
-        count = buf.read_i32()
+        count = buf.readI32()
         if count < 0:
             raise InternalError("Unexpected negative sequence length")
 
         return [
-            _UniffiConverterTypeBlobListIncompleteResponse.read(buf) for i in range(count)
+            FfiConverterTypeEntry.read(buf) for i in range(count)
         ]
 
 
 
-class _UniffiConverterSequenceTypeConnectionInfo(_UniffiConverterRustBuffer):
+class FfiConverterSequenceTypeHash(FfiConverterRustBuffer):
     @classmethod
     def write(cls, value, buf):
         items = len(value)
-        buf.write_i32(items)
+        buf.writeI32(items)
         for item in value:
-            _UniffiConverterTypeConnectionInfo.write(item, buf)
+            FfiConverterTypeHash.write(item, buf)
 
     @classmethod
     def read(cls, buf):
-        count = buf.read_i32()
+        count = buf.readI32()
         if count < 0:
             raise InternalError("Unexpected negative sequence length")
 
         return [
-            _UniffiConverterTypeConnectionInfo.read(buf) for i in range(count)
+            FfiConverterTypeHash.read(buf) for i in range(count)
         ]
 
 
 
-class _UniffiConverterSequenceTypeLinkAndName(_UniffiConverterRustBuffer):
+class FfiConverterSequenceTypeConnectionInfo(FfiConverterRustBuffer):
     @classmethod
     def write(cls, value, buf):
         items = len(value)
-        buf.write_i32(items)
+        buf.writeI32(items)
         for item in value:
-            _UniffiConverterTypeLinkAndName.write(item, buf)
+            FfiConverterTypeConnectionInfo.write(item, buf)
 
     @classmethod
     def read(cls, buf):
-        count = buf.read_i32()
+        count = buf.readI32()
         if count < 0:
             raise InternalError("Unexpected negative sequence length")
 
         return [
-            _UniffiConverterTypeLinkAndName.read(buf) for i in range(count)
+            FfiConverterTypeConnectionInfo.read(buf) for i in range(count)
         ]
 
 
 
-class _UniffiConverterSequenceTypeListTagsResponse(_UniffiConverterRustBuffer):
+class FfiConverterSequenceTypeSocketAddr(FfiConverterRustBuffer):
     @classmethod
     def write(cls, value, buf):
         items = len(value)
-        buf.write_i32(items)
+        buf.writeI32(items)
         for item in value:
-            _UniffiConverterTypeListTagsResponse.write(item, buf)
+            FfiConverterTypeSocketAddr.write(item, buf)
 
     @classmethod
     def read(cls, buf):
-        count = buf.read_i32()
+        count = buf.readI32()
         if count < 0:
             raise InternalError("Unexpected negative sequence length")
 
         return [
-            _UniffiConverterTypeListTagsResponse.read(buf) for i in range(count)
+            FfiConverterTypeSocketAddr.read(buf) for i in range(count)
         ]
 
 
 
-class _UniffiConverterSequenceTypeNamespaceAndCapability(_UniffiConverterRustBuffer):
+class FfiConverterSequenceOptionalDouble(FfiConverterRustBuffer):
     @classmethod
     def write(cls, value, buf):
         items = len(value)
-        buf.write_i32(items)
+        buf.writeI32(items)
         for item in value:
-            _UniffiConverterTypeNamespaceAndCapability.write(item, buf)
+            FfiConverterOptionalDouble.write(item, buf)
 
     @classmethod
     def read(cls, buf):
-        count = buf.read_i32()
+        count = buf.readI32()
         if count < 0:
             raise InternalError("Unexpected negative sequence length")
 
         return [
-            _UniffiConverterTypeNamespaceAndCapability.read(buf) for i in range(count)
+            FfiConverterOptionalDouble.read(buf) for i in range(count)
         ]
 
 
 
-class _UniffiConverterMapStringTypeCounterStats(_UniffiConverterRustBuffer):
+class FfiConverterMapStringTypeCounterStats(FfiConverterRustBuffer):
     @classmethod
     def write(cls, items, buf):
-        buf.write_i32(len(items))
+        buf.writeI32(len(items))
         for (key, value) in items.items():
-            _UniffiConverterString.write(key, buf)
-            _UniffiConverterTypeCounterStats.write(value, buf)
+            FfiConverterString.write(key, buf)
+            FfiConverterTypeCounterStats.write(value, buf)
 
     @classmethod
     def read(cls, buf):
-        count = buf.read_i32()
+        count = buf.readI32()
         if count < 0:
             raise InternalError("Unexpected negative map size")
 
         # It would be nice to use a dict comprehension,
         # but in Python 3.7 and before the evaluation order is not according to spec,
         # so we we're reading the value before the key.
         # This loop makes the order explicit: first reading the key, then the value.
         d = {}
         for i in range(count):
-            key = _UniffiConverterString.read(buf)
-            val = _UniffiConverterTypeCounterStats.read(buf)
+            key = FfiConverterString.read(buf)
+            val = FfiConverterTypeCounterStats.read(buf)
             d[key] = val
         return d
 
-def key_to_path(key: "bytes",prefix: "typing.Optional[str]",root: "typing.Optional[str]") -> "str":
-    '''
-    Helper function that translates a key that was derived from the [`path_to_key`] function back
-    into a path.
-
-    If `prefix` exists, it will be stripped before converting back to a path
-    If `root` exists, will add the root as a parent to the created path
-    Removes any null byte that has been appened to the key
-    '''
-    
-    
-    
-    return _UniffiConverterString.lift(_rust_call_with_error(_UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_func_key_to_path,
-        _UniffiConverterBytes.lower(key),
-        _UniffiConverterOptionalString.lower(prefix),
-        _UniffiConverterOptionalString.lower(root)))
-
-
-def path_to_key(path: "str",prefix: "typing.Optional[str]",root: "typing.Optional[str]") -> "bytes":
-    '''
-    Helper function that creates a document key from a canonicalized path, removing the `root` and adding the `prefix`, if they exist
-
-    Appends the null byte to the end of the key.
-    '''
-    
-    
-    
-    return _UniffiConverterBytes.lift(_rust_call_with_error(_UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_func_path_to_key,
-        _UniffiConverterString.lower(path),
-        _UniffiConverterOptionalString.lower(prefix),
-        _UniffiConverterOptionalString.lower(root)))
-
-
 def set_log_level(level: "LogLevel"):
-    '''Set the logging level.'''
     
-    _rust_call(_UniffiLib.uniffi_iroh_fn_func_set_log_level,
-        _UniffiConverterTypeLogLevel.lower(level))
+    rust_call(_UniFFILib.uniffi_iroh_fn_func_set_log_level,
+        FfiConverterTypeLogLevel.lower(level))
 
 
 def start_metrics_collection():
-    '''Initialize the global metrics collection.'''
-    _rust_call_with_error(_UniffiConverterTypeIrohError,_UniffiLib.uniffi_iroh_fn_func_start_metrics_collection,)
+    rust_call_with_error(FfiConverterTypeIrohError,_UniFFILib.uniffi_iroh_fn_func_start_metrics_collection,)
 
 
 __all__ = [
     "InternalError",
-    "AddProgressType",
-    "BlobExportFormat",
-    "BlobExportMode",
-    "BlobFormat",
-    "CapabilityKind",
-    "ConnType",
+    "ConnectionType",
     "ContentStatus",
-    "DocExportProgressType",
-    "DocImportProgressType",
-    "DownloadProgressType",
     "IrohError",
     "LiveEventType",
     "LogLevel",
     "Origin",
-    "ShareMode",
-    "ShareTicketOptions",
-    "SortBy",
-    "SortDirection",
+    "SocketAddr",
     "SyncReason",
-    "AddProgressAbort",
-    "AddProgressAllDone",
-    "AddProgressDone",
-    "AddProgressFound",
-    "AddProgressProgress",
-    "BlobAddOutcome",
-    "BlobListCollectionsResponse",
-    "BlobListIncompleteResponse",
-    "BlobListResponse",
     "ConnectionInfo",
-    "ConnectionTypeMixed",
     "CounterStats",
-    "DocExportProgressAbort",
-    "DocExportProgressFound",
-    "DocExportProgressProgress",
-    "DocImportProgressAbort",
-    "DocImportProgressAllDone",
-    "DocImportProgressFound",
-    "DocImportProgressIngestDone",
-    "DocImportProgressProgress",
-    "DownloadProgressAbort",
-    "DownloadProgressAllDone",
-    "DownloadProgressDone",
-    "DownloadProgressFound",
-    "DownloadProgressFoundHashSeq",
-    "DownloadProgressFoundLocal",
-    "DownloadProgressProgress",
-    "HashAndTag",
     "InsertRemoteEvent",
-    "LatencyAndControlMsg",
-    "LinkAndName",
-    "ListTagsResponse",
-    "NamespaceAndCapability",
-    "NodeOptions",
-    "OpenState",
-    "QueryOptions",
+    "LiveStatus",
     "SyncEvent",
-    "key_to_path",
-    "path_to_key",
     "set_log_level",
     "start_metrics_collection",
-    "AddProgress",
-    "AuthorId",
-    "BlobDownloadRequest",
-    "BlobTicket",
-    "Collection",
-    "ConnectionType",
-    "DirectAddrInfo",
+    "IrohNode",
     "Doc",
-    "DocExportProgress",
-    "DocImportProgress",
-    "DownloadPolicy",
-    "DownloadProgress",
+    "AuthorId",
     "Entry",
-    "FilterKind",
     "Hash",
-    "IrohNode",
+    "DocTicket",
     "LiveEvent",
-    "NodeAddr",
-    "NodeStatusResponse",
+    "NamespaceId",
     "PublicKey",
-    "Query",
-    "RangeSpec",
-    "SetTagOption",
-    "WrapOption",
-    "AddCallback",
-    "DocExportFileCallback",
-    "DocImportFileCallback",
-    "DownloadCallback",
     "SubscribeCallback",
 ]
```

