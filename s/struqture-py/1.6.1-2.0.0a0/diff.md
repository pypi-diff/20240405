# Comparing `tmp/struqture_py-1.6.1.tar.gz` & `tmp/struqture_py-2.0.0a0.tar.gz`

## Comparing `struqture_py-1.6.1.tar` & `struqture_py-2.0.0a0.tar`

### file list

```diff
@@ -1,108 +1,97 @@
--rw-r--r--   0     1001      127     1131 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/Cargo.toml
--rw-r--r--   0     1001      127    11363 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/LICENSE
--rw-r--r--   0     1001      127    29521 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/bosons/bosonic_hamiltonian.rs
--rw-r--r--   0     1001      127    19443 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/bosons/bosonic_hamiltonian_system.rs
--rw-r--r--   0     1001      127    46497 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/bosons/bosonic_indices.rs
--rw-r--r--   0     1001      127    26166 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/bosons/bosonic_noise_operator.rs
--rw-r--r--   0     1001      127    18806 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/bosons/bosonic_noise_system.rs
--rw-r--r--   0     1001      127    10535 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/bosons/bosonic_open_system.rs
--rw-r--r--   0     1001      127    24663 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/bosons/bosonic_operator.rs
--rw-r--r--   0     1001      127    17333 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/bosons/bosonic_system.rs
--rw-r--r--   0     1001      127     3411 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/bosons/mod.rs
--rw-r--r--   0     1001      127    31002 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/fermions/fermionic_hamiltonian.rs
--rw-r--r--   0     1001      127    20720 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/fermions/fermionic_hamiltonian_system.rs
--rw-r--r--   0     1001      127    59790 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/fermions/fermionic_indices.rs
--rw-r--r--   0     1001      127    30020 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/fermions/fermionic_noise_operator.rs
--rw-r--r--   0     1001      127    19968 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/fermions/fermionic_noise_system.rs
--rw-r--r--   0     1001      127    11708 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/fermions/fermionic_open_system.rs
--rw-r--r--   0     1001      127    25882 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/fermions/fermionic_operator.rs
--rw-r--r--   0     1001      127    18560 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/fermions/fermionic_system.rs
--rw-r--r--   0     1001      127     3509 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/fermions/mod.rs
--rw-r--r--   0     1001      127    39112 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/lib.rs
--rw-r--r--   0     1001      127     2201 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/mappings/jordan_wigner.rs
--rw-r--r--   0     1001      127      839 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/mappings/mod.rs
--rw-r--r--   0     1001      127    22877 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/mixed_systems/mixed_decoherence_product.rs
--rw-r--r--   0     1001      127    33298 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/mixed_systems/mixed_hamiltonian.rs
--rw-r--r--   0     1001      127    31469 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/mixed_systems/mixed_hamiltonian_system.rs
--rw-r--r--   0     1001      127    38219 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/mixed_systems/mixed_hermitian_product.rs
--rw-r--r--   0     1001      127    39057 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/mixed_systems/mixed_noise_operator.rs
--rw-r--r--   0     1001      127    34632 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/mixed_systems/mixed_noise_system.rs
--rw-r--r--   0     1001      127    17155 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/mixed_systems/mixed_open_system.rs
--rw-r--r--   0     1001      127    31686 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/mixed_systems/mixed_operator.rs
--rw-r--r--   0     1001      127    33989 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/mixed_systems/mixed_plus_minus_operator.rs
--rw-r--r--   0     1001      127    19475 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/mixed_systems/mixed_plus_minus_product.rs
--rw-r--r--   0     1001      127    29484 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/mixed_systems/mixed_product.rs
--rw-r--r--   0     1001      127    30216 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/mixed_systems/mixed_system.rs
--rw-r--r--   0     1001      127     9315 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/mixed_systems/mod.rs
--rw-r--r--   0     1001      127     1159 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/prelude.rs
--rw-r--r--   0     1001      127    26697 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/spins/decoherence_operator.rs
--rw-r--r--   0     1001      127    38073 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/spins/decoherence_product.rs
--rw-r--r--   0     1001      127    20752 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/spins/mod.rs
--rw-r--r--   0     1001      127    27414 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/spins/pauli_product.rs
--rw-r--r--   0     1001      127    31999 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/spins/plus_minus_noise_operator.rs
--rw-r--r--   0     1001      127    29395 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/spins/plus_minus_operator.rs
--rw-r--r--   0     1001      127    41997 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/spins/plus_minus_product.rs
--rw-r--r--   0     1001      127    27817 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/spins/spin_hamiltonian.rs
--rw-r--r--   0     1001      127    21141 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/spins/spin_hamiltonian_system.rs
--rw-r--r--   0     1001      127    38362 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/spins/spin_noise_operator.rs
--rw-r--r--   0     1001      127    20965 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/spins/spin_noise_system.rs
--rw-r--r--   0     1001      127    13420 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/spins/spin_open_system.rs
--rw-r--r--   0     1001      127    28902 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/spins/spin_operator.rs
--rw-r--r--   0     1001      127    19362 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture/src/spins/spin_system.rs
--rw-r--r--   0     1001      127     3073 2024-03-05 13:43:29.000000 struqture_py-1.6.1/README.md
--rw-r--r--   0     1001      127      481 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py-macros/Cargo.toml
--rw-r--r--   0     1001      127    11363 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py-macros/LICENSE
--rw-r--r--   0     1001      127     3868 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py-macros/src/lib.rs
--rw-r--r--   0     1001      127     6356 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py-macros/src/mappings.rs
--rw-r--r--   0     1001      127    35539 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py-macros/src/noiseless_system_wrapper.rs
--rw-r--r--   0     1001      127    46523 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py-macros/src/noisy_system_wrapper.rs
--rw-r--r--   0     1001      127    25128 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py-macros/src/product_wrapper.rs
--rw-r--r--   0        0        0     1620 1970-01-01 00:00:00.000000 struqture_py-1.6.1/struqture-py/Cargo.toml
--rw-r--r--   0     1001      127      701 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/build.rs
--rw-r--r--   0     1001      127     3288 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/bosons/boson_product.rs
--rw-r--r--   0     1001      127     5081 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/bosons/bosonic_hamiltonian_system.rs
--rw-r--r--   0     1001      127     4283 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/bosons/bosonic_noise_system.rs
--rw-r--r--   0     1001      127     2844 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/bosons/bosonic_open_system.rs
--rw-r--r--   0     1001      127     4459 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/bosons/bosonic_system.rs
--rw-r--r--   0     1001      127     3702 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/bosons/hermitian_boson_product.rs
--rw-r--r--   0     1001      127     2885 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/bosons/mod.rs
--rw-r--r--   0     1001      127     3640 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/fermions/fermion_product.rs
--rw-r--r--   0     1001      127     5507 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/fermions/fermionic_hamiltonian_system.rs
--rw-r--r--   0     1001      127     4502 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/fermions/fermionic_noise_system.rs
--rw-r--r--   0     1001      127     3045 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/fermions/fermionic_open_system.rs
--rw-r--r--   0     1001      127     4679 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/fermions/fermionic_system.rs
--rw-r--r--   0     1001      127     3956 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/fermions/hermitian_fermion_product.rs
--rw-r--r--   0     1001      127     2975 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/fermions/mod.rs
--rw-r--r--   0     1001      127     3200 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/lib.rs
--rw-r--r--   0     1001      127     9190 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/mixed_systems/mixed_decoherence_product.rs
--rw-r--r--   0     1001      127     6525 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/mixed_systems/mixed_hamiltonian_system.rs
--rw-r--r--   0     1001      127     9133 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/mixed_systems/mixed_hermitian_product.rs
--rw-r--r--   0     1001      127     4839 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/mixed_systems/mixed_noise_system.rs
--rw-r--r--   0     1001      127     3602 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/mixed_systems/mixed_open_system.rs
--rw-r--r--   0     1001      127     6971 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/mixed_systems/mixed_plus_minus_operator.rs
--rw-r--r--   0     1001      127     7594 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/mixed_systems/mixed_plus_minus_product.rs
--rw-r--r--   0     1001      127     8775 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/mixed_systems/mixed_product.rs
--rw-r--r--   0     1001      127     5437 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/mixed_systems/mixed_system.rs
--rw-r--r--   0     1001      127     2995 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/mixed_systems/mod.rs
--rw-r--r--   0     1001      127     4957 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/spins/decoherence_product.rs
--rw-r--r--   0     1001      127     2431 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/spins/mod.rs
--rw-r--r--   0     1001      127     4826 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/spins/pauli_product.rs
--rw-r--r--   0     1001      127     7413 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/spins/plus_minus_noise_operator.rs
--rw-r--r--   0     1001      127     9607 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/spins/plus_minus_operator.rs
--rw-r--r--   0     1001      127    12596 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/spins/plus_minus_product.rs
--rw-r--r--   0     1001      127     5527 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/spins/spin_hamiltonian_system.rs
--rw-r--r--   0     1001      127     4484 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/spins/spin_noise_system.rs
--rw-r--r--   0     1001      127     3332 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/spins/spin_open_system.rs
--rw-r--r--   0     1001      127     4917 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/src/spins/spin_system.rs
--rw-r--r--   0     1001      127  2355516 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/struqture_py/DEPENDENCIES
--rw-r--r--   0     1001      127      503 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/struqture_py/LICENSE_FOR_BINARY_DISTRIBUTION
--rw-r--r--   0     1001      127     2404 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/struqture_py/PYTHON_LICENSE
--rw-r--r--   0     1001      127      443 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture-py/struqture_py/__init__.py
--rw-r--r--   0     1001      127    54793 2024-03-05 13:43:29.000000 struqture_py-1.6.1/Cargo.lock
--rw-r--r--   0        0        0      126 1970-01-01 00:00:00.000000 struqture_py-1.6.1/Cargo.toml
--rw-r--r--   0        0        0      579 1970-01-01 00:00:00.000000 struqture_py-1.6.1/pyproject.toml
--rw-r--r--   0     1001      127  2355516 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture_py/DEPENDENCIES
--rw-r--r--   0     1001      127      503 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture_py/LICENSE_FOR_BINARY_DISTRIBUTION
--rw-r--r--   0     1001      127     2404 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture_py/PYTHON_LICENSE
--rw-r--r--   0     1001      127      443 2024-03-05 13:43:29.000000 struqture_py-1.6.1/struqture_py/__init__.py
--rw-r--r--   0        0        0     3745 1970-01-01 00:00:00.000000 struqture_py-1.6.1/PKG-INFO
+-rw-r--r--   0     1001      127     1234 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/Cargo.toml
+-rw-r--r--   0     1001      127    11363 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/LICENSE
+-rw-r--r--   0     1001      127    29116 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/bosons/bosonic_hamiltonian.rs
+-rw-r--r--   0     1001      127    48450 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/bosons/bosonic_indices.rs
+-rw-r--r--   0     1001      127    25266 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/bosons/bosonic_noise_operator.rs
+-rw-r--r--   0     1001      127    10169 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/bosons/bosonic_open_system.rs
+-rw-r--r--   0     1001      127    24260 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/bosons/bosonic_operator.rs
+-rw-r--r--   0     1001      127     3180 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/bosons/mod.rs
+-rw-r--r--   0     1001      127    30637 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/fermions/fermionic_hamiltonian.rs
+-rw-r--r--   0     1001      127    61833 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/fermions/fermionic_indices.rs
+-rw-r--r--   0     1001      127    29180 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/fermions/fermionic_noise_operator.rs
+-rw-r--r--   0     1001      127    11356 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/fermions/fermionic_open_system.rs
+-rw-r--r--   0     1001      127    25560 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/fermions/fermionic_operator.rs
+-rw-r--r--   0     1001      127     3260 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/fermions/mod.rs
+-rw-r--r--   0     1001      127    38866 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/lib.rs
+-rw-r--r--   0     1001      127     2209 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/mappings/jordan_wigner.rs
+-rw-r--r--   0     1001      127      839 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/mappings/mod.rs
+-rw-r--r--   0     1001      127    23947 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/mixed_systems/mixed_decoherence_product.rs
+-rw-r--r--   0     1001      127    33371 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/mixed_systems/mixed_hamiltonian.rs
+-rw-r--r--   0     1001      127    39252 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/mixed_systems/mixed_hermitian_product.rs
+-rw-r--r--   0     1001      127    38319 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/mixed_systems/mixed_noise_operator.rs
+-rw-r--r--   0     1001      127    12168 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/mixed_systems/mixed_open_system.rs
+-rw-r--r--   0     1001      127    31549 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/mixed_systems/mixed_operator.rs
+-rw-r--r--   0     1001      127    33885 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/mixed_systems/mixed_plus_minus_operator.rs
+-rw-r--r--   0     1001      127    20394 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/mixed_systems/mixed_plus_minus_product.rs
+-rw-r--r--   0     1001      127    30500 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/mixed_systems/mixed_product.rs
+-rw-r--r--   0     1001      127     7779 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/mixed_systems/mod.rs
+-rw-r--r--   0     1001      127     1159 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/prelude.rs
+-rw-r--r--   0     1001      127    10394 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/serialisation_meta_information.rs
+-rw-r--r--   0     1001      127    26141 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/spins/decoherence_operator.rs
+-rw-r--r--   0     1001      127    39095 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/spins/decoherence_product.rs
+-rw-r--r--   0     1001      127    20508 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/spins/mod.rs
+-rw-r--r--   0     1001      127    28429 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/spins/pauli_product.rs
+-rw-r--r--   0     1001      127    31800 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/spins/plus_minus_noise_operator.rs
+-rw-r--r--   0     1001      127    29493 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/spins/plus_minus_operator.rs
+-rw-r--r--   0     1001      127    42865 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/spins/plus_minus_product.rs
+-rw-r--r--   0     1001      127    27826 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/spins/qubit_hamiltonian.rs
+-rw-r--r--   0     1001      127    39223 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/spins/qubit_noise_operator.rs
+-rw-r--r--   0     1001      127    13226 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/spins/qubit_open_system.rs
+-rw-r--r--   0     1001      127    28675 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture/src/spins/qubit_operator.rs
+-rw-r--r--   0     1001      127     3075 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/README.md
+-rw-r--r--   0     1001      127      489 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py-macros/Cargo.toml
+-rw-r--r--   0     1001      127    11363 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py-macros/LICENSE
+-rw-r--r--   0     1001      127     3868 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py-macros/src/lib.rs
+-rw-r--r--   0     1001      127     5768 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py-macros/src/mappings.rs
+-rw-r--r--   0     1001      127    39668 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py-macros/src/noiseless_system_wrapper.rs
+-rw-r--r--   0     1001      127    54424 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py-macros/src/noisy_system_wrapper.rs
+-rw-r--r--   0     1001      127    32254 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py-macros/src/product_wrapper.rs
+-rw-r--r--   0        0        0     1822 1970-01-01 00:00:00.000000 struqture_py-2.0.0a0/struqture-py/Cargo.toml
+-rw-r--r--   0     1001      127      701 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/build.rs
+-rw-r--r--   0     1001      127     3302 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/bosons/boson_product.rs
+-rw-r--r--   0     1001      127     4565 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/bosons/bosonic_hamiltonian.rs
+-rw-r--r--   0     1001      127     2550 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/bosons/bosonic_noise_operator.rs
+-rw-r--r--   0     1001      127     2619 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/bosons/bosonic_open_system.rs
+-rw-r--r--   0     1001      127     4387 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/bosons/bosonic_operator.rs
+-rw-r--r--   0     1001      127     3716 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/bosons/hermitian_boson_product.rs
+-rw-r--r--   0     1001      127     2867 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/bosons/mod.rs
+-rw-r--r--   0     1001      127     3632 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/fermions/fermion_product.rs
+-rw-r--r--   0     1001      127     5274 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/fermions/fermionic_hamiltonian.rs
+-rw-r--r--   0     1001      127     2766 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/fermions/fermionic_noise_operator.rs
+-rw-r--r--   0     1001      127     2809 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/fermions/fermionic_open_system.rs
+-rw-r--r--   0     1001      127     4600 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/fermions/fermionic_operator.rs
+-rw-r--r--   0     1001      127     3940 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/fermions/hermitian_fermion_product.rs
+-rw-r--r--   0     1001      127     2957 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/fermions/mod.rs
+-rw-r--r--   0     1001      127     3200 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/lib.rs
+-rw-r--r--   0     1001      127     9204 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/mixed_systems/mixed_decoherence_product.rs
+-rw-r--r--   0     1001      127     5851 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/mixed_systems/mixed_hamiltonian.rs
+-rw-r--r--   0     1001      127     9147 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/mixed_systems/mixed_hermitian_product.rs
+-rw-r--r--   0     1001      127     3351 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/mixed_systems/mixed_noise_operator.rs
+-rw-r--r--   0     1001      127     3427 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/mixed_systems/mixed_open_system.rs
+-rw-r--r--   0     1001      127     5322 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/mixed_systems/mixed_operator.rs
+-rw-r--r--   0     1001      127     6223 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/mixed_systems/mixed_plus_minus_operator.rs
+-rw-r--r--   0     1001      127     7608 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/mixed_systems/mixed_plus_minus_product.rs
+-rw-r--r--   0     1001      127     8789 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/mixed_systems/mixed_product.rs
+-rw-r--r--   0     1001      127     2981 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/mixed_systems/mod.rs
+-rw-r--r--   0     1001      127     4945 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/spins/decoherence_product.rs
+-rw-r--r--   0     1001      127     2441 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/spins/mod.rs
+-rw-r--r--   0     1001      127     4844 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/spins/pauli_product.rs
+-rw-r--r--   0     1001      127     4324 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/spins/plus_minus_noise_operator.rs
+-rw-r--r--   0     1001      127     6659 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/spins/plus_minus_operator.rs
+-rw-r--r--   0     1001      127     9350 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/spins/plus_minus_product.rs
+-rw-r--r--   0     1001      127     5038 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/spins/qubit_hamiltonian.rs
+-rw-r--r--   0     1001      127     4313 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/spins/qubit_noise_operator.rs
+-rw-r--r--   0     1001      127     3154 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/spins/qubit_open_system.rs
+-rw-r--r--   0     1001      127     4880 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/src/spins/qubit_operator.rs
+-rw-r--r--   0     1001      127  2355516 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/struqture_py/DEPENDENCIES
+-rw-r--r--   0     1001      127      503 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/struqture_py/LICENSE_FOR_BINARY_DISTRIBUTION
+-rw-r--r--   0     1001      127     2404 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/struqture_py/PYTHON_LICENSE
+-rw-r--r--   0     1001      127      443 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture-py/struqture_py/__init__.py
+-rw-r--r--   0     1001      127    55215 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/Cargo.lock
+-rw-r--r--   0        0        0      126 1970-01-01 00:00:00.000000 struqture_py-2.0.0a0/Cargo.toml
+-rw-r--r--   0        0        0      587 1970-01-01 00:00:00.000000 struqture_py-2.0.0a0/pyproject.toml
+-rw-r--r--   0     1001      127      443 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture_py/__init__.py
+-rw-r--r--   0     1001      127  2355516 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture_py/DEPENDENCIES
+-rw-r--r--   0     1001      127      503 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture_py/LICENSE_FOR_BINARY_DISTRIBUTION
+-rw-r--r--   0     1001      127     2404 2024-04-05 08:27:01.000000 struqture_py-2.0.0a0/struqture_py/PYTHON_LICENSE
+-rw-r--r--   0        0        0     3749 1970-01-01 00:00:00.000000 struqture_py-2.0.0a0/PKG-INFO
```

### Comparing `struqture_py-1.6.1/struqture/Cargo.toml` & `struqture_py-2.0.0a0/struqture/Cargo.toml`

 * *Files 16% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 [package]
 name = "struqture"
-version = "1.6.1"
+version = "2.0.0-alpha.0"
 authors = ["HQS Quantum Simulations <info@quantumsimulations.de>"]
 edition = "2021"
 rust-version = "1.57"
 categories = ["science", "simulation"]
 description = "HQS tool for representing operators, Hamiltonians and open systems."
 license = "Apache-2.0"
 include = ["Cargo.toml", "src*", "LICENSE", "../README.md"]
@@ -21,22 +21,24 @@
 num-complex = { version = "0.4"}
 thiserror = "1.0"
 test-case = "3.1"
 itertools = "0.12"
 ndarray = {version="0.15"}
 tinyvec = {version="1.6", features=["alloc", "serde"]}
 schemars ={version="0.8.12", optional=true}
-indexmap = {version="2", optional=true}
+indexmap = {version="2"}
+struqture_one = {package = "struqture", version="=1", optional=true}
 
 [dev-dependencies]
 nalgebra = "0.32"
 serde_test = {version="1.0"}
 bincode = "1.3"
 serde_json = "1.0"
 rand = "0.8"
 jsonschema = {version = "0.17"}
 criterion = {version = "0.5"}
 
 [features]
 default = ["json_schema"]
 json_schema = ["schemars", "qoqo_calculator/json_schema"]
-indexed_map_iterators = ["indexmap"]
+struqture_1_export = ["struqture_one"]
+struqture_1_import = ["struqture_one"]
```

### Comparing `struqture_py-1.6.1/struqture/LICENSE` & `struqture_py-2.0.0a0/struqture/LICENSE`

 * *Files identical despite different names*

### Comparing `struqture_py-1.6.1/struqture/src/bosons/bosonic_hamiltonian.rs` & `struqture_py-2.0.0a0/struqture/src/bosons/bosonic_hamiltonian.rs`

 * *Files 18% similar despite different names*

```diff
@@ -9,30 +9,24 @@
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
 use super::{BosonOperator, BosonProduct, HermitianBosonProduct, ModeIndex, OperateOnBosons};
 use crate::{
     GetValue, OperateOnDensityMatrix, OperateOnModes, OperateOnState, StruqtureError,
-    StruqtureVersionSerializable, SymmetricIndex, MINIMUM_STRUQTURE_VERSION,
+    SymmetricIndex,
 };
 use qoqo_calculator::{CalculatorComplex, CalculatorFloat};
 use serde::{Deserialize, Serialize};
 use std::fmt::{self, Write};
 use std::iter::{FromIterator, IntoIterator};
 use std::ops;
 
-#[cfg(feature = "indexed_map_iterators")]
-use indexmap::map::{Entry, Iter, Keys, Values};
-#[cfg(feature = "indexed_map_iterators")]
+use indexmap::map::{Entry, Iter};
 use indexmap::IndexMap;
-#[cfg(not(feature = "indexed_map_iterators"))]
-use std::collections::hash_map::{Entry, Iter, Keys, Values};
-#[cfg(not(feature = "indexed_map_iterators"))]
-use std::collections::HashMap;
 
 /// BosonHamiltonians are combinations of HermitianBosonProducts with specific CalculatorComplex coefficients.
 ///
 /// This is a representation of sums of creation and annihilation operators with weightings (and their hermitian conjugates), in order to build a full hamiltonian.
 /// BosonHamiltonian is the hermitian equivalent of BosonOperator.
 ///
 /// # Example
@@ -52,25 +46,26 @@
 ///
 /// // Access what you set:
 /// assert_eq!(sh.get(&bp_0), &CalculatorComplex::from(0.5));
 /// assert_eq!(sh.get(&bp_1), &CalculatorComplex::from(0.2));
 /// ```
 ///
 #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
-#[serde(from = "BosonHamiltonianSerialize")]
+#[serde(try_from = "BosonHamiltonianSerialize")]
 #[serde(into = "BosonHamiltonianSerialize")]
 pub struct BosonHamiltonian {
     /// The internal HashMap of HermitianBosonProducts and coefficients (CalculatorComplex)
-    #[cfg(feature = "indexed_map_iterators")]
     internal_map: IndexMap<HermitianBosonProduct, CalculatorComplex>,
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    internal_map: HashMap<HermitianBosonProduct, CalculatorComplex>,
 }
 
-impl crate::MinSupportedVersion for BosonHamiltonian {}
+impl crate::SerializationSupport for BosonHamiltonian {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::BosonHamiltonian
+    }
+}
 
 #[cfg(feature = "json_schema")]
 impl schemars::JsonSchema for BosonHamiltonian {
     fn schema_name() -> String {
         "BosonHamiltonian".to_string()
     }
 
@@ -80,87 +75,78 @@
 }
 
 #[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
 #[cfg_attr(feature = "json_schema", derive(schemars::JsonSchema))]
 #[cfg_attr(feature = "json_schema", schemars(deny_unknown_fields))]
 struct BosonHamiltonianSerialize {
     items: Vec<(HermitianBosonProduct, CalculatorFloat, CalculatorFloat)>,
-    _struqture_version: StruqtureVersionSerializable,
+    serialisation_meta: crate::StruqtureSerialisationMeta,
 }
 
-impl From<BosonHamiltonianSerialize> for BosonHamiltonian {
-    fn from(value: BosonHamiltonianSerialize) -> Self {
+impl TryFrom<BosonHamiltonianSerialize> for BosonHamiltonian {
+    type Error = StruqtureError;
+    fn try_from(value: BosonHamiltonianSerialize) -> Result<Self, Self::Error> {
+        let target_serialisation_meta =
+            <Self as crate::SerializationSupport>::target_serialisation_meta();
+        crate::check_can_be_deserialised(&target_serialisation_meta, &value.serialisation_meta)?;
         let new_noise_op: BosonHamiltonian = value
             .items
             .into_iter()
             .map(|(key, real, imag)| (key, CalculatorComplex { re: real, im: imag }))
             .collect();
-        new_noise_op
+        Ok(new_noise_op)
     }
 }
 
 impl From<BosonHamiltonian> for BosonHamiltonianSerialize {
     fn from(value: BosonHamiltonian) -> Self {
+        let serialisation_meta = crate::SerializationSupport::struqture_serialisation_meta(&value);
         let new_noise_op: Vec<(HermitianBosonProduct, CalculatorFloat, CalculatorFloat)> = value
             .into_iter()
             .map(|(key, val)| (key, val.re, val.im))
             .collect();
-        let current_version = StruqtureVersionSerializable {
-            major_version: MINIMUM_STRUQTURE_VERSION.0,
-            minor_version: MINIMUM_STRUQTURE_VERSION.1,
-        };
         Self {
             items: new_noise_op,
-            _struqture_version: current_version,
+            serialisation_meta,
         }
     }
 }
 
 impl<'a> OperateOnDensityMatrix<'a> for BosonHamiltonian {
     type Index = HermitianBosonProduct;
     type Value = CalculatorComplex;
-    type IteratorType = Iter<'a, Self::Index, Self::Value>;
-    type KeyIteratorType = Keys<'a, Self::Index, Self::Value>;
-    type ValueIteratorType = Values<'a, Self::Index, Self::Value>;
 
     // From trait
     fn get(&self, key: &Self::Index) -> &Self::Value {
         match self.internal_map.get(key) {
             Some(value) => value,
             None => &CalculatorComplex::ZERO,
         }
     }
 
     // From trait
-    fn iter(&'a self) -> Self::IteratorType {
+    fn iter(&'a self) -> impl ExactSizeIterator<Item = (&'a Self::Index, &'a Self::Value)> {
         self.internal_map.iter()
     }
 
     // From trait
-    fn keys(&'a self) -> Self::KeyIteratorType {
+    fn keys(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Index> {
         self.internal_map.keys()
     }
 
     // From trait
-    fn values(&'a self) -> Self::ValueIteratorType {
+    fn values(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Value> {
         self.internal_map.values()
     }
 
-    #[cfg(feature = "indexed_map_iterators")]
     // From trait
     fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
         self.internal_map.shift_remove(key)
     }
 
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    // From trait
-    fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
-        self.internal_map.remove(key)
-    }
-
     // From trait
     fn empty_clone(&self, capacity: Option<usize>) -> Self {
         match capacity {
             Some(cap) => Self::with_capacity(cap),
             None => Self::new(),
         }
     }
@@ -187,18 +173,15 @@
             if key.is_natural_hermitian() && value.im != CalculatorFloat::ZERO {
                 Err(StruqtureError::NonHermitianOperator)
             } else {
                 Ok(self.internal_map.insert(key, value))
             }
         } else {
             match self.internal_map.entry(key) {
-                #[cfg(feature = "indexed_map_iterators")]
                 Entry::Occupied(val) => Ok(Some(val.shift_remove())),
-                #[cfg(not(feature = "indexed_map_iterators"))]
-                Entry::Occupied(val) => Ok(Some(val.remove())),
                 Entry::Vacant(_) => Ok(None),
             }
         }
     }
 
     /// Adds a new (HermitianBosonProduct key, CalculatorComplex value) pair to the BosonHamiltonian.
     ///
@@ -231,39 +214,30 @@
     // From trait
     fn hermitian_conjugate(&self) -> Self {
         self.clone()
     }
 }
 
 impl<'a> OperateOnModes<'a> for BosonHamiltonian {
-    /// Returns maximum index in BosonHamiltonian internal_map.
+    /// Gets the maximum index of the BosonHamiltonian.
     ///
     /// # Returns
     ///
-    /// * `usize` - Maximum index.
+    /// * `usize` - The number of modes in the BosonHamiltonian.
     fn current_number_modes(&self) -> usize {
         let mut max_mode: usize = 0;
         if !self.internal_map.is_empty() {
             for key in self.internal_map.keys() {
                 if key.current_number_modes() > max_mode {
                     max_mode = key.current_number_modes()
                 }
             }
         }
         max_mode
     }
-
-    /// Gets the maximum index of the BosonHamiltonian.
-    ///
-    /// # Returns
-    ///
-    /// * `usize` - The number of modes in the BosonHamiltonian.
-    fn number_modes(&self) -> usize {
-        self.current_number_modes()
-    }
 }
 
 impl<'a> OperateOnBosons<'a> for BosonHamiltonian {}
 
 /// Implements the default function (Default trait) of BosonHamiltonian (an empty BosonHamiltonian).
 ///
 impl Default for BosonHamiltonian {
@@ -278,17 +252,14 @@
     /// Creates a new BosonHamiltonian.
     ///
     /// # Returns
     ///
     /// * `Self` - The new (empty) BosonHamiltonian.
     pub fn new() -> Self {
         BosonHamiltonian {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::new(),
-            #[cfg(feature = "indexed_map_iterators")]
             internal_map: IndexMap::new(),
         }
     }
 
     /// Creates a new BosonHamiltonian with pre-allocated capacity.
     ///
     /// # Arguments
@@ -296,44 +267,46 @@
     /// * `capacity` - The pre-allocated capacity of the hamiltonian.
     ///
     /// # Returns
     ///
     /// * `Self` - The new (empty) BosonHamiltonian.
     pub fn with_capacity(capacity: usize) -> Self {
         Self {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::with_capacity(capacity),
-            #[cfg(feature = "indexed_map_iterators")]
             internal_map: IndexMap::with_capacity(capacity),
         }
     }
 
-    /// Separate self into an operator with the terms of given number of creation and annihilation operators and an operator with the remaining operations
-    ///
-    /// # Arguments
-    ///
-    /// * `number_creators_annihilators` - Number of creation and annihilation terms to filter for in the keys.
-    ///
-    /// # Returns
-    ///
-    /// `Ok((separated, remainder))` - Operator with the noise terms where number_creators_annihilators matches the number of spins the operator product acts on and Operator with all other contributions.
-    pub fn separate_into_n_terms(
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(
         &self,
-        number_creators_annihilators: (usize, usize),
-    ) -> Result<(Self, Self), StruqtureError> {
-        let mut separated = Self::default();
-        let mut remainder = Self::default();
-        for (prod, val) in self.iter() {
-            if (prod.creators().len(), prod.annihilators().len()) == number_creators_annihilators {
-                separated.add_operator_product(prod.clone(), val.clone())?;
-            } else {
-                remainder.add_operator_product(prod.clone(), val.clone())?;
-            }
+    ) -> Result<struqture_one::bosons::BosonHamiltonianSystem, StruqtureError> {
+        let mut new_boson_system = struqture_one::bosons::BosonHamiltonianSystem::new(None);
+        for (key, val) in self.iter() {
+            let one_key = key.to_struqture_1()?;
+            let _ = struqture_one::OperateOnDensityMatrix::set(
+                &mut new_boson_system,
+                one_key,
+                val.clone(),
+            );
+        }
+        Ok(new_boson_system)
+    }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::bosons::BosonHamiltonianSystem,
+    ) -> Result<Self, StruqtureError> {
+        let mut new_qubit_operator = Self::new();
+        for (key, val) in struqture_one::OperateOnDensityMatrix::iter(value) {
+            let self_key = HermitianBosonProduct::from_struqture_1(key)?;
+            let _ = new_qubit_operator.set(self_key, val.clone());
         }
-        Ok((separated, remainder))
+        Ok(new_qubit_operator)
     }
 }
 
 impl TryFrom<BosonOperator> for BosonHamiltonian {
     type Error = StruqtureError;
     /// Tries to convert a BosonOperator into a BosonHamiltonian.
     ///
@@ -540,17 +513,14 @@
     }
 }
 
 /// Implements the into_iter function (IntoIterator trait) of BosonHamiltonian.
 ///
 impl IntoIterator for BosonHamiltonian {
     type Item = (HermitianBosonProduct, CalculatorComplex);
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    type IntoIter = std::collections::hash_map::IntoIter<HermitianBosonProduct, CalculatorComplex>;
-    #[cfg(feature = "indexed_map_iterators")]
     type IntoIter = indexmap::map::IntoIter<HermitianBosonProduct, CalculatorComplex>;
     /// Returns the BosonHamiltonian in Iterator form.
     ///
     /// # Returns
     ///
     /// * `Self::IntoIter` - The BosonHamiltonian in Iterator form.
     fn into_iter(self) -> Self::IntoIter {
@@ -650,96 +620,102 @@
 }
 
 #[cfg(test)]
 mod test {
     use super::*;
     use serde_test::{assert_tokens, Configure, Token};
 
-    // Test the Clone and PartialEq traits of SpinOperator
+    // Test the Clone and PartialEq traits of QubitOperator
     #[test]
     fn so_from_sos() {
         let pp: HermitianBosonProduct = HermitianBosonProduct::new([0], [0]).unwrap();
         let sos = BosonHamiltonianSerialize {
             items: vec![(pp.clone(), 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "BosonHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0-alpha.0".to_string(),
             },
         };
         let mut so = BosonHamiltonian::new();
         so.set(pp, CalculatorComplex::from(0.5)).unwrap();
 
-        assert_eq!(BosonHamiltonian::from(sos.clone()), so);
+        assert_eq!(BosonHamiltonian::try_from(sos.clone()).unwrap(), so);
         assert_eq!(BosonHamiltonianSerialize::from(so), sos);
     }
-    // Test the Clone and PartialEq traits of SpinOperator
+    // Test the Clone and PartialEq traits of QubitOperator
     #[test]
     fn clone_partial_eq() {
         let pp: HermitianBosonProduct = HermitianBosonProduct::new([0], [0]).unwrap();
         let sos = BosonHamiltonianSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "BosonHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         // Test Clone trait
         assert_eq!(sos.clone(), sos);
 
         // Test PartialEq trait
         let pp_1: HermitianBosonProduct = HermitianBosonProduct::new([0], [0]).unwrap();
         let sos_1 = BosonHamiltonianSerialize {
             items: vec![(pp_1, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "BosonHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
         let pp_2: HermitianBosonProduct = HermitianBosonProduct::new([0], [1]).unwrap();
         let sos_2 = BosonHamiltonianSerialize {
             items: vec![(pp_2, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "BosonHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
         assert!(sos_1 == sos);
         assert!(sos == sos_1);
         assert!(sos_2 != sos);
         assert!(sos != sos_2);
     }
 
-    // Test the Debug trait of SpinOperator
+    // Test the Debug trait of QubitOperator
     #[test]
     fn debug() {
         let pp: HermitianBosonProduct = HermitianBosonProduct::new([0], [0]).unwrap();
         let sos = BosonHamiltonianSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "BosonHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_eq!(
             format!("{:?}", sos),
-            "BosonHamiltonianSerialize { items: [(HermitianBosonProduct { creators: [0], annihilators: [0] }, Float(0.5), Float(0.0))], _struqture_version: StruqtureVersionSerializable { major_version: 1, minor_version: 0 } }"
+            "BosonHamiltonianSerialize { items: [(HermitianBosonProduct { creators: [0], annihilators: [0] }, Float(0.5), Float(0.0))], serialisation_meta: StruqtureSerialisationMeta { type_name: \"BosonHamiltonian\", min_version: (2, 0, 0), version: \"2.0.0\" } }"
         );
     }
 
-    /// Test SpinOperator Serialization and Deserialization traits (readable)
+    /// Test QubitOperator Serialization and Deserialization traits (readable)
     #[test]
     fn serde_readable() {
         let pp: HermitianBosonProduct = HermitianBosonProduct::new([0], [0]).unwrap();
         let sos = BosonHamiltonianSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "BosonHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_tokens(
             &sos.readable(),
             &[
                 Token::Struct {
@@ -750,38 +726,45 @@
                 Token::Seq { len: Some(1) },
                 Token::Tuple { len: 3 },
                 Token::Str("c0a0"),
                 Token::F64(0.5),
                 Token::F64(0.0),
                 Token::TupleEnd,
                 Token::SeqEnd,
-                Token::Str("_struqture_version"),
+                Token::Str("serialisation_meta"),
                 Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
                 },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(0),
+                Token::Str("type_name"),
+                Token::Str("BosonHamiltonian"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
                 Token::StructEnd,
                 Token::StructEnd,
             ],
         );
     }
 
-    /// Test SpinOperator Serialization and Deserialization traits (compact)
+    /// Test QubitOperator Serialization and Deserialization traits (compact)
     #[test]
     fn serde_compact() {
         let pp: HermitianBosonProduct = HermitianBosonProduct::new([0], [0]).unwrap();
         let sos = BosonHamiltonianSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "BosonHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_tokens(
             &sos.compact(),
             &[
                 Token::Struct {
@@ -807,22 +790,28 @@
                 Token::NewtypeVariant {
                     name: "CalculatorFloat",
                     variant: "Float",
                 },
                 Token::F64(0.0),
                 Token::TupleEnd,
                 Token::SeqEnd,
-                Token::Str("_struqture_version"),
+                Token::Str("serialisation_meta"),
                 Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
                 },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(0),
+                Token::Str("type_name"),
+                Token::Str("BosonHamiltonian"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
                 Token::StructEnd,
                 Token::StructEnd,
             ],
         );
     }
 }
```

### Comparing `struqture_py-1.6.1/struqture/src/bosons/bosonic_indices.rs` & `struqture_py-2.0.0a0/struqture/src/bosons/bosonic_indices.rs`

 * *Files 2% similar despite different names*

```diff
@@ -59,15 +59,19 @@
         let meta = obj.metadata();
         meta.description = Some("Represents products of Bosonic creators and annhilators by a string creators (c) or annihilators (a) followed by the modes they are acting on. E.g. c0a1.".to_string());
 
         schemars::schema::Schema::Object(obj)
     }
 }
 
-impl crate::MinSupportedVersion for BosonProduct {}
+impl crate::SerializationSupport for BosonProduct {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::BosonProduct
+    }
+}
 
 /// Implementing serde serialization writing directly to string.
 ///
 impl Serialize for BosonProduct {
     /// Serialization function for BosonProduct according to string type.
     ///
     /// # Arguments
@@ -245,14 +249,37 @@
             value,
         ))
     }
 }
 
 impl BosonIndex for BosonProduct {}
 
+impl BosonProduct {
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(&self) -> Result<struqture_one::bosons::BosonProduct, StruqtureError> {
+        let self_string = self.to_string();
+        let struqture_one_product = struqture_one::bosons::BosonProduct::from_str(&self_string)
+            .map_err(|err| StruqtureError::GenericError {
+                msg: format!("{}", err),
+            })?;
+        Ok(struqture_one_product)
+    }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::bosons::BosonProduct,
+    ) -> Result<Self, StruqtureError> {
+        let value_string = value.to_string();
+        let pauli_product = Self::from_str(&value_string)?;
+        Ok(pauli_product)
+    }
+}
+
 impl CorrespondsTo<BosonProduct> for BosonProduct {
     /// Gets the BosonProduct corresponding to self (here, itself).
     ///
     /// # Returns
     ///
     /// * `BosonProduct` - The BosonProduct corresponding to Self.
     fn corresponds_to(&self) -> BosonProduct {
@@ -564,15 +591,19 @@
         let meta = obj.metadata();
         meta.description = Some("Represents products of Bosonic creators and annhilators by a string creators (c) or annihilators (a) followed by the modes they are acting on. E.g. c0a1.".to_string());
 
         schemars::schema::Schema::Object(obj)
     }
 }
 
-impl crate::MinSupportedVersion for HermitianBosonProduct {}
+impl crate::SerializationSupport for HermitianBosonProduct {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::HermitianBosonProduct
+    }
+}
 
 /// Implementing serde serialization writing directly to string.
 ///
 impl Serialize for HermitianBosonProduct {
     /// Serialization function for HermitianBosonProduct according to string type.
     ///
     /// # Arguments
@@ -811,14 +842,41 @@
             ))
         }
     }
 }
 
 impl BosonIndex for HermitianBosonProduct {}
 
+impl HermitianBosonProduct {
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(
+        &self,
+    ) -> Result<struqture_one::bosons::HermitianBosonProduct, StruqtureError> {
+        let self_string = self.to_string();
+        let struqture_one_product = struqture_one::bosons::HermitianBosonProduct::from_str(
+            &self_string,
+        )
+        .map_err(|err| StruqtureError::GenericError {
+            msg: format!("{}", err),
+        })?;
+        Ok(struqture_one_product)
+    }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::bosons::HermitianBosonProduct,
+    ) -> Result<Self, StruqtureError> {
+        let value_string = value.to_string();
+        let pauli_product = Self::from_str(&value_string)?;
+        Ok(pauli_product)
+    }
+}
+
 impl CorrespondsTo<HermitianBosonProduct> for HermitianBosonProduct {
     /// Gets the HermitianBosonProduct corresponding to self (here, itself).
     ///
     /// # Returns
     ///
     /// * `HermitianBosonProduct` - The HermitianBosonProduct corresponding to Self.
     fn corresponds_to(&self) -> HermitianBosonProduct {
```

### Comparing `struqture_py-1.6.1/struqture/src/bosons/bosonic_noise_operator.rs` & `struqture_py-2.0.0a0/struqture/src/fermions/fermionic_noise_operator.rs`

 * *Files 15% similar despite different names*

```diff
@@ -6,216 +6,211 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
-use super::{BosonProduct, OperateOnBosons};
-use crate::{
-    ModeIndex, OperateOnDensityMatrix, OperateOnModes, StruqtureError,
-    StruqtureVersionSerializable, MINIMUM_STRUQTURE_VERSION,
-};
+use super::{FermionOperator, FermionProduct, OperateOnFermions};
+use crate::mappings::JordanWignerFermionToSpin;
+use crate::spins::{DecoherenceOperator, QubitLindbladNoiseOperator};
+use crate::{ModeIndex, OperateOnDensityMatrix, OperateOnModes, StruqtureError};
+use itertools::Itertools;
 use qoqo_calculator::{CalculatorComplex, CalculatorFloat};
 use serde::{Deserialize, Serialize};
 use std::fmt::{self, Write};
 use std::iter::{FromIterator, IntoIterator};
 use std::ops;
 
-#[cfg(feature = "indexed_map_iterators")]
-use indexmap::map::{Entry, Iter, Keys, Values};
-#[cfg(feature = "indexed_map_iterators")]
+use indexmap::map::{Entry, Iter};
 use indexmap::IndexMap;
-#[cfg(not(feature = "indexed_map_iterators"))]
-use std::collections::hash_map::{Entry, Iter, Keys, Values};
-#[cfg(not(feature = "indexed_map_iterators"))]
-use std::collections::HashMap;
 
-/// BosonLindbladNoiseOperators represent noise interactions in the Lindblad equation.
+/// FermionLindbladNoiseOperators represent noise interactions in the Lindblad equation.
 ///
-/// In the Lindblad equation, Linblad noise operator L_i are not limited to [crate::bosons::BosonProduct] style operators.
-/// We use ([crate::bosons::BosonProduct], [crate::bosons::BosonProduct]) as a unique basis.
+/// In the Lindblad equation, Linblad noise operator L_i are not limited to [crate::fermions::FermionProduct] style operators.
+/// We use ([crate::fermions::FermionProduct], [crate::fermions::FermionProduct]) as a unique basis.
 ///
 /// # Example
 ///
 /// ```
 /// use struqture::prelude::*;
 /// use qoqo_calculator::CalculatorComplex;
-/// use struqture::bosons::{BosonProduct, BosonLindbladNoiseOperator};
+/// use struqture::fermions::{FermionProduct, FermionLindbladNoiseOperator};
 ///
-/// let mut system = BosonLindbladNoiseOperator::new();
+/// let mut system = FermionLindbladNoiseOperator::new();
 ///
 /// // Set noise terms:
-/// let bp_0_1 = BosonProduct::new([0], [1]).unwrap();
-/// let bp_0 = BosonProduct::new([], [0]).unwrap();
+/// let bp_0_1 = FermionProduct::new([0], [1]).unwrap();
+/// let bp_0 = FermionProduct::new([], [0]).unwrap();
 /// system.set((bp_0_1.clone(), bp_0_1.clone()), CalculatorComplex::from(0.5)).unwrap();
 /// system.set((bp_0.clone(), bp_0.clone()), CalculatorComplex::from(0.2)).unwrap();
 ///
 /// // Access what you set:
 /// assert_eq!(system.current_number_modes(), 2_usize);
 /// assert_eq!(system.get(&(bp_0_1.clone(), bp_0_1.clone())), &CalculatorComplex::from(0.5));
 /// assert_eq!(system.get(&(bp_0.clone(), bp_0.clone())), &CalculatorComplex::from(0.2));
 /// ```
 ///
 #[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
-#[serde(from = "BosonLindbladNoiseOperatorSerialize")]
-#[serde(into = "BosonLindbladNoiseOperatorSerialize")]
-pub struct BosonLindbladNoiseOperator {
+#[serde(try_from = "FermionLindbladNoiseOperatorSerialize")]
+#[serde(into = "FermionLindbladNoiseOperatorSerialize")]
+pub struct FermionLindbladNoiseOperator {
     /// The internal map representing the noise terms
-    #[cfg(feature = "indexed_map_iterators")]
-    internal_map: IndexMap<(BosonProduct, BosonProduct), CalculatorComplex>,
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    internal_map: HashMap<(BosonProduct, BosonProduct), CalculatorComplex>,
+    internal_map: IndexMap<(FermionProduct, FermionProduct), CalculatorComplex>,
 }
 
-impl crate::MinSupportedVersion for BosonLindbladNoiseOperator {}
+impl crate::SerializationSupport for FermionLindbladNoiseOperator {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::FermionLindbladNoiseOperator
+    }
+}
 
 #[cfg(feature = "json_schema")]
-impl schemars::JsonSchema for BosonLindbladNoiseOperator {
+impl schemars::JsonSchema for FermionLindbladNoiseOperator {
     fn schema_name() -> String {
-        "BosonLindbladNoiseOperator".to_string()
+        "FermionLindbladNoiseOperator".to_string()
     }
 
     fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
-        <BosonLindbladNoiseOperatorSerialize>::json_schema(gen)
+        <FermionLindbladNoiseOperatorSerialize>::json_schema(gen)
     }
 }
 
 #[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
 #[cfg_attr(feature = "json_schema", derive(schemars::JsonSchema))]
 #[cfg_attr(feature = "json_schema", schemars(deny_unknown_fields))]
-struct BosonLindbladNoiseOperatorSerialize {
-    /// The vector representing the internal map of the BosonLindbladNoiseOperator
-    items: Vec<(BosonProduct, BosonProduct, CalculatorFloat, CalculatorFloat)>,
-    /// The struqture version
-    _struqture_version: StruqtureVersionSerializable,
-}
-
-impl From<BosonLindbladNoiseOperatorSerialize> for BosonLindbladNoiseOperator {
-    fn from(value: BosonLindbladNoiseOperatorSerialize) -> Self {
-        let new_noise_op: BosonLindbladNoiseOperator = value
+struct FermionLindbladNoiseOperatorSerialize {
+    /// The vector representing the internal map of the FermionLindbladNoiseOperator
+    items: Vec<(
+        FermionProduct,
+        FermionProduct,
+        CalculatorFloat,
+        CalculatorFloat,
+    )>,
+    serialisation_meta: crate::StruqtureSerialisationMeta,
+}
+
+impl TryFrom<FermionLindbladNoiseOperatorSerialize> for FermionLindbladNoiseOperator {
+    type Error = StruqtureError;
+    fn try_from(value: FermionLindbladNoiseOperatorSerialize) -> Result<Self, Self::Error> {
+        let target_serialisation_meta =
+            <Self as crate::SerializationSupport>::target_serialisation_meta();
+        crate::check_can_be_deserialised(&target_serialisation_meta, &value.serialisation_meta)?;
+        let new_noise_op: FermionLindbladNoiseOperator = value
             .items
             .into_iter()
             .map(|(left, right, real, imag)| {
                 ((left, right), CalculatorComplex { re: real, im: imag })
             })
             .collect();
-        new_noise_op
+        Ok(new_noise_op)
     }
 }
 
-impl From<BosonLindbladNoiseOperator> for BosonLindbladNoiseOperatorSerialize {
-    fn from(value: BosonLindbladNoiseOperator) -> Self {
-        let new_noise_op: Vec<(BosonProduct, BosonProduct, CalculatorFloat, CalculatorFloat)> =
-            value
-                .into_iter()
-                .map(|((left, right), val)| (left, right, val.re, val.im))
-                .collect();
-        let current_version = StruqtureVersionSerializable {
-            major_version: MINIMUM_STRUQTURE_VERSION.0,
-            minor_version: MINIMUM_STRUQTURE_VERSION.1,
-        };
+impl From<FermionLindbladNoiseOperator> for FermionLindbladNoiseOperatorSerialize {
+    fn from(value: FermionLindbladNoiseOperator) -> Self {
+        let serialisation_meta = crate::SerializationSupport::struqture_serialisation_meta(&value);
+        let new_noise_op: Vec<(
+            FermionProduct,
+            FermionProduct,
+            CalculatorFloat,
+            CalculatorFloat,
+        )> = value
+            .into_iter()
+            .map(|((left, right), val)| (left, right, val.re, val.im))
+            .collect();
         Self {
             items: new_noise_op,
-            _struqture_version: current_version,
+            serialisation_meta,
         }
     }
 }
 
-impl<'a> OperateOnDensityMatrix<'a> for BosonLindbladNoiseOperator {
-    type Index = (BosonProduct, BosonProduct);
+impl<'a> OperateOnDensityMatrix<'a> for FermionLindbladNoiseOperator {
+    type Index = (FermionProduct, FermionProduct);
     type Value = CalculatorComplex;
-    type IteratorType = Iter<'a, (BosonProduct, BosonProduct), CalculatorComplex>;
-    type KeyIteratorType = Keys<'a, (BosonProduct, BosonProduct), CalculatorComplex>;
-    type ValueIteratorType = Values<'a, (BosonProduct, BosonProduct), CalculatorComplex>;
 
     // From trait
     fn get(&self, key: &Self::Index) -> &Self::Value {
         match self.internal_map.get(key) {
             Some(value) => value,
             None => &CalculatorComplex::ZERO,
         }
     }
 
     // From trait
-    fn iter(&'a self) -> Self::IteratorType {
+    fn iter(&'a self) -> impl ExactSizeIterator<Item = (&'a Self::Index, &'a Self::Value)> {
         self.internal_map.iter()
     }
 
     // From trait
-    fn keys(&'a self) -> Self::KeyIteratorType {
+    fn keys(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Index> {
         self.internal_map.keys()
     }
 
     // From trait
-    fn values(&'a self) -> Self::ValueIteratorType {
+    fn values(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Value> {
         self.internal_map.values()
     }
 
-    #[cfg(feature = "indexed_map_iterators")]
     // From trait
     fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
         self.internal_map.shift_remove(key)
     }
 
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    // From trait
-    fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
-        self.internal_map.remove(key)
-    }
-
     // From trait
     fn empty_clone(&self, capacity: Option<usize>) -> Self {
         match capacity {
             Some(cap) => Self::with_capacity(cap),
             None => Self::new(),
         }
     }
 
-    /// Overwrites an existing entry or sets a new entry in the BosonLindbladNoiseOperator with the given ((BosonProduct, BosonProduct) key, CalculatorComplex value) pair.
+    /// Overwrites an existing entry or sets a new entry in the FermionLindbladNoiseOperator with the given ((FermionProduct, FermionProduct) key, CalculatorComplex value) pair.
     ///
     /// # Arguments
     ///
-    /// * `key` - The (BosonProduct, BosonProduct) key to set in the BosonLindbladNoiseOperator.
-    /// * `value` - The corresponding CalculatorComplex value to set for the key in the BosonLindbladNoiseOperator.
+    /// * `key` - The (FermionProduct, FermionProduct) key to set in the FermionLindbladNoiseOperator.
+    /// * `value` - The corresponding CalculatorComplex value to set for the key in the FermionLindbladNoiseOperator.
     ///
     /// # Returns
     ///
     /// * `Ok(Some(CalculatorComplex))` - The key existed, this is the value it had before it was set with the value input.
     /// * `Ok(None)` - The key did not exist, it has been set with its corresponding value.
     /// * `Err(StruqtureError::InvalidLindbladTerms)` - The input contained identities, which are not allowed as Lindblad operators.
     ///
     /// # Panics
     ///
-    /// * Internal error in BosonProduct::new
+    /// * Internal error in FermionProduct::new
     fn set(
         &mut self,
         key: Self::Index,
         value: Self::Value,
     ) -> Result<Option<Self::Value>, StruqtureError> {
-        if key.0 == BosonProduct::new([], [])? || key.1 == BosonProduct::new([], [])? {
+        if key.0 == FermionProduct::new([], [])? || key.1 == FermionProduct::new([], [])? {
             return Err(StruqtureError::InvalidLindbladTerms);
         }
 
         if value != CalculatorComplex::ZERO {
             Ok(self.internal_map.insert(key, value))
         } else {
             match self.internal_map.entry(key) {
-                #[cfg(feature = "indexed_map_iterators")]
                 Entry::Occupied(val) => Ok(Some(val.shift_remove())),
-                #[cfg(not(feature = "indexed_map_iterators"))]
-                Entry::Occupied(val) => Ok(Some(val.remove())),
                 Entry::Vacant(_) => Ok(None),
             }
         }
     }
 }
 
-impl<'a> OperateOnModes<'a> for BosonLindbladNoiseOperator {
-    // From trait
+impl<'a> OperateOnModes<'a> for FermionLindbladNoiseOperator {
+    /// Gets the maximum index of the FermionLindbladNoiseOperator.
+    ///
+    /// # Returns
+    ///
+    /// * `usize` - The number of fermionic modes in the FermionLindbladNoiseOperator.
     fn current_number_modes(&'a self) -> usize {
         let mut max_mode: usize = 0;
         if !self.is_empty() {
             for key in self.keys() {
                 let maxk = key
                     .0
                     .current_number_modes()
@@ -223,458 +218,535 @@
                 if maxk > max_mode {
                     max_mode = maxk;
                 }
             }
         }
         max_mode
     }
-
-    /// Gets the maximum index of the BosonLindbladNoiseOperator.
-    ///
-    /// # Returns
-    ///
-    /// * `usize` - The number of bosons in the BosonLindbladNoiseOperator.
-    fn number_modes(&'a self) -> usize {
-        self.current_number_modes()
-    }
 }
 
-impl<'a> OperateOnBosons<'a> for BosonLindbladNoiseOperator {}
+impl<'a> OperateOnFermions<'a> for FermionLindbladNoiseOperator {}
 
-/// Implements the default function (Default trait) of BosonLindbladNoiseOperator (an empty BosonLindbladNoiseOperator).
+/// Implements the default function (Default trait) of FermionLindbladNoiseOperator (an empty FermionLindbladNoiseOperator).
 ///
-impl Default for BosonLindbladNoiseOperator {
+impl Default for FermionLindbladNoiseOperator {
     fn default() -> Self {
         Self::new()
     }
 }
 
-/// Functions for the BosonLindbladNoiseOperator
+/// Functions for the FermionLindbladNoiseOperator
 ///
-impl BosonLindbladNoiseOperator {
-    /// Creates a new BosonLindbladNoiseOperator.
+impl FermionLindbladNoiseOperator {
+    /// Creates a new FermionLindbladNoiseOperator.
     ///
     /// # Returns
     ///
-    /// * `Self` - The new (empty) BosonLindbladNoiseOperator.
+    /// * `Self` - The new (empty) FermionLindbladNoiseOperator.
     pub fn new() -> Self {
-        BosonLindbladNoiseOperator {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::new(),
-            #[cfg(feature = "indexed_map_iterators")]
+        FermionLindbladNoiseOperator {
             internal_map: IndexMap::new(),
         }
     }
 
-    /// Creates a new BosonLindbladNoiseOperator with pre-allocated capacity.
+    /// Creates a new FermionLindbladNoiseOperator with pre-allocated capacity.
     ///
     /// # Arguments
     ///
     /// * `capacity` - The pre-allocated capacity of the operator.
     ///
     /// # Returns
     ///
-    /// * `Self` - The new (empty) BosonLindbladNoiseOperator.
+    /// * `Self` - The new (empty) FermionLindbladNoiseOperator.
     pub fn with_capacity(capacity: usize) -> Self {
-        BosonLindbladNoiseOperator {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::with_capacity(capacity),
-            #[cfg(feature = "indexed_map_iterators")]
+        FermionLindbladNoiseOperator {
             internal_map: IndexMap::with_capacity(capacity),
         }
     }
 
-    /// Separate self into an operator with the terms of given number of creation and annihilation operators and an operator with the remaining operations
+    /// Adds all noise entries corresponding to a ((FermionOperator, FermionOperator), CalculatorFloat).
+    ///
+    /// In the Lindblad equation, Linblad noise operator L_i are not limited to [crate::fermions::FermionProduct] style operators.
+    /// We use ([crate::spins::FermionProduct], [crate::spins::FermionProduct]) as a unique basis.
+    /// This function adds a Linblad-Term defined by a combination of Lindblad operators given as general [crate::fermions::FermionOperator]
     ///
     /// # Arguments
     ///
-    /// * `number_creators_annihilators_left` - Number of creators and number of annihilators to filter for in the left term of the keys.
-    /// * `number_creators_annihilators_right` - Number of creators and number of annihilators to filter for in the right term of the keys.
+    /// * `left` - FermionOperator that acts on the density matrix from the left in the Lindblad equation.
+    /// * `right` -  FermionOperator that acts on the density matrix from the right and in hermitian conjugated form in the Lindblad equation.
+    /// * `value` - CalculatorComplex value representing the global coefficient of the noise term.
     ///
     /// # Returns
     ///
-    /// `Ok((separated, remainder))` - Operator with the noise terms where the number of creation and annihilation operators matches the number of spins the operator product acts on and Operator with all other contributions.
-    pub fn separate_into_n_terms(
-        &self,
-        number_creators_annihilators_left: (usize, usize),
-        number_creators_annihilators_right: (usize, usize),
-    ) -> Result<(Self, Self), StruqtureError> {
-        let mut separated = Self::default();
-        let mut remainder = Self::default();
-        for ((prod_l, prod_r), val) in self.iter() {
-            if (prod_l.creators().len(), prod_l.annihilators().len())
-                == number_creators_annihilators_left
-                && (prod_r.creators().len(), prod_r.annihilators().len())
-                    == number_creators_annihilators_right
+    /// * `Ok(())` - The noise was correctly added.
+    /// * `Err(StruqtureError::InvalidLindbladTerms)` - The input contained identities, which are not allowed as Lindblad operators.
+    pub fn add_noise_from_full_operators(
+        &mut self,
+        left: &FermionOperator,
+        right: &FermionOperator,
+        value: CalculatorComplex,
+    ) -> Result<(), StruqtureError> {
+        if left.is_empty() || right.is_empty() {
+            return Err(StruqtureError::InvalidLindbladTerms);
+        }
+
+        for ((fermion_product_left, value_left), (fermion_product_right, value_right)) in
+            left.iter().cartesian_product(right.into_iter())
+        {
+            if !(*fermion_product_left == FermionProduct::new([], [])?
+                || *fermion_product_right == FermionProduct::new([], [])?)
             {
-                separated.add_operator_product((prod_l.clone(), prod_r.clone()), val.clone())?;
-            } else {
-                remainder.add_operator_product((prod_l.clone(), prod_r.clone()), val.clone())?;
+                let value_complex = value_right.conj() * value_left;
+                self.add_operator_product(
+                    (fermion_product_left.clone(), fermion_product_right.clone()),
+                    value_complex * value.clone(),
+                )?;
             }
         }
-        Ok((separated, remainder))
+        Ok(())
+    }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(
+        &self,
+    ) -> Result<struqture_one::fermions::FermionLindbladNoiseSystem, StruqtureError> {
+        let mut new_fermion_system = struqture_one::fermions::FermionLindbladNoiseSystem::new(None);
+        for (key, val) in self.iter() {
+            let one_key_left = key.0.to_struqture_1()?;
+            let one_key_right = key.1.to_struqture_1()?;
+            let _ = struqture_one::OperateOnDensityMatrix::set(
+                &mut new_fermion_system,
+                (one_key_left, one_key_right),
+                val.clone(),
+            );
+        }
+        Ok(new_fermion_system)
+    }
+
+    /// Import from struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::fermions::FermionLindbladNoiseSystem,
+    ) -> Result<Self, StruqtureError> {
+        let mut new_qubit_operator = Self::new();
+        for (key, val) in struqture_one::OperateOnDensityMatrix::iter(value) {
+            let self_key_left = FermionProduct::from_struqture_1(&key.0)?;
+            let self_key_right = FermionProduct::from_struqture_1(&key.1)?;
+            let _ = new_qubit_operator.set((self_key_left, self_key_right), val.clone());
+        }
+        Ok(new_qubit_operator)
     }
 }
 
-/// Implements the negative sign function of BosonLindbladNoiseOperator.
+/// Implements the negative sign function of FermionLindbladNoiseOperator.
 ///
-impl ops::Neg for BosonLindbladNoiseOperator {
-    type Output = BosonLindbladNoiseOperator;
-    /// Implement minus sign for BosonLindbladNoiseOperator.
+impl ops::Neg for FermionLindbladNoiseOperator {
+    type Output = FermionLindbladNoiseOperator;
+    /// Implement minus sign for FermionOperator.
     ///
     /// # Returns
     ///
-    /// * `Self` - The BosonLindbladNoiseOperator * -1.
+    /// * `Self` - The FermionOperator * -1.
     fn neg(self) -> Self {
-        #[cfg(not(feature = "indexed_map_iterators"))]
-        let mut internal = HashMap::with_capacity(self.len());
-        #[cfg(feature = "indexed_map_iterators")]
         let mut internal = IndexMap::with_capacity(self.len());
         for (key, val) in self {
             internal.insert(key.clone(), val.neg());
         }
-        BosonLindbladNoiseOperator {
+        FermionLindbladNoiseOperator {
             internal_map: internal,
         }
     }
 }
 
-/// Implements the plus function of BosonLindbladNoiseOperator by BosonLindbladNoiseOperator.
+/// Implements the plus function of FermionLindbladNoiseOperator by FermionLindbladNoiseOperator.
 ///
-impl<T, V> ops::Add<T> for BosonLindbladNoiseOperator
+impl<T, V> ops::Add<T> for FermionLindbladNoiseOperator
 where
-    T: IntoIterator<Item = ((BosonProduct, BosonProduct), V)>,
+    T: IntoIterator<Item = ((FermionProduct, FermionProduct), V)>,
     V: Into<CalculatorComplex>,
 {
     type Output = Self;
-    /// Implements `+` (add) for BosonLindbladNoiseOperator and BosonLindbladNoiseOperator.
+    /// Implements `+` (add) for two FermionOperators.
     ///
     /// # Arguments
     ///
-    /// * `other` - The BosonLindbladNoiseOperator to be added.
+    /// * `other` - The FermionOperator to be added.
     ///
     /// # Returns
     ///
-    /// * `Self` - The two BosonLindbladNoiseOperators added together.
+    /// * `Self` - The two FermionOperators added together.
     ///
     /// # Panics
     ///
     /// * Internal error in add_operator_product.
     fn add(mut self, other: T) -> Self {
         for (key, value) in other.into_iter() {
             self.add_operator_product(key.clone(), Into::<CalculatorComplex>::into(value))
                 .expect("Internal bug in add_operator_product");
         }
         self
     }
 }
 
-/// Implements the minus function of BosonLindbladNoiseOperator by BosonLindbladNoiseOperator.
+/// Implements the minus function of FermionLindbladNoiseOperator by FermionLindbladNoiseOperator.
 ///
-impl<T, V> ops::Sub<T> for BosonLindbladNoiseOperator
+impl<T, V> ops::Sub<T> for FermionLindbladNoiseOperator
 where
-    T: IntoIterator<Item = ((BosonProduct, BosonProduct), V)>,
+    T: IntoIterator<Item = ((FermionProduct, FermionProduct), V)>,
     V: Into<CalculatorComplex>,
 {
     type Output = Self;
-    /// Implements `-` (subtract) for two BosonLindbladNoiseOperators.
+    /// Implements `-` (subtract) for two FermionLindbladNoiseOperators.
     ///
     /// # Arguments
     ///
-    /// * `other` - The BosonLindbladNoiseOperator to be subtracted.
+    /// * `other` - The FermionLindbladNoiseOperator to be subtracted.
     ///
     /// # Returns
     ///
-    /// * `Self` - The two BosonLindbladNoiseOperators subtracted.
+    /// * `Self` - The two FermionLindbladNoiseOperators subtracted.
     ///
     /// # Panics
     ///
     /// * Internal error in add_operator_product.
     fn sub(mut self, other: T) -> Self {
         for (key, value) in other.into_iter() {
             self.add_operator_product(key.clone(), Into::<CalculatorComplex>::into(value) * -1.0)
                 .expect("Internal bug in add_operator_product");
         }
         self
     }
 }
 
-/// Implements the multiplication function of BosonLindbladNoiseOperator by CalculatorComplex.
+/// Implements the multiplication function of FermionLindbladNoiseOperator by CalculatorFloat.
 ///
-impl<T> ops::Mul<T> for BosonLindbladNoiseOperator
+impl<T> ops::Mul<T> for FermionLindbladNoiseOperator
 where
     T: Into<CalculatorComplex>,
 {
     type Output = Self;
-    /// Implement `*` for BosonLindbladNoiseOperator and CalculatorComplex.
+    /// Implement `*` for FermionLindbladNoiseOperator and CalculatorFloat.
     ///
     /// # Arguments
     ///
-    /// * `other` - The CalculatorComplex by which to multiply.
+    /// * `other` - The CalculatorFloat by which to multiply.
     ///
     /// # Returns
     ///
-    /// * `Self` - The BosonLindbladNoiseOperator multiplied by the CalculatorComplex.
+    /// * `Self` - The FermionLindbladNoiseOperator multiplied by the CalculatorFloat.
     fn mul(self, other: T) -> Self {
         let other_cc = Into::<CalculatorComplex>::into(other);
-        #[cfg(not(feature = "indexed_map_iterators"))]
-        let mut internal = HashMap::with_capacity(self.len());
-        #[cfg(feature = "indexed_map_iterators")]
         let mut internal = IndexMap::with_capacity(self.len());
         for (key, val) in self {
             internal.insert(key, val * other_cc.clone());
         }
-        BosonLindbladNoiseOperator {
+        FermionLindbladNoiseOperator {
             internal_map: internal,
         }
     }
 }
 
-/// Implements the into_iter function (IntoIterator trait) of BosonLindbladNoiseOperator.
+/// Implements the into_iter function (IntoIterator trait) of FermionLindbladNoiseOperator.
 ///
-impl IntoIterator for BosonLindbladNoiseOperator {
-    type Item = ((BosonProduct, BosonProduct), CalculatorComplex);
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    type IntoIter =
-        std::collections::hash_map::IntoIter<(BosonProduct, BosonProduct), CalculatorComplex>;
-    #[cfg(feature = "indexed_map_iterators")]
-    type IntoIter = indexmap::map::IntoIter<(BosonProduct, BosonProduct), CalculatorComplex>;
-    /// Returns the BosonLindbladNoiseOperator in Iterator form.
+impl IntoIterator for FermionLindbladNoiseOperator {
+    type Item = ((FermionProduct, FermionProduct), CalculatorComplex);
+    type IntoIter = indexmap::map::IntoIter<(FermionProduct, FermionProduct), CalculatorComplex>;
+    /// Returns the FermionLindbladNoiseOperator in Iterator form.
     ///
     /// # Returns
     ///
-    /// * `Self::IntoIter` - The BosonLindbladNoiseOperator in Iterator form.
+    /// * `Self::IntoIter` - The FermionLindbladNoiseOperator in Iterator form.
     fn into_iter(self) -> Self::IntoIter {
         self.internal_map.into_iter()
     }
 }
 
-/// Implements the into_iter function (IntoIterator trait) of reference BosonLindbladNoiseOperator.
+/// Implements the into_iter function (IntoIterator trait) of reference FermionLindbladNoiseOperator.
 ///
-impl<'a> IntoIterator for &'a BosonLindbladNoiseOperator {
-    type Item = (&'a (BosonProduct, BosonProduct), &'a CalculatorComplex);
-    type IntoIter = Iter<'a, (BosonProduct, BosonProduct), CalculatorComplex>;
+impl<'a> IntoIterator for &'a FermionLindbladNoiseOperator {
+    type Item = (&'a (FermionProduct, FermionProduct), &'a CalculatorComplex);
+    type IntoIter = Iter<'a, (FermionProduct, FermionProduct), CalculatorComplex>;
 
-    /// Returns the reference BosonLindbladNoiseOperator in Iterator form.
+    /// Returns the reference FermionLindbladNoiseOperator in Iterator form.
     ///
     /// # Returns
     ///
-    /// * `Self::IntoIter` - The reference BosonLindbladNoiseOperator in Iterator form.
+    /// * `Self::IntoIter` - The reference FermionLindbladNoiseOperator in Iterator form.
     fn into_iter(self) -> Self::IntoIter {
         self.internal_map.iter()
     }
 }
 
-/// Implements the from_iter function (FromIterator trait) of BosonLindbladNoiseOperator.
+/// Implements the from_iter function (FromIterator trait) of FermionLindbladNoiseOperator.
 ///
-impl FromIterator<((BosonProduct, BosonProduct), CalculatorComplex)>
-    for BosonLindbladNoiseOperator
+impl FromIterator<((FermionProduct, FermionProduct), CalculatorComplex)>
+    for FermionLindbladNoiseOperator
 {
-    /// Returns the object in BosonLindbladNoiseOperator form, from an Iterator form of the object.
+    /// Returns the object in FermionLindbladNoiseOperator form, from an Iterator form of the object.
     ///
     /// # Arguments
     ///
-    /// * `iter` - The iterator containing the information from which to create the BosonLindbladNoiseOperator.
+    /// * `iter` - The iterator containing the information from which to create the FermionLindbladNoiseOperator.
     ///
     /// # Returns
     ///
-    /// * `Self::IntoIter` - The iterator in BosonLindbladNoiseOperator form.
-    fn from_iter<I: IntoIterator<Item = ((BosonProduct, BosonProduct), CalculatorComplex)>>(
+    /// * `Self::IntoIter` - The iterator in FermionLindbladNoiseOperator form.
+    ///
+    /// # Panics
+    ///
+    /// * Internal error in add_operator_product.
+    fn from_iter<I: IntoIterator<Item = ((FermionProduct, FermionProduct), CalculatorComplex)>>(
         iter: I,
     ) -> Self {
-        let mut slno = BosonLindbladNoiseOperator::new();
+        let mut slno = FermionLindbladNoiseOperator::new();
         for (pair, cc) in iter {
             slno.add_operator_product(pair, cc)
                 .expect("Internal bug in add_operator_product");
         }
         slno
     }
 }
 
-/// Implements the extend function (Extend trait) of BosonLindbladNoiseOperator.
+/// Implements the extend function (Extend trait) of FermionLindbladNoiseOperator.
 ///
-impl Extend<((BosonProduct, BosonProduct), CalculatorComplex)> for BosonLindbladNoiseOperator {
-    /// Extends the BosonLindbladNoiseOperator by the specified operations (in Iterator form).
+impl Extend<((FermionProduct, FermionProduct), CalculatorComplex)>
+    for FermionLindbladNoiseOperator
+{
+    /// Extends the FermionLindbladNoiseOperator by the specified operations (in Iterator form).
     ///
     /// # Arguments
     ///
-    /// * `iter` - The iterator containing the operations by which to extend the BosonLindbladNoiseOperator.
-    fn extend<I: IntoIterator<Item = ((BosonProduct, BosonProduct), CalculatorComplex)>>(
+    /// * `iter` - The iterator containing the operations by which to extend the FermionLindbladNoiseOperator.
+    ///
+    /// # Panics
+    ///
+    /// * Internal error in add_operator_product.
+    fn extend<I: IntoIterator<Item = ((FermionProduct, FermionProduct), CalculatorComplex)>>(
         &mut self,
         iter: I,
     ) {
         for (pair, cc) in iter {
             self.add_operator_product(pair, cc)
                 .expect("Internal bug in add_operator_product");
         }
     }
 }
 
-/// Implements the format function (Display trait) of BosonLindbladNoiseOperator.
+/// Implements the format function (Display trait) of FermionLindbladNoiseOperator.
 ///
-impl fmt::Display for BosonLindbladNoiseOperator {
-    /// Formats the BosonLindbladNoiseOperator using the given formatter.
+impl fmt::Display for FermionLindbladNoiseOperator {
+    /// Formats the FermionLindbladNoiseOperator using the given formatter.
     ///
     /// # Arguments
     ///
     /// * `f` - The formatter to use.
     ///
     /// # Returns
     ///
-    /// * `std::fmt::Result` - The formatted BosonLindbladNoiseOperator.
+    /// * `std::fmt::Result` - The formatted FermionLindbladNoiseOperator.
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        let mut output = "BosonLindbladNoiseOperator{\n".to_string();
+        let mut output = "FermionLindbladNoiseOperator{\n".to_string();
         for (key, val) in self.iter() {
             writeln!(output, "({}, {}): {},", key.0, key.1, val)?;
         }
         output.push('}');
 
         write!(f, "{}", output)
     }
 }
 
+impl JordanWignerFermionToSpin for FermionLindbladNoiseOperator {
+    type Output = QubitLindbladNoiseOperator;
+
+    /// Implements JordanWignerFermionToSpin for a FermionLindbladNoiseOperator.
+    ///
+    /// The convention used is that |0> represents an empty fermionic state (spin-orbital),
+    /// and |1> represents an occupied fermionic state.
+    ///
+    /// # Returns
+    ///
+    /// * `QubitLindbladNoiseOperator` - The spin noise operator that results from the transformation.
+    ///
+    /// # Panics
+    ///
+    /// * Internal bug in add_noise_from_full_operators.
+    fn jordan_wigner(&self) -> Self::Output {
+        let mut out = QubitLindbladNoiseOperator::new();
+
+        for key in self.keys() {
+            let decoherence_operator_left = DecoherenceOperator::from(key.0.jordan_wigner());
+            let decoherence_operator_right = DecoherenceOperator::from(key.1.jordan_wigner());
+
+            out.add_noise_from_full_operators(
+                &decoherence_operator_left,
+                &decoherence_operator_right,
+                self.get(key).into(),
+            )
+            .expect("Internal bug in add_noise_from_full_operators");
+        }
+        out
+    }
+}
+
 #[cfg(test)]
 mod test {
     use super::*;
     use serde_test::{assert_tokens, Configure, Token};
 
-    // Test the Clone and PartialEq traits of SpinOperator
+    // Test the Clone and PartialEq traits of QubitOperator
     #[test]
     fn so_from_sos() {
-        let pp: BosonProduct = BosonProduct::new([0], [0]).unwrap();
-        let sos = BosonLindbladNoiseOperatorSerialize {
+        let pp: FermionProduct = FermionProduct::new([0], [0]).unwrap();
+        let sos = FermionLindbladNoiseOperatorSerialize {
             items: vec![(pp.clone(), pp.clone(), 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "FermionLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0-alpha.0".to_string(),
             },
         };
-        let mut so = BosonLindbladNoiseOperator::new();
+        let mut so = FermionLindbladNoiseOperator::new();
         so.set((pp.clone(), pp), CalculatorComplex::from(0.5))
             .unwrap();
 
-        assert_eq!(BosonLindbladNoiseOperator::from(sos.clone()), so);
-        assert_eq!(BosonLindbladNoiseOperatorSerialize::from(so), sos);
+        assert_eq!(
+            FermionLindbladNoiseOperator::try_from(sos.clone()).unwrap(),
+            so
+        );
+        assert_eq!(FermionLindbladNoiseOperatorSerialize::from(so), sos);
     }
-    // Test the Clone and PartialEq traits of SpinOperator
+    // Test the Clone and PartialEq traits of QubitOperator
     #[test]
     fn clone_partial_eq() {
-        let pp: BosonProduct = BosonProduct::new([0], [0]).unwrap();
-        let sos = BosonLindbladNoiseOperatorSerialize {
+        let pp: FermionProduct = FermionProduct::new([0], [0]).unwrap();
+        let sos = FermionLindbladNoiseOperatorSerialize {
             items: vec![(pp.clone(), pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "FermionLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         // Test Clone trait
         assert_eq!(sos.clone(), sos);
 
         // Test PartialEq trait
-        let pp_1: BosonProduct = BosonProduct::new([0], [0]).unwrap();
-        let sos_1 = BosonLindbladNoiseOperatorSerialize {
+        let pp_1: FermionProduct = FermionProduct::new([0], [0]).unwrap();
+        let sos_1 = FermionLindbladNoiseOperatorSerialize {
             items: vec![(pp_1.clone(), pp_1, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "FermionLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
-        let pp_2: BosonProduct = BosonProduct::new([0], [1]).unwrap();
-        let sos_2 = BosonLindbladNoiseOperatorSerialize {
+        let pp_2: FermionProduct = FermionProduct::new([0], [1]).unwrap();
+        let sos_2 = FermionLindbladNoiseOperatorSerialize {
             items: vec![(pp_2.clone(), pp_2, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "FermionLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
         assert!(sos_1 == sos);
         assert!(sos == sos_1);
         assert!(sos_2 != sos);
         assert!(sos != sos_2);
     }
 
-    // Test the Debug trait of SpinOperator
+    // Test the Debug trait of QubitOperator
     #[test]
     fn debug() {
-        let pp: BosonProduct = BosonProduct::new([0], [0]).unwrap();
-        let sos = BosonLindbladNoiseOperatorSerialize {
+        let pp: FermionProduct = FermionProduct::new([0], [0]).unwrap();
+        let sos = FermionLindbladNoiseOperatorSerialize {
             items: vec![(pp.clone(), pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "FermionLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_eq!(
             format!("{:?}", sos),
-            "BosonLindbladNoiseOperatorSerialize { items: [(BosonProduct { creators: [0], annihilators: [0] }, BosonProduct { creators: [0], annihilators: [0] }, Float(0.5), Float(0.0))], _struqture_version: StruqtureVersionSerializable { major_version: 1, minor_version: 0 } }"
+            "FermionLindbladNoiseOperatorSerialize { items: [(FermionProduct { creators: [0], annihilators: [0] }, FermionProduct { creators: [0], annihilators: [0] }, Float(0.5), Float(0.0))], serialisation_meta: StruqtureSerialisationMeta { type_name: \"FermionLindbladNoiseOperator\", min_version: (2, 0, 0), version: \"2.0.0\" } }"
         );
     }
 
-    /// Test SpinOperator Serialization and Deserialization traits (readable)
+    /// Test QubitOperator Serialization and Deserialization traits (readable)
     #[test]
     fn serde_readable() {
-        let pp: BosonProduct = BosonProduct::new([0], [0]).unwrap();
-        let sos = BosonLindbladNoiseOperatorSerialize {
+        let pp: FermionProduct = FermionProduct::new([0], [0]).unwrap();
+        let sos = FermionLindbladNoiseOperatorSerialize {
             items: vec![(pp.clone(), pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "FermionLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_tokens(
             &sos.readable(),
             &[
                 Token::Struct {
-                    name: "BosonLindbladNoiseOperatorSerialize",
+                    name: "FermionLindbladNoiseOperatorSerialize",
                     len: 2,
                 },
                 Token::Str("items"),
                 Token::Seq { len: Some(1) },
                 Token::Tuple { len: 4 },
                 Token::Str("c0a0"),
                 Token::Str("c0a0"),
                 Token::F64(0.5),
                 Token::F64(0.0),
                 Token::TupleEnd,
                 Token::SeqEnd,
-                Token::Str("_struqture_version"),
+                Token::Str("serialisation_meta"),
                 Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
                 },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(0),
+                Token::Str("type_name"),
+                Token::Str("FermionLindbladNoiseOperator"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
                 Token::StructEnd,
                 Token::StructEnd,
             ],
         );
     }
 
-    /// Test SpinOperator Serialization and Deserialization traits (compact)
+    /// Test QubitOperator Serialization and Deserialization traits (compact)
     #[test]
     fn serde_compact() {
-        let pp: BosonProduct = BosonProduct::new([0], [0]).unwrap();
-        let sos = BosonLindbladNoiseOperatorSerialize {
+        let pp: FermionProduct = FermionProduct::new([0], [0]).unwrap();
+        let sos = FermionLindbladNoiseOperatorSerialize {
             items: vec![(pp.clone(), pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "FermionLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_tokens(
             &sos.compact(),
             &[
                 Token::Struct {
-                    name: "BosonLindbladNoiseOperatorSerialize",
+                    name: "FermionLindbladNoiseOperatorSerialize",
                     len: 2,
                 },
                 Token::Str("items"),
                 Token::Seq { len: Some(1) },
                 Token::Tuple { len: 4 },
                 Token::Tuple { len: 2 },
                 Token::Seq { len: Some(1) },
@@ -700,22 +772,28 @@
                 Token::NewtypeVariant {
                     name: "CalculatorFloat",
                     variant: "Float",
                 },
                 Token::F64(0.0),
                 Token::TupleEnd,
                 Token::SeqEnd,
-                Token::Str("_struqture_version"),
+                Token::Str("serialisation_meta"),
                 Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
                 },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(0),
+                Token::Str("type_name"),
+                Token::Str("FermionLindbladNoiseOperator"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
                 Token::StructEnd,
                 Token::StructEnd,
             ],
         );
     }
 }
```

### Comparing `struqture_py-1.6.1/struqture/src/bosons/bosonic_open_system.rs` & `struqture_py-2.0.0a0/struqture/src/bosons/bosonic_open_system.rs`

 * *Files 12% similar despite different names*

```diff
@@ -6,31 +6,31 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
-use super::{BosonHamiltonianSystem, BosonLindbladNoiseSystem};
+use super::{BosonHamiltonian, BosonLindbladNoiseOperator};
 use crate::{OpenSystem, OperateOnDensityMatrix, OperateOnModes, StruqtureError};
 use qoqo_calculator::CalculatorFloat;
 use serde::{Deserialize, Serialize};
 use std::fmt::{self, Write};
 use std::ops;
 
-/// BosonLindbladOpenSystems are representations of open systems of bosons, where a system (BosonHamiltonianSystem) interacts with the environment via noise (BosonLindbladNoiseSystem).
+/// BosonLindbladOpenSystems are representations of open systems of bosons, where a system (BosonHamiltonian) interacts with the environment via noise (BosonLindbladNoiseOperator).
 ///
 /// # Example
 ///
 /// ```
 /// use struqture::prelude::*;
 /// use qoqo_calculator::CalculatorComplex;
 /// use struqture::bosons::{BosonProduct, HermitianBosonProduct, BosonLindbladOpenSystem};
 ///
-/// let mut system = BosonLindbladOpenSystem::new(None);
+/// let mut system = BosonLindbladOpenSystem::new();
 ///
 /// let bp_0_1 = BosonProduct::new([0], [1]).unwrap();
 /// let bp_0 = HermitianBosonProduct::new([], [0]).unwrap();
 /// system.noise_mut().set((bp_0_1.clone(), bp_0_1.clone()), CalculatorComplex::from(0.5)).unwrap();
 /// system.system_mut().set(bp_0.clone(), CalculatorComplex::from(0.2)).unwrap();
 ///
 /// // Access what you set:
@@ -38,25 +38,29 @@
 /// assert_eq!(system.system().get(&bp_0.clone()), &CalculatorComplex::from(0.2));
 /// ```
 ///
 #[derive(Debug, Clone, PartialEq, Deserialize, Serialize, Default)]
 #[cfg_attr(feature = "json_schema", derive(schemars::JsonSchema))]
 #[cfg_attr(feature = "json_schema", schemars(deny_unknown_fields))]
 pub struct BosonLindbladOpenSystem {
-    /// The BosonHamiltonianSystem representing the system terms of the open system
-    system: BosonHamiltonianSystem,
-    /// The BosonLindbladNoiseSystem representing the noise terms of the open system
-    noise: BosonLindbladNoiseSystem,
+    /// The BosonHamiltonian representing the system terms of the open system
+    system: BosonHamiltonian,
+    /// The BosonLindbladNoiseOperator representing the noise terms of the open system
+    noise: BosonLindbladNoiseOperator,
 }
 
-impl crate::MinSupportedVersion for BosonLindbladOpenSystem {}
+impl crate::SerializationSupport for BosonLindbladOpenSystem {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::BosonLindbladOpenSystem
+    }
+}
 
 impl<'a> OpenSystem<'a> for BosonLindbladOpenSystem {
-    type System = BosonHamiltonianSystem;
-    type Noise = BosonLindbladNoiseSystem;
+    type System = BosonHamiltonian;
+    type Noise = BosonLindbladNoiseOperator;
 
     // From trait
     fn noise(&self) -> &Self::Noise {
         &self.noise
     }
 
     // From trait
@@ -75,105 +79,90 @@
     }
 
     // From trait
     fn ungroup(self) -> (Self::System, Self::Noise) {
         (self.system, self.noise)
     }
 
-    /// Takes a tuple of a system (BosonHamiltonianSystem) and a noise term (BosonLindbladNoiseSystem) and combines them to be a BosonLindbladOpenSystem.
+    /// Takes a tuple of a system (BosonHamiltonian) and a noise term (BosonLindbladNoiseOperator) and combines them to be a BosonLindbladOpenSystem.
     ///
     /// # Arguments
     ///
-    /// * `system` - The BosonHamiltonianSystem to have in the BosonLindbladOpenSystem.
-    /// * `noise` - The BosonLindbladNoiseSystem to have in the BosonLindbladOpenSystem.
+    /// * `system` - The BosonHamiltonian to have in the BosonLindbladOpenSystem.
+    /// * `noise` - The BosonLindbladNoiseOperator to have in the BosonLindbladOpenSystem.
     ///
     /// # Returns
     ///
     /// * `Ok(Self)` - The BosonLindbladOpenSystem with input system and noise terms.
     /// * `Err(StruqtureError::MissmatchedNumberModes)` - The system and noise do not have the same number of modes.
     fn group(system: Self::System, noise: Self::Noise) -> Result<Self, StruqtureError> {
-        let (system, noise) = if system.number_modes != noise.number_modes {
-            match (system.number_modes, noise.number_modes) {
-                (Some(n), None) => {
-                    if n >= noise.number_modes() {
-                        let mut noise = noise;
-                        noise.number_modes = Some(n);
-                        (system, noise)
-                    } else {
-                        return Err(StruqtureError::MissmatchedNumberModes);
-                    }
-                }
-                (None, Some(n)) => {
-                    if n >= system.number_modes() {
-                        let mut system = system;
-                        system.number_modes = Some(n);
-                        (system, noise)
-                    } else {
-                        return Err(StruqtureError::MissmatchedNumberModes);
-                    }
-                }
-                (Some(_), Some(_)) => {
-                    return Err(StruqtureError::MissmatchedNumberModes);
-                }
-                _ => panic!("Unexpected missmatch of number modes"),
-            }
-        } else {
-            (system, noise)
-        };
         Ok(Self { system, noise })
     }
 
     // From trait
     fn empty_clone(&self) -> Self {
         Self::group(self.system.empty_clone(None), self.noise.empty_clone(None)).expect(
             "Internal error: Number of modes in system and noise unexpectedly does not match.",
         )
     }
 }
 
 impl<'a> OperateOnModes<'a> for BosonLindbladOpenSystem {
-    /// Gets the maximum number_modes of the BosonHamiltonianSystem/BosonLindbladNoiseSystem.
+    /// Gets the maximum current_number_modes of the BosonHamiltonian/BosonLindbladNoiseOperator.
     ///
     /// # Returns
     ///
     /// * `usize` - The number of bosons in the BosonLindbladOpenSystem.
-    fn number_modes(&self) -> usize {
-        self.system.number_modes().max(self.noise.number_modes())
-    }
-
-    /// Return maximum index in BosonLindbladOpenSystem.
-    ///
-    /// # Returns
-    ///
-    /// * `usize` - Maximum index.
     fn current_number_modes(&self) -> usize {
         self.system
             .current_number_modes()
             .max(self.noise.current_number_modes())
     }
 }
 
 /// Functions for the BosonLindbladOpenSystem
 ///
 impl BosonLindbladOpenSystem {
     /// Creates a new BosonLindbladOpenSystem.
     ///
-    /// # Arguments
-    ///
-    /// * `number_modes` - The number of modes in the open system.
-    ///
     /// # Returns
     ///
     /// * `Self` - The new (empty) BosonLindbladOpenSystem.
-    pub fn new(number_modes: Option<usize>) -> Self {
+    pub fn new() -> Self {
         BosonLindbladOpenSystem {
-            system: BosonHamiltonianSystem::new(number_modes),
-            noise: BosonLindbladNoiseSystem::new(number_modes),
+            system: BosonHamiltonian::new(),
+            noise: BosonLindbladNoiseOperator::new(),
         }
     }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(
+        &self,
+    ) -> Result<struqture_one::bosons::BosonLindbladOpenSystem, StruqtureError> {
+        let new_system = self.system().to_struqture_1()?;
+        let new_noise = self.noise().to_struqture_1()?;
+
+        struqture_one::OpenSystem::group(new_system, new_noise).map_err(
+            |err| StruqtureError::GenericError { msg:
+                format!("Could not convert struqture 2.x BosonLindbladOpenSystem to 1.x BosonLindbladOpenSystem, group function failed: {:?}.", err)
+            }
+        )
+    }
+
+    /// Import from struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::bosons::BosonLindbladOpenSystem,
+    ) -> Result<Self, StruqtureError> {
+        let (system_one, noise_one) = struqture_one::OpenSystem::ungroup(value.clone());
+        let new_system = BosonHamiltonian::from_struqture_1(&system_one)?;
+        let new_noise = BosonLindbladNoiseOperator::from_struqture_1(&noise_one)?;
+        Self::group(new_system, new_noise)
+    }
 }
 
 /// Implements the negative sign function of BosonLindbladOpenSystem.
 ///
 impl ops::Neg for BosonLindbladOpenSystem {
     type Output = Self;
     /// Implement minus sign for BosonLindbladOpenSystem.
@@ -199,20 +188,20 @@
     /// # Arguments
     ///
     /// * `other` - The BosonLindbladOpenSystem to be added.
     ///
     /// # Returns
     ///
     /// * `Ok(Self)` - The two BosonLindbladOpenSystems added together.
-    /// * `Err(StruqtureError::NumberModesExceeded)` - Index of HermitianBosonProduct exceeds that of the BosonHamiltonianSystem.
-    /// * `Err(StruqtureError::NumberModesExceeded)` - Index of (BosonProduct, BosonProduct) exceeds that of the BosonLindbladNoiseSystem.
+    /// * `Err(StruqtureError::NumberModesExceeded)` - Index of HermitianBosonProduct exceeds that of the BosonHamiltonian.
+    /// * `Err(StruqtureError::NumberModesExceeded)` - Index of (BosonProduct, BosonProduct) exceeds that of the BosonLindbladNoiseOperator.
     fn add(self, other: BosonLindbladOpenSystem) -> Self::Output {
         let (self_sys, self_noise) = self.ungroup();
         let (other_sys, other_noise) = other.ungroup();
-        Self::group((self_sys + other_sys)?, (self_noise + other_noise)?)
+        Self::group((self_sys + other_sys)?, self_noise + other_noise)
     }
 }
 
 /// Implements the minus function of BosonLindbladOpenSystem by BosonLindbladOpenSystem.
 ///
 impl ops::Sub<BosonLindbladOpenSystem> for BosonLindbladOpenSystem {
     type Output = Result<Self, StruqtureError>;
@@ -221,20 +210,20 @@
     /// # Arguments
     ///
     /// * `other` - The BosonLindbladOpenSystem to be subtracted.
     ///
     /// # Returns
     ///
     /// * `Ok(Self)` - The two BosonLindbladOpenSystems added together.
-    /// * `Err(StruqtureError::NumberModesExceeded)` - Index of HermitianBosonProduct exceeds that of the BosonHamiltonianSystem.
-    /// * `Err(StruqtureError::NumberModesExceeded)` - Index of (BosonProduct, BosonProduct) exceeds that of the BosonLindbladNoiseSystem.
+    /// * `Err(StruqtureError::NumberModesExceeded)` - Index of HermitianBosonProduct exceeds that of the BosonHamiltonian.
+    /// * `Err(StruqtureError::NumberModesExceeded)` - Index of (BosonProduct, BosonProduct) exceeds that of the BosonLindbladNoiseOperator.
     fn sub(self, other: BosonLindbladOpenSystem) -> Self::Output {
         let (self_sys, self_noise) = self.ungroup();
         let (other_sys, other_noise) = other.ungroup();
-        Self::group((self_sys - other_sys)?, (self_noise - other_noise)?)
+        Self::group((self_sys - other_sys)?, self_noise - other_noise)
     }
 }
 
 /// Implements the multiplication function of BosonLindbladOpenSystem by CalculatorFloat.
 ///
 impl ops::Mul<CalculatorFloat> for BosonLindbladOpenSystem {
     type Output = Self;
@@ -242,15 +231,15 @@
     ///
     /// # Arguments
     ///
     /// * `other` - The CalculatorFloat by which to multiply.
     ///
     /// # Returns
     ///
-    /// * `Self` - The BosonLindbladNoiseSystem multiplied by the CalculatorFloat.
+    /// * `Self` - The BosonLindbladNoiseOperator multiplied by the CalculatorFloat.
     fn mul(self, rhs: CalculatorFloat) -> Self::Output {
         Self {
             system: self.system * rhs.clone(),
             noise: self.noise * rhs,
         }
     }
 }
@@ -264,15 +253,15 @@
     ///
     /// * `f` - The formatter to use.
     ///
     /// # Returns
     ///
     /// * `std::fmt::Result` - The formatted BosonLindbladOpenSystem.
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        let mut output = format!("BosonLindbladOpenSystem({}){{\n", self.number_modes());
+        let mut output = "BosonLindbladOpenSystem{\n".to_string();
         output.push_str("System: {\n");
         for (key, val) in self.system.iter() {
             writeln!(output, "{}: {},", key, val)?;
         }
         output.push_str("}\n");
         output.push_str("Noise: {\n");
         for ((row, column), val) in self.noise.iter() {
```

### Comparing `struqture_py-1.6.1/struqture/src/bosons/bosonic_operator.rs` & `struqture_py-2.0.0a0/struqture/src/bosons/bosonic_operator.rs`

 * *Files 12% similar despite different names*

```diff
@@ -10,31 +10,24 @@
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
 use super::{BosonHamiltonian, OperateOnBosons};
 use crate::bosons::BosonProduct;
 use crate::{
     GetValue, ModeIndex, OperateOnDensityMatrix, OperateOnModes, OperateOnState, StruqtureError,
-    StruqtureVersionSerializable, SymmetricIndex, MINIMUM_STRUQTURE_VERSION,
+    SymmetricIndex,
 };
-use itertools::Itertools;
 use qoqo_calculator::{CalculatorComplex, CalculatorFloat};
 use serde::{Deserialize, Serialize};
 use std::fmt::{self, Write};
 use std::iter::{FromIterator, IntoIterator};
 use std::ops;
 
-#[cfg(feature = "indexed_map_iterators")]
-use indexmap::map::{Entry, Iter, Keys, Values};
-#[cfg(feature = "indexed_map_iterators")]
+use indexmap::map::{Entry, Iter};
 use indexmap::IndexMap;
-#[cfg(not(feature = "indexed_map_iterators"))]
-use std::collections::hash_map::{Entry, Iter, Keys, Values};
-#[cfg(not(feature = "indexed_map_iterators"))]
-use std::collections::HashMap;
 
 /// BosonOperators are combinations of BosonProducts with specific CalculatorComplex coefficients.
 ///
 /// # Example
 ///
 /// ```
 /// use struqture::prelude::*;
@@ -53,26 +46,26 @@
 ///
 /// // Access what you set:
 /// assert_eq!(bo.get(&bp_0), &CalculatorComplex::from(0.5));
 /// assert_eq!(bo.get(&bp_1), &CalculatorComplex::from(0.2));
 /// ```
 ///
 #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
-#[serde(from = "BosonOperatorSerialize")]
+#[serde(try_from = "BosonOperatorSerialize")]
 #[serde(into = "BosonOperatorSerialize")]
 pub struct BosonOperator {
     /// The internal HashMap of BosonProducts and coefficients (CalculatorComplex)
-    #[cfg(feature = "indexed_map_iterators")]
     internal_map: IndexMap<BosonProduct, CalculatorComplex>,
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    internal_map: HashMap<BosonProduct, CalculatorComplex>,
 }
 
-impl crate::MinSupportedVersion for BosonOperator {}
-
+impl crate::SerializationSupport for BosonOperator {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::BosonOperator
+    }
+}
 #[cfg(feature = "json_schema")]
 impl schemars::JsonSchema for BosonOperator {
     fn schema_name() -> String {
         "BosonOperator".to_string()
     }
 
     fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
@@ -81,87 +74,78 @@
 }
 
 #[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
 #[cfg_attr(feature = "json_schema", derive(schemars::JsonSchema))]
 #[cfg_attr(feature = "json_schema", schemars(deny_unknown_fields))]
 struct BosonOperatorSerialize {
     items: Vec<(BosonProduct, CalculatorFloat, CalculatorFloat)>,
-    _struqture_version: StruqtureVersionSerializable,
+    serialisation_meta: crate::StruqtureSerialisationMeta,
 }
 
-impl From<BosonOperatorSerialize> for BosonOperator {
-    fn from(value: BosonOperatorSerialize) -> Self {
+impl TryFrom<BosonOperatorSerialize> for BosonOperator {
+    type Error = StruqtureError;
+    fn try_from(value: BosonOperatorSerialize) -> Result<Self, Self::Error> {
+        let target_serialisation_meta =
+            <Self as crate::SerializationSupport>::target_serialisation_meta();
+        crate::check_can_be_deserialised(&target_serialisation_meta, &value.serialisation_meta)?;
         let new_noise_op: BosonOperator = value
             .items
             .into_iter()
             .map(|(key, real, imag)| (key, CalculatorComplex { re: real, im: imag }))
             .collect();
-        new_noise_op
+        Ok(new_noise_op)
     }
 }
 
 impl From<BosonOperator> for BosonOperatorSerialize {
     fn from(value: BosonOperator) -> Self {
+        let serialisation_meta = crate::SerializationSupport::struqture_serialisation_meta(&value);
         let new_noise_op: Vec<(BosonProduct, CalculatorFloat, CalculatorFloat)> = value
             .into_iter()
             .map(|(key, val)| (key, val.re, val.im))
             .collect();
-        let current_version = StruqtureVersionSerializable {
-            major_version: MINIMUM_STRUQTURE_VERSION.0,
-            minor_version: MINIMUM_STRUQTURE_VERSION.1,
-        };
         Self {
             items: new_noise_op,
-            _struqture_version: current_version,
+            serialisation_meta,
         }
     }
 }
 
 impl<'a> OperateOnDensityMatrix<'a> for BosonOperator {
     type Index = BosonProduct;
     type Value = CalculatorComplex;
-    type IteratorType = Iter<'a, Self::Index, Self::Value>;
-    type KeyIteratorType = Keys<'a, Self::Index, Self::Value>;
-    type ValueIteratorType = Values<'a, Self::Index, Self::Value>;
 
     // From trait
     fn get(&self, key: &Self::Index) -> &Self::Value {
         match self.internal_map.get(key) {
             Some(value) => value,
             None => &CalculatorComplex::ZERO,
         }
     }
 
     // From trait
-    fn iter(&'a self) -> Self::IteratorType {
+    fn iter(&'a self) -> impl ExactSizeIterator<Item = (&'a Self::Index, &'a Self::Value)> {
         self.internal_map.iter()
     }
 
     // From trait
-    fn keys(&'a self) -> Self::KeyIteratorType {
+    fn keys(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Index> {
         self.internal_map.keys()
     }
 
     // From trait
-    fn values(&'a self) -> Self::ValueIteratorType {
+    fn values(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Value> {
         self.internal_map.values()
     }
 
-    #[cfg(feature = "indexed_map_iterators")]
     // From trait
     fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
         self.internal_map.shift_remove(key)
     }
 
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    // From trait
-    fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
-        self.internal_map.remove(key)
-    }
-
     // From trait
     fn empty_clone(&self, capacity: Option<usize>) -> Self {
         match capacity {
             Some(cap) => Self::with_capacity(cap),
             None => Self::new(),
         }
     }
@@ -182,49 +166,41 @@
         key: Self::Index,
         value: Self::Value,
     ) -> Result<Option<Self::Value>, StruqtureError> {
         if value != CalculatorComplex::ZERO {
             Ok(self.internal_map.insert(key, value))
         } else {
             match self.internal_map.entry(key) {
-                #[cfg(feature = "indexed_map_iterators")]
                 Entry::Occupied(val) => Ok(Some(val.shift_remove())),
-                #[cfg(not(feature = "indexed_map_iterators"))]
-                Entry::Occupied(val) => Ok(Some(val.remove())),
                 Entry::Vacant(_) => Ok(None),
             }
         }
     }
 }
 
 impl<'a> OperateOnState<'a> for BosonOperator {}
 
 impl<'a> OperateOnModes<'a> for BosonOperator {
-    // From trait
+    /// Gets the maximum index of the BosonOperator.
+    ///
+    /// # Returns
+    ///
+    /// * `usize` - The number of bosons in the BosonOperator.
     fn current_number_modes(&'a self) -> usize {
         let mut max_mode: usize = 0;
         if !self.is_empty() {
             for key in self.keys() {
                 let maxk = key.current_number_modes();
                 if maxk > max_mode {
                     max_mode = maxk;
                 }
             }
         }
         max_mode
     }
-
-    /// Gets the maximum index of the BosonOperator.
-    ///
-    /// # Returns
-    ///
-    /// * `usize` - The number of bosons in the BosonOperator.
-    fn number_modes(&'a self) -> usize {
-        self.current_number_modes()
-    }
 }
 
 impl<'a> OperateOnBosons<'a> for BosonOperator {}
 
 /// Implements the default function (Default trait) of BosonOperator (an empty BosonOperator).
 ///
 impl Default for BosonOperator {
@@ -239,17 +215,14 @@
     /// Creates a new BosonOperator.
     ///
     /// # Returns
     ///
     /// * `Self` - The new (empty) BosonOperator.
     pub fn new() -> Self {
         BosonOperator {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::new(),
-            #[cfg(feature = "indexed_map_iterators")]
             internal_map: IndexMap::new(),
         }
     }
 
     /// Creates a new BosonOperator with pre-allocated capacity.
     ///
     /// # Arguments
@@ -257,44 +230,44 @@
     /// * `capacity` - The pre-allocated capacity of the operator.
     ///
     /// # Returns
     ///
     /// * `Self` - The new (empty) BosonOperator.
     pub fn with_capacity(capacity: usize) -> Self {
         BosonOperator {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::with_capacity(capacity),
-            #[cfg(feature = "indexed_map_iterators")]
             internal_map: IndexMap::with_capacity(capacity),
         }
     }
 
-    /// Separate self into an operator with the terms of given number of creation and annihilation operators and an operator with the remaining operations
-    ///
-    /// # Arguments
-    ///
-    /// * `number_creators_annihilators` - Number of creation and annihilation terms to filter for in the keys.
-    ///
-    /// # Returns
-    ///
-    /// `Ok((separated, remainder))` - Operator with the noise terms where number_creators_annihilators matches the number of spins the operator product acts on and Operator with all other contributions.
-    pub fn separate_into_n_terms(
-        &self,
-        number_creators_annihilators: (usize, usize),
-    ) -> Result<(Self, Self), StruqtureError> {
-        let mut separated = Self::default();
-        let mut remainder = Self::default();
-        for (prod, val) in self.iter() {
-            if (prod.creators().len(), prod.annihilators().len()) == number_creators_annihilators {
-                separated.add_operator_product(prod.clone(), val.clone())?;
-            } else {
-                remainder.add_operator_product(prod.clone(), val.clone())?;
-            }
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(&self) -> Result<struqture_one::bosons::BosonSystem, StruqtureError> {
+        let mut new_boson_system = struqture_one::bosons::BosonSystem::new(None);
+        for (key, val) in self.iter() {
+            let one_key = key.to_struqture_1()?;
+            let _ = struqture_one::OperateOnDensityMatrix::set(
+                &mut new_boson_system,
+                one_key,
+                val.clone(),
+            );
+        }
+        Ok(new_boson_system)
+    }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::bosons::BosonSystem,
+    ) -> Result<Self, StruqtureError> {
+        let mut new_qubit_operator = Self::new();
+        for (key, val) in struqture_one::OperateOnDensityMatrix::iter(value) {
+            let self_key = BosonProduct::from_struqture_1(key)?;
+            let _ = new_qubit_operator.set(self_key, val.clone());
         }
-        Ok((separated, remainder))
+        Ok(new_qubit_operator)
     }
 }
 
 impl From<BosonHamiltonian> for BosonOperator {
     /// Converts a BosonHamiltonian into a BosonOperator.
     ///
     /// # Arguments
@@ -440,37 +413,33 @@
     ///
     /// * `Self` - The two BosonOperators multiplied.
     ///
     /// # Panics
     ///
     /// * Internal error in add_operator_product.
     fn mul(self, other: BosonOperator) -> Self {
-        let mut boson_op = BosonOperator::new();
-        for ((left_key, left_val), (right_key, right_val)) in
-            self.into_iter().cartesian_product(other.iter())
-        {
-            let list_of_products = left_key * right_key.clone();
-            let product = left_val.clone() * right_val;
-            for product_key in list_of_products {
-                boson_op
-                    .add_operator_product(product_key, product.clone())
-                    .expect("Internal error in add_operator_product");
+        let mut op = BosonOperator::with_capacity(self.len() * other.len());
+        for (bps, vals) in self {
+            for (bpo, valo) in other.iter() {
+                let boson_products = bps.clone() * bpo.clone();
+                let coefficient = Into::<CalculatorComplex>::into(valo) * vals.clone();
+                for prod in boson_products {
+                    op.add_operator_product(prod, coefficient.clone())
+                        .expect("Internal bug in add_operator_product");
+                }
             }
         }
-        boson_op
+        op
     }
 }
 
 /// Implements the into_iter function (IntoIterator trait) of BosonOperator.
 ///
 impl IntoIterator for BosonOperator {
     type Item = (BosonProduct, CalculatorComplex);
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    type IntoIter = std::collections::hash_map::IntoIter<BosonProduct, CalculatorComplex>;
-    #[cfg(feature = "indexed_map_iterators")]
     type IntoIter = indexmap::map::IntoIter<BosonProduct, CalculatorComplex>;
     /// Returns the BosonOperator in Iterator form.
     ///
     /// # Returns
     ///
     /// * `Self::IntoIter` - The BosonOperator in Iterator form.
     fn into_iter(self) -> Self::IntoIter {
@@ -556,96 +525,102 @@
 }
 
 #[cfg(test)]
 mod test {
     use super::*;
     use serde_test::{assert_tokens, Configure, Token};
 
-    // Test the Clone and PartialEq traits of SpinOperator
+    // Test the Clone and PartialEq traits of QubitOperator
     #[test]
     fn so_from_sos() {
         let pp: BosonProduct = BosonProduct::new([0], [0]).unwrap();
         let sos = BosonOperatorSerialize {
             items: vec![(pp.clone(), 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "BosonOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0-alpha.0".to_string(),
             },
         };
         let mut so = BosonOperator::new();
         so.set(pp, CalculatorComplex::from(0.5)).unwrap();
 
-        assert_eq!(BosonOperator::from(sos.clone()), so);
+        assert_eq!(BosonOperator::try_from(sos.clone()).unwrap(), so);
         assert_eq!(BosonOperatorSerialize::from(so), sos);
     }
-    // Test the Clone and PartialEq traits of SpinOperator
+    // Test the Clone and PartialEq traits of QubitOperator
     #[test]
     fn clone_partial_eq() {
         let pp: BosonProduct = BosonProduct::new([0], [0]).unwrap();
         let sos = BosonOperatorSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "BosonOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         // Test Clone trait
         assert_eq!(sos.clone(), sos);
 
         // Test PartialEq trait
         let pp_1: BosonProduct = BosonProduct::new([0], [0]).unwrap();
         let sos_1 = BosonOperatorSerialize {
             items: vec![(pp_1, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "BosonOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
         let pp_2: BosonProduct = BosonProduct::new([1], [0]).unwrap();
         let sos_2 = BosonOperatorSerialize {
             items: vec![(pp_2, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "BosonOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
         assert!(sos_1 == sos);
         assert!(sos == sos_1);
         assert!(sos_2 != sos);
         assert!(sos != sos_2);
     }
 
-    // Test the Debug trait of SpinOperator
+    // Test the Debug trait of QubitOperator
     #[test]
     fn debug() {
         let pp: BosonProduct = BosonProduct::new([0], [0]).unwrap();
         let sos = BosonOperatorSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "BosonOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_eq!(
             format!("{:?}", sos),
-            "BosonOperatorSerialize { items: [(BosonProduct { creators: [0], annihilators: [0] }, Float(0.5), Float(0.0))], _struqture_version: StruqtureVersionSerializable { major_version: 1, minor_version: 0 } }"
+            "BosonOperatorSerialize { items: [(BosonProduct { creators: [0], annihilators: [0] }, Float(0.5), Float(0.0))], serialisation_meta: StruqtureSerialisationMeta { type_name: \"BosonOperator\", min_version: (2, 0, 0), version: \"2.0.0\" } }"
         );
     }
 
-    /// Test SpinOperator Serialization and Deserialization traits (readable)
+    /// Test QubitOperator Serialization and Deserialization traits (readable)
     #[test]
     fn serde_readable() {
         let pp: BosonProduct = BosonProduct::new([0], [0]).unwrap();
         let sos = BosonOperatorSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "BosonOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_tokens(
             &sos.readable(),
             &[
                 Token::Struct {
@@ -656,38 +631,45 @@
                 Token::Seq { len: Some(1) },
                 Token::Tuple { len: 3 },
                 Token::Str("c0a0"),
                 Token::F64(0.5),
                 Token::F64(0.0),
                 Token::TupleEnd,
                 Token::SeqEnd,
-                Token::Str("_struqture_version"),
+                Token::Str("serialisation_meta"),
                 Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
                 },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(0),
+                Token::Str("type_name"),
+                Token::Str("BosonOperator"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
                 Token::StructEnd,
                 Token::StructEnd,
             ],
         );
     }
 
-    /// Test SpinOperator Serialization and Deserialization traits (compact)
+    /// Test QubitOperator Serialization and Deserialization traits (compact)
     #[test]
     fn serde_compact() {
         let pp: BosonProduct = BosonProduct::new([0], [0]).unwrap();
         let sos = BosonOperatorSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "BosonOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_tokens(
             &sos.compact(),
             &[
                 Token::Struct {
@@ -713,22 +695,28 @@
                 Token::NewtypeVariant {
                     name: "CalculatorFloat",
                     variant: "Float",
                 },
                 Token::F64(0.0),
                 Token::TupleEnd,
                 Token::SeqEnd,
-                Token::Str("_struqture_version"),
+                Token::Str("serialisation_meta"),
                 Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
                 },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(0),
+                Token::Str("type_name"),
+                Token::Str("BosonOperator"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
                 Token::StructEnd,
                 Token::StructEnd,
             ],
         );
     }
 }
```

### Comparing `struqture_py-1.6.1/struqture/src/bosons/mod.rs` & `struqture_py-2.0.0a0/struqture/src/bosons/mod.rs`

 * *Files 6% similar despite different names*

```diff
@@ -16,30 +16,24 @@
 //!
 //! In general the enduser should use the high-level [crate::bosons::BosonSystem] and [crate::bosons::BosonHamiltonian] structs
 //! to represent bosonic quantum Operators and bosonic Hamiltonians respectively.
 //!
 //! Open Quantum Systems should be represented using [crate::bosons::BosonLindbladOpenSystem].
 
 mod bosonic_hamiltonian;
-mod bosonic_hamiltonian_system;
 mod bosonic_indices;
 mod bosonic_noise_operator;
-mod bosonic_noise_system;
 mod bosonic_open_system;
 mod bosonic_operator;
-mod bosonic_system;
 use std::str::FromStr;
 
 pub use bosonic_hamiltonian::BosonHamiltonian;
-pub use bosonic_hamiltonian_system::BosonHamiltonianSystem;
 pub use bosonic_noise_operator::BosonLindbladNoiseOperator;
-pub use bosonic_noise_system::BosonLindbladNoiseSystem;
 pub use bosonic_open_system::BosonLindbladOpenSystem;
 pub use bosonic_operator::BosonOperator;
-pub use bosonic_system::BosonSystem;
 
 use crate::{ModeIndex, OperateOnDensityMatrix, SymmetricIndex};
 pub use bosonic_indices::{BosonProduct, HermitianBosonProduct};
 use qoqo_calculator::CalculatorComplex;
 
 /// Signal Trait for specifying that a type can be used a bosonic index.
 ///
```

### Comparing `struqture_py-1.6.1/struqture/src/fermions/fermionic_hamiltonian.rs` & `struqture_py-2.0.0a0/struqture/src/fermions/fermionic_hamiltonian.rs`

 * *Files 7% similar despite different names*

```diff
@@ -10,33 +10,27 @@
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
 use super::{
     FermionOperator, FermionProduct, HermitianFermionProduct, ModeIndex, OperateOnFermions,
 };
 use crate::mappings::JordanWignerFermionToSpin;
-use crate::spins::SpinHamiltonian;
+use crate::spins::QubitHamiltonian;
 use crate::{
     GetValue, OperateOnDensityMatrix, OperateOnModes, OperateOnState, StruqtureError,
-    StruqtureVersionSerializable, SymmetricIndex, MINIMUM_STRUQTURE_VERSION,
+    SymmetricIndex,
 };
 use qoqo_calculator::{CalculatorComplex, CalculatorFloat};
 use serde::{Deserialize, Serialize};
 use std::fmt::{self, Write};
 use std::iter::{FromIterator, IntoIterator};
 use std::ops;
 
-#[cfg(feature = "indexed_map_iterators")]
-use indexmap::map::{Entry, Iter, Keys, Values};
-#[cfg(feature = "indexed_map_iterators")]
+use indexmap::map::{Entry, Iter};
 use indexmap::IndexMap;
-#[cfg(not(feature = "indexed_map_iterators"))]
-use std::collections::hash_map::{Entry, Iter, Keys, Values};
-#[cfg(not(feature = "indexed_map_iterators"))]
-use std::collections::HashMap;
 
 /// FermionHamiltonians are combinations of FermionProducts with specific CalculatorComplex coefficients.
 ///
 /// This is a representation of sums of creation and annihilation operators with weightings, in order to build a full hamiltonian.
 /// FermionHamiltonian is the hermitian equivalent of FermionOperator.
 ///
 /// # Example
@@ -56,25 +50,26 @@
 ///
 /// // Access what you set:
 /// assert_eq!(fh.get(&fp_0_1), &CalculatorComplex::from(0.5));
 /// assert_eq!(fh.get(&fp_0), &CalculatorComplex::from(0.2));
 /// ```
 ///
 #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
-#[serde(from = "FermionHamiltonianSerialize")]
+#[serde(try_from = "FermionHamiltonianSerialize")]
 #[serde(into = "FermionHamiltonianSerialize")]
 pub struct FermionHamiltonian {
     /// The internal HashMap of FermionProducts and coefficients (CalculatorComplex)
-    #[cfg(feature = "indexed_map_iterators")]
     internal_map: IndexMap<HermitianFermionProduct, CalculatorComplex>,
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    internal_map: HashMap<HermitianFermionProduct, CalculatorComplex>,
 }
 
-impl crate::MinSupportedVersion for FermionHamiltonian {}
+impl crate::SerializationSupport for FermionHamiltonian {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::FermionHamiltonian
+    }
+}
 
 #[cfg(feature = "json_schema")]
 impl schemars::JsonSchema for FermionHamiltonian {
     fn schema_name() -> String {
         "FermionHamiltonian".to_string()
     }
 
@@ -84,87 +79,78 @@
 }
 
 #[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
 #[cfg_attr(feature = "json_schema", derive(schemars::JsonSchema))]
 #[cfg_attr(feature = "json_schema", schemars(deny_unknown_fields))]
 struct FermionHamiltonianSerialize {
     items: Vec<(HermitianFermionProduct, CalculatorFloat, CalculatorFloat)>,
-    _struqture_version: StruqtureVersionSerializable,
+    serialisation_meta: crate::StruqtureSerialisationMeta,
 }
 
-impl From<FermionHamiltonianSerialize> for FermionHamiltonian {
-    fn from(value: FermionHamiltonianSerialize) -> Self {
+impl TryFrom<FermionHamiltonianSerialize> for FermionHamiltonian {
+    type Error = StruqtureError;
+    fn try_from(value: FermionHamiltonianSerialize) -> Result<Self, Self::Error> {
+        let target_serialisation_meta =
+            <Self as crate::SerializationSupport>::target_serialisation_meta();
+        crate::check_can_be_deserialised(&target_serialisation_meta, &value.serialisation_meta)?;
         let new_noise_op: FermionHamiltonian = value
             .items
             .into_iter()
             .map(|(key, real, imag)| (key, CalculatorComplex { re: real, im: imag }))
             .collect();
-        new_noise_op
+        Ok(new_noise_op)
     }
 }
 
 impl From<FermionHamiltonian> for FermionHamiltonianSerialize {
     fn from(value: FermionHamiltonian) -> Self {
+        let serialisation_meta = crate::SerializationSupport::struqture_serialisation_meta(&value);
         let new_noise_op: Vec<(HermitianFermionProduct, CalculatorFloat, CalculatorFloat)> = value
             .into_iter()
             .map(|(key, val)| (key, val.re, val.im))
             .collect();
-        let current_version = StruqtureVersionSerializable {
-            major_version: MINIMUM_STRUQTURE_VERSION.0,
-            minor_version: MINIMUM_STRUQTURE_VERSION.1,
-        };
         Self {
             items: new_noise_op,
-            _struqture_version: current_version,
+            serialisation_meta,
         }
     }
 }
 
 impl<'a> OperateOnDensityMatrix<'a> for FermionHamiltonian {
     type Index = HermitianFermionProduct;
     type Value = CalculatorComplex;
-    type IteratorType = Iter<'a, Self::Index, Self::Value>;
-    type KeyIteratorType = Keys<'a, Self::Index, Self::Value>;
-    type ValueIteratorType = Values<'a, Self::Index, Self::Value>;
 
     // From trait
     fn get(&self, key: &HermitianFermionProduct) -> &CalculatorComplex {
         match self.internal_map.get(key) {
             Some(value) => value,
             None => &CalculatorComplex::ZERO,
         }
     }
 
     // From trait
-    fn iter(&'a self) -> Self::IteratorType {
+    fn iter(&'a self) -> impl ExactSizeIterator<Item = (&'a Self::Index, &'a Self::Value)> {
         self.internal_map.iter()
     }
 
     // From trait
-    fn keys(&'a self) -> Self::KeyIteratorType {
+    fn keys(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Index> {
         self.internal_map.keys()
     }
 
     // From trait
-    fn values(&'a self) -> Self::ValueIteratorType {
+    fn values(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Value> {
         self.internal_map.values()
     }
 
-    #[cfg(feature = "indexed_map_iterators")]
     // From trait
     fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
         self.internal_map.shift_remove(key)
     }
 
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    // From trait
-    fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
-        self.internal_map.remove(key)
-    }
-
     // From trait
     fn empty_clone(&self, capacity: Option<usize>) -> Self {
         match capacity {
             Some(cap) => Self::with_capacity(cap),
             None => Self::new(),
         }
     }
@@ -191,18 +177,15 @@
             if key.is_natural_hermitian() && value.im != CalculatorFloat::ZERO {
                 Err(StruqtureError::NonHermitianOperator)
             } else {
                 Ok(self.internal_map.insert(key, value))
             }
         } else {
             match self.internal_map.entry(key) {
-                #[cfg(feature = "indexed_map_iterators")]
                 Entry::Occupied(val) => Ok(Some(val.shift_remove())),
-                #[cfg(not(feature = "indexed_map_iterators"))]
-                Entry::Occupied(val) => Ok(Some(val.remove())),
                 Entry::Vacant(_) => Ok(None),
             }
         }
     }
 
     /// Adds a new (HermitianFermionProduct key, CalculatorComplex value) pair to the FermionHamiltonian.
     ///
@@ -239,39 +222,30 @@
     /// * `Self` - The hermitian conjugate of Self.
     fn hermitian_conjugate(&self) -> Self {
         self.clone()
     }
 }
 
 impl<'a> OperateOnModes<'a> for FermionHamiltonian {
-    /// Return maximum index in FermionHamiltonian internal_map.
+    /// Gets the maximum index of the FermionHamiltonian.
     ///
     /// # Returns
     ///
-    /// * `usize` - Maximum index.
+    /// * `usize` - The number of modes in the FermionHamiltonian.
     fn current_number_modes(&self) -> usize {
         let mut max_mode: usize = 0;
         if !self.internal_map.is_empty() {
             for key in self.internal_map.keys() {
                 if key.current_number_modes() > max_mode {
                     max_mode = key.current_number_modes()
                 }
             }
         }
         max_mode
     }
-
-    /// Gets the maximum index of the FermionHamiltonian.
-    ///
-    /// # Returns
-    ///
-    /// * `usize` - The number of spins in the FermionHamiltonian.
-    fn number_modes(&self) -> usize {
-        self.current_number_modes()
-    }
 }
 
 impl<'a> OperateOnFermions<'a> for FermionHamiltonian {}
 
 /// Implements the default function (Default trait) of FermionHamiltonian (an empty FermionHamiltonian).
 ///
 impl Default for FermionHamiltonian {
@@ -286,17 +260,14 @@
     /// Creates a new FermionHamiltonian.
     ///
     /// # Returns
     ///
     /// * `Self` - The new (empty) FermionHamiltonian.
     pub fn new() -> Self {
         FermionHamiltonian {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::new(),
-            #[cfg(feature = "indexed_map_iterators")]
             internal_map: IndexMap::new(),
         }
     }
 
     /// Creates a new FermionHamiltonian with pre-allocated capacity.
     ///
     /// # Arguments
@@ -304,44 +275,46 @@
     /// * `capacity` - The pre-allocated capacity of the hamiltonian.
     ///
     /// # Returns
     ///
     /// * `Self` - The new (empty) FermionHamiltonian.
     pub fn with_capacity(capacity: usize) -> Self {
         Self {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::with_capacity(capacity),
-            #[cfg(feature = "indexed_map_iterators")]
             internal_map: IndexMap::with_capacity(capacity),
         }
     }
 
-    /// Separate self into an operator with the terms of given number of creation and annihilation operators and an operator with the remaining operations
-    ///
-    /// # Arguments
-    ///
-    /// * `number_creators_annihilators` - Number of creation and annihilation terms to filter for in the keys.
-    ///
-    /// # Returns
-    ///
-    /// `Ok((separated, remainder))` - Operator with the noise terms where number_creators_annihilators matches the number of spins the operator product acts on and Operator with all other contributions.
-    pub fn separate_into_n_terms(
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(
         &self,
-        number_creators_annihilators: (usize, usize),
-    ) -> Result<(Self, Self), StruqtureError> {
-        let mut separated = Self::default();
-        let mut remainder = Self::default();
-        for (prod, val) in self.iter() {
-            if (prod.creators().len(), prod.annihilators().len()) == number_creators_annihilators {
-                separated.add_operator_product(prod.clone(), val.clone())?;
-            } else {
-                remainder.add_operator_product(prod.clone(), val.clone())?;
-            }
+    ) -> Result<struqture_one::fermions::FermionHamiltonianSystem, StruqtureError> {
+        let mut new_fermion_system = struqture_one::fermions::FermionHamiltonianSystem::new(None);
+        for (key, val) in self.iter() {
+            let one_key = key.to_struqture_1()?;
+            let _ = struqture_one::OperateOnDensityMatrix::set(
+                &mut new_fermion_system,
+                one_key,
+                val.clone(),
+            );
+        }
+        Ok(new_fermion_system)
+    }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::fermions::FermionHamiltonianSystem,
+    ) -> Result<Self, StruqtureError> {
+        let mut new_qubit_operator = Self::new();
+        for (key, val) in struqture_one::OperateOnDensityMatrix::iter(value) {
+            let self_key = HermitianFermionProduct::from_struqture_1(key)?;
+            let _ = new_qubit_operator.set(self_key, val.clone());
         }
-        Ok((separated, remainder))
+        Ok(new_qubit_operator)
     }
 }
 
 impl TryFrom<FermionOperator> for FermionHamiltonian {
     type Error = StruqtureError;
     /// Tries to convert a FermionOperator into a FermionHamiltonian.
     ///
@@ -531,18 +504,14 @@
     }
 }
 
 /// Implements the into_iter function (IntoIterator trait) of FermionHamiltonian.
 ///
 impl IntoIterator for FermionHamiltonian {
     type Item = (HermitianFermionProduct, CalculatorComplex);
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    type IntoIter =
-        std::collections::hash_map::IntoIter<HermitianFermionProduct, CalculatorComplex>;
-    #[cfg(feature = "indexed_map_iterators")]
     type IntoIter = indexmap::map::IntoIter<HermitianFermionProduct, CalculatorComplex>;
     /// Returns the FermionHamiltonian in Iterator form.
     ///
     /// # Returns
     ///
     /// * `Self::IntoIter` - The FermionHamiltonian in Iterator form.
     fn into_iter(self) -> Self::IntoIter {
@@ -637,138 +606,144 @@
         output.push('}');
 
         write!(f, "{}", output)
     }
 }
 
 impl JordanWignerFermionToSpin for FermionHamiltonian {
-    type Output = SpinHamiltonian;
+    type Output = QubitHamiltonian;
 
     /// Implements JordanWignerFermionToSpin for a FermionHamiltonian.
     ///
     /// The convention used is that |0> represents an empty fermionic state (spin-orbital),
     /// and |1> represents an occupied fermionic state.
     ///
     /// # Returns
     ///
-    /// `SpinHamiltonian` - The spin Hamiltonian that results from the transformation.
+    /// `QubitHamiltonian` - The spin Hamiltonian that results from the transformation.
     fn jordan_wigner(&self) -> Self::Output {
-        let mut out = SpinHamiltonian::new();
+        let mut out = QubitHamiltonian::new();
 
         for hfp in self.keys() {
             let coeff = self.get(hfp);
             let creators: Vec<usize> = hfp.creators().cloned().collect();
             let annihilators: Vec<usize> = hfp.annihilators().cloned().collect();
             let fp = FermionProduct::new(creators, annihilators)
                 .expect("Failed to create FermionProduct from HermitianFermionProduct.");
 
             if hfp.is_natural_hermitian() {
                 out = out + hfp.jordan_wigner() * coeff.re.clone();
             } else {
                 let (fp_conj, conjugate_sign) = fp.hermitian_conjugate();
 
-                let spin_op = fp.jordan_wigner() * coeff.clone()
+                let qubit_op = fp.jordan_wigner() * coeff.clone()
                     + fp_conj.jordan_wigner() * conjugate_sign * coeff.conj();
-                let spin_hamiltonian = SpinHamiltonian::try_from(spin_op).expect(
-                    "Something went wrong when attempting to cast SpinOperator into SpinHamiltonian.",
+                let qubit_hamiltonian = QubitHamiltonian::try_from(qubit_op).expect(
+                    "Something went wrong when attempting to cast QubitOperator into QubitHamiltonian.",
                 );
-                out = out + spin_hamiltonian;
+                out = out + qubit_hamiltonian;
             }
         }
         out
     }
 }
 
 #[cfg(test)]
 mod test {
     use super::*;
     use serde_test::{assert_tokens, Configure, Token};
 
-    // Test the Clone and PartialEq traits of SpinOperator
+    // Test the Clone and PartialEq traits of QubitOperator
     #[test]
     fn so_from_sos() {
         let pp: HermitianFermionProduct = HermitianFermionProduct::new([0], [0]).unwrap();
         let sos = FermionHamiltonianSerialize {
             items: vec![(pp.clone(), 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "FermionHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0-alpha.0".to_string(),
             },
         };
         let mut so = FermionHamiltonian::new();
         so.set(pp, CalculatorComplex::from(0.5)).unwrap();
 
-        assert_eq!(FermionHamiltonian::from(sos.clone()), so);
+        assert_eq!(FermionHamiltonian::try_from(sos.clone()).unwrap(), so);
         assert_eq!(FermionHamiltonianSerialize::from(so), sos);
     }
-    // Test the Clone and PartialEq traits of SpinOperator
+    // Test the Clone and PartialEq traits of QubitOperator
     #[test]
     fn clone_partial_eq() {
         let pp: HermitianFermionProduct = HermitianFermionProduct::new([0], [0]).unwrap();
         let sos = FermionHamiltonianSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "FermionHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         // Test Clone trait
         assert_eq!(sos.clone(), sos);
 
         // Test PartialEq trait
         let pp_1: HermitianFermionProduct = HermitianFermionProduct::new([0], [0]).unwrap();
         let sos_1 = FermionHamiltonianSerialize {
             items: vec![(pp_1, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "FermionHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
         let pp_2: HermitianFermionProduct = HermitianFermionProduct::new([0], [1]).unwrap();
         let sos_2 = FermionHamiltonianSerialize {
             items: vec![(pp_2, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "FermionHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
         assert!(sos_1 == sos);
         assert!(sos == sos_1);
         assert!(sos_2 != sos);
         assert!(sos != sos_2);
     }
 
-    // Test the Debug trait of SpinOperator
+    // Test the Debug trait of QubitOperator
     #[test]
     fn debug() {
         let pp: HermitianFermionProduct = HermitianFermionProduct::new([0], [0]).unwrap();
         let sos = FermionHamiltonianSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "FermionHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_eq!(
             format!("{:?}", sos),
-            "FermionHamiltonianSerialize { items: [(HermitianFermionProduct { creators: [0], annihilators: [0] }, Float(0.5), Float(0.0))], _struqture_version: StruqtureVersionSerializable { major_version: 1, minor_version: 0 } }"
+            "FermionHamiltonianSerialize { items: [(HermitianFermionProduct { creators: [0], annihilators: [0] }, Float(0.5), Float(0.0))], serialisation_meta: StruqtureSerialisationMeta { type_name: \"FermionHamiltonian\", min_version: (2, 0, 0), version: \"2.0.0\" } }"
         );
     }
 
-    /// Test SpinOperator Serialization and Deserialization traits (readable)
+    /// Test QubitOperator Serialization and Deserialization traits (readable)
     #[test]
     fn serde_readable() {
         let pp: HermitianFermionProduct = HermitianFermionProduct::new([0], [0]).unwrap();
         let sos = FermionHamiltonianSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "FermionHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_tokens(
             &sos.readable(),
             &[
                 Token::Struct {
@@ -779,38 +754,45 @@
                 Token::Seq { len: Some(1) },
                 Token::Tuple { len: 3 },
                 Token::Str("c0a0"),
                 Token::F64(0.5),
                 Token::F64(0.0),
                 Token::TupleEnd,
                 Token::SeqEnd,
-                Token::Str("_struqture_version"),
+                Token::Str("serialisation_meta"),
                 Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
                 },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(0),
+                Token::Str("type_name"),
+                Token::Str("FermionHamiltonian"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
                 Token::StructEnd,
                 Token::StructEnd,
             ],
         );
     }
 
-    /// Test SpinOperator Serialization and Deserialization traits (compact)
+    /// Test QubitOperator Serialization and Deserialization traits (compact)
     #[test]
     fn serde_compact() {
         let pp: HermitianFermionProduct = HermitianFermionProduct::new([0], [0]).unwrap();
         let sos = FermionHamiltonianSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "FermionHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_tokens(
             &sos.compact(),
             &[
                 Token::Struct {
@@ -836,22 +818,28 @@
                 Token::NewtypeVariant {
                     name: "CalculatorFloat",
                     variant: "Float",
                 },
                 Token::F64(0.0),
                 Token::TupleEnd,
                 Token::SeqEnd,
-                Token::Str("_struqture_version"),
+                Token::Str("serialisation_meta"),
                 Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
                 },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(0),
+                Token::Str("type_name"),
+                Token::Str("FermionHamiltonian"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
                 Token::StructEnd,
                 Token::StructEnd,
             ],
         );
     }
 }
```

### Comparing `struqture_py-1.6.1/struqture/src/fermions/fermionic_indices.rs` & `struqture_py-2.0.0a0/struqture/src/fermions/fermionic_indices.rs`

 * *Files 8% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
 use super::FermionIndex;
 use crate::mappings::JordanWignerFermionToSpin;
 use crate::prelude::*;
-use crate::spins::{PauliProduct, SingleSpinOperator, SpinHamiltonian, SpinOperator};
+use crate::spins::{PauliProduct, QubitHamiltonian, QubitOperator, SingleQubitOperator};
 use crate::{
     CorrespondsTo, CreatorsAnnihilators, GetValue, ModeIndex, StruqtureError, SymmetricIndex,
 };
 
 use qoqo_calculator::*;
 use serde::{
     de::{Error, SeqAccess, Visitor},
@@ -64,15 +64,19 @@
         let meta = obj.metadata();
         meta.description = Some("Represents products of Fermionic creators and annhilators by a string creators (c) or annihilators (a) followed by the modes they are acting on. E.g. c0a1.".to_string());
 
         schemars::schema::Schema::Object(obj)
     }
 }
 
-impl crate::MinSupportedVersion for FermionProduct {}
+impl crate::SerializationSupport for FermionProduct {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::FermionProduct
+    }
+}
 
 /// Implementing serde serialization writing directly to string.
 ///
 impl Serialize for FermionProduct {
     /// Serialization function for FermionProduct according to string type.
     ///
     /// # Arguments
@@ -273,14 +277,39 @@
             value,
         ))
     }
 }
 
 impl FermionIndex for FermionProduct {}
 
+impl FermionProduct {
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(
+        &self,
+    ) -> Result<struqture_one::fermions::FermionProduct, StruqtureError> {
+        let self_string = self.to_string();
+        let struqture_one_product = struqture_one::fermions::FermionProduct::from_str(&self_string)
+            .map_err(|err| StruqtureError::GenericError {
+                msg: format!("{}", err),
+            })?;
+        Ok(struqture_one_product)
+    }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::fermions::FermionProduct,
+    ) -> Result<Self, StruqtureError> {
+        let value_string = value.to_string();
+        let pauli_product = Self::from_str(&value_string)?;
+        Ok(pauli_product)
+    }
+}
+
 impl CorrespondsTo<FermionProduct> for FermionProduct {
     /// Gets the FermionProduct corresponding to self (here, itself).
     ///
     /// # Returns
     ///
     /// * `FermionProduct` - The FermionProduct corresponding to Self.
     fn corresponds_to(&self) -> FermionProduct {
@@ -610,15 +639,19 @@
         let meta = obj.metadata();
         meta.description = Some("Represents products of Fermionic creators and annhilators by a string creators (c) or annihilators (a) followed by the modes they are acting on. E.g. c0a1.".to_string());
 
         schemars::schema::Schema::Object(obj)
     }
 }
 
-impl crate::MinSupportedVersion for HermitianFermionProduct {}
+impl crate::SerializationSupport for HermitianFermionProduct {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::HermitianFermionProduct
+    }
+}
 
 /// Implementing serde serialization writing directly to string.
 ///
 impl Serialize for HermitianFermionProduct {
     /// Serialization function for FermionProduct according to string type.
     ///
     /// # Arguments
@@ -882,14 +915,41 @@
             ))
         }
     }
 }
 
 impl FermionIndex for HermitianFermionProduct {}
 
+impl HermitianFermionProduct {
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(
+        &self,
+    ) -> Result<struqture_one::fermions::HermitianFermionProduct, StruqtureError> {
+        let self_string = self.to_string();
+        let struqture_one_product = struqture_one::fermions::HermitianFermionProduct::from_str(
+            &self_string,
+        )
+        .map_err(|err| StruqtureError::GenericError {
+            msg: format!("{}", err),
+        })?;
+        Ok(struqture_one_product)
+    }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::fermions::HermitianFermionProduct,
+    ) -> Result<Self, StruqtureError> {
+        let value_string = value.to_string();
+        let pauli_product = Self::from_str(&value_string)?;
+        Ok(pauli_product)
+    }
+}
+
 impl CorrespondsTo<HermitianFermionProduct> for HermitianFermionProduct {
     /// Gets the HermitianFermionProduct corresponding to self (here, itself).
     ///
     /// # Returns
     ///
     /// * `HermitianFermionProduct` - The HermitianFermionProduct corresponding to Self.
     fn corresponds_to(&self) -> HermitianFermionProduct {
@@ -1294,149 +1354,149 @@
             }
         }
     }
     (local_indices, contain_double, parity)
 }
 
 impl JordanWignerFermionToSpin for FermionProduct {
-    type Output = SpinOperator;
+    type Output = QubitOperator;
 
     /// Implements JordanWignerFermionToSpin for a FermionProduct.
     ///
     /// The convention used is that |0> represents an empty fermionic state (spin-orbital),
     /// and |1> represents an occupied fermionic state.
     ///
     /// # Returns
     ///
-    /// `SpinOperator` - The spin operator that results from the transformation.
+    /// `QubitOperator` - The spin operator that results from the transformation.
     ///
     /// # Panics
     ///
-    /// * Unexpectedly failed to add a PauliProduct to a SpinOperator internal struqture bug.
+    /// * Unexpectedly failed to add a PauliProduct to a QubitOperator internal struqture bug.
     /// * Internal bug in `add_operator_product`.
     fn jordan_wigner(&self) -> Self::Output {
         let number_creators = self.number_creators();
         let number_annihilators = self.number_annihilators();
-        let mut spin_operator = SpinOperator::new();
+        let mut qubit_operator = QubitOperator::new();
 
         let mut id = PauliProduct::new();
-        id = id.set_pauli(0, SingleSpinOperator::Identity);
-        spin_operator
+        id = id.set_pauli(0, SingleQubitOperator::Identity);
+        qubit_operator
             .add_operator_product(id, CalculatorComplex::new(1.0, 0.0))
             .expect("Internal bug in add_operator_product.");
 
         // Jordan-Wigner strings are inserted every second lowering (raising) operator, in even or
         // odd positions depending on the parity of the total number of creation (annihilation)
         // operators.
         let mut previous = 0;
         for (index, site) in self.creators().enumerate() {
             if index % 2 != number_creators % 2 {
                 for i in previous..*site {
-                    spin_operator = spin_operator * PauliProduct::new().z(i)
+                    qubit_operator = qubit_operator * PauliProduct::new().z(i)
                 }
             }
-            spin_operator = spin_operator * _lowering_operator(site);
+            qubit_operator = qubit_operator * _lowering_operator(site);
             previous = *site;
         }
 
         previous = 0;
         for (index, site) in self.annihilators().enumerate() {
             if index % 2 != number_annihilators % 2 {
                 for i in previous..*site {
-                    spin_operator = spin_operator * PauliProduct::new().z(i)
+                    qubit_operator = qubit_operator * PauliProduct::new().z(i)
                 }
             }
-            spin_operator = spin_operator * _raising_operator(site);
+            qubit_operator = qubit_operator * _raising_operator(site);
             previous = *site;
         }
-        spin_operator
+        qubit_operator
     }
 }
 
 impl JordanWignerFermionToSpin for HermitianFermionProduct {
-    type Output = SpinHamiltonian;
+    type Output = QubitHamiltonian;
 
     /// Implements JordanWignerFermionToSpin for a HermitianFermionProduct.
     ///
     /// The convention used is that |0> represents an empty fermionic state (spin-orbital),
     /// and |1> represents an occupied fermionic state.
     ///
     /// # Returns
     ///
-    /// `SpinHamiltonian` - The spin operator that results from the transformation.
+    /// `QubitHamiltonian` - The spin operator that results from the transformation.
     ///
     /// # Panics
     ///
     /// * Internal bug in `add_operator_product`.
     fn jordan_wigner(&self) -> Self::Output {
         let number_creators = self.number_creators();
         let number_annihilators = self.number_annihilators();
-        let mut spin_operator = SpinOperator::new();
+        let mut qubit_operator = QubitOperator::new();
 
         let mut id = PauliProduct::new();
-        id = id.set_pauli(0, SingleSpinOperator::Identity);
-        spin_operator
+        id = id.set_pauli(0, SingleQubitOperator::Identity);
+        qubit_operator
             .add_operator_product(id, CalculatorComplex::new(1.0, 0.0))
             .expect("Internal bug in add_operator_product.");
 
         // Jordan-Wigner strings are inserted every second lowering (raising) operator, in even or
         // odd positions depending on the parity of the total number of creation (annihilation)
         // operators.
         let mut previous = 0;
         for (index, site) in self.creators().enumerate() {
             if index % 2 != number_creators % 2 {
                 for i in previous..*site {
-                    spin_operator = spin_operator * PauliProduct::new().z(i)
+                    qubit_operator = qubit_operator * PauliProduct::new().z(i)
                 }
             }
-            spin_operator = spin_operator * _lowering_operator(site);
+            qubit_operator = qubit_operator * _lowering_operator(site);
             previous = *site;
         }
 
         previous = 0;
         for (index, site) in self.annihilators().enumerate() {
             if index % 2 != number_annihilators % 2 {
                 for i in previous..*site {
-                    spin_operator = spin_operator * PauliProduct::new().z(i)
+                    qubit_operator = qubit_operator * PauliProduct::new().z(i)
                 }
             }
-            spin_operator = spin_operator * _raising_operator(site);
+            qubit_operator = qubit_operator * _raising_operator(site);
             previous = *site;
         }
 
         // Spin terms with imaginary coefficients are dropped, and
         // real coefficients are doubled.
         if !self.is_natural_hermitian() {
-            let mut out = SpinHamiltonian::new();
-            for (product, coeff) in spin_operator.iter() {
+            let mut out = QubitHamiltonian::new();
+            for (product, coeff) in qubit_operator.iter() {
                 if coeff.im == 0.0.into() {
                     out.add_operator_product(product.clone(), coeff.re.clone() * 2)
                         .expect("Internal bug in add_operator_product.");
                 }
             }
             return out;
         }
-        SpinHamiltonian::try_from(spin_operator).expect(
-            "Error in conversion from SpinOperator to
-SpinHamiltonian, despite the internal check that the HermitianFermionProduct in the jordan-wigner
+        QubitHamiltonian::try_from(qubit_operator).expect(
+            "Error in conversion from QubitOperator to
+QubitHamiltonian, despite the internal check that the HermitianFermionProduct in the jordan-wigner
 transform is hermitian.",
         )
     }
 }
 
-fn _lowering_operator(i: &usize) -> SpinOperator {
-    let mut out = SpinOperator::new();
+fn _lowering_operator(i: &usize) -> QubitOperator {
+    let mut out = QubitOperator::new();
     out.add_operator_product(PauliProduct::new().x(*i), CalculatorComplex::new(0.5, 0.0))
         .expect("Internal bug in add_operator_product.");
     out.add_operator_product(PauliProduct::new().y(*i), CalculatorComplex::new(0.0, -0.5))
         .expect("Internal bug in add_operator_product.");
     out
 }
-fn _raising_operator(i: &usize) -> SpinOperator {
-    let mut out = SpinOperator::new();
+fn _raising_operator(i: &usize) -> QubitOperator {
+    let mut out = QubitOperator::new();
     out.add_operator_product(PauliProduct::new().x(*i), CalculatorComplex::new(0.5, 0.0))
         .expect("Internal bug in add_operator_product.");
     out.add_operator_product(PauliProduct::new().y(*i), CalculatorComplex::new(0.0, 0.5))
         .expect("Internal bug in add_operator_product.");
     out
 }
```

### Comparing `struqture_py-1.6.1/struqture/src/fermions/fermionic_noise_operator.rs` & `struqture_py-2.0.0a0/struqture/src/spins/plus_minus_noise_operator.rs`

 * *Files 17% similar despite different names*

```diff
@@ -6,813 +6,852 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
-use super::{FermionOperator, FermionProduct, OperateOnFermions};
-use crate::mappings::JordanWignerFermionToSpin;
-use crate::spins::{DecoherenceOperator, SpinLindbladNoiseOperator};
-use crate::{
-    ModeIndex, OperateOnDensityMatrix, OperateOnModes, StruqtureError,
-    StruqtureVersionSerializable, MINIMUM_STRUQTURE_VERSION,
-};
+use super::{DecoherenceProduct, QubitLindbladNoiseOperator};
+use crate::fermions::FermionLindbladNoiseOperator;
+use crate::mappings::JordanWignerSpinToFermion;
+use crate::spins::{PlusMinusOperator, PlusMinusProduct};
+use crate::{OperateOnDensityMatrix, StruqtureError};
 use itertools::Itertools;
+use num_complex::Complex64;
 use qoqo_calculator::{CalculatorComplex, CalculatorFloat};
 use serde::{Deserialize, Serialize};
 use std::fmt::{self, Write};
 use std::iter::{FromIterator, IntoIterator};
 use std::ops;
 
-#[cfg(feature = "indexed_map_iterators")]
-use indexmap::map::{Entry, Iter, Keys, Values};
-#[cfg(feature = "indexed_map_iterators")]
+use indexmap::map::{Entry, Iter};
 use indexmap::IndexMap;
-#[cfg(not(feature = "indexed_map_iterators"))]
-use std::collections::hash_map::{Entry, Iter, Keys, Values};
-#[cfg(not(feature = "indexed_map_iterators"))]
 use std::collections::HashMap;
 
-/// FermionLindbladNoiseOperators represent noise interactions in the Lindblad equation.
+/// PlusMinusLindbladNoiseOperators represent noise interactions in the Lindblad equation.
 ///
-/// In the Lindblad equation, Linblad noise operator L_i are not limited to [crate::fermions::FermionProduct] style operators.
-/// We use ([crate::fermions::FermionProduct], [crate::fermions::FermionProduct]) as a unique basis.
+/// In the Lindblad equation, Linblad noise operator L_i are not limited to [crate::spins::PlusMinusProduct] style operators.
+/// We use ([crate::spins::PlusMinusProduct], [crate::spins::PlusMinusProduct]) as a unique basis.
 ///
 /// # Example
 ///
 /// ```
 /// use struqture::prelude::*;
 /// use qoqo_calculator::CalculatorComplex;
-/// use struqture::fermions::{FermionProduct, FermionLindbladNoiseOperator};
+/// use struqture::spins::{PlusMinusProduct, PlusMinusLindbladNoiseOperator};
 ///
-/// let mut system = FermionLindbladNoiseOperator::new();
+/// let mut system = PlusMinusLindbladNoiseOperator::new();
 ///
 /// // Set noise terms:
-/// let bp_0_1 = FermionProduct::new([0], [1]).unwrap();
-/// let bp_0 = FermionProduct::new([], [0]).unwrap();
-/// system.set((bp_0_1.clone(), bp_0_1.clone()), CalculatorComplex::from(0.5)).unwrap();
-/// system.set((bp_0.clone(), bp_0.clone()), CalculatorComplex::from(0.2)).unwrap();
+/// let pp_01 = PlusMinusProduct::new().plus(0).plus(1);
+/// let pp_0 = PlusMinusProduct::new().z(0);
+/// system.set((pp_01.clone(), pp_01.clone()), CalculatorComplex::from(0.5)).unwrap();
+/// system.set((pp_0.clone(), pp_0.clone()), CalculatorComplex::from(0.2)).unwrap();
 ///
 /// // Access what you set:
-/// assert_eq!(system.current_number_modes(), 2_usize);
-/// assert_eq!(system.get(&(bp_0_1.clone(), bp_0_1.clone())), &CalculatorComplex::from(0.5));
-/// assert_eq!(system.get(&(bp_0.clone(), bp_0.clone())), &CalculatorComplex::from(0.2));
+/// assert_eq!(system.get(&(pp_01.clone(), pp_01.clone())), &CalculatorComplex::from(0.5));
+/// assert_eq!(system.get(&(pp_0.clone(), pp_0.clone())), &CalculatorComplex::from(0.2));
 /// ```
 ///
 #[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
-#[serde(from = "FermionLindbladNoiseOperatorSerialize")]
-#[serde(into = "FermionLindbladNoiseOperatorSerialize")]
-pub struct FermionLindbladNoiseOperator {
+#[serde(try_from = "PlusMinusLindbladNoiseOperatorSerialize")]
+#[serde(into = "PlusMinusLindbladNoiseOperatorSerialize")]
+pub struct PlusMinusLindbladNoiseOperator {
     /// The internal map representing the noise terms
-    #[cfg(feature = "indexed_map_iterators")]
-    internal_map: IndexMap<(FermionProduct, FermionProduct), CalculatorComplex>,
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    internal_map: HashMap<(FermionProduct, FermionProduct), CalculatorComplex>,
+    internal_map: IndexMap<(PlusMinusProduct, PlusMinusProduct), CalculatorComplex>,
 }
 
-impl crate::MinSupportedVersion for FermionLindbladNoiseOperator {}
+impl crate::SerializationSupport for PlusMinusLindbladNoiseOperator {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::PlusMinusLindbladNoiseOperator
+    }
+}
 
 #[cfg(feature = "json_schema")]
-impl schemars::JsonSchema for FermionLindbladNoiseOperator {
+impl schemars::JsonSchema for PlusMinusLindbladNoiseOperator {
     fn schema_name() -> String {
-        "FermionLindbladNoiseOperator".to_string()
+        "PlusMinusLindbladNoiseOperator".to_string()
     }
 
     fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
-        <FermionLindbladNoiseOperatorSerialize>::json_schema(gen)
+        <PlusMinusLindbladNoiseOperatorSerialize>::json_schema(gen)
     }
 }
 
 #[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
 #[cfg_attr(feature = "json_schema", derive(schemars::JsonSchema))]
 #[cfg_attr(feature = "json_schema", schemars(deny_unknown_fields))]
-struct FermionLindbladNoiseOperatorSerialize {
-    /// The vector representing the internal map of the FermionLindbladNoiseOperator
+struct PlusMinusLindbladNoiseOperatorSerialize {
+    /// The vector representing the internal map of the PlusMinusLindbladNoiseOperator
     items: Vec<(
-        FermionProduct,
-        FermionProduct,
+        PlusMinusProduct,
+        PlusMinusProduct,
         CalculatorFloat,
         CalculatorFloat,
     )>,
-    /// The struqture version
-    _struqture_version: StruqtureVersionSerializable,
+    serialisation_meta: crate::StruqtureSerialisationMeta,
 }
 
-impl From<FermionLindbladNoiseOperatorSerialize> for FermionLindbladNoiseOperator {
-    fn from(value: FermionLindbladNoiseOperatorSerialize) -> Self {
-        let new_noise_op: FermionLindbladNoiseOperator = value
+impl TryFrom<PlusMinusLindbladNoiseOperatorSerialize> for PlusMinusLindbladNoiseOperator {
+    type Error = StruqtureError;
+    fn try_from(value: PlusMinusLindbladNoiseOperatorSerialize) -> Result<Self, Self::Error> {
+        let target_serialisation_meta =
+            <Self as crate::SerializationSupport>::target_serialisation_meta();
+        crate::check_can_be_deserialised(&target_serialisation_meta, &value.serialisation_meta)?;
+
+        let new_noise_op: PlusMinusLindbladNoiseOperator = value
             .items
             .into_iter()
             .map(|(left, right, real, imag)| {
                 ((left, right), CalculatorComplex { re: real, im: imag })
             })
             .collect();
-        new_noise_op
+        Ok(new_noise_op)
     }
 }
 
-impl From<FermionLindbladNoiseOperator> for FermionLindbladNoiseOperatorSerialize {
-    fn from(value: FermionLindbladNoiseOperator) -> Self {
+impl From<PlusMinusLindbladNoiseOperator> for PlusMinusLindbladNoiseOperatorSerialize {
+    fn from(value: PlusMinusLindbladNoiseOperator) -> Self {
+        let serialisation_meta = crate::SerializationSupport::struqture_serialisation_meta(&value);
+
         let new_noise_op: Vec<(
-            FermionProduct,
-            FermionProduct,
+            PlusMinusProduct,
+            PlusMinusProduct,
             CalculatorFloat,
             CalculatorFloat,
         )> = value
             .into_iter()
             .map(|((left, right), val)| (left, right, val.re, val.im))
             .collect();
-        let current_version = StruqtureVersionSerializable {
-            major_version: MINIMUM_STRUQTURE_VERSION.0,
-            minor_version: MINIMUM_STRUQTURE_VERSION.1,
-        };
         Self {
             items: new_noise_op,
-            _struqture_version: current_version,
+            serialisation_meta,
         }
     }
 }
 
-impl<'a> OperateOnDensityMatrix<'a> for FermionLindbladNoiseOperator {
-    type Index = (FermionProduct, FermionProduct);
+impl<'a> OperateOnDensityMatrix<'a> for PlusMinusLindbladNoiseOperator {
+    type Index = (PlusMinusProduct, PlusMinusProduct);
     type Value = CalculatorComplex;
-    type IteratorType = Iter<'a, (FermionProduct, FermionProduct), CalculatorComplex>;
-    type KeyIteratorType = Keys<'a, (FermionProduct, FermionProduct), CalculatorComplex>;
-    type ValueIteratorType = Values<'a, (FermionProduct, FermionProduct), CalculatorComplex>;
 
     // From trait
     fn get(&self, key: &Self::Index) -> &Self::Value {
         match self.internal_map.get(key) {
             Some(value) => value,
             None => &CalculatorComplex::ZERO,
         }
     }
 
     // From trait
-    fn iter(&'a self) -> Self::IteratorType {
+    fn iter(&'a self) -> impl ExactSizeIterator<Item = (&'a Self::Index, &'a Self::Value)> {
         self.internal_map.iter()
     }
 
     // From trait
-    fn keys(&'a self) -> Self::KeyIteratorType {
+    fn keys(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Index> {
         self.internal_map.keys()
     }
 
     // From trait
-    fn values(&'a self) -> Self::ValueIteratorType {
+    fn values(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Value> {
         self.internal_map.values()
     }
 
-    #[cfg(feature = "indexed_map_iterators")]
     // From trait
     fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
         self.internal_map.shift_remove(key)
     }
 
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    // From trait
-    fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
-        self.internal_map.remove(key)
-    }
-
     // From trait
     fn empty_clone(&self, capacity: Option<usize>) -> Self {
         match capacity {
             Some(cap) => Self::with_capacity(cap),
             None => Self::new(),
         }
     }
 
-    /// Overwrites an existing entry or sets a new entry in the FermionLindbladNoiseOperator with the given ((FermionProduct, FermionProduct) key, CalculatorComplex value) pair.
+    /// Overwrites an existing entry or sets a new entry in the PlusMinusLindbladNoiseOperator with the given ((PlusMinusProduct, PlusMinusProduct) key, CalculatorComplex value) pair.
     ///
     /// # Arguments
     ///
-    /// * `key` - The (FermionProduct, FermionProduct) key to set in the FermionLindbladNoiseOperator.
-    /// * `value` - The corresponding CalculatorComplex value to set for the key in the FermionLindbladNoiseOperator.
+    /// * `key` - The (PlusMinusProduct, PlusMinusProduct) key to set in the PlusMinusLindbladNoiseOperator.
+    /// * `value` - The corresponding CalculatorComplex value to set for the key in the PlusMinusLindbladNoiseOperator.
     ///
     /// # Returns
     ///
     /// * `Ok(Some(CalculatorComplex))` - The key existed, this is the value it had before it was set with the value input.
     /// * `Ok(None)` - The key did not exist, it has been set with its corresponding value.
-    /// * `Err(StruqtureError::InvalidLindbladTerms)` - The input contained identities, which are not allowed as Lindblad operators.
-    ///
-    /// # Panics
-    ///
-    /// * Internal error in FermionProduct::new
     fn set(
         &mut self,
         key: Self::Index,
         value: Self::Value,
     ) -> Result<Option<Self::Value>, StruqtureError> {
-        if key.0 == FermionProduct::new([], [])? || key.1 == FermionProduct::new([], [])? {
-            return Err(StruqtureError::InvalidLindbladTerms);
-        }
-
         if value != CalculatorComplex::ZERO {
             Ok(self.internal_map.insert(key, value))
         } else {
             match self.internal_map.entry(key) {
-                #[cfg(feature = "indexed_map_iterators")]
                 Entry::Occupied(val) => Ok(Some(val.shift_remove())),
-                #[cfg(not(feature = "indexed_map_iterators"))]
-                Entry::Occupied(val) => Ok(Some(val.remove())),
                 Entry::Vacant(_) => Ok(None),
             }
         }
     }
 }
 
-impl<'a> OperateOnModes<'a> for FermionLindbladNoiseOperator {
-    // From trait
-    fn current_number_modes(&'a self) -> usize {
-        let mut max_mode: usize = 0;
-        if !self.is_empty() {
-            for key in self.keys() {
-                let maxk = key
-                    .0
-                    .current_number_modes()
-                    .max(key.1.current_number_modes());
-                if maxk > max_mode {
-                    max_mode = maxk;
-                }
-            }
-        }
-        max_mode
-    }
-
-    /// Gets the maximum index of the FermionLindbladNoiseOperator.
-    ///
-    /// # Returns
-    ///
-    /// * `usize` - The number of fermionic modes in the FermionLindbladNoiseOperator.
-    fn number_modes(&'a self) -> usize {
-        self.current_number_modes()
-    }
-}
-
-impl<'a> OperateOnFermions<'a> for FermionLindbladNoiseOperator {}
-
-/// Implements the default function (Default trait) of FermionLindbladNoiseOperator (an empty FermionLindbladNoiseOperator).
+/// Implements the default function (Default trait) of PlusMinusLindbladNoiseOperator (an empty PlusMinusLindbladNoiseOperator).
 ///
-impl Default for FermionLindbladNoiseOperator {
+impl Default for PlusMinusLindbladNoiseOperator {
     fn default() -> Self {
         Self::new()
     }
 }
 
-/// Functions for the FermionLindbladNoiseOperator
+/// Functions for the PlusMinusLindbladNoiseOperator
 ///
-impl FermionLindbladNoiseOperator {
-    /// Creates a new FermionLindbladNoiseOperator.
+impl PlusMinusLindbladNoiseOperator {
+    /// Creates a new PlusMinusLindbladNoiseOperator.
     ///
     /// # Returns
     ///
-    /// * `Self` - The new (empty) FermionLindbladNoiseOperator.
+    /// * `Self` - The new (empty) PlusMinusLindbladNoiseOperator.
     pub fn new() -> Self {
-        FermionLindbladNoiseOperator {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::new(),
-            #[cfg(feature = "indexed_map_iterators")]
+        PlusMinusLindbladNoiseOperator {
             internal_map: IndexMap::new(),
         }
     }
 
-    /// Creates a new FermionLindbladNoiseOperator with pre-allocated capacity.
+    /// Creates a new PlusMinusLindbladNoiseOperator with pre-allocated capacity.
     ///
     /// # Arguments
     ///
-    /// * `capacity` - The pre-allocated capacity of the operator.
+    /// * `capacity` - The pre-allocated capacity of the system.
     ///
     /// # Returns
     ///
-    /// * `Self` - The new (empty) FermionLindbladNoiseOperator.
+    /// * `Self` - The new (empty) PlusMinusLindbladNoiseOperator.
     pub fn with_capacity(capacity: usize) -> Self {
-        FermionLindbladNoiseOperator {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::with_capacity(capacity),
-            #[cfg(feature = "indexed_map_iterators")]
+        PlusMinusLindbladNoiseOperator {
             internal_map: IndexMap::with_capacity(capacity),
         }
     }
 
-    /// Adds all noise entries corresponding to a ((FermionOperator, FermionOperator), CalculatorFloat).
+    /// Adds all noise entries corresponding to a ((PlusMinusOperator, PlusMinusOperator), CalculatorFloat).
     ///
-    /// In the Lindblad equation, Linblad noise operator L_i are not limited to [crate::spins::FermionProduct] style operators.
-    /// We use ([crate::spins::FermionProduct], [crate::spins::FermionProduct]) as a unique basis.
-    /// This function adds a Linblad-Term defined by a combination of Lindblad operators given as general [crate::spins::FermionOperator]
+    /// In the Lindblad equation, Linblad noise operator L_i are not limited to [crate::spins::PlusMinusProduct] style operators.
+    /// We use ([crate::spins::PlusMinusProduct], [crate::spins::PlusMinusProduct]) as a unique basis.
+    /// This function adds a Linblad-Term defined by a combination of Lindblad operators given as general [crate::spins::PlusMinusOperator]
     ///
     /// # Arguments
     ///
-    /// * `left` - FermionOperator that acts on the density matrix from the left in the Lindblad equation.
-    /// * `right` -  FermionOperator that acts on the density matrix from the right and in hermitian conjugated form in the Lindblad equation.
-    /// * `value` - CalculatorComplex value representing the global coefficient of the noise term.
+    /// * `left` - PlusMinusOperator that acts on the density matrix from the left in the Lindblad equation.
+    /// * `value` -  PlusMinusOperator that acts on the density matrix from the right and in hermitian conjugated form in the Lindblad equation.
     ///
     /// # Returns
     ///
     /// * `Ok(())` - The noise was correctly added.
-    /// * `Err(StruqtureError::InvalidLindbladTerms)` - The input contained identities, which are not allowed as Lindblad operators.
+    /// * `Err(StruqtureError::NumberSpinsExceeded)` - Number of spins in entry exceeds number of spins in system.
     pub fn add_noise_from_full_operators(
         &mut self,
-        left: &FermionOperator,
-        right: &FermionOperator,
+        left: &PlusMinusOperator,
+        right: &PlusMinusOperator,
         value: CalculatorComplex,
     ) -> Result<(), StruqtureError> {
-        if left.is_empty() || right.is_empty() {
-            return Err(StruqtureError::InvalidLindbladTerms);
-        }
-
-        for ((fermion_product_left, value_left), (fermion_product_right, value_right)) in
-            left.iter().cartesian_product(right.iter())
+        for ((decoherence_product_left, value_left), (decoherence_product_right, value_right)) in
+            left.iter().cartesian_product(right.into_iter())
         {
-            if !(*fermion_product_left == FermionProduct::new([], [])?
-                || *fermion_product_right == FermionProduct::new([], [])?)
-            {
-                let value_complex = value_right.conj() * value_left;
-                self.add_operator_product(
-                    (fermion_product_left.clone(), fermion_product_right.clone()),
-                    value_complex * value.clone(),
-                )?;
-            }
+            let value_complex = value_right.conj() * value_left;
+            self.add_operator_product(
+                (
+                    decoherence_product_left.clone(),
+                    decoherence_product_right.clone(),
+                ),
+                value_complex * value.clone(),
+            )?;
         }
         Ok(())
     }
 
-    /// Separate self into an operator with the terms of given number of creation and annihilation operators and an operator with the remaining operations
+    /// Remaps the qubits in the PlusMinusLindbladNoiseOperator.
     ///
     /// # Arguments
     ///
-    /// * `number_creators_annihilators_left` - Number of creators and number of annihilators to filter for in the left term of the keys.
-    /// * `number_creators_annihilators_right` - Number of creators and number of annihilators to filter for in the right term of the keys.
+    /// * `mapping` - HashMap containing the qubit remapping.
     ///
     /// # Returns
     ///
-    /// `Ok((separated, remainder))` - Operator with the noise terms where number_creators_annihilators matches the number of spins the operator product acts on and Operator with all other contributions.
-    pub fn separate_into_n_terms(
+    /// * `Self` - The remapped PlusMinusLindbladNoiseOperator.
+    pub fn remap_qubits(&self, mapping: &HashMap<usize, usize>) -> Self {
+        let mut new_noise = PlusMinusLindbladNoiseOperator::new();
+        for ((left, right), rate) in self.iter() {
+            let new_left = left.remap_qubits(mapping);
+            let new_right = right.remap_qubits(mapping);
+            new_noise
+                .add_operator_product((new_left, new_right), rate.clone())
+                .expect("Internal bug in add_operator_product");
+        }
+        new_noise
+    }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(
         &self,
-        number_creators_annihilators_left: (usize, usize),
-        number_creators_annihilators_right: (usize, usize),
-    ) -> Result<(Self, Self), StruqtureError> {
-        let mut separated = Self::default();
-        let mut remainder = Self::default();
-        for ((prod_l, prod_r), val) in self.iter() {
-            if (prod_l.creators().len(), prod_l.annihilators().len())
-                == number_creators_annihilators_left
-                && (prod_r.creators().len(), prod_r.annihilators().len())
-                    == number_creators_annihilators_right
-            {
-                separated.add_operator_product((prod_l.clone(), prod_r.clone()), val.clone())?;
-            } else {
-                remainder.add_operator_product((prod_l.clone(), prod_r.clone()), val.clone())?;
+    ) -> Result<struqture_one::spins::PlusMinusLindbladNoiseOperator, StruqtureError> {
+        let mut new_pm_system = struqture_one::spins::PlusMinusLindbladNoiseOperator::new();
+        for (key, val) in self.iter() {
+            let one_key_left = key.0.to_struqture_1()?;
+            let one_key_right = key.1.to_struqture_1()?;
+            let _ = struqture_one::OperateOnDensityMatrix::set(
+                &mut new_pm_system,
+                (one_key_left, one_key_right),
+                val.clone(),
+            );
+        }
+        Ok(new_pm_system)
+    }
+
+    /// Import from struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::spins::PlusMinusLindbladNoiseOperator,
+    ) -> Result<Self, StruqtureError> {
+        let mut new_qubit_operator = Self::new();
+        for (key, val) in struqture_one::OperateOnDensityMatrix::iter(value) {
+            let self_key_left = PlusMinusProduct::from_struqture_1(&key.0)?;
+            let self_key_right = PlusMinusProduct::from_struqture_1(&key.1)?;
+            let _ = new_qubit_operator.set((self_key_left, self_key_right), val.clone());
+        }
+        Ok(new_qubit_operator)
+    }
+}
+
+impl From<PlusMinusLindbladNoiseOperator> for QubitLindbladNoiseOperator {
+    /// Converts a PlusMinusLindbladNoiseOperator into a QubitLindbladNoiseOperator.
+    ///
+    /// # Arguments
+    ///
+    /// * `value` - The PlusMinusLindbladNoiseOperator to convert.
+    ///
+    /// # Returns
+    ///
+    /// * `Self` - The PlusMinusLindbladNoiseOperator converted into a QubitLindbladNoiseOperator.
+    fn from(value: PlusMinusLindbladNoiseOperator) -> Self {
+        let mut new_operator = QubitLindbladNoiseOperator::with_capacity(2 * value.len());
+        for ((product_left, product_right), val) in value.into_iter() {
+            let transscribed_vector_left: Vec<(DecoherenceProduct, Complex64)> =
+                product_left.into();
+            let transscribed_vector_right: Vec<(DecoherenceProduct, Complex64)> =
+                product_right.into();
+            for (transscribed_product_left, pref_left) in transscribed_vector_left {
+                for (transscribed_product_right, pref_right) in transscribed_vector_right.clone() {
+                    new_operator
+                        .add_operator_product(
+                            (
+                                transscribed_product_left.clone(),
+                                transscribed_product_right,
+                            ),
+                            val.clone() * pref_left * pref_right,
+                        )
+                        .expect("Unexpected error adding operators. Internal struqture error");
+                }
+            }
+        }
+        new_operator
+    }
+}
+
+impl From<QubitLindbladNoiseOperator> for PlusMinusLindbladNoiseOperator {
+    /// Converts a QubitLindbladNoiseOperator into a PlusMinusLindbladNoiseOperator.
+    ///
+    /// # Arguments
+    ///
+    /// * `value` - The QubitLindbladNoiseOperator to convert.
+    ///
+    /// # Returns
+    ///
+    /// * `Self` - The QubitLindbladNoiseOperator converted into a PlusMinusLindbladNoiseOperator.
+    fn from(value: QubitLindbladNoiseOperator) -> Self {
+        let mut new_operator = PlusMinusLindbladNoiseOperator::with_capacity(2 * value.len());
+        for ((product_left, product_right), val) in value.into_iter() {
+            let transscribed_vector_left: Vec<(PlusMinusProduct, Complex64)> = product_left.into();
+            let transscribed_vector_right: Vec<(PlusMinusProduct, Complex64)> =
+                product_right.into();
+            for (transscribed_product_left, pref_left) in transscribed_vector_left {
+                for (transscribed_product_right, pref_right) in transscribed_vector_right.clone() {
+                    new_operator
+                        .add_operator_product(
+                            (
+                                transscribed_product_left.clone(),
+                                transscribed_product_right,
+                            ),
+                            val.clone() * pref_left * pref_right,
+                        )
+                        .expect("Unexpected error adding operators. Internal struqture error");
+                }
             }
         }
-        Ok((separated, remainder))
+        new_operator
     }
 }
 
-/// Implements the negative sign function of FermionLindbladNoiseOperator.
+/// Implements the negative sign function of PlusMinusLindbladNoiseOperator.
 ///
-impl ops::Neg for FermionLindbladNoiseOperator {
-    type Output = FermionLindbladNoiseOperator;
-    /// Implement minus sign for FermionOperator.
+impl ops::Neg for PlusMinusLindbladNoiseOperator {
+    type Output = PlusMinusLindbladNoiseOperator;
+    /// Implement minus sign for PlusMinusLindbladNoiseOperator.
     ///
     /// # Returns
     ///
-    /// * `Self` - The FermionOperator * -1.
+    /// * `Self` - The PlusMinusLindbladNoiseOperator * -1.
     fn neg(self) -> Self {
-        #[cfg(not(feature = "indexed_map_iterators"))]
-        let mut internal = HashMap::with_capacity(self.len());
-        #[cfg(feature = "indexed_map_iterators")]
-        let mut internal = IndexMap::with_capacity(self.len());
+        let mut internal = self.internal_map.clone();
         for (key, val) in self {
             internal.insert(key.clone(), val.neg());
         }
-        FermionLindbladNoiseOperator {
+        PlusMinusLindbladNoiseOperator {
             internal_map: internal,
         }
     }
 }
 
-/// Implements the plus function of FermionLindbladNoiseOperator by FermionLindbladNoiseOperator.
+/// Implements the plus function of PlusMinusLindbladNoiseOperator by PlusMinusLindbladNoiseOperator.
 ///
-impl<T, V> ops::Add<T> for FermionLindbladNoiseOperator
+impl<T, V> ops::Add<T> for PlusMinusLindbladNoiseOperator
 where
-    T: IntoIterator<Item = ((FermionProduct, FermionProduct), V)>,
+    T: IntoIterator<Item = ((PlusMinusProduct, PlusMinusProduct), V)>,
     V: Into<CalculatorComplex>,
 {
     type Output = Self;
-    /// Implements `+` (add) for two FermionOperators.
+    /// Implements `+` (add) for two PlusMinusLindbladNoiseOperators.
     ///
     /// # Arguments
     ///
-    /// * `other` - The FermionOperator to be added.
+    /// * `other` - The PlusMinusLindbladNoiseOperator to be added.
     ///
     /// # Returns
     ///
-    /// * `Self` - The two FermionOperators added together.
+    /// * `Self` - The two PlusMinusLindbladNoiseOperators added together.
     ///
     /// # Panics
     ///
     /// * Internal error in add_operator_product.
     fn add(mut self, other: T) -> Self {
         for (key, value) in other.into_iter() {
             self.add_operator_product(key.clone(), Into::<CalculatorComplex>::into(value))
                 .expect("Internal bug in add_operator_product");
         }
         self
     }
 }
 
-/// Implements the minus function of FermionLindbladNoiseOperator by FermionLindbladNoiseOperator.
+/// Implements the minus function of PlusMinusLindbladNoiseOperator by PlusMinusLindbladNoiseOperator.
 ///
-impl<T, V> ops::Sub<T> for FermionLindbladNoiseOperator
+impl<T, V> ops::Sub<T> for PlusMinusLindbladNoiseOperator
 where
-    T: IntoIterator<Item = ((FermionProduct, FermionProduct), V)>,
+    T: IntoIterator<Item = ((PlusMinusProduct, PlusMinusProduct), V)>,
     V: Into<CalculatorComplex>,
 {
     type Output = Self;
-    /// Implements `-` (subtract) for two FermionLindbladNoiseOperators.
+    /// Implements `-` (subtract) for two PlusMinusLindbladNoiseOperators.
     ///
     /// # Arguments
     ///
-    /// * `other` - The FermionLindbladNoiseOperator to be subtracted.
+    /// * `other` - The PlusMinusLindbladNoiseOperator to be subtracted.
     ///
     /// # Returns
     ///
-    /// * `Self` - The two FermionLindbladNoiseOperators subtracted.
+    /// * `Self` - The two PlusMinusLindbladNoiseOperators subtracted.
     ///
     /// # Panics
     ///
     /// * Internal error in add_operator_product.
     fn sub(mut self, other: T) -> Self {
         for (key, value) in other.into_iter() {
             self.add_operator_product(key.clone(), Into::<CalculatorComplex>::into(value) * -1.0)
                 .expect("Internal bug in add_operator_product");
         }
         self
     }
 }
 
-/// Implements the multiplication function of FermionLindbladNoiseOperator by CalculatorFloat.
+/// Implements the multiplication function of PlusMinusLindbladNoiseOperator by CalculatorComplex/CalculatorFloat.
 ///
-impl<T> ops::Mul<T> for FermionLindbladNoiseOperator
+impl<T> ops::Mul<T> for PlusMinusLindbladNoiseOperator
 where
     T: Into<CalculatorComplex>,
 {
     type Output = Self;
-    /// Implement `*` for FermionLindbladNoiseOperator and CalculatorFloat.
+    /// Implement `*` for PlusMinusLindbladNoiseOperator and CalculatorComplex/CalculatorFloat.
     ///
     /// # Arguments
     ///
-    /// * `other` - The CalculatorFloat by which to multiply.
+    /// * `other` - The CalculatorComplex or CalculatorFloat by which to multiply.
     ///
     /// # Returns
     ///
-    /// * `Self` - The FermionLindbladNoiseOperator multiplied by the CalculatorFloat.
+    /// * `Self` - The PlusMinusLindbladNoiseOperator multiplied by the CalculatorComplex/CalculatorFloat.
     fn mul(self, other: T) -> Self {
         let other_cc = Into::<CalculatorComplex>::into(other);
-        #[cfg(not(feature = "indexed_map_iterators"))]
-        let mut internal = HashMap::with_capacity(self.len());
-        #[cfg(feature = "indexed_map_iterators")]
-        let mut internal = IndexMap::with_capacity(self.len());
+        let mut internal = self.internal_map.clone();
         for (key, val) in self {
             internal.insert(key, val * other_cc.clone());
         }
-        FermionLindbladNoiseOperator {
+        PlusMinusLindbladNoiseOperator {
             internal_map: internal,
         }
     }
 }
 
-/// Implements the into_iter function (IntoIterator trait) of FermionLindbladNoiseOperator.
+/// Implements the into_iter function (IntoIterator trait) of PlusMinusLindbladNoiseOperator.
 ///
-impl IntoIterator for FermionLindbladNoiseOperator {
-    type Item = ((FermionProduct, FermionProduct), CalculatorComplex);
-    #[cfg(not(feature = "indexed_map_iterators"))]
+impl IntoIterator for PlusMinusLindbladNoiseOperator {
+    type Item = ((PlusMinusProduct, PlusMinusProduct), CalculatorComplex);
     type IntoIter =
-        std::collections::hash_map::IntoIter<(FermionProduct, FermionProduct), CalculatorComplex>;
-    #[cfg(feature = "indexed_map_iterators")]
-    type IntoIter = indexmap::map::IntoIter<(FermionProduct, FermionProduct), CalculatorComplex>;
-    /// Returns the FermionLindbladNoiseOperator in Iterator form.
+        indexmap::map::IntoIter<(PlusMinusProduct, PlusMinusProduct), CalculatorComplex>;
+    /// Returns the PlusMinusLindbladNoiseOperator in Iterator form.
     ///
     /// # Returns
     ///
-    /// * `Self::IntoIter` - The FermionLindbladNoiseOperator in Iterator form.
+    /// * `Self::IntoIter` - The PlusMinusLindbladNoiseOperator in Iterator form.
     fn into_iter(self) -> Self::IntoIter {
         self.internal_map.into_iter()
     }
 }
 
-/// Implements the into_iter function (IntoIterator trait) of reference FermionLindbladNoiseOperator.
+/// Implements the into_iter function (IntoIterator trait) of reference PlusMinusLindbladNoiseOperator.
 ///
-impl<'a> IntoIterator for &'a FermionLindbladNoiseOperator {
-    type Item = (&'a (FermionProduct, FermionProduct), &'a CalculatorComplex);
-    type IntoIter = Iter<'a, (FermionProduct, FermionProduct), CalculatorComplex>;
+impl<'a> IntoIterator for &'a PlusMinusLindbladNoiseOperator {
+    type Item = (
+        &'a (PlusMinusProduct, PlusMinusProduct),
+        &'a CalculatorComplex,
+    );
+    type IntoIter = Iter<'a, (PlusMinusProduct, PlusMinusProduct), CalculatorComplex>;
 
-    /// Returns the reference FermionLindbladNoiseOperator in Iterator form.
+    /// Returns the reference PlusMinusLindbladNoiseOperator in Iterator form.
     ///
     /// # Returns
     ///
-    /// * `Self::IntoIter` - The reference FermionLindbladNoiseOperator in Iterator form.
+    /// * `Self::IntoIter` - The reference PlusMinusLindbladNoiseOperator in Iterator form.
     fn into_iter(self) -> Self::IntoIter {
         self.internal_map.iter()
     }
 }
 
-/// Implements the from_iter function (FromIterator trait) of FermionLindbladNoiseOperator.
+/// Implements the from_iter function (FromIterator trait) of PlusMinusLindbladNoiseOperator.
 ///
-impl FromIterator<((FermionProduct, FermionProduct), CalculatorComplex)>
-    for FermionLindbladNoiseOperator
+impl FromIterator<((PlusMinusProduct, PlusMinusProduct), CalculatorComplex)>
+    for PlusMinusLindbladNoiseOperator
 {
-    /// Returns the object in FermionLindbladNoiseOperator form, from an Iterator form of the object.
+    /// Returns the object in PlusMinusLindbladNoiseOperator form, from an Iterator form of the object.
     ///
     /// # Arguments
     ///
-    /// * `iter` - The iterator containing the information from which to create the FermionLindbladNoiseOperator.
+    /// * `iter` - The iterator containing the information from which to create the PlusMinusLindbladNoiseOperator.
     ///
     /// # Returns
     ///
-    /// * `Self::IntoIter` - The iterator in FermionLindbladNoiseOperator form.
+    /// * `Self::IntoIter` - The iterator in PlusMinusLindbladNoiseOperator form.
     ///
     /// # Panics
     ///
     /// * Internal error in add_operator_product.
-    fn from_iter<I: IntoIterator<Item = ((FermionProduct, FermionProduct), CalculatorComplex)>>(
+    fn from_iter<
+        I: IntoIterator<Item = ((PlusMinusProduct, PlusMinusProduct), CalculatorComplex)>,
+    >(
         iter: I,
     ) -> Self {
-        let mut slno = FermionLindbladNoiseOperator::new();
+        let mut slno = PlusMinusLindbladNoiseOperator::new();
         for (pair, cc) in iter {
             slno.add_operator_product(pair, cc)
                 .expect("Internal bug in add_operator_product");
         }
         slno
     }
 }
 
-/// Implements the extend function (Extend trait) of FermionLindbladNoiseOperator.
+/// Implements the extend function (Extend trait) of PlusMinusLindbladNoiseOperator.
 ///
-impl Extend<((FermionProduct, FermionProduct), CalculatorComplex)>
-    for FermionLindbladNoiseOperator
+impl Extend<((PlusMinusProduct, PlusMinusProduct), CalculatorComplex)>
+    for PlusMinusLindbladNoiseOperator
 {
-    /// Extends the FermionLindbladNoiseOperator by the specified operations (in Iterator form).
+    /// Extends the PlusMinusLindbladNoiseOperator by the specified operations (in Iterator form).
     ///
     /// # Arguments
     ///
-    /// * `iter` - The iterator containing the operations by which to extend the FermionLindbladNoiseOperator.
+    /// * `iter` - The iterator containing the operations by which to extend the PlusMinusLindbladNoiseOperator.
     ///
     /// # Panics
     ///
     /// * Internal error in add_operator_product.
-    fn extend<I: IntoIterator<Item = ((FermionProduct, FermionProduct), CalculatorComplex)>>(
+    fn extend<I: IntoIterator<Item = ((PlusMinusProduct, PlusMinusProduct), CalculatorComplex)>>(
         &mut self,
         iter: I,
     ) {
         for (pair, cc) in iter {
             self.add_operator_product(pair, cc)
                 .expect("Internal bug in add_operator_product");
         }
     }
 }
 
-/// Implements the format function (Display trait) of FermionLindbladNoiseOperator.
+/// Implements the format function (Display trait) of PlusMinusLindbladNoiseOperator.
 ///
-impl fmt::Display for FermionLindbladNoiseOperator {
-    /// Formats the FermionLindbladNoiseOperator using the given formatter.
+impl fmt::Display for PlusMinusLindbladNoiseOperator {
+    /// Formats the PlusMinusLindbladNoiseOperator using the given formatter.
     ///
     /// # Arguments
     ///
     /// * `f` - The formatter to use.
     ///
     /// # Returns
     ///
-    /// * `std::fmt::Result` - The formatted FermionLindbladNoiseOperator.
+    /// * `std::fmt::Result` - The formatted PlusMinusLindbladNoiseOperator.
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        let mut output = "FermionLindbladNoiseOperator{\n".to_string();
+        let mut output = "PlusMinusLindbladNoiseOperator{\n".to_string();
         for (key, val) in self.iter() {
             writeln!(output, "({}, {}): {},", key.0, key.1, val)?;
         }
         output.push('}');
 
         write!(f, "{}", output)
     }
 }
 
-impl JordanWignerFermionToSpin for FermionLindbladNoiseOperator {
-    type Output = SpinLindbladNoiseOperator;
+impl JordanWignerSpinToFermion for PlusMinusLindbladNoiseOperator {
+    type Output = FermionLindbladNoiseOperator;
 
-    /// Implements JordanWignerFermionToSpin for a FermionLindbladNoiseOperator.
+    /// Implements JordanWignerSpinToFermion for a PlusMinusLindbladNoiseOperator.
     ///
     /// The convention used is that |0> represents an empty fermionic state (spin-orbital),
     /// and |1> represents an occupied fermionic state.
     ///
     /// # Returns
     ///
-    /// * `SpinLindbladNoiseOperator` - The spin noise operator that results from the transformation.
-    ///
-    /// # Panics
-    ///
-    /// * Internal bug in add_noise_from_full_operators.
+    /// `FermionLindbladNoiseOperator` - The fermionic noise operator that results from the transformation.
     fn jordan_wigner(&self) -> Self::Output {
-        let mut out = SpinLindbladNoiseOperator::new();
+        let mut out = FermionLindbladNoiseOperator::new();
 
         for key in self.keys() {
-            let decoherence_operator_left = DecoherenceOperator::from(key.0.jordan_wigner());
-            let decoherence_operator_right = DecoherenceOperator::from(key.1.jordan_wigner());
+            let fermion_operator_left = key.0.jordan_wigner();
+            let fermion_operator_right = key.1.jordan_wigner();
 
             out.add_noise_from_full_operators(
-                &decoherence_operator_left,
-                &decoherence_operator_right,
+                &fermion_operator_left,
+                &fermion_operator_right,
                 self.get(key).into(),
             )
             .expect("Internal bug in add_noise_from_full_operators");
         }
         out
     }
 }
 
 #[cfg(test)]
 mod test {
     use super::*;
     use serde_test::{assert_tokens, Configure, Token};
 
-    // Test the Clone and PartialEq traits of SpinOperator
+    // Test the Clone and PartialEq traits of QubitOperator
     #[test]
     fn so_from_sos() {
-        let pp: FermionProduct = FermionProduct::new([0], [0]).unwrap();
-        let sos = FermionLindbladNoiseOperatorSerialize {
+        let pp: PlusMinusProduct = PlusMinusProduct::new().z(0);
+        let sos = PlusMinusLindbladNoiseOperatorSerialize {
             items: vec![(pp.clone(), pp.clone(), 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "PlusMinusLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0-alpha.0".to_string(),
             },
         };
-        let mut so = FermionLindbladNoiseOperator::new();
+        let mut so = PlusMinusLindbladNoiseOperator::new();
         so.set((pp.clone(), pp), CalculatorComplex::from(0.5))
             .unwrap();
 
-        assert_eq!(FermionLindbladNoiseOperator::from(sos.clone()), so);
-        assert_eq!(FermionLindbladNoiseOperatorSerialize::from(so), sos);
+        assert_eq!(
+            PlusMinusLindbladNoiseOperator::try_from(sos.clone()).unwrap(),
+            so
+        );
+        assert_eq!(PlusMinusLindbladNoiseOperatorSerialize::from(so), sos);
     }
-    // Test the Clone and PartialEq traits of SpinOperator
+    // Test the Clone and PartialEq traits of QubitOperator
     #[test]
     fn clone_partial_eq() {
-        let pp: FermionProduct = FermionProduct::new([0], [0]).unwrap();
-        let sos = FermionLindbladNoiseOperatorSerialize {
+        let pp: PlusMinusProduct = PlusMinusProduct::new().z(0);
+        let sos = PlusMinusLindbladNoiseOperatorSerialize {
             items: vec![(pp.clone(), pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "PlusMinusLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         // Test Clone trait
         assert_eq!(sos.clone(), sos);
 
         // Test PartialEq trait
-        let pp_1: FermionProduct = FermionProduct::new([0], [0]).unwrap();
-        let sos_1 = FermionLindbladNoiseOperatorSerialize {
+        let pp_1: PlusMinusProduct = PlusMinusProduct::new().z(0);
+        let sos_1 = PlusMinusLindbladNoiseOperatorSerialize {
             items: vec![(pp_1.clone(), pp_1, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "PlusMinusLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
-        let pp_2: FermionProduct = FermionProduct::new([0], [1]).unwrap();
-        let sos_2 = FermionLindbladNoiseOperatorSerialize {
+        let pp_2: PlusMinusProduct = PlusMinusProduct::new().z(2);
+        let sos_2 = PlusMinusLindbladNoiseOperatorSerialize {
             items: vec![(pp_2.clone(), pp_2, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "PlusMinusLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
         assert!(sos_1 == sos);
         assert!(sos == sos_1);
         assert!(sos_2 != sos);
         assert!(sos != sos_2);
     }
 
-    // Test the Debug trait of SpinOperator
+    // Test the Debug trait of QubitOperator
     #[test]
     fn debug() {
-        let pp: FermionProduct = FermionProduct::new([0], [0]).unwrap();
-        let sos = FermionLindbladNoiseOperatorSerialize {
+        let pp: PlusMinusProduct = PlusMinusProduct::new().z(0);
+        let sos = PlusMinusLindbladNoiseOperatorSerialize {
             items: vec![(pp.clone(), pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "PlusMinusLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_eq!(
             format!("{:?}", sos),
-            "FermionLindbladNoiseOperatorSerialize { items: [(FermionProduct { creators: [0], annihilators: [0] }, FermionProduct { creators: [0], annihilators: [0] }, Float(0.5), Float(0.0))], _struqture_version: StruqtureVersionSerializable { major_version: 1, minor_version: 0 } }"
+            "PlusMinusLindbladNoiseOperatorSerialize { items: [(PlusMinusProduct { items: [(0, Z)] }, PlusMinusProduct { items: [(0, Z)] }, Float(0.5), Float(0.0))], serialisation_meta: StruqtureSerialisationMeta { type_name: \"PlusMinusLindbladNoiseOperator\", min_version: (2, 0, 0), version: \"2.0.0\" } }"
         );
     }
 
-    /// Test SpinOperator Serialization and Deserialization traits (readable)
+    /// Test QubitOperator Serialization and Deserialization traits (readable)
     #[test]
     fn serde_readable() {
-        let pp: FermionProduct = FermionProduct::new([0], [0]).unwrap();
-        let sos = FermionLindbladNoiseOperatorSerialize {
+        let pp = PlusMinusProduct::new().minus(0);
+        let sos = PlusMinusLindbladNoiseOperatorSerialize {
             items: vec![(pp.clone(), pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "PlusMinusLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_tokens(
             &sos.readable(),
             &[
                 Token::Struct {
-                    name: "FermionLindbladNoiseOperatorSerialize",
+                    name: "PlusMinusLindbladNoiseOperatorSerialize",
                     len: 2,
                 },
                 Token::Str("items"),
                 Token::Seq { len: Some(1) },
                 Token::Tuple { len: 4 },
-                Token::Str("c0a0"),
-                Token::Str("c0a0"),
+                Token::Str("0-"),
+                Token::Str("0-"),
                 Token::F64(0.5),
                 Token::F64(0.0),
                 Token::TupleEnd,
                 Token::SeqEnd,
-                Token::Str("_struqture_version"),
+                Token::Str("serialisation_meta"),
                 Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
                 },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(0),
+                Token::Str("type_name"),
+                Token::Str("PlusMinusLindbladNoiseOperator"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
                 Token::StructEnd,
                 Token::StructEnd,
             ],
         );
     }
 
-    /// Test SpinOperator Serialization and Deserialization traits (compact)
+    /// Test QubitOperator Serialization and Deserialization traits (compact)
     #[test]
     fn serde_compact() {
-        let pp: FermionProduct = FermionProduct::new([0], [0]).unwrap();
-        let sos = FermionLindbladNoiseOperatorSerialize {
+        let pp = PlusMinusProduct::new().plus(0);
+        let sos = PlusMinusLindbladNoiseOperatorSerialize {
             items: vec![(pp.clone(), pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "PlusMinusLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_tokens(
             &sos.compact(),
             &[
                 Token::Struct {
-                    name: "FermionLindbladNoiseOperatorSerialize",
+                    name: "PlusMinusLindbladNoiseOperatorSerialize",
                     len: 2,
                 },
                 Token::Str("items"),
                 Token::Seq { len: Some(1) },
                 Token::Tuple { len: 4 },
-                Token::Tuple { len: 2 },
                 Token::Seq { len: Some(1) },
-                Token::U64(0),
-                Token::SeqEnd,
-                Token::Seq { len: Some(1) },
-                Token::U64(0),
-                Token::SeqEnd,
-                Token::TupleEnd,
                 Token::Tuple { len: 2 },
-                Token::Seq { len: Some(1) },
                 Token::U64(0),
+                Token::UnitVariant {
+                    name: "SinglePlusMinusOperator",
+                    variant: "Plus",
+                },
+                Token::TupleEnd,
                 Token::SeqEnd,
                 Token::Seq { len: Some(1) },
+                Token::Tuple { len: 2 },
                 Token::U64(0),
-                Token::SeqEnd,
+                Token::UnitVariant {
+                    name: "SinglePlusMinusOperator",
+                    variant: "Plus",
+                },
                 Token::TupleEnd,
+                Token::SeqEnd,
                 Token::NewtypeVariant {
                     name: "CalculatorFloat",
                     variant: "Float",
                 },
                 Token::F64(0.5),
                 Token::NewtypeVariant {
                     name: "CalculatorFloat",
                     variant: "Float",
                 },
                 Token::F64(0.0),
                 Token::TupleEnd,
                 Token::SeqEnd,
-                Token::Str("_struqture_version"),
+                Token::Str("serialisation_meta"),
                 Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
                 },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(0),
+                Token::Str("type_name"),
+                Token::Str("PlusMinusLindbladNoiseOperator"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
                 Token::StructEnd,
                 Token::StructEnd,
             ],
         );
     }
 }
```

### Comparing `struqture_py-1.6.1/struqture/src/fermions/fermionic_open_system.rs` & `struqture_py-2.0.0a0/struqture/src/fermions/fermionic_open_system.rs`

 * *Files 9% similar despite different names*

```diff
@@ -6,33 +6,33 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
-use super::{FermionHamiltonianSystem, FermionLindbladNoiseSystem};
+use super::{FermionHamiltonian, FermionLindbladNoiseOperator};
 use crate::mappings::JordanWignerFermionToSpin;
-use crate::spins::SpinLindbladOpenSystem;
+use crate::spins::QubitLindbladOpenSystem;
 use crate::{OpenSystem, OperateOnDensityMatrix, OperateOnModes, StruqtureError};
 use qoqo_calculator::CalculatorFloat;
 use serde::{Deserialize, Serialize};
 use std::fmt::{self, Write};
 use std::ops;
 
-/// FermionLindbladOpenSystems are representations of open systems of fermions, where a system (FermionHamiltonianSystem) interacts with the environment via noise (FermionLindbladNoiseSystem).
+/// FermionLindbladOpenSystems are representations of open systems of fermions, where a system (FermionHamiltonian) interacts with the environment via noise (FermionLindbladNoiseOperator).
 ///
 /// # Example
 ///
 /// ```
 /// use struqture::prelude::*;
 /// use qoqo_calculator::CalculatorComplex;
-/// use struqture::fermions::{FermionProduct, HermitianFermionProduct, FermionLindbladOpenSystem, FermionHamiltonianSystem};
+/// use struqture::fermions::{FermionProduct, HermitianFermionProduct, FermionLindbladOpenSystem, FermionHamiltonian};
 ///
-/// let mut system = FermionLindbladOpenSystem::new(None);
+/// let mut system = FermionLindbladOpenSystem::new();
 ///
 /// let bp_0_1 = FermionProduct::new([0], [1]).unwrap();
 /// let bp_0 = HermitianFermionProduct::new([], [0]).unwrap();
 /// system.noise_mut().set((bp_0_1.clone(), bp_0_1.clone()), CalculatorComplex::from(0.5)).unwrap();
 /// system.system_mut().set(bp_0.clone(), CalculatorComplex::from(0.2)).unwrap();
 ///
 /// // Access what you set:
@@ -40,25 +40,28 @@
 /// assert_eq!(system.system().get(&bp_0.clone()), &CalculatorComplex::from(0.2));
 /// ```
 ///
 #[derive(Debug, Clone, PartialEq, Deserialize, Serialize, Default)]
 #[cfg_attr(feature = "json_schema", derive(schemars::JsonSchema))]
 #[cfg_attr(feature = "json_schema", schemars(deny_unknown_fields))]
 pub struct FermionLindbladOpenSystem {
-    /// The FermionHamiltonianSystem representing the system terms of the open system
-    system: FermionHamiltonianSystem,
-    /// The FermionLindbladNoiseSystem representing the noise terms of the open system
-    noise: FermionLindbladNoiseSystem,
+    /// The FermionHamiltonian representing the system terms of the open system
+    system: FermionHamiltonian,
+    /// The FermionLindbladNoiseOperator representing the noise terms of the open system
+    noise: FermionLindbladNoiseOperator,
 }
 
-impl crate::MinSupportedVersion for FermionLindbladOpenSystem {}
-
+impl crate::SerializationSupport for FermionLindbladOpenSystem {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::FermionLindbladOpenSystem
+    }
+}
 impl<'a> OpenSystem<'a> for FermionLindbladOpenSystem {
-    type System = FermionHamiltonianSystem;
-    type Noise = FermionLindbladNoiseSystem;
+    type System = FermionHamiltonian;
+    type Noise = FermionLindbladNoiseOperator;
 
     // From trait
     fn noise(&self) -> &Self::Noise {
         &self.noise
     }
 
     // From trait
@@ -77,105 +80,90 @@
     }
 
     // From trait
     fn ungroup(self) -> (Self::System, Self::Noise) {
         (self.system, self.noise)
     }
 
-    /// Takes a tuple of a system (FermionHamiltonianSystem) and a noise term (FermionLindbladNoiseSystem) and combines them to be a FermionLindbladOpenSystem.
+    /// Takes a tuple of a system (FermionHamiltonian) and a noise term (FermionLindbladNoiseOperator) and combines them to be a FermionLindbladOpenSystem.
     ///
     /// # Arguments
     ///
-    /// * `system` - The FermionHamiltonianSystem to have in the FermionLindbladOpenSystem.
-    /// * `noise` - The FermionLindbladNoiseSystem to have in the FermionLindbladOpenSystem.
+    /// * `system` - The FermionHamiltonian to have in the FermionLindbladOpenSystem.
+    /// * `noise` - The FermionLindbladNoiseOperator to have in the FermionLindbladOpenSystem.
     ///
     /// # Returns
     ///
     /// * `Ok(Self)` - The FermionLindbladOpenSystem with input system and noise terms.
     /// * `Err(StruqtureError::MissmatchedNumberModes)` - The system and noise do not have the same number of modes.
     fn group(system: Self::System, noise: Self::Noise) -> Result<Self, StruqtureError> {
-        let (system, noise) = if system.number_modes != noise.number_modes {
-            match (system.number_modes, noise.number_modes) {
-                (Some(n), None) => {
-                    if n >= noise.number_modes() {
-                        let mut noise = noise;
-                        noise.number_modes = Some(n);
-                        (system, noise)
-                    } else {
-                        return Err(StruqtureError::MissmatchedNumberModes);
-                    }
-                }
-                (None, Some(n)) => {
-                    if n >= system.number_modes() {
-                        let mut system = system;
-                        system.number_modes = Some(n);
-                        (system, noise)
-                    } else {
-                        return Err(StruqtureError::MissmatchedNumberModes);
-                    }
-                }
-                (Some(_), Some(_)) => {
-                    return Err(StruqtureError::MissmatchedNumberModes);
-                }
-                _ => panic!("Unexpected missmatch of number modes"),
-            }
-        } else {
-            (system, noise)
-        };
         Ok(Self { system, noise })
     }
 
     // From trait
     fn empty_clone(&self) -> Self {
         Self::group(self.system.empty_clone(None), self.noise.empty_clone(None)).expect(
             "Internal error: Number of modes in system and noise unexpectedly does not match.",
         )
     }
 }
 
 impl<'a> OperateOnModes<'a> for FermionLindbladOpenSystem {
-    /// Gets the maximum number_modes of the FermionHamiltonianSystem/FermionLindbladNoiseSystem.
+    /// Gets the maximum current_number_modes of the FermionHamiltonian/FermionLindbladNoiseOperator.
     ///
     /// # Returns
     ///
     /// * `usize` - The number of fermions in the FermionLindbladOpenSystem.
-    fn number_modes(&self) -> usize {
-        self.system.number_modes().max(self.noise.number_modes())
-    }
-
-    /// Return maximum index in FermionLindbladOpenSystem.
-    ///
-    /// # Returns
-    ///
-    /// * `usize` - Maximum index.
     fn current_number_modes(&self) -> usize {
         self.system
             .current_number_modes()
             .max(self.noise.current_number_modes())
     }
 }
 
 /// Functions for the FermionLindbladOpenSystem
 ///
 impl FermionLindbladOpenSystem {
     /// Creates a new FermionLindbladOpenSystem.
     ///
-    /// # Arguments
-    ///
-    /// * `number_modes` - The number of modes in the system.
-    ///
     /// # Returns
     ///
     /// * `Self` - The new (empty) FermionLindbladOpenSystem.
-    pub fn new(number_modes: Option<usize>) -> Self {
+    pub fn new() -> Self {
         FermionLindbladOpenSystem {
-            system: FermionHamiltonianSystem::new(number_modes),
-            noise: FermionLindbladNoiseSystem::new(number_modes),
+            system: FermionHamiltonian::new(),
+            noise: FermionLindbladNoiseOperator::new(),
         }
     }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(
+        &self,
+    ) -> Result<struqture_one::fermions::FermionLindbladOpenSystem, StruqtureError> {
+        let new_system = self.system().to_struqture_1()?;
+        let new_noise = self.noise().to_struqture_1()?;
+
+        struqture_one::OpenSystem::group(new_system, new_noise).map_err(
+            |err| StruqtureError::GenericError { msg:
+                format!("Could not convert struqture 2.x FermionLindbladOpenSystem to 1.x FermionLindbladOpenSystem, group function failed: {:?}.", err)
+            }
+        )
+    }
+
+    /// Import from struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::fermions::FermionLindbladOpenSystem,
+    ) -> Result<Self, StruqtureError> {
+        let (system_one, noise_one) = struqture_one::OpenSystem::ungroup(value.clone());
+        let new_system = FermionHamiltonian::from_struqture_1(&system_one)?;
+        let new_noise = FermionLindbladNoiseOperator::from_struqture_1(&noise_one)?;
+        Self::group(new_system, new_noise)
+    }
 }
 
 /// Implements the negative sign function of FermionLindbladOpenSystem.
 ///
 impl ops::Neg for FermionLindbladOpenSystem {
     type Output = Self;
     /// Implement minus sign for FermionLindbladOpenSystem.
@@ -201,20 +189,20 @@
     /// # Arguments
     ///
     /// * `other` - The FermionLindbladOpenSystem to be added.
     ///
     /// # Returns
     ///
     /// * `Ok(Self)` - The two FermionLindbladOpenSystems added together.
-    /// * `Err(StruqtureError::NumberModesExceeded)` - Index of HermitianFermionProduct exceeds that of the FermionHamiltonianSystem.
-    /// * `Err(StruqtureError::NumberModesExceeded)` - Index of (FermionProduct, FermionProduct) exceeds that of the FermionLindbladNoiseSystem.
+    /// * `Err(StruqtureError::NumberModesExceeded)` - Index of HermitianFermionProduct exceeds that of the FermionHamiltonian.
+    /// * `Err(StruqtureError::NumberModesExceeded)` - Index of (FermionProduct, FermionProduct) exceeds that of the FermionLindbladNoiseOperator.
     fn add(self, other: FermionLindbladOpenSystem) -> Self::Output {
         let (self_sys, self_noise) = self.ungroup();
         let (other_sys, other_noise) = other.ungroup();
-        Self::group((self_sys + other_sys)?, (self_noise + other_noise)?)
+        Self::group((self_sys + other_sys)?, self_noise + other_noise)
     }
 }
 
 /// Implements the minus function of FermionLindbladOpenSystem by FermionLindbladOpenSystem.
 ///
 impl ops::Sub<FermionLindbladOpenSystem> for FermionLindbladOpenSystem {
     type Output = Result<Self, StruqtureError>;
@@ -223,20 +211,20 @@
     /// # Arguments
     ///
     /// * `other` - The FermionLindbladOpenSystem to be subtracted.
     ///
     /// # Returns
     ///
     /// * `Ok(Self)` - The two FermionLindbladOpenSystems subtracted.
-    /// * `Err(StruqtureError::NumberModesExceeded)` - Index of HermitianFermionProduct exceeds that of the FermionHamiltonianSystem.
-    /// * `Err(StruqtureError::NumberModesExceeded)` - Index of (FermionProduct, FermionProduct) exceeds that of the FermionLindbladNoiseSystem.
+    /// * `Err(StruqtureError::NumberModesExceeded)` - Index of HermitianFermionProduct exceeds that of the FermionHamiltonian.
+    /// * `Err(StruqtureError::NumberModesExceeded)` - Index of (FermionProduct, FermionProduct) exceeds that of the FermionLindbladNoiseOperator.
     fn sub(self, other: FermionLindbladOpenSystem) -> Self::Output {
         let (self_sys, self_noise) = self.ungroup();
         let (other_sys, other_noise) = other.ungroup();
-        Self::group((self_sys - other_sys)?, (self_noise - other_noise)?)
+        Self::group((self_sys - other_sys)?, self_noise - other_noise)
     }
 }
 
 /// Implements the multiplication function of FermionLindbladOpenSystem by CalculatorFloat.
 ///
 impl ops::Mul<CalculatorFloat> for FermionLindbladOpenSystem {
     type Output = Self;
@@ -244,15 +232,15 @@
     ///
     /// # Arguments
     ///
     /// * `other` - The CalculatorFloat by which to multiply.
     ///
     /// # Returns
     ///
-    /// * `Self` - The FermionLindbladNoiseSystem multiplied by the CalculatorFloat.
+    /// * `Self` - The FermionLindbladNoiseOperator multiplied by the CalculatorFloat.
     fn mul(self, rhs: CalculatorFloat) -> Self::Output {
         Self {
             system: self.system * rhs.clone(),
             noise: self.noise * rhs,
         }
     }
 }
@@ -266,15 +254,15 @@
     ///
     /// * `f` - The formatter to use.
     ///
     /// # Returns
     ///
     /// * `std::fmt::Result` - The formatted FermionLindbladOpenSystem.
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        let mut output = format!("FermionLindbladOpenSystem({}){{\n", self.number_modes());
+        let mut output = "FermionLindbladOpenSystem{\n".to_string();
         output.push_str("System: {\n");
         for (key, val) in self.system.iter() {
             writeln!(output, "{}: {},", key, val)?;
         }
         output.push_str("}\n");
         output.push_str("Noise: {\n");
         for ((row, column), val) in self.noise.iter() {
@@ -284,24 +272,24 @@
         output.push('}');
 
         write!(f, "{}", output)
     }
 }
 
 impl JordanWignerFermionToSpin for FermionLindbladOpenSystem {
-    type Output = SpinLindbladOpenSystem;
+    type Output = QubitLindbladOpenSystem;
 
     /// Implements JordanWignerFermionToSpin for a FermionLindbladOpenSystem.
     ///
     /// The convention used is that |0> represents an empty fermionic state (spin-orbital),
     /// and |1> represents an occupied fermionic state.
     ///
     /// # Returns
     ///
-    /// `SpinLindbladOpenSystem` - The spin open system that results from the transformation.
+    /// `QubitLindbladOpenSystem` - The spin open system that results from the transformation.
     fn jordan_wigner(&self) -> Self::Output {
         let jw_system = self.system().jordan_wigner();
         let jw_noise = self.noise().jordan_wigner();
-        SpinLindbladOpenSystem::group(jw_system, jw_noise)
-            .expect("Internal bug in jordan_wigner() for FermionHamiltonianSystem or FermionLindbladNoiseSystem. The number of modes in the fermionic system should equal the number of spins in the spin system.")
+        QubitLindbladOpenSystem::group(jw_system, jw_noise)
+            .expect("Internal bug in jordan_wigner() for FermionHamiltonian or FermionLindbladNoiseOperator. The number of modes in the fermionic system should equal the number of spins in the spin system.")
     }
 }
```

### Comparing `struqture_py-1.6.1/struqture/src/fermions/fermionic_operator.rs` & `struqture_py-2.0.0a0/struqture/src/spins/plus_minus_operator.rs`

 * *Files 23% similar despite different names*

```diff
@@ -6,757 +6,844 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
-use super::{FermionHamiltonian, OperateOnFermions};
-use crate::fermions::FermionProduct;
-use crate::mappings::JordanWignerFermionToSpin;
-use crate::spins::SpinOperator;
-use crate::{
-    GetValue, ModeIndex, OperateOnDensityMatrix, OperateOnModes, OperateOnState, StruqtureError,
-    StruqtureVersionSerializable, SymmetricIndex, MINIMUM_STRUQTURE_VERSION,
-};
-// use itertools::Itertools;
+use super::{DecoherenceOperator, DecoherenceProduct, PauliProduct, QubitOperator};
+use crate::fermions::FermionOperator;
+use crate::mappings::JordanWignerSpinToFermion;
+use crate::spins::{PlusMinusProduct, QubitHamiltonian};
+use crate::{OperateOnDensityMatrix, OperateOnState, StruqtureError, SymmetricIndex};
+use num_complex::Complex64;
 use qoqo_calculator::{CalculatorComplex, CalculatorFloat};
 use serde::{Deserialize, Serialize};
+
+use indexmap::map::{Entry, Iter};
+use indexmap::IndexMap;
+
 use std::fmt::{self, Write};
 use std::iter::{FromIterator, IntoIterator};
 use std::ops;
 
-#[cfg(feature = "indexed_map_iterators")]
-use indexmap::map::{Entry, Iter, Keys, Values};
-#[cfg(feature = "indexed_map_iterators")]
-use indexmap::IndexMap;
-#[cfg(not(feature = "indexed_map_iterators"))]
-use std::collections::hash_map::{Entry, Iter, Keys, Values};
-#[cfg(not(feature = "indexed_map_iterators"))]
-use std::collections::HashMap;
-
-/// FermionOperators are combinations of FermionProducts with specific CalculatorComplex coefficients.
+/// PlusMinusOperators are combinations of PlusMinusProducts with specific CalculatorComplex coefficients.
+///
+/// This is a representation of sums of pauli products with weightings, in order to build a full hamiltonian.
 ///
 /// # Example
 ///
 /// ```
 /// use struqture::prelude::*;
 /// use qoqo_calculator::CalculatorComplex;
-/// use struqture::fermions::{OperateOnFermions, FermionProduct};
-/// use struqture::fermions::FermionOperator;
-/// let mut fo = FermionOperator::new();
-///
-/// // Representing the opetator $ 1/2 b_0^{dagger} + 1/5 b_1 $
-/// // Creating a FermionProduct with a creation operator acting on mode 0 and no annihilation operators
-/// let fp_0 = FermionProduct::new([0],[]).unwrap();
-/// // Creating a FermionProduct with a annihilation operator acting on mode 1 and no creation operators
-/// let fp_1 = FermionProduct::new([],[1]).unwrap();
-/// fo.set(fp_0.clone(), CalculatorComplex::from(0.5)).unwrap();
-/// fo.set(fp_1.clone(), CalculatorComplex::from(0.2)).unwrap();
+/// use struqture::spins::{OperateOnSpins, PlusMinusProduct, PlusMinusOperator};
+///
+/// let mut so = PlusMinusOperator::new();
+///
+/// // Representing the hamiltonian $ 1/2 \sigma_0^{+} \sigma_1^{+} + 1/5 \sigma_0^{z} $
+/// let pp_0x1x = PlusMinusProduct::new().plus(0).plus(1);
+/// let pp_0z = PlusMinusProduct::new().z(0);
+/// so.add_operator_product(pp_0x1x.clone(), CalculatorComplex::from(0.5)).unwrap();
+/// so.add_operator_product(pp_0z.clone(), CalculatorComplex::from(0.2)).unwrap();
 ///
 /// // Access what you set:
-/// assert_eq!(fo.get(&fp_0), &CalculatorComplex::from(0.5));
-/// assert_eq!(fo.get(&fp_1), &CalculatorComplex::from(0.2));
+/// assert_eq!(so.get(&pp_0x1x), &CalculatorComplex::from(0.5));
+/// assert_eq!(so.get(&pp_0z), &CalculatorComplex::from(0.2));
 /// ```
 ///
 #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
-#[serde(from = "FermionOperatorSerialize")]
-#[serde(into = "FermionOperatorSerialize")]
-pub struct FermionOperator {
-    /// The internal HashMap of FermionProducts and coefficients (CalculatorComplex)
-    #[cfg(feature = "indexed_map_iterators")]
-    internal_map: IndexMap<FermionProduct, CalculatorComplex>,
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    internal_map: HashMap<FermionProduct, CalculatorComplex>,
+#[serde(try_from = "PlusMinusOperatorSerialize")]
+#[serde(into = "PlusMinusOperatorSerialize")]
+pub struct PlusMinusOperator {
+    // The internal HashMap of PlusMinusProducts and coefficients (CalculatorComplex)
+    internal_map: IndexMap<PlusMinusProduct, CalculatorComplex>,
+}
+
+impl crate::SerializationSupport for PlusMinusOperator {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::PlusMinusOperator
+    }
 }
-impl crate::MinSupportedVersion for FermionOperator {}
 
 #[cfg(feature = "json_schema")]
-impl schemars::JsonSchema for FermionOperator {
+impl schemars::JsonSchema for PlusMinusOperator {
     fn schema_name() -> String {
-        "FermionOperator".to_string()
+        "PlusMinusOperator".to_string()
     }
 
     fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
-        <FermionOperatorSerialize>::json_schema(gen)
+        <PlusMinusOperatorSerialize>::json_schema(gen)
     }
 }
 
 #[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
 #[cfg_attr(feature = "json_schema", derive(schemars::JsonSchema))]
 #[cfg_attr(feature = "json_schema", schemars(deny_unknown_fields))]
-struct FermionOperatorSerialize {
-    items: Vec<(FermionProduct, CalculatorFloat, CalculatorFloat)>,
-    _struqture_version: StruqtureVersionSerializable,
+struct PlusMinusOperatorSerialize {
+    items: Vec<(PlusMinusProduct, CalculatorFloat, CalculatorFloat)>,
+    serialisation_meta: crate::StruqtureSerialisationMeta,
 }
 
-impl From<FermionOperatorSerialize> for FermionOperator {
-    fn from(value: FermionOperatorSerialize) -> Self {
-        let new_noise_op: FermionOperator = value
+impl TryFrom<PlusMinusOperatorSerialize> for PlusMinusOperator {
+    type Error = StruqtureError;
+    fn try_from(value: PlusMinusOperatorSerialize) -> Result<Self, Self::Error> {
+        let target_serialisation_meta =
+            <Self as crate::SerializationSupport>::target_serialisation_meta();
+        crate::check_can_be_deserialised(&target_serialisation_meta, &value.serialisation_meta)?;
+        let new_noise_op: PlusMinusOperator = value
             .items
             .into_iter()
             .map(|(key, real, imag)| (key, CalculatorComplex { re: real, im: imag }))
             .collect();
-        new_noise_op
+        Ok(new_noise_op)
     }
 }
 
-impl From<FermionOperator> for FermionOperatorSerialize {
-    fn from(value: FermionOperator) -> Self {
-        let new_noise_op: Vec<(FermionProduct, CalculatorFloat, CalculatorFloat)> = value
+impl From<PlusMinusOperator> for PlusMinusOperatorSerialize {
+    fn from(value: PlusMinusOperator) -> Self {
+        let serialisation_meta = crate::SerializationSupport::struqture_serialisation_meta(&value);
+
+        let new_noise_op: Vec<(PlusMinusProduct, CalculatorFloat, CalculatorFloat)> = value
             .into_iter()
             .map(|(key, val)| (key, val.re, val.im))
             .collect();
-        let current_version = StruqtureVersionSerializable {
-            major_version: MINIMUM_STRUQTURE_VERSION.0,
-            minor_version: MINIMUM_STRUQTURE_VERSION.1,
-        };
         Self {
             items: new_noise_op,
-            _struqture_version: current_version,
+            serialisation_meta,
         }
     }
 }
 
-impl<'a> OperateOnDensityMatrix<'a> for FermionOperator {
-    type Index = FermionProduct;
+impl<'a> OperateOnDensityMatrix<'a> for PlusMinusOperator {
     type Value = CalculatorComplex;
-    type IteratorType = Iter<'a, Self::Index, Self::Value>;
-    type KeyIteratorType = Keys<'a, Self::Index, Self::Value>;
-    type ValueIteratorType = Values<'a, Self::Index, Self::Value>;
+    type Index = PlusMinusProduct;
 
     // From trait
-    fn get(&self, key: &FermionProduct) -> &CalculatorComplex {
+    fn get(&self, key: &Self::Index) -> &Self::Value {
         match self.internal_map.get(key) {
             Some(value) => value,
             None => &CalculatorComplex::ZERO,
         }
     }
 
     // From trait
-    fn iter(&'a self) -> Self::IteratorType {
+    fn iter(&'a self) -> impl ExactSizeIterator<Item = (&'a Self::Index, &'a Self::Value)> {
         self.internal_map.iter()
     }
 
     // From trait
-    fn keys(&'a self) -> Self::KeyIteratorType {
+    fn keys(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Index> {
         self.internal_map.keys()
     }
 
     // From trait
-    fn values(&'a self) -> Self::ValueIteratorType {
+    fn values(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Value> {
         self.internal_map.values()
     }
 
-    #[cfg(feature = "indexed_map_iterators")]
     // From trait
     fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
         self.internal_map.shift_remove(key)
     }
 
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    // From trait
-    fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
-        self.internal_map.remove(key)
-    }
-
     // From trait
     fn empty_clone(&self, capacity: Option<usize>) -> Self {
         match capacity {
             Some(cap) => Self::with_capacity(cap),
             None => Self::new(),
         }
     }
 
-    /// Overwrites an existing entry or sets a new entry in the FermionOperator with the given (FermionProduct key, CalculatorComplex value) pair.
+    /// Overwrites an existing entry or sets a new entry in the PlusMinusOperator with the given (PlusMinusProduct key, CalculatorComplex value) pair.
     ///
     /// # Arguments
     ///
-    /// * `key` - The FermionProduct key to set in the FermionOperator.
-    /// * `value` - The corresponding CalculatorComplex value to set for the key in the FermionOperator.
+    /// * `key` - The PlusMinusProduct key to set in the PlusMinusOperator.
+    /// * `value` - The corresponding CalculatorComplex value to set for the key in the PlusMinusOperator.
     ///
     /// # Returns
     ///
     /// * `Ok(Some(CalculatorComplex))` - The key existed, this is the value it had before it was set with the value input.
     /// * `Ok(None)` - The key did not exist, it has been set with its corresponding value.
     fn set(
         &mut self,
         key: Self::Index,
         value: Self::Value,
     ) -> Result<Option<Self::Value>, StruqtureError> {
         if value != CalculatorComplex::ZERO {
             Ok(self.internal_map.insert(key, value))
         } else {
             match self.internal_map.entry(key) {
-                #[cfg(feature = "indexed_map_iterators")]
                 Entry::Occupied(val) => Ok(Some(val.shift_remove())),
-                #[cfg(not(feature = "indexed_map_iterators"))]
-                Entry::Occupied(val) => Ok(Some(val.remove())),
                 Entry::Vacant(_) => Ok(None),
             }
         }
     }
 }
 
-impl<'a> OperateOnState<'a> for FermionOperator {}
-
-impl<'a> OperateOnModes<'a> for FermionOperator {
+impl<'a> OperateOnState<'a> for PlusMinusOperator {
     // From trait
-    fn current_number_modes(&'a self) -> usize {
-        let mut max_mode: usize = 0;
-        if !self.is_empty() {
-            for key in self.keys() {
-                let maxk = key.current_number_modes();
-                if maxk > max_mode {
-                    max_mode = maxk;
-                }
-            }
+    fn hermitian_conjugate(&self) -> Self {
+        let mut new_operator = Self::with_capacity(self.len());
+        for (pauli_product, value) in self.iter() {
+            let (new_boson_product, prefactor) = pauli_product.hermitian_conjugate();
+            new_operator
+                .add_operator_product(new_boson_product, value.conj() * prefactor)
+                .expect("Internal bug in add_operator_product");
         }
-        max_mode
-    }
-
-    /// Gets the maximum index of the FermionOperator.
-    ///
-    /// # Returns
-    ///
-    /// * `usize` - The number of fermions in the FermionOperator.
-    fn number_modes(&'a self) -> usize {
-        self.current_number_modes()
+        new_operator
     }
 }
 
-impl<'a> OperateOnFermions<'a> for FermionOperator {}
-
-/// Implements the default function (Default trait) of FermionOperator (an empty FermionOperator).
+/// Implements the default function (Default trait) of PlusMinusOperator (an empty PlusMinusOperator).
 ///
-impl Default for FermionOperator {
+impl Default for PlusMinusOperator {
     fn default() -> Self {
         Self::new()
     }
 }
 
-/// Functions for the FermionOperator
+/// Functions for the PlusMinusOperator
 ///
-impl FermionOperator {
-    /// Creates a new FermionOperator.
+impl PlusMinusOperator {
+    /// Creates a new PlusMinusOperator.
     ///
     /// # Returns
     ///
-    /// * `Self` - The new (empty) FermionOperator.
+    /// * `Self` - The new (empty) PlusMinusOperator.
     pub fn new() -> Self {
-        FermionOperator {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::new(),
-            #[cfg(feature = "indexed_map_iterators")]
+        PlusMinusOperator {
             internal_map: IndexMap::new(),
         }
     }
 
-    /// Creates a new FermionOperator with pre-allocated capacity.
+    /// Creates a new PlusMinusOperator with pre-allocated capacity.
     ///
     /// # Arguments
     ///
-    /// * `capacity` - The pre-allocated capacity of the operator.
+    /// * `capacity` - The pre-allocated capacity of the system.
     ///
     /// # Returns
     ///
-    /// * `Self` - The new (empty) FermionOperator.
+    /// * `Self` - The new (empty) PlusMinusOperator.
     pub fn with_capacity(capacity: usize) -> Self {
-        FermionOperator {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::with_capacity(capacity),
-            #[cfg(feature = "indexed_map_iterators")]
+        PlusMinusOperator {
             internal_map: IndexMap::with_capacity(capacity),
         }
     }
 
-    /// Separate self into an operator with the terms of given number of creation and annihilation operators and an operator with the remaining operations
+    /// Gets the maximum index of the PlusMinusOperator.
+    ///
+    /// # Returns
+    ///
+    /// * `usize` - The number of spins in the PlusMinusOperator.
+    pub fn current_number_spins(&self) -> usize {
+        let mut max_mode: usize = 0;
+        if !self.internal_map.is_empty() {
+            for key in self.internal_map.keys() {
+                if key.current_number_spins() > max_mode {
+                    max_mode = key.current_number_spins()
+                }
+            }
+        }
+        max_mode
+    }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(
+        &self,
+    ) -> Result<struqture_one::spins::PlusMinusOperator, StruqtureError> {
+        let mut new_pm_system = struqture_one::spins::PlusMinusOperator::new();
+        for (key, val) in self.iter() {
+            let one_key = key.to_struqture_1()?;
+            let _ = struqture_one::OperateOnDensityMatrix::set(
+                &mut new_pm_system,
+                one_key,
+                val.clone(),
+            );
+        }
+        Ok(new_pm_system)
+    }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::spins::PlusMinusOperator,
+    ) -> Result<Self, StruqtureError> {
+        let mut new_qubit_operator = Self::new();
+        for (key, val) in struqture_one::OperateOnDensityMatrix::iter(value) {
+            let self_key = PlusMinusProduct::from_struqture_1(key)?;
+            let _ = new_qubit_operator.set(self_key, val.clone());
+        }
+        Ok(new_qubit_operator)
+    }
+}
+
+impl From<PlusMinusOperator> for QubitOperator {
+    /// Converts a PlusMinusOperator into a QubitOperator.
     ///
     /// # Arguments
     ///
-    /// * `number_creators_annihilators` - Number of creation and annihilation terms to filter for in the keys.
+    /// * `value` - The PlusMinusOperator to convert.
     ///
     /// # Returns
     ///
-    /// `Ok((separated, remainder))` - Operator with the noise terms where number_creators_annihilators matches the number of spins the operator product acts on and Operator with all other contributions.
-    pub fn separate_into_n_terms(
-        &self,
-        number_creators_annihilators: (usize, usize),
-    ) -> Result<(Self, Self), StruqtureError> {
-        let mut separated = Self::default();
-        let mut remainder = Self::default();
-        for (prod, val) in self.iter() {
-            if (prod.creators().len(), prod.annihilators().len()) == number_creators_annihilators {
-                separated.add_operator_product(prod.clone(), val.clone())?;
-            } else {
-                remainder.add_operator_product(prod.clone(), val.clone())?;
+    /// * `Self` - The PlusMinusOperator converted into a QubitOperator.
+    fn from(value: PlusMinusOperator) -> Self {
+        let mut new_operator = QubitOperator::with_capacity(2 * value.len());
+        for (product, val) in value.into_iter() {
+            let transscribed_vector: Vec<(PauliProduct, Complex64)> = product.into();
+            for (transscribed_product, prefactor) in transscribed_vector {
+                new_operator
+                    .add_operator_product(transscribed_product, val.clone() * prefactor)
+                    .expect("Unexpected error adding operators. Internal struqture error");
             }
         }
-        Ok((separated, remainder))
+        new_operator
     }
 }
 
-impl From<FermionHamiltonian> for FermionOperator {
-    /// Converts a FermionHamiltonian into a FermionOperator.
+impl From<QubitOperator> for PlusMinusOperator {
+    /// Converts a QubitOperator into a PlusMinusOperator.
     ///
     /// # Arguments
     ///
-    /// * `hamiltonian` - The FermionHamiltonian to convert.
+    /// * `value` - The QubitOperator to convert.
     ///
     /// # Returns
     ///
-    /// * `Self` - The FermionHamiltonian converted into a FermionOperator.
+    /// * `Self` - The QubitOperator converted into a PlusMinusOperator.
+    fn from(value: QubitOperator) -> Self {
+        let mut new_operator = PlusMinusOperator::with_capacity(2 * value.len());
+        for (product, val) in value.into_iter() {
+            let transscribed_vector: Vec<(PlusMinusProduct, Complex64)> = product.into();
+            for (transscribed_product, prefactor) in transscribed_vector {
+                new_operator
+                    .add_operator_product(transscribed_product, val.clone() * prefactor)
+                    .expect("Unexpected error adding operators. Internal struqture error");
+            }
+        }
+        new_operator
+    }
+}
+
+impl From<PlusMinusOperator> for DecoherenceOperator {
+    /// Converts a PlusMinusOperator into a DecoherenceOperator.
     ///
-    /// # Panics
+    /// # Arguments
     ///
-    /// * Internal error in add_operator_product.
-    fn from(hamiltonian: FermionHamiltonian) -> Self {
-        let mut internal = FermionOperator::new();
-        for (key, value) in hamiltonian.into_iter() {
-            let bp = FermionProduct::get_key(&key);
-            internal
-                .add_operator_product(bp.clone(), value.clone())
-                .expect("Internal bug in add_operator_product");
-            if !key.is_natural_hermitian() {
-                let bp_conj = bp.hermitian_conjugate();
-                internal
-                    .add_operator_product(FermionProduct::get_key(&bp_conj.0), value * bp_conj.1)
-                    .expect("Internal error in add_operator_product");
+    /// * `value` - The PlusMinusOperator to convert.
+    ///
+    /// # Returns
+    ///
+    /// * `Self` - The PlusMinusOperator converted into a DecoherenceOperator.
+    fn from(value: PlusMinusOperator) -> Self {
+        let mut new_operator = DecoherenceOperator::with_capacity(2 * value.len());
+        for (product, val) in value.into_iter() {
+            let transscribed_vector: Vec<(DecoherenceProduct, Complex64)> = product.into();
+            for (transscribed_product, prefactor) in transscribed_vector {
+                new_operator
+                    .add_operator_product(transscribed_product, val.clone() * prefactor)
+                    .expect("Unexpected error adding operators. Internal struqture error");
+            }
+        }
+        new_operator
+    }
+}
+
+impl From<DecoherenceOperator> for PlusMinusOperator {
+    /// Converts a DecoherenceOperator into a PlusMinusOperator.
+    ///
+    /// # Arguments
+    ///
+    /// * `value` - The DecoherenceOperator to convert.
+    ///
+    /// # Returns
+    ///
+    /// * `Self` - The DecoherenceOperator converted into a PlusMinusOperator.
+    fn from(value: DecoherenceOperator) -> Self {
+        let mut new_operator = PlusMinusOperator::with_capacity(2 * value.len());
+        for (product, val) in value.into_iter() {
+            let transscribed_vector: Vec<(PlusMinusProduct, Complex64)> = product.into();
+            for (transscribed_product, prefactor) in transscribed_vector {
+                new_operator
+                    .add_operator_product(transscribed_product, val.clone() * prefactor)
+                    .expect("Unexpected error adding operators. Internal struqture error");
+            }
+        }
+        new_operator
+    }
+}
+
+impl TryFrom<PlusMinusOperator> for QubitHamiltonian {
+    type Error = StruqtureError;
+
+    /// Tries to converts a PlusMinusOperator into a QubitHamiltonian.
+    ///
+    /// # Arguments
+    ///
+    /// * `value` - The PlusMinusOperator to try to convert.
+    ///
+    /// # Returns
+    ///
+    /// * `Ok(Self)` - The PlusMinusOperator converted into a QubitHamiltonian.
+    /// * `Err(StruqtureError::NonHermitianOperator)` - Key is naturally hermitian (on-diagonal term), but its corresponding value is not real.
+    fn try_from(value: PlusMinusOperator) -> Result<Self, Self::Error> {
+        let tmp_operator = QubitOperator::from(value).truncate(1e-16);
+        QubitHamiltonian::try_from(tmp_operator)
+    }
+}
+
+impl From<QubitHamiltonian> for PlusMinusOperator {
+    /// Converts a QubitHamiltonian into a PlusMinusOperator.
+    ///
+    /// # Arguments
+    ///
+    /// * `value` - The QubitHamiltonian to convert.
+    ///
+    /// # Returns
+    ///
+    /// * `Self` - The QubitHamiltonian converted into a PlusMinusOperator.
+    fn from(value: QubitHamiltonian) -> Self {
+        let mut new_operator = PlusMinusOperator::with_capacity(2 * value.len());
+        for (product, val) in value.into_iter() {
+            let transscribed_vector: Vec<(PlusMinusProduct, Complex64)> = product.into();
+            for (transscribed_product, prefactor) in transscribed_vector {
+                new_operator
+                    .add_operator_product(
+                        transscribed_product,
+                        CalculatorComplex::from(val.clone()) * prefactor,
+                    )
+                    .expect("Unexpected error adding operators. Internal struqture error");
             }
         }
-        internal
+        new_operator.truncate(1e-16)
     }
 }
 
-/// Implements the negative sign function of FermionOperator.
+/// Implements the negative sign function of PlusMinusOperator.
 ///
-impl ops::Neg for FermionOperator {
-    type Output = FermionOperator;
-    /// Implement minus sign for FermionOperator.
+impl ops::Neg for PlusMinusOperator {
+    type Output = PlusMinusOperator;
+    /// Implement minus sign for PlusMinusOperator.
     ///
     /// # Returns
     ///
-    /// * `Self` - The FermionOperator * -1.
+    /// * `Self` - The PlusMinusOperator * -1.
     fn neg(self) -> Self {
-        let mut internal = self.internal_map.clone();
-        for key in self.keys() {
-            internal.insert(key.clone(), internal[key].clone() * -1.0);
+        let mut internal = IndexMap::with_capacity(self.len());
+        for (key, val) in self {
+            internal.insert(key.clone(), val.neg());
         }
-        FermionOperator {
+        PlusMinusOperator {
             internal_map: internal,
         }
     }
 }
 
-/// Implements the plus function of FermionOperator by FermionOperator.
+/// Implements the plus function of PlusMinusOperator by PlusMinusOperator.
 ///
-impl ops::Add<FermionOperator> for FermionOperator {
+impl<T, V> ops::Add<T> for PlusMinusOperator
+where
+    T: IntoIterator<Item = (PlusMinusProduct, V)>,
+    V: Into<CalculatorComplex>,
+{
     type Output = Self;
-    /// Implements `+` (add) for two FermionOperators.
+    /// Implements `+` (add) for two PlusMinusOperators.
     ///
     /// # Arguments
     ///
-    /// * `other` - The FermionOperator to be added.
+    /// * `other` - The PlusMinusOperator to be added.
     ///
     /// # Returns
     ///
-    /// * `Self` - The two FermionOperators added together.
+    /// * `Self` - The two PlusMinusOperators added together.
     ///
     /// # Panics
     ///
     /// * Internal error in add_operator_product.
-    fn add(mut self, other: FermionOperator) -> Self {
+    fn add(mut self, other: T) -> Self {
         for (key, value) in other.into_iter() {
-            self.add_operator_product(key, value)
+            self.add_operator_product(key.clone(), Into::<CalculatorComplex>::into(value))
                 .expect("Internal bug in add_operator_product");
         }
         self
     }
 }
 
-/// Implements the minus function of FermionOperator by FermionOperator.
+/// Implements the minus function of PlusMinusOperator by PlusMinusOperator.
 ///
-impl ops::Sub<FermionOperator> for FermionOperator {
+impl<T, V> ops::Sub<T> for PlusMinusOperator
+where
+    T: IntoIterator<Item = (PlusMinusProduct, V)>,
+    V: Into<CalculatorComplex>,
+{
     type Output = Self;
-    /// Implements `-` (subtract) for two FermionOperators.
+    /// Implements `-` (subtract) for two PlusMinusOperators.
     ///
     /// # Arguments
     ///
-    /// * `other` - The FermionOperator to be subtracted.
+    /// * `other` - The PlusMinusOperator to be subtracted.
     ///
     /// # Returns
     ///
-    /// * `Self` - The two FermionOperators subtracted.
+    /// * `Self` - The two PlusMinusOperators subtracted.
     ///
     /// # Panics
     ///
     /// * Internal error in add_operator_product.
-    fn sub(mut self, other: FermionOperator) -> Self {
+    fn sub(mut self, other: T) -> Self {
         for (key, value) in other.into_iter() {
-            self.add_operator_product(key, value * -1.0)
+            self.add_operator_product(key.clone(), Into::<CalculatorComplex>::into(value) * -1.0)
                 .expect("Internal bug in add_operator_product");
         }
         self
     }
 }
 
-/// Implements the multiplication function of FermionOperator by CalculatorComplex/CalculatorFloat.
+/// Implements the multiplication function of PlusMinusOperator by CalculatorComplex/CalculatorFloat.
 ///
-impl<T> ops::Mul<T> for FermionOperator
+impl<T> ops::Mul<T> for PlusMinusOperator
 where
     T: Into<CalculatorComplex>,
 {
     type Output = Self;
-    /// Implement `*` for FermionOperator and CalculatorComplex/CalculatorFloat.
+    /// Implement `*` for PlusMinusOperator and CalculatorComplex/CalculatorFloat.
     ///
     /// # Arguments
     ///
     /// * `other` - The CalculatorComplex or CalculatorFloat by which to multiply.
     ///
     /// # Returns
     ///
-    /// * `Self` - The FermionOperator multiplied by the CalculatorComplex/CalculatorFloat.
+    /// * `Self` - The PlusMinusOperator multiplied by the CalculatorComplex/CalculatorFloat.
     fn mul(self, other: T) -> Self {
         let other_cc = Into::<CalculatorComplex>::into(other);
-        let mut internal = self.internal_map.clone();
-        for key in self.keys() {
-            internal.insert(key.clone(), internal[key].clone() * other_cc.clone());
+        let mut internal = IndexMap::with_capacity(self.len());
+        for (key, val) in self {
+            internal.insert(key, val * other_cc.clone());
         }
-        FermionOperator {
+        PlusMinusOperator {
             internal_map: internal,
         }
     }
 }
 
-/// Implements the multiplication function of FermionOperator by FermionOperator.
+/// Implements the into_iter function (IntoIterator trait) of PlusMinusOperator.
 ///
-impl ops::Mul<FermionOperator> for FermionOperator {
-    type Output = Self;
-    /// Implement `*` for FermionOperator and FermionOperator.
-    ///
-    /// # Arguments
-    ///
-    /// * `other` - The FermionOperator to multiply by.
-    ///
-    /// # Returns
-    ///
-    /// * `Self` - The two FermionOperators multiplied.
-    ///
-    /// # Panics
-    ///
-    /// * Internal error in add_operator_product.
-    fn mul(self, other: FermionOperator) -> Self {
-        let mut op = FermionOperator::with_capacity(self.len() * other.len());
-        for (bps, vals) in self {
-            for (bpo, valo) in other.iter() {
-                let fermion_products = bps.clone() * bpo.clone();
-                let coefficient = Into::<CalculatorComplex>::into(valo) * vals.clone();
-                for (prod, coeff) in fermion_products {
-                    op.add_operator_product(prod, coefficient.clone() * coeff)
-                        .expect("Internal bug in add_operator_product");
-                }
-            }
-        }
-        op
-    }
-}
+impl IntoIterator for PlusMinusOperator {
+    type Item = (PlusMinusProduct, CalculatorComplex);
+    type IntoIter = indexmap::map::IntoIter<PlusMinusProduct, CalculatorComplex>;
 
-/// Implements the into_iter function (IntoIterator trait) of FermionOperator.
-///
-impl IntoIterator for FermionOperator {
-    type Item = (FermionProduct, CalculatorComplex);
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    type IntoIter = std::collections::hash_map::IntoIter<FermionProduct, CalculatorComplex>;
-    #[cfg(feature = "indexed_map_iterators")]
-    type IntoIter = indexmap::map::IntoIter<FermionProduct, CalculatorComplex>;
-    /// Returns the FermionOperator in Iterator form.
+    /// Returns the PlusMinusOperator in Iterator form.
     ///
     /// # Returns
     ///
-    /// * `Self::IntoIter` - The FermionOperator in Iterator form.
+    /// * `Self::IntoIter` - The PlusMinusOperator in Iterator form.
     fn into_iter(self) -> Self::IntoIter {
         self.internal_map.into_iter()
     }
 }
 
-/// Implements the into_iter function (IntoIterator trait) of reference FermionOperator.
+/// Implements the into_iter function (IntoIterator trait) of reference PlusMinusOperator.
 ///
-impl<'a> IntoIterator for &'a FermionOperator {
-    type Item = (&'a FermionProduct, &'a CalculatorComplex);
-    type IntoIter = Iter<'a, FermionProduct, CalculatorComplex>;
+impl<'a> IntoIterator for &'a PlusMinusOperator {
+    type Item = (&'a PlusMinusProduct, &'a CalculatorComplex);
+    type IntoIter = Iter<'a, PlusMinusProduct, CalculatorComplex>;
 
-    /// Returns the reference FermionOperator in Iterator form.
+    /// Returns the reference PlusMinusOperator in Iterator form.
     ///
     /// # Returns
     ///
-    /// * `Self::IntoIter` - The FermionOperator in Iterator form.
+    /// * `Self::IntoIter` - The reference PlusMinusOperator in Iterator form.
     fn into_iter(self) -> Self::IntoIter {
         self.internal_map.iter()
     }
 }
 
-/// Implements the from_iter function (FromIterator trait) of FermionOperator.
+/// Implements the from_iter function (FromIterator trait) of PlusMinusOperator.
 ///
-impl FromIterator<(FermionProduct, CalculatorComplex)> for FermionOperator {
-    /// Returns the object in FermionOperator form, from an Iterator form of the object.
+impl FromIterator<(PlusMinusProduct, CalculatorComplex)> for PlusMinusOperator {
+    /// Returns the object in PlusMinusOperator form, from an Iterator form of the object.
     ///
     /// # Arguments
     ///
-    /// * `iter` - The iterator containing the information from which to create the FermionOperator.
+    /// * `iter` - The iterator containing the information from which to create the PlusMinusOperator.
     ///
     /// # Returns
     ///
-    /// * `Self::IntoIter` - The iterator in FermionOperator form.
+    /// * `Self::IntoIter` - The iterator in PlusMinusOperator form.
     ///
     /// # Panics
     ///
     /// * Internal error in add_operator_product.
-    fn from_iter<I: IntoIterator<Item = (FermionProduct, CalculatorComplex)>>(iter: I) -> Self {
-        let mut so = FermionOperator::new();
+    fn from_iter<I: IntoIterator<Item = (PlusMinusProduct, CalculatorComplex)>>(iter: I) -> Self {
+        let mut so = PlusMinusOperator::new();
         for (pp, cc) in iter {
             so.add_operator_product(pp, cc)
                 .expect("Internal bug in add_operator_product");
         }
         so
     }
 }
 
-/// Implements the extend function (Extend trait) of FermionOperator.
+/// Implements the extend function (Extend trait) of PlusMinusOperator.
 ///
-impl Extend<(FermionProduct, CalculatorComplex)> for FermionOperator {
-    /// Extends the FermionOperator by the specified operations (in Iterator form).
+impl Extend<(PlusMinusProduct, CalculatorComplex)> for PlusMinusOperator {
+    /// Extends the PlusMinusOperator by the specified operations (in Iterator form).
     ///
     /// # Arguments
     ///
-    /// * `iter` - The iterator containing the operations by which to extend the FermionOperator.
+    /// * `iter` - The iterator containing the operations by which to extend the PlusMinusOperator.
     ///
     /// # Panics
     ///
     /// * Internal error in add_operator_product.
-    fn extend<I: IntoIterator<Item = (FermionProduct, CalculatorComplex)>>(&mut self, iter: I) {
+    fn extend<I: IntoIterator<Item = (PlusMinusProduct, CalculatorComplex)>>(&mut self, iter: I) {
         for (pp, cc) in iter {
             self.add_operator_product(pp, cc)
                 .expect("Internal bug in add_operator_product");
         }
     }
 }
 
-/// Implements the format function (Display trait) of FermionOperator.
+/// Implements the format function (Display trait) of PlusMinusOperator.
 ///
-impl fmt::Display for FermionOperator {
-    /// Formats the FermionOperator using the given formatter.
+impl fmt::Display for PlusMinusOperator {
+    /// Formats the PlusMinusOperator using the given formatter.
     ///
     /// # Arguments
     ///
     /// * `f` - The formatter to use.
     ///
     /// # Returns
     ///
-    /// * `std::fmt::Result` - The formatted FermionOperator.
+    /// * `std::fmt::Result` - The formatted PlusMinusOperator.
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        let mut output = "FermionOperator{\n".to_string();
+        let mut output = "PlusMinusOperator{\n".to_string();
         for (key, val) in self.iter() {
             writeln!(output, "{}: {},", key, val)?;
         }
         output.push('}');
 
         write!(f, "{}", output)
     }
 }
 
-impl JordanWignerFermionToSpin for FermionOperator {
-    type Output = SpinOperator;
+impl JordanWignerSpinToFermion for PlusMinusOperator {
+    type Output = FermionOperator;
 
-    /// Implements JordanWignerFermionToSpin for a FermionOperator.
+    /// Implements JordanWignerSpinToFermion for a PlusMinusOperator.
     ///
     /// The convention used is that |0> represents an empty fermionic state (spin-orbital),
     /// and |1> represents an occupied fermionic state.
     ///
     /// # Returns
     ///
-    /// `SpinOperator` - The spin operator that results from the transformation.
+    /// `FermionOperator` - The fermion operator that results from the transformation.
     fn jordan_wigner(&self) -> Self::Output {
-        let mut out = SpinOperator::new();
-        for fp in self.keys() {
-            out = out + fp.jordan_wigner() * self.get(fp);
+        let mut out = FermionOperator::new();
+        for pmp in self.keys() {
+            out = out + pmp.jordan_wigner() * self.get(pmp);
         }
         out
     }
 }
 
 #[cfg(test)]
 mod test {
     use super::*;
     use serde_test::{assert_tokens, Configure, Token};
 
-    // Test the Clone and PartialEq traits of SpinOperator
+    // Test the Clone and PartialEq traits of PlusMinusOperator
     #[test]
     fn so_from_sos() {
-        let pp: FermionProduct = FermionProduct::new([0], [0]).unwrap();
-        let sos = FermionOperatorSerialize {
+        let pp: PlusMinusProduct = PlusMinusProduct::new().z(0);
+        let sos = PlusMinusOperatorSerialize {
             items: vec![(pp.clone(), 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "PlusMinusOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0-alpha.0".to_string(),
             },
         };
-        let mut so = FermionOperator::new();
+        let mut so = PlusMinusOperator::new();
         so.set(pp, CalculatorComplex::from(0.5)).unwrap();
 
-        assert_eq!(FermionOperator::from(sos.clone()), so);
-        assert_eq!(FermionOperatorSerialize::from(so), sos);
+        assert_eq!(PlusMinusOperator::try_from(sos.clone()).unwrap(), so);
+        assert_eq!(PlusMinusOperatorSerialize::from(so), sos);
     }
-    // Test the Clone and PartialEq traits of SpinOperator
+    // Test the Clone and PartialEq traits of PlusMinusOperator
     #[test]
     fn clone_partial_eq() {
-        let pp: FermionProduct = FermionProduct::new([0], [0]).unwrap();
-        let sos = FermionOperatorSerialize {
+        let pp: PlusMinusProduct = PlusMinusProduct::new().z(0);
+        let sos = PlusMinusOperatorSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "PlusMinusOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         // Test Clone trait
         assert_eq!(sos.clone(), sos);
 
         // Test PartialEq trait
-        let pp_1: FermionProduct = FermionProduct::new([0], [0]).unwrap();
-        let sos_1 = FermionOperatorSerialize {
+        let pp_1: PlusMinusProduct = PlusMinusProduct::new().z(0);
+        let sos_1 = PlusMinusOperatorSerialize {
             items: vec![(pp_1, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "PlusMinusOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
-        let pp_2: FermionProduct = FermionProduct::new([1], [0]).unwrap();
-        let sos_2 = FermionOperatorSerialize {
+        let pp_2: PlusMinusProduct = PlusMinusProduct::new().z(2);
+        let sos_2 = PlusMinusOperatorSerialize {
             items: vec![(pp_2, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "PlusMinusOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
         assert!(sos_1 == sos);
         assert!(sos == sos_1);
         assert!(sos_2 != sos);
         assert!(sos != sos_2);
     }
 
-    // Test the Debug trait of SpinOperator
+    // Test the Debug trait of PlusMinusOperator
     #[test]
     fn debug() {
-        let pp: FermionProduct = FermionProduct::new([0], [0]).unwrap();
-        let sos = FermionOperatorSerialize {
+        let pp: PlusMinusProduct = PlusMinusProduct::new().z(0);
+        let sos = PlusMinusOperatorSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "PlusMinusOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_eq!(
             format!("{:?}", sos),
-            "FermionOperatorSerialize { items: [(FermionProduct { creators: [0], annihilators: [0] }, Float(0.5), Float(0.0))], _struqture_version: StruqtureVersionSerializable { major_version: 1, minor_version: 0 } }"
+            "PlusMinusOperatorSerialize { items: [(PlusMinusProduct { items: [(0, Z)] }, Float(0.5), Float(0.0))], serialisation_meta: StruqtureSerialisationMeta { type_name: \"PlusMinusOperator\", min_version: (2, 0, 0), version: \"2.0.0\" } }"
         );
     }
 
-    /// Test SpinOperator Serialization and Deserialization traits (readable)
+    /// Test PlusMinusOperator Serialization and Deserialization traits (readable)
     #[test]
     fn serde_readable() {
-        let pp: FermionProduct = FermionProduct::new([0], [0]).unwrap();
-        let sos = FermionOperatorSerialize {
+        let pp = PlusMinusProduct::new().plus(0);
+        let sos = PlusMinusOperatorSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "PlusMinusOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_tokens(
             &sos.readable(),
             &[
                 Token::Struct {
-                    name: "FermionOperatorSerialize",
+                    name: "PlusMinusOperatorSerialize",
                     len: 2,
                 },
                 Token::Str("items"),
                 Token::Seq { len: Some(1) },
                 Token::Tuple { len: 3 },
-                Token::Str("c0a0"),
+                Token::Str("0+"),
                 Token::F64(0.5),
                 Token::F64(0.0),
                 Token::TupleEnd,
                 Token::SeqEnd,
-                Token::Str("_struqture_version"),
+                Token::Str("serialisation_meta"),
                 Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
                 },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(0),
+                Token::Str("type_name"),
+                Token::Str("PlusMinusOperator"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
                 Token::StructEnd,
                 Token::StructEnd,
             ],
         );
     }
 
-    /// Test SpinOperator Serialization and Deserialization traits (compact)
+    /// Test PlusMinusOperator Serialization and Deserialization traits (compact)
     #[test]
     fn serde_compact() {
-        let pp: FermionProduct = FermionProduct::new([0], [0]).unwrap();
-        let sos = FermionOperatorSerialize {
+        let pp = PlusMinusProduct::new().plus(0);
+        let sos = PlusMinusOperatorSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "PlusMinusOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_tokens(
             &sos.compact(),
             &[
                 Token::Struct {
-                    name: "FermionOperatorSerialize",
+                    name: "PlusMinusOperatorSerialize",
                     len: 2,
                 },
                 Token::Str("items"),
                 Token::Seq { len: Some(1) },
                 Token::Tuple { len: 3 },
-                Token::Tuple { len: 2 },
-                Token::Seq { len: Some(1) },
-                Token::U64(0),
-                Token::SeqEnd,
                 Token::Seq { len: Some(1) },
+                Token::Tuple { len: 2 },
                 Token::U64(0),
-                Token::SeqEnd,
+                Token::UnitVariant {
+                    name: "SinglePlusMinusOperator",
+                    variant: "Plus",
+                },
                 Token::TupleEnd,
+                Token::SeqEnd,
                 Token::NewtypeVariant {
                     name: "CalculatorFloat",
                     variant: "Float",
                 },
                 Token::F64(0.5),
                 Token::NewtypeVariant {
                     name: "CalculatorFloat",
                     variant: "Float",
                 },
                 Token::F64(0.0),
                 Token::TupleEnd,
                 Token::SeqEnd,
-                Token::Str("_struqture_version"),
+                Token::Str("serialisation_meta"),
                 Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
                 },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(0),
+                Token::Str("type_name"),
+                Token::Str("PlusMinusOperator"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
                 Token::StructEnd,
                 Token::StructEnd,
             ],
         );
     }
 }
```

### Comparing `struqture_py-1.6.1/struqture/src/fermions/mod.rs` & `struqture_py-2.0.0a0/struqture/src/fermions/mod.rs`

 * *Files 10% similar despite different names*

```diff
@@ -16,30 +16,24 @@
 //!
 //! In general the enduser should use the high-level [crate::fermions::FermionSystem] and [crate::fermions::FermionHamiltonian] structs
 //! to represent fermionic quantum Operators and fermionic Hamiltonians respectively.
 //!
 //! Open Quantum Systems should be represented using [crate::fermions::FermionLindbladOpenSystem].
 
 mod fermionic_hamiltonian;
-mod fermionic_hamiltonian_system;
 mod fermionic_indices;
 mod fermionic_noise_operator;
-mod fermionic_noise_system;
 mod fermionic_open_system;
 mod fermionic_operator;
-mod fermionic_system;
 use std::str::FromStr;
 
 pub use fermionic_hamiltonian::FermionHamiltonian;
-pub use fermionic_hamiltonian_system::FermionHamiltonianSystem;
 pub use fermionic_noise_operator::FermionLindbladNoiseOperator;
-pub use fermionic_noise_system::FermionLindbladNoiseSystem;
 pub use fermionic_open_system::FermionLindbladOpenSystem;
 pub use fermionic_operator::FermionOperator;
-pub use fermionic_system::FermionSystem;
 
 use crate::{ModeIndex, OperateOnDensityMatrix, SymmetricIndex};
 pub use fermionic_indices::{FermionProduct, HermitianFermionProduct};
 use qoqo_calculator::CalculatorComplex;
 
 /// Signal Trait for specifying that a type can be used a fermionic index.
 ///
```

### Comparing `struqture_py-1.6.1/struqture/src/lib.rs` & `struqture_py-2.0.0a0/struqture/src/lib.rs`

 * *Files 9% similar despite different names*

```diff
@@ -24,16 +24,24 @@
 use std::collections::HashMap;
 use std::fmt::Debug;
 use std::ops::Add;
 use std::ops::Mul;
 use std::ops::Sub;
 use std::str::FromStr;
 use thiserror::Error;
+
+mod serialisation_meta_information;
+pub use serialisation_meta_information::{
+    check_can_be_deserialised, SerializationSupport, StruqtureSerialisationMeta, StruqtureType,
+};
+
 pub const STRUQTURE_VERSION: &str = env!("CARGO_PKG_VERSION");
-pub const MINIMUM_STRUQTURE_VERSION: (u32, u32, u32) = (1, 0, 0);
+// if it should be up
+pub const CURRENT_STRUQTURE_VERSION: (u32, u32, u32) = (2, 0, 0);
+pub const MINIMUM_STRUQTURE_VERSION: (u32, u32, u32) = (2, 0, 0);
 use tinyvec::TinyVec;
 #[derive(
     Clone,
     Copy,
     PartialEq,
     Eq,
     PartialOrd,
@@ -165,16 +173,16 @@
     },
     /// Error when adding a key to an object as the SpinIndex object key already exists.
     #[error("Cannot assign pauli matrix to index {index:?} as it is already occupied")]
     OperatorIndexAlreadyOccupied {
         /// Index that is occupied.
         index: String,
     },
-    /// Error when index of SpinIndex object exceeds that of the Spin(Hamiltonian)System.
-    #[error("Index of SpinIndex object exceeds that of the Spin(Hamiltonian)System")]
+    /// Error when index of SpinIndex object exceeds that of the QubitHamiltonian/QubitOperator.
+    #[error("Index of SpinIndex object exceeds that of the QubitHamiltonian/QubitOperator")]
     NumberSpinsExceeded,
     /// Error when number of spins between system and noise missmatched.
     #[error("Number of spins between system and noise missmatched")]
     MissmatchedNumberSpins,
     /// Error when number of modes between system and noise missmatched.
     #[error("Number of modes between system and noise missmatched")]
     MissmatchedNumberModes,
@@ -233,14 +241,34 @@
         /// Minor version of the library
         library_minor_version: u32,
         /// Major version of the data
         data_major_version: u32,
         /// Minor version of the data
         data_minor_version: u32,
     },
+    #[error("Trying to deserialize a {name_type} with incompatible version of struqture. Library version: {library_major_version}.{library_minor_version} Data version: {data_major_version}.{data_minor_version}.")]
+    NewVersionMissmatch {
+        /// Major version of the library
+        library_major_version: u32,
+        /// Minor version of the library
+        library_minor_version: u32,
+        /// Major version of the data
+        data_major_version: u32,
+        /// Minor version of the data
+        data_minor_version: u32,
+        /// Type of object trying to be deserialized.
+        name_type: String,
+    },
+    #[error("Trying to use a struqture {source_type} object as a struqture {target_type} object. Did you maybe pass the wrong object into a function?")]
+    TypeMissmatch {
+        /// The type of the data that is deserialized.
+        source_type: String,
+        /// The type of the target that the data is supposed to be deserialized to.
+        target_type: String,
+    },
     /// Transparent propagation of CalculatorError.
     #[error(transparent)]
     CalculatorError(#[from] CalculatorError),
     /// Error when trying to insert identities into noise operators
     #[error("Lindblad operators need to be traceless.")]
     InvalidLindbladTerms,
     /// Gerneric Error in struqture.
@@ -297,15 +325,15 @@
     + Default
     + serde::Serialize
 where
     Self::SingleSpinType: Copy,
 {
     /// Type of operators on single spin in a SpinIndex.
     ///
-    /// This can either be a [crate::spins::SingleSpinOperator] (`I`, `X`, `Y` or `Z`)
+    /// This can either be a [crate::spins::SingleQubitOperator] (`I`, `X`, `Y` or `Z`)
     /// or a [crate::spins::SingleOperator/Hamiltonian] (`I`, `X`, `iY` or `Z`)
     type SingleSpinType;
 
     /// Creates a new Self typed object.
     ///
     /// # Returns
     ///
@@ -658,17 +686,17 @@
 /// Trait for all objects that can act on a quantum density matrix like a superoperator.
 ///
 /// # Example
 /// ```
 /// use qoqo_calculator::CalculatorComplex;
 /// use std::collections::HashMap;
 /// use struqture::prelude::*;
-/// use struqture::spins::{OperateOnSpins, PauliProduct, SpinOperator};
+/// use struqture::spins::{OperateOnSpins, PauliProduct, QubitOperator};
 ///
-/// let mut so = SpinOperator::new();
+/// let mut so = QubitOperator::new();
 /// let pp_0z = PauliProduct::new().z(0);
 /// so.add_operator_product(pp_0z.clone(), CalculatorComplex::from(0.2)).unwrap();
 /// let mut mapping: HashMap<PauliProduct, CalculatorComplex> = HashMap::new();
 /// mapping.insert(pp_0z.clone(), CalculatorComplex::from(0.2));
 ///
 /// // Functions provided in this :
 /// assert_eq!(so.get(&pp_0z), &CalculatorComplex::from(0.2));
@@ -702,23 +730,20 @@
     Self: 'a,
     &'a Self: IntoIterator,
     Self::Index: Clone,
     Self::Value: Mul<f64, Output = Self::Value>,
     Self::Value: Add<Self::Value, Output = Self::Value>,
     Self::Value: Clone,
     Self::Value: TruncateTrait,
-    Self::IteratorType: ExactSizeIterator<Item = (&'a Self::Index, &'a Self::Value)>,
-    Self::KeyIteratorType: ExactSizeIterator<Item = &'a Self::Index>,
-    Self::ValueIteratorType: ExactSizeIterator<Item = &'a Self::Value>,
 {
     type Index;
     type Value;
-    type IteratorType;
-    type KeyIteratorType;
-    type ValueIteratorType;
+    // type IteratorType; // can be removed (and two below) + in where clause
+    // type KeyIteratorType;
+    // type ValueIteratorType;
 
     /// Gets the Self::Value typed coefficient corresponding to the key.
     ///
     /// # Arguments
     ///
     /// * `key` - The Self::Index key for which to retrieve the value.
     ///
@@ -728,29 +753,29 @@
     fn get(&self, key: &Self::Index) -> &Self::Value;
 
     /// Returns the iterator form of Self.
     ///
     /// # Returns
     ///
     /// * `Iter<'_, Self::Index, Self::Value>` - Self in iterator form.
-    fn iter(&'a self) -> Self::IteratorType;
+    fn iter(&'a self) -> impl ExactSizeIterator<Item = (&'a Self::Index, &'a Self::Value)>;
 
     /// Returns the unsorted keys in Self.
     ///
     /// # Returns
     ///
     /// * `Keys<'_, Self::Index, Self::Value>` - The sequence of keys of Self.
-    fn keys(&'a self) -> Self::KeyIteratorType;
+    fn keys(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Index>; // use this here instead impl ExactSizeIterator + Iterator<Item = &'a <Self as OperateOnDensityMatrix<'a>>::Index>
 
     /// Returns the unsorted values in Self.
     ///
     /// # Returns
     ///
     /// * `Values<'_, Self::Index, Self::Value>` - The sequence of values of Self.
-    fn values(&'a self) -> Self::ValueIteratorType;
+    fn values(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Value>;
 
     /// Returns number of entries in object.
     ///
     /// # Returns
     ///
     /// * `usize` - The length of the object's internal_map.
     fn len(&'a self) -> usize {
@@ -844,57 +869,42 @@
     <<Self as OpenSystem<'a>>::System as OperateOnDensityMatrix<'a>>::Value: Add<
         <<Self as OpenSystem<'a>>::System as OperateOnDensityMatrix<'a>>::Value,
         Output = <<Self as OpenSystem<'a>>::System as OperateOnDensityMatrix<'a>>::Value,
     >,
     <<Self as OpenSystem<'a>>::System as OperateOnDensityMatrix<'a>>::Value: Clone,
     <<Self as OpenSystem<'a>>::System as OperateOnDensityMatrix<'a>>::Value: TruncateTrait,
     <<Self as OpenSystem<'a>>::System as OperateOnDensityMatrix<'a>>::Value: ConjugationTrait,
-    <<Self as OpenSystem<'a>>::System as OperateOnDensityMatrix<'a>>::IteratorType:
-        ExactSizeIterator<
-            Item = (
-                &'a <<Self as OpenSystem<'a>>::System as OperateOnDensityMatrix<'a>>::Index,
-                &'a <<Self as OpenSystem<'a>>::System as OperateOnDensityMatrix<'a>>::Value,
-            ),
-        >,
-    <<Self as OpenSystem<'a>>::System as OperateOnDensityMatrix<'a>>::KeyIteratorType:
-        ExactSizeIterator<
-            Item = &'a <<Self as OpenSystem<'a>>::System as OperateOnDensityMatrix<'a>>::Index,
-        >,
-    <<Self as OpenSystem<'a>>::System as OperateOnDensityMatrix<'a>>::ValueIteratorType:
-        ExactSizeIterator<
-            Item = &'a <<Self as OpenSystem<'a>>::System as OperateOnDensityMatrix<'a>>::Value,
-        >,
+    // <<Self as OpenSystem<'a>>::System as OperateOnDensityMatrix<'a>>::IteratorType:
+    //     ExactSizeIterator<
+    //         Item = (
+    //             &'a <<Self as OpenSystem<'a>>::System as OperateOnDensityMatrix<'a>>::Index,
+    //             &'a <<Self as OpenSystem<'a>>::System as OperateOnDensityMatrix<'a>>::Value,
+    //         ),
+    //     >,
+    // <<Self as OpenSystem<'a>>::System as OperateOnDensityMatrix<'a>>::KeyIteratorType:
+    //     ExactSizeIterator<
+    //         Item = &'a <<Self as OpenSystem<'a>>::System as OperateOnDensityMatrix<'a>>::Index,
+    //     >,
+    // <<Self as OpenSystem<'a>>::System as OperateOnDensityMatrix<'a>>::ValueIteratorType:
+    //     ExactSizeIterator<
+    //         Item = &'a <<Self as OpenSystem<'a>>::System as OperateOnDensityMatrix<'a>>::Value,
+    //     >,
     Self::Noise: OperateOnDensityMatrix<'a>,
     Self::Noise: 'a,
     &'a Self::Noise: IntoIterator,
     <<Self as OpenSystem<'a>>::Noise as OperateOnDensityMatrix<'a>>::Index: Clone,
     <<Self as OpenSystem<'a>>::Noise as OperateOnDensityMatrix<'a>>::Value:
         Mul<f64, Output = <<Self as OpenSystem<'a>>::Noise as OperateOnDensityMatrix<'a>>::Value>,
     <<Self as OpenSystem<'a>>::Noise as OperateOnDensityMatrix<'a>>::Value: Add<
         <<Self as OpenSystem<'a>>::Noise as OperateOnDensityMatrix<'a>>::Value,
         Output = <<Self as OpenSystem<'a>>::Noise as OperateOnDensityMatrix<'a>>::Value,
     >,
     <<Self as OpenSystem<'a>>::Noise as OperateOnDensityMatrix<'a>>::Value: Clone,
     <<Self as OpenSystem<'a>>::Noise as OperateOnDensityMatrix<'a>>::Value: TruncateTrait,
     <<Self as OpenSystem<'a>>::Noise as OperateOnDensityMatrix<'a>>::Value: ConjugationTrait,
-    <<Self as OpenSystem<'a>>::Noise as OperateOnDensityMatrix<'a>>::IteratorType:
-        ExactSizeIterator<
-            Item = (
-                &'a <<Self as OpenSystem<'a>>::Noise as OperateOnDensityMatrix<'a>>::Index,
-                &'a <<Self as OpenSystem<'a>>::Noise as OperateOnDensityMatrix<'a>>::Value,
-            ),
-        >,
-    <<Self as OpenSystem<'a>>::Noise as OperateOnDensityMatrix<'a>>::KeyIteratorType:
-        ExactSizeIterator<
-            Item = &'a <<Self as OpenSystem<'a>>::Noise as OperateOnDensityMatrix<'a>>::Index,
-        >,
-    <<Self as OpenSystem<'a>>::Noise as OperateOnDensityMatrix<'a>>::ValueIteratorType:
-        ExactSizeIterator<
-            Item = &'a <<Self as OpenSystem<'a>>::Noise as OperateOnDensityMatrix<'a>>::Value,
-        >,
 {
     type System;
     type Noise;
 
     /// Returns the Self::Noise of the OpenSystem object.
     ///
     /// # Returns
@@ -968,17 +978,17 @@
 /// Trait for all objects that can act on a quantum state like an operator.
 ///
 /// # Example
 /// ```
 /// use qoqo_calculator::CalculatorComplex;
 /// use std::collections::HashMap;
 /// use struqture::prelude::*;
-/// use struqture::spins::{OperateOnSpins, PauliProduct, SpinOperator};
+/// use struqture::spins::{OperateOnSpins, PauliProduct, QubitOperator};
 ///
-/// let mut so = SpinOperator::new();
+/// let mut so = QubitOperator::new();
 /// let pp_0z = PauliProduct::new().z(0);
 /// so.add_operator_product(pp_0z.clone(), CalculatorComplex::from(0.2)).unwrap();
 ///
 /// // Functions provided in this :
 /// assert_eq!(so.hermitian_conjugate(), so);
 /// ```
 ///
@@ -999,17 +1009,14 @@
     Self::Index: Clone,
     Self::Index: SymmetricIndex,
     Self::Value: Mul<f64, Output = Self::Value>,
     Self::Value: Add<Self::Value, Output = Self::Value>,
     Self::Value: Clone,
     Self::Value: TruncateTrait,
     Self::Value: ConjugationTrait,
-    Self::IteratorType: ExactSizeIterator<Item = (&'a Self::Index, &'a Self::Value)>,
-    Self::KeyIteratorType: ExactSizeIterator<Item = &'a Self::Index>,
-    Self::ValueIteratorType: ExactSizeIterator<Item = &'a Self::Value>,
 {
     /// Returns the hermitian conjugate of Self.
     ///
     /// # Returns
     ///
     /// * `Self` - The hermitian conjugate of Self.
     fn hermitian_conjugate(&'a self) -> Self {
@@ -1031,33 +1038,24 @@
 /// use std::collections::HashMap;
 /// use struqture::bosons::{HermitianBosonProduct, BosonHamiltonian};
 ///
 /// let mut sh = BosonHamiltonian::new();
 ///
 /// // Functions provided in this :
 /// assert_eq!(sh.current_number_modes(), 0);
-/// assert_eq!(sh.number_modes(), 0);
 ///
 /// let pp_0z = HermitianBosonProduct::new([0], [0]).unwrap();
 /// sh.add_operator_product(pp_0z.clone(), CalculatorComplex::from(0.2)).unwrap();
 ///
 /// assert_eq!(sh.current_number_modes(), 1);
-/// assert_eq!(sh.number_modes(), 1);
 /// ```
 ///
 pub trait OperateOnModes<'a>: PartialEq + Clone + Mul<CalculatorFloat> + Add + Sub {
-    /// Return maximum index in Self.
-    ///
-    /// # Returns
-    ///
-    /// * `usize` - Maximum index.
-    fn current_number_modes(&'a self) -> usize;
-
     // Document locally
-    fn number_modes(&'a self) -> usize;
+    fn current_number_modes(&'a self) -> usize;
 }
 
 /// Shorthand type notation for a tuple of lists of indices of creators and annihilators
 type CreatorsAnnihilators = (TinyVec<[usize; 2]>, TinyVec<[usize; 2]>);
 
 pub mod bosons;
 pub mod fermions;
@@ -1065,18 +1063,7 @@
 pub mod mixed_systems;
 pub mod prelude;
 pub mod spins;
 
 /// Shorhand type for TinyVec representation of creators or annihilators
 #[cfg(test)]
 type ModeTinyVec = TinyVec<[usize; 2]>;
-
-/// Trait for implementing a function to determine the minimum supported version of struqture required.
-pub trait MinSupportedVersion {
-    /// Returns the minimum version of struqture required to deserialize this object.
-    ///
-    /// # Returns
-    /// (majon_verision, minor_version, patch_version)
-    fn min_supported_version() -> (usize, usize, usize) {
-        (1, 0, 0)
-    }
-}
```

### Comparing `struqture_py-1.6.1/struqture/src/mappings/jordan_wigner.rs` & `struqture_py-2.0.0a0/struqture/src/mappings/jordan_wigner.rs`

 * *Files 11% similar despite different names*

```diff
@@ -17,31 +17,31 @@
 //!
 //! JW(a_p^{dagger}) = ( \prod_{i = 1}^{p - 1} Z_i )(X_p - i Y_p)*1/2
 //! JW(a_p) = ( \prod_{i = 1}^{p - 1} Z_i )(X_p + i Y_p)*1/2
 
 pub trait JordanWignerFermionToSpin {
     /// The Output type for the JordanWigner transformation
     ///
-    /// For a FermionProduct, HermitianFermionProduct or FermionOperator it will be a SpinOperator
-    /// For a FermionHamiltonian it will be a SpinHamiltonian
-    /// For a FermionLindbladNoiseOperator it will be a SpinLindbladNoiseOperator
-    /// For a FermionLindbladOpenSystem it will be a SpinLindbladOpenSystem etc.
+    /// For a FermionProduct, HermitianFermionProduct or FermionOperator it will be a QubitOperator
+    /// For a FermionHamiltonian it will be a QubitHamiltonian
+    /// For a FermionLindbladNoiseOperator it will be a QubitLindbladNoiseOperator
+    /// For a FermionLindbladOpenSystem it will be a QubitLindbladOpenSystem etc.
     type Output;
 
     /// Transform the given fermionic object into a spin object using
     /// the Jordan Wigner mapping.
     fn jordan_wigner(&self) -> Self::Output;
 }
 
 pub trait JordanWignerSpinToFermion {
     /// The Output type for the JordanWigner transformation
     ///
-    /// For a PauliProduct, SpinOperator or PlusMinusOperator it will be a FermionOperator
-    /// For a SpinHamiltonian it will be a FermionHamiltonian
-    /// For a SpinLindbladNoiseOperator it will be a FermionLindbladNoiseOperator
-    /// For a SpinLindbladOpenSystem it will be a FermionLindbladOpenSystem
+    /// For a PauliProduct, QubitOperator or PlusMinusOperator it will be a FermionOperator
+    /// For a QubitHamiltonian it will be a FermionHamiltonian
+    /// For a QubitLindbladNoiseOperator it will be a FermionLindbladNoiseOperator
+    /// For a QubitLindbladOpenSystem it will be a FermionLindbladOpenSystem
     type Output;
 
     /// Transform the given spin object into a fermionic object using
     /// the Jordan Wigner mapping.
     fn jordan_wigner(&self) -> Self::Output;
 }
```

### Comparing `struqture_py-1.6.1/struqture/src/mappings/mod.rs` & `struqture_py-2.0.0a0/struqture/src/mappings/mod.rs`

 * *Files identical despite different names*

### Comparing `struqture_py-1.6.1/struqture/src/mixed_systems/mixed_decoherence_product.rs` & `struqture_py-2.0.0a0/struqture/src/mixed_systems/mixed_decoherence_product.rs`

 * *Files 10% similar despite different names*

```diff
@@ -70,15 +70,19 @@
         let meta = obj.metadata();
         meta.description = Some("Represents products of Spin operators and Bosonic and Fermionic creators and annhilators by a string. Spin Operators  X, iY and Z are preceeded and creators (c) and annihilators (a) are followed by the modes they are acting on. E.g. :S0X1iY:Bc0a0:Fc0a0:.".to_string());
 
         schemars::schema::Schema::Object(obj)
     }
 }
 
-impl crate::MinSupportedVersion for MixedDecoherenceProduct {}
+impl crate::SerializationSupport for MixedDecoherenceProduct {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::MixedDecoherenceProduct
+    }
+}
 
 impl Serialize for MixedDecoherenceProduct {
     /// Serialization function for MixedDecoherenceProduct according to string type.
     ///
     /// # Arguments
     ///
     /// * `self` - MixedDecoherenceProduct to be serialized.
@@ -196,14 +200,41 @@
             let pp_visitor = MixedDecoherenceProductVisitor;
 
             deserializer.deserialize_tuple(3, pp_visitor)
         }
     }
 }
 
+impl MixedDecoherenceProduct {
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(
+        &self,
+    ) -> Result<struqture_one::mixed_systems::MixedDecoherenceProduct, StruqtureError> {
+        let self_string = self.to_string();
+        let struqture_one_product =
+            struqture_one::mixed_systems::MixedDecoherenceProduct::from_str(&self_string).map_err(
+                |err| StruqtureError::GenericError {
+                    msg: format!("{}", err),
+                },
+            )?;
+        Ok(struqture_one_product)
+    }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::mixed_systems::MixedDecoherenceProduct,
+    ) -> Result<Self, StruqtureError> {
+        let value_string = value.to_string();
+        let pauli_product = Self::from_str(&value_string)?;
+        Ok(pauli_product)
+    }
+}
+
 impl MixedIndex for MixedDecoherenceProduct {
     type BosonicIndexType = BosonProduct;
     type SpinIndexType = DecoherenceProduct;
     type FermionicIndexType = FermionProduct;
 
     /// Creates a new MixedDecoherenceProduct.
     ///
```

### Comparing `struqture_py-1.6.1/struqture/src/mixed_systems/mixed_hamiltonian.rs` & `struqture_py-2.0.0a0/struqture/src/mixed_systems/mixed_hamiltonian.rs`

 * *Files 17% similar despite different names*

```diff
@@ -6,33 +6,29 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
-use super::{HermitianMixedProduct, MixedIndex, MixedOperator, OperateOnMixedSystems};
+use super::{
+    HermitianMixedProduct, HermitianOperateOnMixedSystems, MixedIndex, MixedOperator,
+    OperateOnMixedSystems,
+};
 use crate::{
-    ModeIndex, OperateOnDensityMatrix, OperateOnState, SpinIndex, StruqtureError,
-    StruqtureVersionSerializable, SymmetricIndex, MINIMUM_STRUQTURE_VERSION,
+    ModeIndex, OperateOnDensityMatrix, OperateOnState, SpinIndex, StruqtureError, SymmetricIndex,
 };
 use qoqo_calculator::{CalculatorComplex, CalculatorFloat};
 use serde::{Deserialize, Serialize};
 use std::fmt::{self, Write};
 use std::iter::{FromIterator, IntoIterator};
 use std::ops;
 
-#[cfg(feature = "indexed_map_iterators")]
-use indexmap::map::{Entry, Iter, Keys, Values};
-#[cfg(feature = "indexed_map_iterators")]
+use indexmap::map::{Entry, Iter};
 use indexmap::IndexMap;
-#[cfg(not(feature = "indexed_map_iterators"))]
-use std::collections::hash_map::{Entry, Iter, Keys, Values};
-#[cfg(not(feature = "indexed_map_iterators"))]
-use std::collections::HashMap;
 
 /// MixedHamiltonians are combinations of HermitianMixedProducts with specific CalculatorComplex coefficients.
 ///
 /// This is a representation of sums of Pauli products with weightings in order to build a full Hamiltonian.
 ///
 /// # Example
 ///
@@ -53,31 +49,32 @@
 ///
 /// // Access what you set:
 /// assert_eq!(sh.get(&pp_1), &CalculatorComplex::from(0.5));
 /// assert_eq!(sh.get(&pp_0), &CalculatorComplex::from(0.2));
 /// ```
 ///
 #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
-#[serde(from = "MixedHamiltonianSerialize")]
+#[serde(try_from = "MixedHamiltonianSerialize")]
 #[serde(into = "MixedHamiltonianSerialize")]
 pub struct MixedHamiltonian {
     /// The internal HashMap of HermitianMixedProducts and coefficients (CalculatorFloat)
-    #[cfg(feature = "indexed_map_iterators")]
     internal_map: IndexMap<HermitianMixedProduct, CalculatorComplex>,
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    internal_map: HashMap<HermitianMixedProduct, CalculatorComplex>,
     /// Number of Spin subsystems
-    n_spins: usize,
+    pub(crate) n_spins: usize,
     /// Number of Boson subsystems
-    n_bosons: usize,
+    pub(crate) n_bosons: usize,
     /// Number of Fermion subsystems
-    n_fermions: usize,
+    pub(crate) n_fermions: usize,
 }
 
-impl crate::MinSupportedVersion for MixedHamiltonian {}
+impl crate::SerializationSupport for MixedHamiltonian {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::MixedHamiltonian
+    }
+}
 
 #[cfg(feature = "json_schema")]
 impl schemars::JsonSchema for MixedHamiltonian {
     fn schema_name() -> String {
         "MixedHamiltonian".to_string()
     }
 
@@ -90,92 +87,83 @@
 #[cfg_attr(feature = "json_schema", derive(schemars::JsonSchema))]
 #[cfg_attr(feature = "json_schema", schemars(deny_unknown_fields))]
 struct MixedHamiltonianSerialize {
     items: Vec<(HermitianMixedProduct, CalculatorFloat, CalculatorFloat)>,
     n_spins: usize,
     n_bosons: usize,
     n_fermions: usize,
-    _struqture_version: StruqtureVersionSerializable,
+    serialisation_meta: crate::StruqtureSerialisationMeta,
 }
 
-impl From<MixedHamiltonianSerialize> for MixedHamiltonian {
-    fn from(value: MixedHamiltonianSerialize) -> Self {
+impl TryFrom<MixedHamiltonianSerialize> for MixedHamiltonian {
+    type Error = StruqtureError;
+    fn try_from(value: MixedHamiltonianSerialize) -> Result<Self, Self::Error> {
+        let target_serialisation_meta =
+            <Self as crate::SerializationSupport>::target_serialisation_meta();
+        crate::check_can_be_deserialised(&target_serialisation_meta, &value.serialisation_meta)?;
         let mut new_noise_op =
             MixedHamiltonian::new(value.n_spins, value.n_bosons, value.n_fermions);
         for (key, real, imag) in value.items.iter() {
             let _ =
                 new_noise_op.add_operator_product(key.clone(), CalculatorComplex::new(real, imag));
         }
-        new_noise_op
+        Ok(new_noise_op)
     }
 }
 
 impl From<MixedHamiltonian> for MixedHamiltonianSerialize {
     fn from(value: MixedHamiltonian) -> Self {
+        let serialisation_meta = crate::SerializationSupport::struqture_serialisation_meta(&value);
         let new_noise_op: Vec<(HermitianMixedProduct, CalculatorFloat, CalculatorFloat)> = value
             .clone()
             .into_iter()
             .map(|(key, val)| (key, val.re, val.im))
             .collect();
-        let current_version = StruqtureVersionSerializable {
-            major_version: MINIMUM_STRUQTURE_VERSION.0,
-            minor_version: MINIMUM_STRUQTURE_VERSION.1,
-        };
         Self {
             items: new_noise_op,
             n_spins: value.n_spins,
             n_bosons: value.n_bosons,
             n_fermions: value.n_fermions,
-            _struqture_version: current_version,
+            serialisation_meta,
         }
     }
 }
 
 impl<'a> OperateOnDensityMatrix<'a> for MixedHamiltonian {
     type Index = HermitianMixedProduct;
     type Value = CalculatorComplex;
-    type IteratorType = Iter<'a, Self::Index, Self::Value>;
-    type KeyIteratorType = Keys<'a, Self::Index, Self::Value>;
-    type ValueIteratorType = Values<'a, Self::Index, Self::Value>;
 
     // From trait
     fn get(&self, key: &Self::Index) -> &Self::Value {
         match self.internal_map.get(key) {
             Some(value) => value,
             None => &CalculatorComplex::ZERO,
         }
     }
 
     // From trait
-    fn iter(&'a self) -> Self::IteratorType {
+    fn iter(&'a self) -> impl ExactSizeIterator<Item = (&'a Self::Index, &'a Self::Value)> {
         self.internal_map.iter()
     }
 
     // From trait
-    fn keys(&'a self) -> Self::KeyIteratorType {
+    fn keys(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Index> {
         self.internal_map.keys()
     }
 
     // From trait
-    fn values(&'a self) -> Self::ValueIteratorType {
+    fn values(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Value> {
         self.internal_map.values()
     }
 
-    #[cfg(feature = "indexed_map_iterators")]
     // From trait
     fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
         self.internal_map.shift_remove(key)
     }
 
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    // From trait
-    fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
-        self.internal_map.remove(key)
-    }
-
     // From trait
     fn empty_clone(&self, capacity: Option<usize>) -> Self {
         match capacity {
             Some(cap) => Self::with_capacity(self.n_spins, self.n_bosons, self.n_fermions, cap),
             None => Self::new(self.n_spins, self.n_bosons, self.n_fermions),
         }
     }
@@ -216,54 +204,43 @@
             if key.is_natural_hermitian() && value.im != CalculatorFloat::ZERO {
                 Err(StruqtureError::NonHermitianOperator)
             } else {
                 Ok(self.internal_map.insert(key, value))
             }
         } else {
             match self.internal_map.entry(key) {
-                #[cfg(feature = "indexed_map_iterators")]
                 Entry::Occupied(val) => Ok(Some(val.shift_remove())),
-                #[cfg(not(feature = "indexed_map_iterators"))]
-                Entry::Occupied(val) => Ok(Some(val.remove())),
                 Entry::Vacant(_) => Ok(None),
             }
         }
     }
 }
 
 impl<'a> OperateOnState<'a> for MixedHamiltonian {
     // From trait
     fn hermitian_conjugate(&self) -> Self {
         self.clone()
     }
 }
 
-impl<'a> OperateOnMixedSystems<'a> for MixedHamiltonian {
-    // From trait
-    fn number_spins(&self) -> Vec<usize> {
-        self.current_number_spins()
-    }
+impl<'a> HermitianOperateOnMixedSystems<'a> for MixedHamiltonian {}
 
+impl<'a> OperateOnMixedSystems<'a> for MixedHamiltonian {
     // From trait
     fn current_number_spins(&self) -> Vec<usize> {
-        let mut number_spins: Vec<usize> = (0..self.n_spins).map(|_| 0).collect();
+        let mut current_number_spins: Vec<usize> = (0..self.n_spins).map(|_| 0).collect();
         for key in self.keys() {
             for (index, s) in key.spins().enumerate() {
                 let maxk = s.current_number_spins();
-                if maxk > number_spins[index] {
-                    number_spins[index] = maxk
+                if maxk > current_number_spins[index] {
+                    current_number_spins[index] = maxk
                 }
             }
         }
-        number_spins
-    }
-
-    // From trait
-    fn number_bosonic_modes(&self) -> Vec<usize> {
-        self.current_number_bosonic_modes()
+        current_number_spins
     }
 
     // From trait
     fn current_number_bosonic_modes(&self) -> Vec<usize> {
         let mut number_bosons: Vec<usize> = (0..self.n_bosons).map(|_| 0).collect();
         for key in self.keys() {
             for (index, s) in key.bosons().enumerate() {
@@ -273,19 +250,14 @@
                 }
             }
         }
         number_bosons
     }
 
     // From trait
-    fn number_fermionic_modes(&self) -> Vec<usize> {
-        self.current_number_fermionic_modes()
-    }
-
-    // From trait
     fn current_number_fermionic_modes(&self) -> Vec<usize> {
         let mut number_fermions: Vec<usize> = (0..self.n_fermions).map(|_| 0).collect();
         for key in self.keys() {
             for (index, s) in key.fermions().enumerate() {
                 let maxk = s.current_number_modes();
                 if maxk > number_fermions[index] {
                     number_fermions[index] = maxk
@@ -316,17 +288,14 @@
     /// * `n_fermions` - Number of fermionic sub-systems
     ///
     /// # Returns
     ///
     /// * `Self` - The new (empty) MixedHamiltonian.
     pub fn new(n_spins: usize, n_bosons: usize, n_fermions: usize) -> Self {
         MixedHamiltonian {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::new(),
-            #[cfg(feature = "indexed_map_iterators")]
             internal_map: IndexMap::new(),
             n_spins,
             n_bosons,
             n_fermions,
         }
     }
 
@@ -345,53 +314,64 @@
     pub fn with_capacity(
         n_spins: usize,
         n_bosons: usize,
         n_fermions: usize,
         capacity: usize,
     ) -> Self {
         Self {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::with_capacity(capacity),
-            #[cfg(feature = "indexed_map_iterators")]
             internal_map: IndexMap::with_capacity(capacity),
             n_spins,
             n_bosons,
             n_fermions,
         }
     }
 
-    // /// Separate self into an operator with the terms of given number of spins, bosons and fermions and an operator with the remaining operations
-    // ///
-    // /// # Arguments
-    // ///
-    // /// * `number_particles` - Number of spins, bosons and fermions to filter for in the keys.
-    // ///
-    // /// # Returns
-    // ///
-    // /// `Ok((separated, remainder))` - Operator with the noise terms where number_particles matches the number of spins the operator product acts on and Operator with all other contributions.
-    // pub fn separate_into_n_terms(
-    //     &self,
-    //     number_particles: (usize, usize, usize),
-    // ) -> Result<(Self, Self), StruqtureError> {
-    //     let mut separated = Self::default();
-    //     let mut remainder = Self::default();
-    //     for (prod, val) in self.iter() {
-    //         if (
-    //             prod.spins().len(),
-    //             prod.bosons().len(),
-    //             prod.fermions().len(),
-    //         ) == number_particles
-    //         {
-    //             separated.add_operator_product(prod.clone(), val.clone())?;
-    //         } else {
-    //             remainder.add_operator_product(prod.clone(), val.clone())?;
-    //         }
-    //     }
-    //     Ok((separated, remainder))
-    // }
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(
+        &self,
+    ) -> Result<struqture_one::mixed_systems::MixedHamiltonianSystem, StruqtureError> {
+        let mut new_mixed_system = struqture_one::mixed_systems::MixedHamiltonianSystem::new(
+            vec![None; self.n_spins],
+            vec![None; self.n_bosons],
+            vec![None; self.n_fermions],
+        );
+        for (key, val) in self.iter() {
+            let one_key = key.to_struqture_1()?;
+            let _ = struqture_one::OperateOnDensityMatrix::set(
+                &mut new_mixed_system,
+                one_key,
+                val.clone(),
+            );
+        }
+        Ok(new_mixed_system)
+    }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::mixed_systems::MixedHamiltonianSystem,
+    ) -> Result<Self, StruqtureError> {
+        let mut new_qubit_operator = Self::new(
+            struqture_one::mixed_systems::OperateOnMixedSystems::current_number_spins(value).len(),
+            struqture_one::mixed_systems::OperateOnMixedSystems::current_number_bosonic_modes(
+                value,
+            )
+            .len(),
+            struqture_one::mixed_systems::OperateOnMixedSystems::current_number_fermionic_modes(
+                value,
+            )
+            .len(),
+        );
+        for (key, val) in struqture_one::OperateOnDensityMatrix::iter(value) {
+            let self_key = HermitianMixedProduct::from_struqture_1(key)?;
+            let _ = new_qubit_operator.set(self_key, val.clone());
+        }
+        Ok(new_qubit_operator)
+    }
 }
 
 /// Implements the negative sign function of MixedHamiltonian.
 ///
 impl ops::Neg for MixedHamiltonian {
     type Output = MixedHamiltonian;
     /// Implement minus sign for MixedHamiltonian.
@@ -539,17 +519,14 @@
     }
 }
 
 /// Implements the into_iter function (IntoIterator trait) of MixedHamiltonian.
 ///
 impl IntoIterator for MixedHamiltonian {
     type Item = (HermitianMixedProduct, CalculatorComplex);
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    type IntoIter = std::collections::hash_map::IntoIter<HermitianMixedProduct, CalculatorComplex>;
-    #[cfg(feature = "indexed_map_iterators")]
     type IntoIter = indexmap::map::IntoIter<HermitianMixedProduct, CalculatorComplex>;
     /// Returns the MixedHamiltonian in Iterator form.
     ///
     /// # Returns
     ///
     /// * `Self::IntoIter` - The MixedHamiltonian in Iterator form.
     fn into_iter(self) -> Self::IntoIter {
@@ -663,56 +640,58 @@
 mod test {
     use super::*;
     use crate::bosons::BosonProduct;
     use crate::fermions::FermionProduct;
     use crate::spins::PauliProduct;
     use serde_test::{assert_tokens, Configure, Token};
 
-    // Test the Clone and PartialEq traits of SpinOperator
+    // Test the Clone and PartialEq traits of QubitOperator
     #[test]
     fn so_from_sos() {
         let pp: HermitianMixedProduct = HermitianMixedProduct::new(
             [PauliProduct::new().z(2)],
             [BosonProduct::new([0], [3]).unwrap()],
             [FermionProduct::new([0], [2]).unwrap()],
         )
         .unwrap();
         let sos = MixedHamiltonianSerialize {
             items: vec![(pp.clone(), 0.5.into(), 0.0.into())],
             n_spins: 1,
             n_bosons: 1,
             n_fermions: 1,
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0-alpha.0".to_string(),
             },
         };
         let mut so = MixedHamiltonian::new(1, 1, 1);
         so.set(pp, CalculatorComplex::from(0.5)).unwrap();
 
-        assert_eq!(MixedHamiltonian::from(sos.clone()), so);
+        assert_eq!(MixedHamiltonian::try_from(sos.clone()).unwrap(), so);
         assert_eq!(MixedHamiltonianSerialize::from(so), sos);
     }
-    // Test the Clone and PartialEq traits of SpinOperator
+    // Test the Clone and PartialEq traits of QubitOperator
     #[test]
     fn clone_partial_eq() {
         let pp: HermitianMixedProduct = HermitianMixedProduct::new(
             [PauliProduct::new().z(2)],
             [BosonProduct::new([0], [3]).unwrap()],
             [FermionProduct::new([0], [2]).unwrap()],
         )
         .unwrap();
         let sos = MixedHamiltonianSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
             n_spins: 1,
             n_bosons: 1,
             n_fermions: 1,
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         // Test Clone trait
         assert_eq!(sos.clone(), sos);
 
         // Test PartialEq trait
@@ -723,84 +702,88 @@
         )
         .unwrap();
         let sos_1 = MixedHamiltonianSerialize {
             items: vec![(pp_1, 0.5.into(), 0.0.into())],
             n_spins: 1,
             n_bosons: 1,
             n_fermions: 1,
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
         let pp_2: HermitianMixedProduct = HermitianMixedProduct::new(
             [PauliProduct::new().z(0)],
             [BosonProduct::new([0], [3]).unwrap()],
             [FermionProduct::new([0], [2]).unwrap()],
         )
         .unwrap();
         let sos_2 = MixedHamiltonianSerialize {
             items: vec![(pp_2, 0.5.into(), 0.0.into())],
             n_spins: 1,
             n_bosons: 1,
             n_fermions: 1,
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
         assert!(sos_1 == sos);
         assert!(sos == sos_1);
         assert!(sos_2 != sos);
         assert!(sos != sos_2);
     }
 
-    // Test the Debug trait of SpinOperator
+    // Test the Debug trait of QubitOperator
     #[test]
     fn debug() {
         let pp: HermitianMixedProduct = HermitianMixedProduct::new(
             [PauliProduct::new().z(2)],
             [BosonProduct::new([0], [3]).unwrap()],
             [FermionProduct::new([0], [2]).unwrap()],
         )
         .unwrap();
         let sos = MixedHamiltonianSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
             n_spins: 1,
             n_bosons: 1,
             n_fermions: 1,
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_eq!(
             format!("{:?}", sos),
-            "MixedHamiltonianSerialize { items: [(HermitianMixedProduct { spins: [PauliProduct { items: [(2, Z)] }], bosons: [BosonProduct { creators: [0], annihilators: [3] }], fermions: [FermionProduct { creators: [0], annihilators: [2] }] }, Float(0.5), Float(0.0))], n_spins: 1, n_bosons: 1, n_fermions: 1, _struqture_version: StruqtureVersionSerializable { major_version: 1, minor_version: 0 } }"
+            "MixedHamiltonianSerialize { items: [(HermitianMixedProduct { spins: [PauliProduct { items: [(2, Z)] }], bosons: [BosonProduct { creators: [0], annihilators: [3] }], fermions: [FermionProduct { creators: [0], annihilators: [2] }] }, Float(0.5), Float(0.0))], n_spins: 1, n_bosons: 1, n_fermions: 1, serialisation_meta: StruqtureSerialisationMeta { type_name: \"MixedHamiltonian\", min_version: (2, 0, 0), version: \"2.0.0\" } }"
         );
     }
 
-    /// Test SpinOperator Serialization and Deserialization traits (readable)
+    /// Test QubitOperator Serialization and Deserialization traits (readable)
     #[test]
     fn serde_readable() {
         let pp: HermitianMixedProduct = HermitianMixedProduct::new(
             [PauliProduct::new().z(2)],
             [BosonProduct::new([0], [3]).unwrap()],
             [FermionProduct::new([0], [2]).unwrap()],
         )
         .unwrap();
         let sos = MixedHamiltonianSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
             n_spins: 1,
             n_bosons: 1,
             n_fermions: 1,
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_tokens(
             &sos.readable(),
             &[
                 Token::Struct {
@@ -817,46 +800,53 @@
                 Token::SeqEnd,
                 Token::Str("n_spins"),
                 Token::U64(1),
                 Token::Str("n_bosons"),
                 Token::U64(1),
                 Token::Str("n_fermions"),
                 Token::U64(1),
-                Token::Str("_struqture_version"),
+                Token::Str("serialisation_meta"),
                 Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
                 },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(0),
+                Token::Str("type_name"),
+                Token::Str("MixedHamiltonian"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
                 Token::StructEnd,
                 Token::StructEnd,
             ],
         );
     }
 
-    /// Test SpinOperator Serialization and Deserialization traits (compact)
+    /// Test QubitOperator Serialization and Deserialization traits (compact)
     #[test]
     fn serde_compact() {
         let pp: HermitianMixedProduct = HermitianMixedProduct::new(
             [PauliProduct::new().z(2)],
             [BosonProduct::new([0], [3]).unwrap()],
             [FermionProduct::new([0], [2]).unwrap()],
         )
         .unwrap();
         let sos = MixedHamiltonianSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
             n_spins: 1,
             n_bosons: 1,
             n_fermions: 1,
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_tokens(
             &sos.compact(),
             &[
                 Token::Struct {
@@ -868,15 +858,15 @@
                 Token::Tuple { len: 3 },
                 Token::Tuple { len: 3 },
                 Token::Seq { len: Some(1) },
                 Token::Seq { len: Some(1) },
                 Token::Tuple { len: 2 },
                 Token::U64(2),
                 Token::UnitVariant {
-                    name: "SingleSpinOperator",
+                    name: "SingleQubitOperator",
                     variant: "Z",
                 },
                 Token::TupleEnd,
                 Token::SeqEnd,
                 Token::SeqEnd,
                 Token::Seq { len: Some(1) },
                 Token::Tuple { len: 2 },
@@ -913,22 +903,28 @@
                 Token::SeqEnd,
                 Token::Str("n_spins"),
                 Token::U64(1),
                 Token::Str("n_bosons"),
                 Token::U64(1),
                 Token::Str("n_fermions"),
                 Token::U64(1),
-                Token::Str("_struqture_version"),
+                Token::Str("serialisation_meta"),
                 Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
                 },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(0),
+                Token::Str("type_name"),
+                Token::Str("MixedHamiltonian"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
                 Token::StructEnd,
                 Token::StructEnd,
             ],
         );
     }
 }
```

### Comparing `struqture_py-1.6.1/struqture/src/mixed_systems/mixed_hamiltonian_system.rs` & `struqture_py-2.0.0a0/struqture/src/mixed_systems/mixed_plus_minus_operator.rs`

 * *Files 25% similar despite different names*

```diff
@@ -6,807 +6,930 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
-use super::{
-    HermitianMixedProduct, HermitianOperateOnMixedSystems, MixedHamiltonian, MixedSystem,
-    OperateOnMixedSystems,
-};
-#[cfg(feature = "json_schema")]
-use crate::mixed_systems::TinyVecDef;
-use crate::prelude::*;
-use crate::{OperateOnDensityMatrix, OperateOnState, StruqtureError};
-use qoqo_calculator::CalculatorComplex;
+use super::{MixedOperator, MixedPlusMinusProduct, MixedProduct, OperateOnMixedSystems};
+use crate::{ModeIndex, OperateOnDensityMatrix, OperateOnState, StruqtureError};
+use num_complex::Complex64;
+use qoqo_calculator::{CalculatorComplex, CalculatorFloat};
 use serde::{Deserialize, Serialize};
 use std::fmt::{self, Write};
 use std::iter::{FromIterator, IntoIterator};
 use std::ops;
-use tinyvec::TinyVec;
 
-#[cfg(feature = "indexed_map_iterators")]
-use indexmap::map::{Iter, Keys, Values};
-#[cfg(not(feature = "indexed_map_iterators"))]
-use std::collections::hash_map::{Iter, Keys, Values};
+use indexmap::map::{Entry, Iter};
+use indexmap::IndexMap;
 
-/// MixedHamiltonianSystems are representations of physical systems of spins, with a MixedHamiltonian to represent the hermitian hamiltonian of the system, and an optional number of spins.
+/// MixedOperators are combinations of MixedProducts with specific CalculatorComplex coefficients.
 ///
 /// # Example
 ///
 /// ```
 /// use struqture::prelude::*;
 /// use qoqo_calculator::CalculatorComplex;
-/// use struqture::spins::PauliProduct;
+/// use struqture::spins::PlusMinusProduct;
 /// use struqture::bosons::BosonProduct;
 /// use struqture::fermions::FermionProduct;
-/// use struqture::mixed_systems::{MixedHamiltonianSystem, HermitianMixedProduct};
+/// use struqture::mixed_systems::{MixedPlusMinusProduct, MixedPlusMinusOperator};
 ///
-/// let mut ms = MixedHamiltonianSystem::new([Some(2_usize)], [Some(2_usize)], [Some(2_usize)]);
+/// let mut sh = MixedPlusMinusOperator::new(1, 1, 1);
 ///
-/// let pp_0x1x_c0a1: HermitianMixedProduct = HermitianMixedProduct::new(
-///     [PauliProduct::new().x(0).x(1)],
-///     [BosonProduct::new([], [1]).unwrap()],
-///     [FermionProduct::new([0], [1]).unwrap()],
-/// )
-/// .unwrap();
-/// let pp_0z_c0a1: HermitianMixedProduct = HermitianMixedProduct::new(
-///     [PauliProduct::new().z(0)],
-///     [BosonProduct::new([0], [1]).unwrap()],
-///     [FermionProduct::new([0], [0]).unwrap()],
-/// )
-/// .unwrap();
-/// ms.set(pp_0x1x_c0a1.clone(), CalculatorComplex::from(0.5))
-///     .unwrap();
-/// ms.set(pp_0z_c0a1.clone(), CalculatorComplex::from(0.2))
-///     .unwrap();
+/// let mp_1: MixedPlusMinusProduct = MixedPlusMinusProduct::new([PlusMinusProduct::new().plus(0),], [BosonProduct::new([0], [1]).unwrap()], [FermionProduct::new([0], [1]).unwrap()]);
+/// let mp_0: MixedPlusMinusProduct = MixedPlusMinusProduct::new([PlusMinusProduct::new().z(0),], [BosonProduct::new([0], [1]).unwrap()], [FermionProduct::new([0], [1]).unwrap()]);
+/// sh.set(mp_1.clone(), CalculatorComplex::from(0.5)).unwrap();
+/// sh.set(mp_0.clone(), CalculatorComplex::from(0.2)).unwrap();
+///
+/// // Access what you set:
+/// assert_eq!(sh.get(&mp_1), &CalculatorComplex::from(0.5));
+/// assert_eq!(sh.get(&mp_0), &CalculatorComplex::from(0.2));
 /// ```
 ///
-#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]
-pub struct MixedHamiltonianSystem {
-    /// The number of spins in each subsystem
-    pub(crate) number_spins: TinyVec<[Option<usize>; 2]>,
-    /// The number of bosons in each subsystem
-    pub(crate) number_bosons: TinyVec<[Option<usize>; 2]>,
-    /// The number of fermions in each subsystem
-    pub(crate) number_fermions: TinyVec<[Option<usize>; 2]>,
-    /// The MixedHamiltonian representing the Hamiltonian of the MixedHamiltonianSystem
-    pub(crate) hamiltonian: MixedHamiltonian,
+#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
+#[serde(try_from = "MixedPlusMinusOperatorSerialize")]
+#[serde(into = "MixedPlusMinusOperatorSerialize")]
+pub struct MixedPlusMinusOperator {
+    /// The internal HashMap of MixedProducts and coefficients (CalculatorComplex)
+    internal_map: IndexMap<MixedPlusMinusProduct, CalculatorComplex>,
+    /// Number of Spin subsystems
+    n_spins: usize,
+    /// Number of Boson subsystems
+    n_bosons: usize,
+    /// Number of Fermion subsystems
+    n_fermions: usize,
+}
+
+impl crate::SerializationSupport for MixedPlusMinusOperator {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::MixedPlusMinusOperator
+    }
 }
 
 #[cfg(feature = "json_schema")]
-impl schemars::JsonSchema for MixedHamiltonianSystem {
+impl schemars::JsonSchema for MixedPlusMinusOperator {
     fn schema_name() -> String {
-        "MixedHamiltonianSystem".to_string()
+        "MixedPlusMinusOperator".to_string()
     }
 
     fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
-        <SchemaHelperMixedHamiltonianSystem>::json_schema(gen)
+        <MixedPlusMinusOperatorSerialize>::json_schema(gen)
     }
 }
 
-#[cfg(feature = "json_schema")]
-#[derive(schemars::JsonSchema)]
-#[schemars(deny_unknown_fields)]
-#[allow(dead_code)]
-struct SchemaHelperMixedHamiltonianSystem {
-    /// The number of spins in each subsystem
-    #[serde(with = "TinyVecDef")]
-    number_spins: TinyVec<[Option<usize>; 2]>,
-    /// The number of bosons in each subsystem
-    #[serde(with = "TinyVecDef")]
-    number_bosons: TinyVec<[Option<usize>; 2]>,
-    /// The number of fermions in each subsystem
-    #[serde(with = "TinyVecDef")]
-    number_fermions: TinyVec<[Option<usize>; 2]>,
-    /// The MixedHamiltonian representing the Hamiltonian of the MixedHamiltonianSystem
-    pub(crate) hamiltonian: MixedHamiltonian,
+#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
+#[cfg_attr(feature = "json_schema", derive(schemars::JsonSchema))]
+#[cfg_attr(feature = "json_schema", schemars(deny_unknown_fields))]
+struct MixedPlusMinusOperatorSerialize {
+    items: Vec<(MixedPlusMinusProduct, CalculatorFloat, CalculatorFloat)>,
+    n_spins: usize,
+    n_bosons: usize,
+    n_fermions: usize,
+    serialisation_meta: crate::StruqtureSerialisationMeta,
 }
 
-impl crate::MinSupportedVersion for MixedHamiltonianSystem {}
+impl TryFrom<MixedPlusMinusOperatorSerialize> for MixedPlusMinusOperator {
+    type Error = StruqtureError;
+    fn try_from(value: MixedPlusMinusOperatorSerialize) -> Result<Self, Self::Error> {
+        let target_serialisation_meta =
+            <Self as crate::SerializationSupport>::target_serialisation_meta();
+        crate::check_can_be_deserialised(&target_serialisation_meta, &value.serialisation_meta)?;
+        let mut new_noise_op =
+            MixedPlusMinusOperator::new(value.n_spins, value.n_bosons, value.n_fermions);
+        for (key, real, imag) in value.items.iter() {
+            let _ =
+                new_noise_op.add_operator_product(key.clone(), CalculatorComplex::new(real, imag));
+        }
+        Ok(new_noise_op)
+    }
+}
+
+impl From<MixedPlusMinusOperator> for MixedPlusMinusOperatorSerialize {
+    fn from(value: MixedPlusMinusOperator) -> Self {
+        let serialisation_meta = crate::SerializationSupport::struqture_serialisation_meta(&value);
+        let new_noise_op: Vec<(MixedPlusMinusProduct, CalculatorFloat, CalculatorFloat)> = value
+            .clone()
+            .into_iter()
+            .map(|(key, val)| (key, val.re, val.im))
+            .collect();
+        Self {
+            items: new_noise_op,
+            n_spins: value.n_spins,
+            n_bosons: value.n_bosons,
+            n_fermions: value.n_fermions,
+            serialisation_meta,
+        }
+    }
+}
 
-impl<'a> OperateOnDensityMatrix<'a> for MixedHamiltonianSystem {
-    type Index = HermitianMixedProduct;
+impl<'a> OperateOnDensityMatrix<'a> for MixedPlusMinusOperator {
+    type Index = MixedPlusMinusProduct;
     type Value = CalculatorComplex;
-    type IteratorType = Iter<'a, Self::Index, Self::Value>;
-    type KeyIteratorType = Keys<'a, Self::Index, Self::Value>;
-    type ValueIteratorType = Values<'a, Self::Index, Self::Value>;
 
     // From trait
     fn get(&self, key: &Self::Index) -> &Self::Value {
-        self.hamiltonian.get(key)
+        match self.internal_map.get(key) {
+            Some(value) => value,
+            None => &CalculatorComplex::ZERO,
+        }
     }
 
     // From trait
-    fn iter(&'a self) -> Self::IteratorType {
-        self.hamiltonian.iter()
+    fn iter(&'a self) -> impl ExactSizeIterator<Item = (&'a Self::Index, &'a Self::Value)> {
+        self.internal_map.iter()
     }
 
     // From trait
-    fn keys(&'a self) -> Self::KeyIteratorType {
-        self.hamiltonian.keys()
+    fn keys(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Index> {
+        self.internal_map.keys()
     }
 
     // From trait
-    fn values(&'a self) -> Self::ValueIteratorType {
-        self.hamiltonian.values()
+    fn values(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Value> {
+        self.internal_map.values()
     }
 
     // From trait
     fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
-        self.hamiltonian.remove(key)
+        self.internal_map.shift_remove(key)
     }
 
     // From trait
     fn empty_clone(&self, capacity: Option<usize>) -> Self {
         match capacity {
-            Some(cap) => Self {
-                number_spins: self.number_spins.clone(),
-                number_bosons: self.number_bosons.clone(),
-                number_fermions: self.number_fermions.clone(),
-                hamiltonian: MixedHamiltonian::with_capacity(
-                    self.number_spins.len(),
-                    self.number_bosons.len(),
-                    self.number_fermions.len(),
-                    cap,
-                ),
-            },
-            None => Self {
-                number_spins: self.number_spins.clone(),
-                number_bosons: self.number_bosons.clone(),
-                number_fermions: self.number_fermions.clone(),
-                hamiltonian: MixedHamiltonian::new(
-                    self.number_spins.len(),
-                    self.number_bosons.len(),
-                    self.number_fermions.len(),
-                ),
-            },
+            Some(cap) => Self::with_capacity(self.n_spins, self.n_bosons, self.n_fermions, cap),
+            None => Self::new(self.n_spins, self.n_bosons, self.n_fermions),
         }
     }
 
-    /// Overwrites an existing entry or sets a new entry in the MixedHamiltonianSystem with the given (HermitianMixedProduct key, CalculatorComplex value) pair.
+    /// Overwrites an existing entry or sets a new entry in the MixedPlusMinusOperator with the given (MixedPlusMinusProduct key, CalculatorComplex value) pair.
     ///
     /// # Arguments
     ///
-    /// * `key` - The HermitianMixedProduct key to set in the MixedHamiltonianSystem.
-    /// * `value` - The corresponding CalculatorComplex value to set for the key in the MixedHamiltonianSystem.
+    /// * `key` - The MixedPlusMinusProduct key to set in the MixedPlusMinusOperator.
+    /// * `value` - The corresponding CalculatorComplex value to set for the key in the MixedPlusMinusOperator.
     ///
     /// # Returns
     ///
     /// * `Ok(Some(CalculatorComplex))` - The key existed, this is the value it had before it was set with the value input.
     /// * `Ok(None)` - The key did not exist, it has been set with its corresponding value.
     /// * `Err(StruqtureError::MissmatchedNumberSubsystems)` - Number of subsystems in system and key do not match.
-    /// * `Err(StruqtureError::NonHermitianOperator)` - Key is naturally hermitian (on-diagonal term), but its corresponding value is not real.
     fn set(
         &mut self,
         key: Self::Index,
         value: Self::Value,
     ) -> Result<Option<Self::Value>, StruqtureError> {
-        if key.spins().len() != self.number_spins.len()
-            || key.bosons().len() != self.number_bosons.len()
-            || key.fermions().len() != self.number_fermions.len()
+        if key.spins().len() != self.n_spins
+            || key.bosons().len() != self.n_bosons
+            || key.fermions().len() != self.n_fermions
         {
             return Err(StruqtureError::MissmatchedNumberSubsystems {
-                target_number_spin_subsystems: self.number_spins.len(),
-                target_number_boson_subsystems: self.number_bosons.len(),
-                target_number_fermion_subsystems: self.number_fermions.len(),
+                target_number_spin_subsystems: self.n_spins,
+                target_number_boson_subsystems: self.n_bosons,
+                target_number_fermion_subsystems: self.n_fermions,
                 actual_number_spin_subsystems: key.spins().len(),
                 actual_number_boson_subsystems: key.bosons().len(),
                 actual_number_fermion_subsystems: key.fermions().len(),
             });
         }
-        for (x, y) in key.bosons().zip(self.number_bosons.clone()) {
-            if let Some(max_number) = y {
-                if x.current_number_modes() > max_number {
-                    return Err(StruqtureError::MissmatchedNumberModes);
-                }
-            }
-        }
-        for (x, y) in key.fermions().zip(self.number_fermions.clone()) {
-            if let Some(max_number) = y {
-                if x.current_number_modes() > max_number {
-                    return Err(StruqtureError::MissmatchedNumberModes);
-                }
-            }
-        }
-        for (x, y) in key.spins().zip(self.number_spins.clone()) {
-            if let Some(max_number) = y {
-                if x.current_number_spins() > max_number {
-                    return Err(StruqtureError::MissmatchedNumberSpins);
-                }
-            }
-        }
-        self.hamiltonian.set(key, value)
-    }
-
-    /// Adds a new (HermitianMixedProduct key, CalculatorComplex value) pair to the MixedHamiltonianSystem.
-    ///
-    /// # Arguments
-    ///
-    /// * `key` - The HermitianMixedProduct key to added to the MixedHamiltonianSystem.
-    /// * `value` - The corresponding CalculatorComplex value to add for the key in the MixedHamiltonianSystem.
-    ///
-    /// # Returns
-    ///
-    /// * `Ok(())` - The (key, value) pair was successfully added.
-    /// * `Err(StruqtureError::MissmatchedNumberSubsystems)` - Number of subsystems in system and key do not match.
-    /// * `Err(StruqtureError::NonHermitianOperator)` - Key is naturally hermitian (on-diagonal term), but its corresponding value is not real.
-    fn add_operator_product(
-        &mut self,
-        key: Self::Index,
-        value: Self::Value,
-    ) -> Result<(), StruqtureError> {
-        if key.spins().len() != self.number_spins.len()
-            || key.bosons().len() != self.number_bosons.len()
-            || key.fermions().len() != self.number_fermions.len()
-        {
-            return Err(StruqtureError::MissmatchedNumberSubsystems {
-                target_number_spin_subsystems: self.number_spins.len(),
-                target_number_boson_subsystems: self.number_bosons.len(),
-                target_number_fermion_subsystems: self.number_fermions.len(),
-                actual_number_spin_subsystems: key.spins().len(),
-                actual_number_boson_subsystems: key.bosons().len(),
-                actual_number_fermion_subsystems: key.fermions().len(),
-            });
-        }
-        for (x, y) in key.bosons().zip(self.number_bosons.clone()) {
-            if let Some(max_number) = y {
-                if x.current_number_modes() > max_number {
-                    return Err(StruqtureError::MissmatchedNumberModes);
-                }
-            }
-        }
-        for (x, y) in key.fermions().zip(self.number_fermions.clone()) {
-            if let Some(max_number) = y {
-                if x.current_number_modes() > max_number {
-                    return Err(StruqtureError::MissmatchedNumberModes);
-                }
-            }
-        }
-        for (x, y) in key.spins().zip(self.number_spins.clone()) {
-            if let Some(max_number) = y {
-                if x.current_number_spins() > max_number {
-                    return Err(StruqtureError::MissmatchedNumberSpins);
-                }
+        if value.re != CalculatorFloat::ZERO || value.im != CalculatorFloat::ZERO {
+            // Catch on diagonals with non-zero imaginary values
+            Ok(self.internal_map.insert(key, value))
+        } else {
+            match self.internal_map.entry(key) {
+                Entry::Occupied(val) => Ok(Some(val.shift_remove())),
+                Entry::Vacant(_) => Ok(None),
             }
         }
-        self.hamiltonian.add_operator_product(key, value)
     }
 }
 
-impl<'a> OperateOnState<'a> for MixedHamiltonianSystem {
+impl<'a> OperateOnState<'a> for MixedPlusMinusOperator {
     // From trait
     fn hermitian_conjugate(&self) -> Self {
         self.clone()
     }
 }
 
-impl<'a> OperateOnMixedSystems<'a> for MixedHamiltonianSystem {
-    // From trait
-    fn number_spins(&self) -> Vec<usize> {
-        self.number_spins
-            .iter()
-            .zip(self.current_number_spins())
-            .map(|(target, current)| target.unwrap_or_else(|| current))
-            .collect()
-    }
-
+impl<'a> OperateOnMixedSystems<'a> for MixedPlusMinusOperator {
     // From trait
     fn current_number_spins(&self) -> Vec<usize> {
-        let mut number_spins: Vec<usize> = (0..self.number_spins.len()).map(|_| 0).collect();
+        let mut current_number_spins: Vec<usize> = (0..self.n_spins).map(|_| 0).collect();
         for key in self.keys() {
             for (index, s) in key.spins().enumerate() {
                 let maxk = s.current_number_spins();
-                if maxk > number_spins[index] {
-                    number_spins[index] = maxk
+                if maxk > current_number_spins[index] {
+                    current_number_spins[index] = maxk
                 }
             }
         }
-        number_spins
-    }
-
-    // From trait
-    fn number_bosonic_modes(&self) -> Vec<usize> {
-        self.number_bosons
-            .iter()
-            .zip(self.current_number_bosonic_modes())
-            .map(|(target, current)| target.unwrap_or_else(|| current))
-            .collect()
+        current_number_spins
     }
 
     // From trait
     fn current_number_bosonic_modes(&self) -> Vec<usize> {
-        let mut number_bosons: Vec<usize> = (0..self.number_bosons.len()).map(|_| 0).collect();
+        let mut number_bosons: Vec<usize> = (0..self.n_bosons).map(|_| 0).collect();
         for key in self.keys() {
             for (index, s) in key.bosons().enumerate() {
                 let maxk = s.current_number_modes();
                 if maxk > number_bosons[index] {
                     number_bosons[index] = maxk
                 }
             }
         }
         number_bosons
     }
 
     // From trait
-    fn number_fermionic_modes(&self) -> Vec<usize> {
-        self.number_fermions
-            .iter()
-            .zip(self.current_number_fermionic_modes())
-            .map(|(target, current)| target.unwrap_or_else(|| current))
-            .collect()
-    }
-
-    // From trait
     fn current_number_fermionic_modes(&self) -> Vec<usize> {
-        let mut number_fermions: Vec<usize> = (0..self.number_fermions.len()).map(|_| 0).collect();
+        let mut number_fermions: Vec<usize> = (0..self.n_fermions).map(|_| 0).collect();
         for key in self.keys() {
             for (index, s) in key.fermions().enumerate() {
                 let maxk = s.current_number_modes();
                 if maxk > number_fermions[index] {
                     number_fermions[index] = maxk
                 }
             }
         }
         number_fermions
     }
 }
 
-impl<'a> HermitianOperateOnMixedSystems<'a> for MixedHamiltonianSystem {}
+/// Implements the default function (Default trait) of MixedPlusMinusOperator (an empty MixedPlusMinusOperator).
+///
+impl Default for MixedPlusMinusOperator {
+    fn default() -> Self {
+        Self::new(0, 0, 0)
+    }
+}
 
-/// Functions for the MixedHamiltonianSystem
+/// Functions for the MixedPlusMinusOperator
 ///
-impl MixedHamiltonianSystem {
-    /// Creates a new MixedHamiltonianSystem.
+impl MixedPlusMinusOperator {
+    /// Creates a new MixedPlusMinusOperator.
     ///
-    /// # Arguments
+    /// # Arguments:
     ///
-    /// * `number_spins` - The number of spins in each spin subsystem
-    /// * `number_bosons` - The number of boson modes in each bosonic subsystem
-    /// * `number_fermions` - The number of fermion modes in each fermionic subsystem
+    /// * `n_spins` - Number of spin sub-systems
+    /// * `n_bosons` - Number of bosonic sub-systems
+    /// * `n_fermions` - Number of fermionic sub-systems
     ///
     /// # Returns
     ///
-    /// * `Self` - The new MixedHamiltonianSystem with the input number of spins and modes.
-    pub fn new(
-        number_spins: impl IntoIterator<Item = Option<usize>>,
-        number_bosons: impl IntoIterator<Item = Option<usize>>,
-        number_fermions: impl IntoIterator<Item = Option<usize>>,
-    ) -> Self {
-        let number_spins: TinyVec<[Option<usize>; 2]> = number_spins.into_iter().collect();
-        let number_bosons: TinyVec<[Option<usize>; 2]> = number_bosons.into_iter().collect();
-        let number_fermions: TinyVec<[Option<usize>; 2]> = number_fermions.into_iter().collect();
-        let hamiltonian = MixedHamiltonian::new(
-            number_spins.len(),
-            number_bosons.len(),
-            number_fermions.len(),
-        );
-        MixedHamiltonianSystem {
-            number_spins,
-            number_bosons,
-            number_fermions,
-            hamiltonian,
+    /// * `Self` - The new (empty) MixedPlusMinusOperator.
+    pub fn new(n_spins: usize, n_bosons: usize, n_fermions: usize) -> Self {
+        MixedPlusMinusOperator {
+            internal_map: IndexMap::new(),
+            n_spins,
+            n_bosons,
+            n_fermions,
         }
     }
 
-    /// Creates a new MixedHamiltonianSystem with pre-allocated capacity.
+    /// Creates a new MixedPlusMinusOperator with capacity.
     ///
     /// # Arguments
     ///
-    /// * `number_spins` - The number of spins in each spin subsystem
-    /// * `number_bosons` - The number of boson modes in each bosonic subsystem
-    /// * `number_fermions` - The number of fermion modes in each fermionic subsystem
-    /// * `capacity` - The pre-allocated capacity of the system.
+    /// * `n_spins` - The number of spin sub-systems.
+    /// * `n_bosons` - The number of boson sub-systems.
+    /// * `n_fermions` - The number of fermion sub-systems.
+    /// * `capacity` - The pre-allocated capacity of the operator.
     ///
     /// # Returns
     ///
-    /// * `Self` - The new MixedHamiltonianSystem with the input number of spins and modes.
+    /// * `Self` - The new (empty) MixedPlusMinusOperator.
     pub fn with_capacity(
-        number_spins: impl IntoIterator<Item = Option<usize>>,
-        number_bosons: impl IntoIterator<Item = Option<usize>>,
-        number_fermions: impl IntoIterator<Item = Option<usize>>,
+        n_spins: usize,
+        n_bosons: usize,
+        n_fermions: usize,
         capacity: usize,
     ) -> Self {
-        let number_spins: TinyVec<[Option<usize>; 2]> = number_spins.into_iter().collect();
-        let number_bosons: TinyVec<[Option<usize>; 2]> = number_bosons.into_iter().collect();
-        let number_fermions: TinyVec<[Option<usize>; 2]> = number_fermions.into_iter().collect();
-        let hamiltonian = MixedHamiltonian::with_capacity(
-            number_spins.len(),
-            number_bosons.len(),
-            number_fermions.len(),
-            capacity,
+        Self {
+            internal_map: IndexMap::with_capacity(capacity),
+            n_spins,
+            n_bosons,
+            n_fermions,
+        }
+    }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(
+        &self,
+    ) -> Result<struqture_one::mixed_systems::MixedPlusMinusOperator, StruqtureError> {
+        let mut new_mixed_system = struqture_one::mixed_systems::MixedPlusMinusOperator::new(
+            self.n_spins,
+            self.n_bosons,
+            self.n_fermions,
+        );
+        for (key, val) in self.iter() {
+            let one_key = key.to_struqture_1()?;
+            let _ = struqture_one::OperateOnDensityMatrix::set(
+                &mut new_mixed_system,
+                one_key,
+                val.clone(),
+            );
+        }
+        Ok(new_mixed_system)
+    }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::mixed_systems::MixedPlusMinusOperator,
+    ) -> Result<Self, StruqtureError> {
+        let mut new_qubit_operator = Self::new(
+            struqture_one::mixed_systems::OperateOnMixedSystems::current_number_spins(value).len(),
+            struqture_one::mixed_systems::OperateOnMixedSystems::current_number_bosonic_modes(
+                value,
+            )
+            .len(),
+            struqture_one::mixed_systems::OperateOnMixedSystems::current_number_fermionic_modes(
+                value,
+            )
+            .len(),
         );
-        MixedHamiltonianSystem {
-            number_spins,
-            number_bosons,
-            number_fermions,
-            hamiltonian,
+        for (key, val) in struqture_one::OperateOnDensityMatrix::iter(value) {
+            let self_key = MixedPlusMinusProduct::from_struqture_1(key)?;
+            let _ = new_qubit_operator.set(self_key, val.clone());
         }
+        Ok(new_qubit_operator)
     }
+}
 
-    /// Returns the MixedHamiltonian of the MixedHamiltonianSystem.
+impl TryFrom<MixedPlusMinusOperator> for MixedOperator {
+    type Error = StruqtureError;
+    /// Converts a MixedPlusMinusOperator into a MixedOperator.
+    ///
+    /// # Arguments
+    ///
+    /// * `value` - The MixedPlusMinusOperator to convert.
     ///
     /// # Returns
     ///
-    /// * `&MixedHamiltonian` - The MixedHamiltonian of the MixedHamiltonianSystem.
-    pub fn hamiltonian(&self) -> &MixedHamiltonian {
-        &self.hamiltonian
+    /// * `Self` - The MixedPlusMinusOperator converted into a MixedOperator.
+    fn try_from(value: MixedPlusMinusOperator) -> Result<Self, Self::Error> {
+        let mut new_operator = MixedOperator::with_capacity(
+            value.n_spins,
+            value.n_bosons,
+            value.n_fermions,
+            2 * value.len(),
+        );
+        for (product, val) in value.into_iter() {
+            let transscribed_vector: Vec<(MixedProduct, Complex64)> = product.try_into()?;
+            for (transscribed_product, prefactor) in transscribed_vector {
+                new_operator
+                    .add_operator_product(transscribed_product, val.clone() * prefactor)
+                    .expect("Unexpected error adding operators. Internal struqture error");
+            }
+        }
+        Ok(new_operator)
     }
+}
 
-    /// Creates a MixedHamiltonianSystem from a MixedHamiltonian and an optional number of spins/modes.
+impl From<MixedOperator> for MixedPlusMinusOperator {
+    /// Converts a MixedOperator into a MixedPlusMinusOperator.
     ///
     /// # Arguments
     ///
-    /// * `hamiltonian` - The MixedHamiltonian to create the MixedHamiltonianSystem from.
-    /// * `number_spins` - The number of spins for the MixedHamiltonianSystem to be created.
-    /// * `number_bosons` - The number of boson modes for the MixedHamiltonianSystem to be created.
-    /// * `number_fermions` - The number of fermion modes for the MixedHamiltonianSystem to be created.
+    /// * `value` - The MixedOperator to convert.
     ///
     /// # Returns
     ///
-    /// * `Ok(Self)` - The MixedHamiltonianSystem created from the inputs.
-    /// * `Err(StruqtureError::NumberSpinsExceeded)` - Number of spins in entry exceeds number of spins in system.
-    pub fn from_hamiltonian(
-        hamiltonian: MixedHamiltonian,
-        number_spins: impl IntoIterator<Item = Option<usize>>,
-        number_bosons: impl IntoIterator<Item = Option<usize>>,
-        number_fermions: impl IntoIterator<Item = Option<usize>>,
-    ) -> Result<Self, StruqtureError> {
-        let number_spins: TinyVec<[Option<usize>; 2]> = number_spins.into_iter().collect();
-        let number_bosons: TinyVec<[Option<usize>; 2]> = number_bosons.into_iter().collect();
-        let number_fermions: TinyVec<[Option<usize>; 2]> = number_fermions.into_iter().collect();
-
-        if hamiltonian
-            .current_number_spins()
-            .iter()
-            .zip(number_spins.iter())
-            .all(|(current, target)| match target {
-                Some(x) => current <= x,
-                None => true,
-            })
-            && hamiltonian
-                .current_number_bosonic_modes()
-                .iter()
-                .zip(number_bosons.iter())
-                .all(|(current, target)| match target {
-                    Some(x) => current <= x,
-                    None => true,
-                })
-            && hamiltonian
-                .current_number_fermionic_modes()
-                .iter()
-                .zip(number_fermions.iter())
-                .all(|(current, target)| match target {
-                    Some(x) => current <= x,
-                    None => true,
-                })
-        {
-            Ok(MixedHamiltonianSystem {
-                number_spins,
-                number_bosons,
-                number_fermions,
-                hamiltonian,
-            })
-        } else {
-            Err(StruqtureError::NumberSpinsExceeded)
+    /// * `Self` - The MixedOperator converted into a MixedPlusMinusOperator.
+    fn from(value: MixedOperator) -> Self {
+        let mut new_operator = MixedPlusMinusOperator::with_capacity(
+            value.current_number_spins().len(),
+            value.current_number_bosonic_modes().len(),
+            value.current_number_fermionic_modes().len(),
+            2 * value.len(),
+        );
+        for (product, val) in value.into_iter() {
+            let transscribed_vector: Vec<(MixedPlusMinusProduct, Complex64)> = product.into();
+            for (transscribed_product, prefactor) in transscribed_vector {
+                new_operator
+                    .add_operator_product(transscribed_product, val.clone() * prefactor)
+                    .expect("Unexpected error adding operators. Internal struqture error");
+            }
         }
+        new_operator
     }
-
-    // /// Separate self into an operator with the terms of given number of spins, bosons and fermions and an operator with the remaining operations
-    // ///
-    // /// # Arguments
-    // ///
-    // /// * `number_particles` - Number of spins, bosons and fermions to filter for in the keys.
-    // ///
-    // /// # Returns
-    // ///
-    // /// `Ok((separated, remainder))` - Operator with the noise terms where number_particles matches the number of spins the operator product acts on and Operator with all other contributions.
-    // pub fn separate_into_n_terms(
-    //     &self,
-    //     number_particles: (usize, usize, usize),
-    // ) -> Result<(Self, Self), StruqtureError> {
-    //     let mut separated = Self::default();
-    //     let mut remainder = Self::default();
-    //     for (prod, val) in self.iter() {
-    //         if (
-    //             prod.spins().len(),
-    //             prod.bosons().len(),
-    //             prod.fermions().len(),
-    //         ) == number_particles
-    //         {
-    //             separated.add_operator_product(prod.clone(), val.clone())?;
-    //         } else {
-    //             remainder.add_operator_product(prod.clone(), val.clone())?;
-    //         }
-    //     }
-    //     Ok((separated, remainder))
-    // }
 }
 
-/// Implements the negative sign function of MixedHamiltonianSystem.
+/// Implements the negative sign function of MixedPlusMinusOperator.
 ///
-impl ops::Neg for MixedHamiltonianSystem {
-    type Output = Self;
-    /// Implement minus sign for MixedHamiltonianSystem.
+impl ops::Neg for MixedPlusMinusOperator {
+    type Output = MixedPlusMinusOperator;
+    /// Implement minus sign for MixedPlusMinusOperator.
     ///
     /// # Returns
     ///
-    /// * `Self` - The MixedHamiltonianSystem * -1.
-    fn neg(mut self) -> Self {
-        self.hamiltonian = self.hamiltonian.neg();
-        self
+    /// * `Self` - The MixedPlusMinusOperator * -1.
+    fn neg(self) -> Self {
+        let mut internal = self.internal_map.clone();
+        let n_spins = self.n_spins;
+        let n_bosons = self.n_bosons;
+        let n_fermions = self.n_fermions;
+        for key in self.keys() {
+            internal.insert(key.clone(), internal[key].clone() * -1.0);
+        }
+        MixedPlusMinusOperator {
+            internal_map: internal,
+            n_spins,
+            n_bosons,
+            n_fermions,
+        }
     }
 }
 
-/// Implements the plus function of MixedHamiltonianSystem by MixedHamiltonianSystem.
+/// Implements the plus function of MixedPlusMinusOperator by MixedPlusMinusOperator.
 ///
-impl<T, V> ops::Add<T> for MixedHamiltonianSystem
+impl<T, V> ops::Add<T> for MixedPlusMinusOperator
 where
-    T: IntoIterator<Item = (HermitianMixedProduct, V)>,
+    T: IntoIterator<Item = (MixedPlusMinusProduct, V)>,
     V: Into<CalculatorComplex>,
 {
     type Output = Result<Self, StruqtureError>;
-    /// Implements `+` (add) for two MixedHamiltonianSystems.
+    /// Implements `+` (add) for two MixedOperators.
     ///
     /// # Arguments
     ///
-    /// * `other` - The MixedHamiltonianSystem to be added.
+    /// * `other` - The MixedPlusMinusOperator to be added.
     ///
     /// # Returns
     ///
-    /// * `Ok(Self)` - The two MixedHamiltonianSystems added together.
+    /// * `Ok(Self)` - The two MixedOperators added together.
     /// * `Err(StruqtureError::MissmatchedNumberSubsystems)` - Number of subsystems in system and key do not match.
-    /// * `Err(StruqtureError::NonHermitianOperator)` - Key is naturally hermitian (on-diagonal term), but its corresponding value is not real.
     fn add(mut self, other: T) -> Self::Output {
         for (key, value) in other.into_iter() {
             self.add_operator_product(key.clone(), Into::<CalculatorComplex>::into(value))?;
         }
         Ok(self)
     }
 }
 
-/// Implements the minus function of MixedHamiltonianSystem by MixedHamiltonianSystem.
+/// Implements the minus function of MixedPlusMinusOperator by MixedPlusMinusOperator.
 ///
-impl<T, V> ops::Sub<T> for MixedHamiltonianSystem
+impl<T, V> ops::Sub<T> for MixedPlusMinusOperator
 where
-    T: IntoIterator<Item = (HermitianMixedProduct, V)>,
+    T: IntoIterator<Item = (MixedPlusMinusProduct, V)>,
     V: Into<CalculatorComplex>,
 {
     type Output = Result<Self, StruqtureError>;
-    /// Implements `-` (subtract) for two MixedHamiltonianSystems.
+    /// Implements `-` (subtract) for two MixedOperators.
     ///
     /// # Arguments
     ///
-    /// * `other` - The MixedHamiltonianSystem to be subtracted.
+    /// * `other` - The MixedPlusMinusOperator to be subtracted.
     ///
     /// # Returns
     ///
-    /// * `Ok(Self)` - The two MixedHamiltonianSystems subtracted.
+    /// * `Ok(Self)` - The two MixedOperators subtracted.
     /// * `Err(StruqtureError::MissmatchedNumberSubsystems)` - Number of subsystems in system and key do not match.
-    /// * `Err(StruqtureError::NonHermitianOperator)` - Key is naturally hermitian (on-diagonal term), but its corresponding value is not real.
     fn sub(mut self, other: T) -> Self::Output {
         for (key, value) in other.into_iter() {
             self.add_operator_product(key.clone(), Into::<CalculatorComplex>::into(value) * -1.0)?;
         }
         Ok(self)
     }
 }
 
-/// Implements the multiplication function of MixedHamiltonianSystem by CalculatorComplex/CalculatorFloat.
+/// Implements the multiplication function of MixedPlusMinusOperator by CalculatorComplex/CalculatorFloat.
 ///
-impl<T> ops::Mul<T> for MixedHamiltonianSystem
+impl<T> ops::Mul<T> for MixedPlusMinusOperator
 where
     T: Into<CalculatorComplex>,
 {
     type Output = Self;
-    /// Implement `*` for MixedHamiltonianSystem and CalculatorComplex/CalculatorFloat.
+    /// Implement `*` for MixedPlusMinusOperator and CalculatorComplex/CalculatorFloat.
     ///
     /// # Arguments
     ///
     /// * `other` - The CalculatorComplex or CalculatorFloat by which to multiply.
     ///
     /// # Returns
     ///
-    /// * `Self` - The MixedHamiltonianSystem multiplied by the CalculatorComplex/CalculatorFloat.
-    fn mul(mut self, other: T) -> Self {
+    /// * `Self` - The MixedPlusMinusOperator multiplied by the CalculatorComplex/CalculatorFloat.
+    fn mul(self, other: T) -> Self {
         let other_cc = Into::<CalculatorComplex>::into(other);
-        self.hamiltonian = self.hamiltonian * other_cc;
-        self
-    }
-}
-
-/// Implements the multiplication function of MixedHamiltonianSystem by MixedHamiltonianSystem.
-///
-impl ops::Mul<MixedHamiltonianSystem> for MixedHamiltonianSystem {
-    type Output = Result<MixedSystem, StruqtureError>;
-    /// Implement `*` for MixedHamiltonianSystem and MixedHamiltonianSystem.
-    ///
-    /// # Arguments
-    ///
-    /// * `other` - The MixedHamiltonianSystem to multiply by.
-    ///
-    /// # Returns
-    ///
-    /// * `Ok(MixedSystem)` - The two MixedHamiltonianSystems multiplied.
-    /// * `Err(StruqtureError::MissmatchedNumberSubsystems)` - Number of subsystems in system and key do not match.
-    fn mul(self, other: MixedHamiltonianSystem) -> Self::Output {
-        if self.number_spins.len() != other.number_spins.len()
-            || self.number_bosons.len() != other.number_bosons.len()
-            || self.number_fermions.len() != other.number_fermions.len()
-        {
-            return Err(StruqtureError::MissmatchedNumberSubsystems {
-                target_number_spin_subsystems: self.number_spins.len(),
-                target_number_boson_subsystems: self.number_bosons.len(),
-                target_number_fermion_subsystems: self.number_fermions.len(),
-                actual_number_spin_subsystems: other.number_spins.len(),
-                actual_number_boson_subsystems: other.number_bosons.len(),
-                actual_number_fermion_subsystems: other.number_fermions.len(),
-            });
+        let mut internal = self.internal_map.clone();
+        let n_spins = self.n_spins;
+        let n_bosons = self.n_bosons;
+        let n_fermions = self.n_fermions;
+        for key in self.keys() {
+            internal.insert(key.clone(), internal[key].clone() * other_cc.clone());
         }
-        let capacity = self.len() * other.len();
-        let mut spin_op = MixedSystem::with_capacity(
-            self.number_spins.clone(),
-            self.number_bosons.clone(),
-            self.number_fermions.clone(),
-            capacity,
-        );
-        for (pps, vals) in self {
-            for (ppo, valo) in other.iter() {
-                let products = (pps.clone() * ppo.clone())?;
-                for (ppp, coefficient) in products {
-                    let coefficient =
-                        Into::<CalculatorComplex>::into(valo) * vals.clone() * coefficient;
-                    spin_op.add_operator_product(ppp, coefficient)?;
-                }
-            }
+        MixedPlusMinusOperator {
+            internal_map: internal,
+            n_spins,
+            n_bosons,
+            n_fermions,
         }
-        Ok(spin_op)
     }
 }
 
-/// Implements the into_iter function (IntoIterator trait) of MixedHamiltonianSystem.
+/// Implements the into_iter function (IntoIterator trait) of MixedPlusMinusOperator.
 ///
-impl IntoIterator for MixedHamiltonianSystem {
-    type Item = (HermitianMixedProduct, CalculatorComplex);
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    type IntoIter = std::collections::hash_map::IntoIter<HermitianMixedProduct, CalculatorComplex>;
-    #[cfg(feature = "indexed_map_iterators")]
-    type IntoIter = indexmap::map::IntoIter<HermitianMixedProduct, CalculatorComplex>;
-    /// Returns the MixedHamiltonianSystem in Iterator form.
+impl IntoIterator for MixedPlusMinusOperator {
+    type Item = (MixedPlusMinusProduct, CalculatorComplex);
+    type IntoIter = indexmap::map::IntoIter<MixedPlusMinusProduct, CalculatorComplex>;
+    /// Returns the MixedPlusMinusOperator in Iterator form.
     ///
     /// # Returns
     ///
-    /// * `Self::IntoIter` - The MixedHamiltonianSystem in Iterator form.
+    /// * `Self::IntoIter` - The MixedPlusMinusOperator in Iterator form.
     fn into_iter(self) -> Self::IntoIter {
-        self.hamiltonian.into_iter()
+        self.internal_map.into_iter()
     }
 }
 
-/// Implements the into_iter function (IntoIterator trait) of reference MixedHamiltonianSystem.
+/// Implements the into_iter function (IntoIterator trait) of reference MixedPlusMinusOperator.
 ///
-impl<'a> IntoIterator for &'a MixedHamiltonianSystem {
-    type Item = (&'a HermitianMixedProduct, &'a CalculatorComplex);
-    type IntoIter = Iter<'a, HermitianMixedProduct, CalculatorComplex>;
+impl<'a> IntoIterator for &'a MixedPlusMinusOperator {
+    type Item = (&'a MixedPlusMinusProduct, &'a CalculatorComplex);
+    type IntoIter = Iter<'a, MixedPlusMinusProduct, CalculatorComplex>;
 
-    /// Returns the reference MixedHamiltonianSystem in Iterator form.
+    /// Returns the reference MixedPlusMinusOperator in Iterator form.
     ///
     /// # Returns
     ///
-    /// * `Self::IntoIter` - The reference MixedHamiltonianSystem in Iterator form.
+    /// * `Self::IntoIter` - The reference MixedPlusMinusOperator in Iterator form.
     fn into_iter(self) -> Self::IntoIter {
-        self.hamiltonian.iter()
+        self.internal_map.iter()
     }
 }
 
-/// Implements the from_iter function (FromIterator trait) of MixedHamiltonianSystem.
+/// Implements the from_iter function (FromIterator trait) of MixedPlusMinusOperator.
 ///
-impl FromIterator<(HermitianMixedProduct, CalculatorComplex)> for MixedHamiltonianSystem {
-    /// Returns the object in MixedHamiltonianSystem form, from an Iterator form of the object.
+impl FromIterator<(MixedPlusMinusProduct, CalculatorComplex)> for MixedPlusMinusOperator {
+    /// Returns the object in MixedPlusMinusOperator form, from an Iterator form of the object.
     ///
     /// # Arguments
     ///
-    /// * `iter` - The iterator containing the information from which to create the MixedHamiltonianSystem.
+    /// * `iter` - The iterator containing the information from which to create the MixedPlusMinusOperator.
     ///
     /// # Returns
     ///
-    /// * `Self::IntoIter` - The iterator in MixedHamiltonianSystem form.
+    /// * `Self::IntoIter` - The iterator in MixedPlusMinusOperator form.
     ///
     /// # Panics
     ///
     /// * Internal error in set.
     /// * Internal error in add_operator_product.
-    fn from_iter<I: IntoIterator<Item = (HermitianMixedProduct, CalculatorComplex)>>(
+    fn from_iter<I: IntoIterator<Item = (MixedPlusMinusProduct, CalculatorComplex)>>(
         iter: I,
     ) -> Self {
         let mut iterator = iter.into_iter();
         match iterator.next() {
             Some(first_element) => {
-                let number_spins: Vec<Option<usize>> =
-                    (0..first_element.0.spins().len()).map(|_| None).collect();
-                let number_bosons: Vec<Option<usize>> =
-                    (0..first_element.0.bosons().len()).map(|_| None).collect();
-                let number_fermions: Vec<Option<usize>> = (0..first_element.0.fermions().len())
-                    .map(|_| None)
-                    .collect();
-                let mut slno =
-                    MixedHamiltonianSystem::new(number_spins, number_bosons, number_fermions);
-                slno.set(first_element.0, first_element.1)
+                let spins = first_element.0.spins().len();
+                let bosons = first_element.0.bosons().len();
+                let fermions = first_element.0.fermions().len();
+                let mut mpmo = MixedPlusMinusOperator::new(spins, bosons, fermions);
+                mpmo.set(first_element.0, first_element.1)
                     .expect("Internal error in set");
                 for (pair, cc) in iterator {
-                    slno.add_operator_product(pair, cc)
+                    mpmo.add_operator_product(pair, cc)
                         .expect("Internal error in add_operator_product");
                 }
-                slno
+                mpmo
             }
-            None => MixedHamiltonianSystem::new([], [], []),
+            None => MixedPlusMinusOperator::new(0, 0, 0),
         }
     }
 }
 
-/// Implements the extend function (Extend trait) of MixedHamiltonianSystem.
+/// Implements the extend function (Extend trait) of MixedPlusMinusOperator.
 ///
-impl Extend<(HermitianMixedProduct, CalculatorComplex)> for MixedHamiltonianSystem {
-    /// Extends the MixedHamiltonianSystem by the specified operations (in Iterator form).
+impl Extend<(MixedPlusMinusProduct, CalculatorComplex)> for MixedPlusMinusOperator {
+    /// Extends the MixedPlusMinusOperator by the specified operations (in Iterator form).
     ///
     /// # Arguments
     ///
-    /// * `iter` - The iterator containing the operations by which to extend the MixedHamiltonianSystem.
+    /// * `iter` - The iterator containing the operations by which to extend the MixedPlusMinusOperator.
     ///
     /// # Panics
     ///
     /// * Internal error in add_operator_product.
-    fn extend<I: IntoIterator<Item = (HermitianMixedProduct, CalculatorComplex)>>(
+    fn extend<I: IntoIterator<Item = (MixedPlusMinusProduct, CalculatorComplex)>>(
         &mut self,
         iter: I,
     ) {
         for (pp, cc) in iter {
             self.add_operator_product(pp, cc)
                 .expect("Internal error in add_operator_product");
         }
     }
 }
 
-/// Implements the format function (Display trait) of MixedHamiltonianSystem.
+/// Implements the format function (Display trait) of MixedPlusMinusOperator.
 ///
-impl fmt::Display for MixedHamiltonianSystem {
-    /// Formats the MixedHamiltonianSystem using the given formatter.
+impl fmt::Display for MixedPlusMinusOperator {
+    /// Formats the MixedPlusMinusOperator using the given formatter.
     ///
     /// # Arguments
     ///
     /// * `f` - The formatter to use.
     ///
     /// # Returns
     ///
-    /// * `std::fmt::Result` - The formatted MixedHamiltonianSystem.
+    /// * `std::fmt::Result` - The formatted MixedPlusMinusOperator.
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        let mut output = "MixedHamiltonianSystem(\n".to_string();
-        output.push_str("number_spins: ");
-        for n in self.number_spins() {
-            write!(output, "{}, ", n)?;
-        }
-        output.push('\n');
-        output.push_str("number_bosons: ");
-        for n in self.number_bosonic_modes() {
-            write!(output, "{}, ", n)?;
-        }
-        output.push('\n');
-        output.push_str("number_fermions: ");
-        for n in self.number_fermionic_modes() {
-            write!(output, "{}, ", n)?;
-        }
-        output.push_str(")\n");
-        output.push('{');
-        let mut vec: Vec<(&HermitianMixedProduct, &CalculatorComplex)> = self.iter().collect();
-        vec.sort_unstable_by(|(left_index, _), (right_index, _)| {
-            left_index
-                .partial_cmp(right_index)
-                .expect("Cannot compare two unsigned integers internal error in struqture.spins")
-        });
-        for (key, val) in vec {
+        let mut output = "MixedPlusMinusOperator{\n".to_string();
+        for (key, val) in self.iter() {
             writeln!(output, "{}: {},", key, val)?;
         }
         output.push('}');
 
         write!(f, "{}", output)
     }
 }
+
+#[cfg(test)]
+mod test {
+    use super::*;
+    use crate::bosons::BosonProduct;
+    use crate::fermions::FermionProduct;
+    use crate::spins::PlusMinusProduct;
+    use serde_test::{assert_tokens, Configure, Token};
+
+    // Test the Clone and PartialEq traits of MixedOperator
+    #[test]
+    fn mpmo_from_mpmos() {
+        let pp: MixedPlusMinusProduct = MixedPlusMinusProduct::new(
+            [PlusMinusProduct::new().z(2)],
+            [BosonProduct::new([0], [3]).unwrap()],
+            [FermionProduct::new([0], [2]).unwrap()],
+        );
+        let mpmos = MixedPlusMinusOperatorSerialize {
+            items: vec![(pp.clone(), 0.5.into(), 0.0.into())],
+            n_spins: 1,
+            n_bosons: 1,
+            n_fermions: 1,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedPlusMinusOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0-alpha.0".to_string(),
+            },
+        };
+        let mut mpmo = MixedPlusMinusOperator::new(1, 1, 1);
+        mpmo.set(pp, CalculatorComplex::from(0.5)).unwrap();
+
+        assert_eq!(
+            MixedPlusMinusOperator::try_from(mpmos.clone()).unwrap(),
+            mpmo
+        );
+        assert_eq!(MixedPlusMinusOperatorSerialize::from(mpmo), mpmos);
+    }
+    // Test the Clone and PartialEq traits of MixedOperator
+    #[test]
+    fn clone_partial_eq() {
+        let pp: MixedPlusMinusProduct = MixedPlusMinusProduct::new(
+            [PlusMinusProduct::new().z(2)],
+            [BosonProduct::new([0], [3]).unwrap()],
+            [FermionProduct::new([0], [2]).unwrap()],
+        );
+        let mpmos = MixedPlusMinusOperatorSerialize {
+            items: vec![(pp, 0.5.into(), 0.0.into())],
+            n_spins: 1,
+            n_bosons: 1,
+            n_fermions: 1,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedPlusMinusOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
+            },
+        };
+
+        // Test Clone trait
+        assert_eq!(mpmos.clone(), mpmos);
+
+        // Test PartialEq trait
+        let pp_1: MixedPlusMinusProduct = MixedPlusMinusProduct::new(
+            [PlusMinusProduct::new().z(2)],
+            [BosonProduct::new([0], [3]).unwrap()],
+            [FermionProduct::new([0], [2]).unwrap()],
+        );
+        let mpmos_1 = MixedPlusMinusOperatorSerialize {
+            items: vec![(pp_1, 0.5.into(), 0.0.into())],
+            n_spins: 1,
+            n_bosons: 1,
+            n_fermions: 1,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedPlusMinusOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
+            },
+        };
+        let pp_2: MixedPlusMinusProduct = MixedPlusMinusProduct::new(
+            [PlusMinusProduct::new().z(0)],
+            [BosonProduct::new([0], [3]).unwrap()],
+            [FermionProduct::new([0], [2]).unwrap()],
+        );
+        let mpmos_2 = MixedPlusMinusOperatorSerialize {
+            items: vec![(pp_2, 0.5.into(), 0.0.into())],
+            n_spins: 1,
+            n_bosons: 1,
+            n_fermions: 1,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedPlusMinusOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
+            },
+        };
+        assert!(mpmos_1 == mpmos);
+        assert!(mpmos == mpmos_1);
+        assert!(mpmos_2 != mpmos);
+        assert!(mpmos != mpmos_2);
+    }
+
+    // Test the Debug trait of MixedOperator
+    #[test]
+    fn debug() {
+        let pp: MixedPlusMinusProduct = MixedPlusMinusProduct::new(
+            [PlusMinusProduct::new().z(2)],
+            [BosonProduct::new([0], [3]).unwrap()],
+            [FermionProduct::new([0], [2]).unwrap()],
+        );
+        let mpmos = MixedPlusMinusOperatorSerialize {
+            items: vec![(pp, 0.5.into(), 0.0.into())],
+            n_spins: 1,
+            n_bosons: 1,
+            n_fermions: 1,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedPlusMinusOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
+            },
+        };
+
+        assert_eq!(
+            format!("{:?}", mpmos),
+            "MixedPlusMinusOperatorSerialize { items: [(MixedPlusMinusProduct { spins: [PlusMinusProduct { items: [(2, Z)] }], bosons: [BosonProduct { creators: [0], annihilators: [3] }], fermions: [FermionProduct { creators: [0], annihilators: [2] }] }, Float(0.5), Float(0.0))], n_spins: 1, n_bosons: 1, n_fermions: 1, serialisation_meta: StruqtureSerialisationMeta { type_name: \"MixedPlusMinusOperator\", min_version: (2, 0, 0), version: \"2.0.0\" } }"
+        );
+    }
+
+    /// Test MixedOperator Serialization and Deserialization traits (readable)
+    #[test]
+    fn serde_readable() {
+        let pp: MixedPlusMinusProduct = MixedPlusMinusProduct::new(
+            [PlusMinusProduct::new().z(2)],
+            [BosonProduct::new([0], [3]).unwrap()],
+            [FermionProduct::new([0], [2]).unwrap()],
+        );
+        let mpmos = MixedPlusMinusOperatorSerialize {
+            items: vec![(pp, 0.5.into(), 0.0.into())],
+            n_spins: 1,
+            n_bosons: 1,
+            n_fermions: 1,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedPlusMinusOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
+            },
+        };
+
+        assert_tokens(
+            &mpmos.readable(),
+            &[
+                Token::Struct {
+                    name: "MixedPlusMinusOperatorSerialize",
+                    len: 5,
+                },
+                Token::Str("items"),
+                Token::Seq { len: Some(1) },
+                Token::Tuple { len: 3 },
+                Token::Str("S2Z:Bc0a3:Fc0a2:"),
+                Token::F64(0.5),
+                Token::F64(0.0),
+                Token::TupleEnd,
+                Token::SeqEnd,
+                Token::Str("n_spins"),
+                Token::U64(1),
+                Token::Str("n_bosons"),
+                Token::U64(1),
+                Token::Str("n_fermions"),
+                Token::U64(1),
+                Token::Str("serialisation_meta"),
+                Token::Struct {
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
+                },
+                Token::Str("type_name"),
+                Token::Str("MixedPlusMinusOperator"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
+                Token::StructEnd,
+                Token::StructEnd,
+            ],
+        );
+    }
+
+    /// Test MixedOperator Serialization and Deserialization traits (compact)
+    #[test]
+    fn serde_compact() {
+        let pp: MixedPlusMinusProduct = MixedPlusMinusProduct::new(
+            [PlusMinusProduct::new().z(2)],
+            [BosonProduct::new([0], [3]).unwrap()],
+            [FermionProduct::new([0], [2]).unwrap()],
+        );
+        let mpmos = MixedPlusMinusOperatorSerialize {
+            items: vec![(pp, 0.5.into(), 0.0.into())],
+            n_spins: 1,
+            n_bosons: 1,
+            n_fermions: 1,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedPlusMinusOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
+            },
+        };
+
+        assert_tokens(
+            &mpmos.compact(),
+            &[
+                Token::Struct {
+                    name: "MixedPlusMinusOperatorSerialize",
+                    len: 5,
+                },
+                Token::Str("items"),
+                Token::Seq { len: Some(1) },
+                Token::Tuple { len: 3 },
+                Token::Tuple { len: 3 },
+                Token::Seq { len: Some(1) },
+                Token::Seq { len: Some(1) },
+                Token::Tuple { len: 2 },
+                Token::U64(2),
+                Token::UnitVariant {
+                    name: "SinglePlusMinusOperator",
+                    variant: "Z",
+                },
+                Token::TupleEnd,
+                Token::SeqEnd,
+                Token::SeqEnd,
+                Token::Seq { len: Some(1) },
+                Token::Tuple { len: 2 },
+                Token::Seq { len: Some(1) },
+                Token::U64(0),
+                Token::SeqEnd,
+                Token::Seq { len: Some(1) },
+                Token::U64(3),
+                Token::SeqEnd,
+                Token::TupleEnd,
+                Token::SeqEnd,
+                Token::Seq { len: Some(1) },
+                Token::Tuple { len: 2 },
+                Token::Seq { len: Some(1) },
+                Token::U64(0),
+                Token::SeqEnd,
+                Token::Seq { len: Some(1) },
+                Token::U64(2),
+                Token::SeqEnd,
+                Token::TupleEnd,
+                Token::SeqEnd,
+                Token::TupleEnd,
+                Token::NewtypeVariant {
+                    name: "CalculatorFloat",
+                    variant: "Float",
+                },
+                Token::F64(0.5),
+                Token::NewtypeVariant {
+                    name: "CalculatorFloat",
+                    variant: "Float",
+                },
+                Token::F64(0.0),
+                Token::TupleEnd,
+                Token::SeqEnd,
+                Token::Str("n_spins"),
+                Token::U64(1),
+                Token::Str("n_bosons"),
+                Token::U64(1),
+                Token::Str("n_fermions"),
+                Token::U64(1),
+                Token::Str("serialisation_meta"),
+                Token::Struct {
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
+                },
+                Token::Str("type_name"),
+                Token::Str("MixedPlusMinusOperator"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
+                Token::StructEnd,
+                Token::StructEnd,
+            ],
+        );
+    }
+}
```

### Comparing `struqture_py-1.6.1/struqture/src/mixed_systems/mixed_hermitian_product.rs` & `struqture_py-2.0.0a0/struqture/src/mixed_systems/mixed_hermitian_product.rs`

 * *Files 1% similar despite different names*

```diff
@@ -69,15 +69,19 @@
         let meta = obj.metadata();
         meta.description = Some("Represents products of Spin operators and Bosonic and Fermionic creators and annhilators by a string. Spin Operators  X, Y and Z are preceeded and creators (c) and annihilators (a) are followed by the modes they are acting on. E.g. :S0X1Y:Bc0a0:Fc0a0:.".to_string());
 
         schemars::schema::Schema::Object(obj)
     }
 }
 
-impl crate::MinSupportedVersion for HermitianMixedProduct {}
+impl crate::SerializationSupport for HermitianMixedProduct {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::HermitianMixedProduct
+    }
+}
 
 impl Serialize for HermitianMixedProduct {
     /// Serialization function for HermitianMixedProduct according to string type.
     ///
     /// # Arguments
     ///
     /// * `self` - HermitianMixedProduct to be serialized.
@@ -198,14 +202,41 @@
             let pp_visitor = HermitianMixedProductVisitor;
 
             deserializer.deserialize_tuple(3, pp_visitor)
         }
     }
 }
 
+impl HermitianMixedProduct {
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(
+        &self,
+    ) -> Result<struqture_one::mixed_systems::HermitianMixedProduct, StruqtureError> {
+        let self_string = self.to_string();
+        let struqture_one_product = struqture_one::mixed_systems::HermitianMixedProduct::from_str(
+            &self_string,
+        )
+        .map_err(|err| StruqtureError::GenericError {
+            msg: format!("{}", err),
+        })?;
+        Ok(struqture_one_product)
+    }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::mixed_systems::HermitianMixedProduct,
+    ) -> Result<Self, StruqtureError> {
+        let value_string = value.to_string();
+        let pauli_product = Self::from_str(&value_string)?;
+        Ok(pauli_product)
+    }
+}
+
 impl MixedIndex for HermitianMixedProduct {
     type SpinIndexType = PauliProduct;
     type BosonicIndexType = BosonProduct;
     type FermionicIndexType = FermionProduct;
 
     /// Creates a new HermitianMixedProduct.
     ///
```

### Comparing `struqture_py-1.6.1/struqture/src/mixed_systems/mixed_noise_operator.rs` & `struqture_py-2.0.0a0/struqture/src/mixed_systems/mixed_noise_operator.rs`

 * *Files 9% similar despite different names*

```diff
@@ -8,31 +8,23 @@
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
 use super::{MixedDecoherenceProduct, MixedIndex, OperateOnMixedSystems};
 use crate::prelude::*;
-use crate::{
-    OperateOnDensityMatrix, StruqtureError, StruqtureVersionSerializable, MINIMUM_STRUQTURE_VERSION,
-};
+use crate::{OperateOnDensityMatrix, StruqtureError};
 use qoqo_calculator::{CalculatorComplex, CalculatorFloat};
 use serde::{Deserialize, Serialize};
 use std::fmt::{self, Write};
 use std::iter::{FromIterator, IntoIterator};
 use std::ops;
 
-#[cfg(feature = "indexed_map_iterators")]
-use indexmap::map::{Entry, Iter, Keys, Values};
-#[cfg(feature = "indexed_map_iterators")]
+use indexmap::map::{Entry, Iter};
 use indexmap::IndexMap;
-#[cfg(not(feature = "indexed_map_iterators"))]
-use std::collections::hash_map::{Entry, Iter, Keys, Values};
-#[cfg(not(feature = "indexed_map_iterators"))]
-use std::collections::HashMap;
 
 /// MixedLindbladNoiseOperators represent noise interactions in the Lindblad equation.
 ///
 /// In the Lindblad equation, Linblad noise operator L_i are not limited to [crate::mixed_systems::MixedDecoherenceProduct] style operators.
 /// We use ([crate::mixed_systems::MixedDecoherenceProduct], [crate::mixed_systems::MixedDecoherenceProduct]) as a unique basis.
 ///
 /// # Example
@@ -55,32 +47,32 @@
 ///
 /// // Access what you set:
 /// assert_eq!(system.get(&(pp_01.clone(), pp_01.clone())), &CalculatorComplex::from(0.5));
 /// assert_eq!(system.get(&(pp_0.clone(), pp_0.clone())), &CalculatorComplex::from(0.2));
 /// ```
 ///
 #[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
-#[serde(from = "MixedLindbladNoiseOperatorSerialize")]
+#[serde(try_from = "MixedLindbladNoiseOperatorSerialize")]
 #[serde(into = "MixedLindbladNoiseOperatorSerialize")]
 pub struct MixedLindbladNoiseOperator {
     /// The internal map representing the noise terms
-    #[cfg(feature = "indexed_map_iterators")]
     internal_map: IndexMap<(MixedDecoherenceProduct, MixedDecoherenceProduct), CalculatorComplex>,
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    internal_map: HashMap<(MixedDecoherenceProduct, MixedDecoherenceProduct), CalculatorComplex>,
     /// Number of Spin subsystems
-    n_spins: usize,
+    pub(crate) n_spins: usize,
     /// Number of Boson subsystems
-    n_bosons: usize,
+    pub(crate) n_bosons: usize,
     /// Number of Fermion subsystems
-    n_fermions: usize,
+    pub(crate) n_fermions: usize,
 }
 
-impl crate::MinSupportedVersion for MixedLindbladNoiseOperator {}
-
+impl crate::SerializationSupport for MixedLindbladNoiseOperator {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::MixedLindbladNoiseOperator
+    }
+}
 #[cfg(feature = "json_schema")]
 impl schemars::JsonSchema for MixedLindbladNoiseOperator {
     fn schema_name() -> String {
         "MixedLindbladNoiseOperator".to_string()
     }
 
     fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
@@ -98,105 +90,92 @@
         MixedDecoherenceProduct,
         CalculatorFloat,
         CalculatorFloat,
     )>,
     n_spins: usize,
     n_bosons: usize,
     n_fermions: usize,
-    /// The struqture version
-    _struqture_version: StruqtureVersionSerializable,
+    serialisation_meta: crate::StruqtureSerialisationMeta,
 }
 
-impl From<MixedLindbladNoiseOperatorSerialize> for MixedLindbladNoiseOperator {
-    fn from(value: MixedLindbladNoiseOperatorSerialize) -> Self {
+impl TryFrom<MixedLindbladNoiseOperatorSerialize> for MixedLindbladNoiseOperator {
+    type Error = StruqtureError;
+    fn try_from(value: MixedLindbladNoiseOperatorSerialize) -> Result<Self, Self::Error> {
+        let target_serialisation_meta =
+            <Self as crate::SerializationSupport>::target_serialisation_meta();
+        crate::check_can_be_deserialised(&target_serialisation_meta, &value.serialisation_meta)?;
         let mut new_noise_op =
             MixedLindbladNoiseOperator::new(value.n_spins, value.n_bosons, value.n_fermions);
         for (key_l, key_r, real, imag) in value.items.iter() {
             new_noise_op
                 .add_operator_product(
                     (key_l.clone(), key_r.clone()),
                     CalculatorComplex::new(real, imag),
                 )
                 .expect("Internal bug in add_operator_product");
         }
-        new_noise_op
+        Ok(new_noise_op)
     }
 }
 
 impl From<MixedLindbladNoiseOperator> for MixedLindbladNoiseOperatorSerialize {
     fn from(value: MixedLindbladNoiseOperator) -> Self {
+        let serialisation_meta = crate::SerializationSupport::struqture_serialisation_meta(&value);
         let new_noise_op: Vec<(
             MixedDecoherenceProduct,
             MixedDecoherenceProduct,
             CalculatorFloat,
             CalculatorFloat,
         )> = value
             .clone()
             .into_iter()
             .map(|((left, right), val)| (left, right, val.re, val.im))
             .collect();
-        let current_version = StruqtureVersionSerializable {
-            major_version: MINIMUM_STRUQTURE_VERSION.0,
-            minor_version: MINIMUM_STRUQTURE_VERSION.1,
-        };
         Self {
             items: new_noise_op,
             n_spins: value.n_spins,
             n_bosons: value.n_bosons,
             n_fermions: value.n_fermions,
-            _struqture_version: current_version,
+            serialisation_meta,
         }
     }
 }
 
 impl<'a> OperateOnDensityMatrix<'a> for MixedLindbladNoiseOperator {
     type Index = (MixedDecoherenceProduct, MixedDecoherenceProduct);
     type Value = CalculatorComplex;
-    type IteratorType =
-        Iter<'a, (MixedDecoherenceProduct, MixedDecoherenceProduct), CalculatorComplex>;
-    type KeyIteratorType =
-        Keys<'a, (MixedDecoherenceProduct, MixedDecoherenceProduct), CalculatorComplex>;
-    type ValueIteratorType =
-        Values<'a, (MixedDecoherenceProduct, MixedDecoherenceProduct), CalculatorComplex>;
 
     // From trait
     fn get(&self, key: &Self::Index) -> &Self::Value {
         match self.internal_map.get(key) {
             Some(value) => value,
             None => &CalculatorComplex::ZERO,
         }
     }
 
     // From trait
-    fn iter(&'a self) -> Self::IteratorType {
+    fn iter(&'a self) -> impl ExactSizeIterator<Item = (&'a Self::Index, &'a Self::Value)> {
         self.internal_map.iter()
     }
 
     // From trait
-    fn keys(&'a self) -> Self::KeyIteratorType {
+    fn keys(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Index> {
         self.internal_map.keys()
     }
 
     // From trait
-    fn values(&'a self) -> Self::ValueIteratorType {
+    fn values(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Value> {
         self.internal_map.values()
     }
 
-    #[cfg(feature = "indexed_map_iterators")]
     // From trait
     fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
         self.internal_map.shift_remove(key)
     }
 
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    // From trait
-    fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
-        self.internal_map.remove(key)
-    }
-
     // From trait
     fn empty_clone(&self, capacity: Option<usize>) -> Self {
         match capacity {
             Some(cap) => Self::with_capacity(self.n_spins, self.n_bosons, self.n_fermions, cap),
             None => Self::new(self.n_spins, self.n_bosons, self.n_fermions),
         }
     }
@@ -244,54 +223,41 @@
                 actual_number_fermion_subsystems: key.1.fermions().len(),
             });
         }
         if value != CalculatorComplex::ZERO {
             Ok(self.internal_map.insert(key, value))
         } else {
             match self.internal_map.entry(key) {
-                #[cfg(feature = "indexed_map_iterators")]
                 Entry::Occupied(val) => Ok(Some(val.shift_remove())),
-                #[cfg(not(feature = "indexed_map_iterators"))]
-                Entry::Occupied(val) => Ok(Some(val.remove())),
                 Entry::Vacant(_) => Ok(None),
             }
         }
     }
 }
 impl<'a> OperateOnMixedSystems<'a> for MixedLindbladNoiseOperator {
     // From trait
-    fn number_spins(&self) -> Vec<usize> {
-        self.current_number_spins()
-    }
-
-    // From trait
     fn current_number_spins(&self) -> Vec<usize> {
-        let mut number_spins: Vec<usize> = (0..self.n_spins).map(|_| 0).collect();
+        let mut current_number_spins: Vec<usize> = (0..self.n_spins).map(|_| 0).collect();
         if !self.internal_map.is_empty() {
             for (key_left, key_right) in self.keys() {
                 for (index, s) in key_left.spins().enumerate() {
                     let maxk = (s.current_number_spins()).max(s.current_number_spins());
-                    if maxk > number_spins[index] {
-                        number_spins[index] = maxk
+                    if maxk > current_number_spins[index] {
+                        current_number_spins[index] = maxk
                     }
                 }
                 for (index, s) in key_right.spins().enumerate() {
                     let maxk = (s.current_number_spins()).max(s.current_number_spins());
-                    if maxk > number_spins[index] {
-                        number_spins[index] = maxk
+                    if maxk > current_number_spins[index] {
+                        current_number_spins[index] = maxk
                     }
                 }
             }
         }
-        number_spins
-    }
-
-    // From trait
-    fn number_bosonic_modes(&self) -> Vec<usize> {
-        self.current_number_bosonic_modes()
+        current_number_spins
     }
 
     // From trait
     fn current_number_bosonic_modes(&self) -> Vec<usize> {
         let mut number_bosons: Vec<usize> = (0..self.n_bosons).map(|_| 0).collect();
         if !self.internal_map.is_empty() {
             for (key_left, key_right) in self.keys() {
@@ -309,19 +275,14 @@
                 }
             }
         }
         number_bosons
     }
 
     // From trait
-    fn number_fermionic_modes(&self) -> Vec<usize> {
-        self.current_number_fermionic_modes()
-    }
-
-    // From trait
     fn current_number_fermionic_modes(&self) -> Vec<usize> {
         let mut number_fermions: Vec<usize> = (0..self.n_fermions).map(|_| 0).collect();
         if !self.internal_map.is_empty() {
             for (key_left, key_right) in self.keys() {
                 for (index, f) in key_left.fermions().enumerate() {
                     let maxk = (f.current_number_modes()).max(f.current_number_modes());
                     if maxk > number_fermions[index] {
@@ -360,17 +321,14 @@
     /// * `n_fermions` - Number of fermionic sub-systems
     ///
     /// # Returns
     ///
     /// * `Self` - The new (empty) MixedLindbladNoiseOperator.
     pub fn new(n_spins: usize, n_bosons: usize, n_fermions: usize) -> Self {
         MixedLindbladNoiseOperator {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::new(),
-            #[cfg(feature = "indexed_map_iterators")]
             internal_map: IndexMap::new(),
             n_spins,
             n_bosons,
             n_fermions,
         }
     }
 
@@ -389,75 +347,78 @@
     pub fn with_capacity(
         n_spins: usize,
         n_bosons: usize,
         n_fermions: usize,
         capacity: usize,
     ) -> Self {
         MixedLindbladNoiseOperator {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::with_capacity(capacity),
-            #[cfg(feature = "indexed_map_iterators")]
             internal_map: IndexMap::with_capacity(capacity),
             n_spins,
             n_bosons,
             n_fermions,
         }
     }
 
-    // /// Separate self into an operator with the terms of given number of qubits and an operator with the remaining operations
-    // ///
-    // /// # Arguments
-    // ///
-    // /// * `number_particles_left` - Number of spins, bosons and fermions to filter for in the left term of the keys.
-    // /// * `number_particles_right` - Number of spins, bosons and fermions to filter for in the right term of the keys.
-    // ///
-    // /// # Returns
-    // ///
-    // /// `Ok((separated, remainder))` - Operator with the noise terms where number_particles matches the number of spins the operator product acts on and Operator with all other contributions.
-    // pub fn separate_into_n_terms(
-    //     &self,
-    //     number_particles_left: (usize, usize, usize),
-    //     number_particles_right: (usize, usize, usize),
-    // ) -> Result<(Self, Self), StruqtureError> {
-    //     let mut separated = Self::default();
-    //     let mut remainder = Self::default();
-    //     for ((prod_l, prod_r), val) in self.iter() {
-    //         if (
-    //             prod_l.spins().len(),
-    //             prod_l.bosons().len(),
-    //             prod_l.fermions().len(),
-    //         ) == number_particles_left
-    //             && (
-    //                 prod_r.spins().len(),
-    //                 prod_r.bosons().len(),
-    //                 prod_r.fermions().len(),
-    //             ) == number_particles_right
-    //         {
-    //             separated.add_operator_product((prod_l.clone(), prod_r.clone()), val.clone())?;
-    //         } else {
-    //             remainder.add_operator_product((prod_l.clone(), prod_r.clone()), val.clone())?;
-    //         }
-    //     }
-    //     Ok((separated, remainder))
-    // }
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(
+        &self,
+    ) -> Result<struqture_one::mixed_systems::MixedLindbladNoiseSystem, StruqtureError> {
+        let mut new_mixed_system = struqture_one::mixed_systems::MixedLindbladNoiseSystem::new(
+            vec![None; self.n_spins],
+            vec![None; self.n_bosons],
+            vec![None; self.n_fermions],
+        );
+        for (key, val) in self.iter() {
+            let one_key_left = key.0.to_struqture_1()?;
+            let one_key_right = key.1.to_struqture_1()?;
+            let _ = struqture_one::OperateOnDensityMatrix::set(
+                &mut new_mixed_system,
+                (one_key_left, one_key_right),
+                val.clone(),
+            );
+        }
+        Ok(new_mixed_system)
+    }
+
+    /// Import from struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::mixed_systems::MixedLindbladNoiseSystem,
+    ) -> Result<Self, StruqtureError> {
+        let mut new_qubit_operator = Self::new(
+            struqture_one::mixed_systems::OperateOnMixedSystems::current_number_spins(value).len(),
+            struqture_one::mixed_systems::OperateOnMixedSystems::current_number_bosonic_modes(
+                value,
+            )
+            .len(),
+            struqture_one::mixed_systems::OperateOnMixedSystems::current_number_fermionic_modes(
+                value,
+            )
+            .len(),
+        );
+        for (key, val) in struqture_one::OperateOnDensityMatrix::iter(value) {
+            let self_key_left = MixedDecoherenceProduct::from_struqture_1(&key.0)?;
+            let self_key_right = MixedDecoherenceProduct::from_struqture_1(&key.1)?;
+            let _ = new_qubit_operator.set((self_key_left, self_key_right), val.clone());
+        }
+        Ok(new_qubit_operator)
+    }
 }
 
 /// Implements the negative sign function of MixedLindbladNoiseOperator.
 ///
 impl ops::Neg for MixedLindbladNoiseOperator {
     type Output = MixedLindbladNoiseOperator;
     /// Implement minus sign for MixedLindbladNoiseOperator.
     ///
     /// # Returns
     ///
     /// * `Self` - The MixedLindbladNoiseOperator * -1.
     fn neg(self) -> Self {
-        #[cfg(not(feature = "indexed_map_iterators"))]
-        let mut internal = HashMap::with_capacity(self.len());
-        #[cfg(feature = "indexed_map_iterators")]
         let mut internal = IndexMap::with_capacity(self.len());
         let n_spins = self.n_spins;
         let n_bosons = self.n_bosons;
         let n_fermions = self.n_fermions;
         for (key, val) in self {
             internal.insert(key.clone(), val.neg());
         }
@@ -544,17 +505,14 @@
     /// * `other` - The CalculatorComplex or CalculatorFloat by which to multiply.
     ///
     /// # Returns
     ///
     /// * `Self` - The MixedLindbladNoiseOperator multiplied by the CalculatorComplex/CalculatorFloat.
     fn mul(self, other: T) -> Self {
         let other_cc = Into::<CalculatorComplex>::into(other);
-        #[cfg(not(feature = "indexed_map_iterators"))]
-        let mut internal = HashMap::with_capacity(self.len());
-        #[cfg(feature = "indexed_map_iterators")]
         let mut internal = IndexMap::with_capacity(self.len());
         let n_spins = self.n_spins;
         let n_bosons = self.n_bosons;
         let n_fermions = self.n_fermions;
         for (key, val) in self {
             internal.insert(key, val * other_cc.clone());
         }
@@ -570,20 +528,14 @@
 /// Implements the into_iter function (IntoIterator trait) of MixedLindbladNoiseOperator.
 ///
 impl IntoIterator for MixedLindbladNoiseOperator {
     type Item = (
         (MixedDecoherenceProduct, MixedDecoherenceProduct),
         CalculatorComplex,
     );
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    type IntoIter = std::collections::hash_map::IntoIter<
-        (MixedDecoherenceProduct, MixedDecoherenceProduct),
-        CalculatorComplex,
-    >;
-    #[cfg(feature = "indexed_map_iterators")]
     type IntoIter = indexmap::map::IntoIter<
         (MixedDecoherenceProduct, MixedDecoherenceProduct),
         CalculatorComplex,
     >;
     /// Returns the MixedLindbladNoiseOperator in Iterator form.
     ///
     /// # Returns
@@ -728,58 +680,63 @@
     use super::*;
     use crate::bosons::BosonProduct;
     use crate::fermions::FermionProduct;
     use crate::spins::DecoherenceProduct;
     use serde_test::{assert_tokens, Configure, Token};
     use std::str::FromStr;
 
-    // Test the Clone and PartialEq traits of SpinOperator
+    // Test the Clone and PartialEq traits of QubitOperator
     #[test]
     fn so_from_sos() {
         let spins = DecoherenceProduct::from_str("0X").unwrap();
         let creators = &[0];
         let annihilators = &[3];
         let bosons = BosonProduct::new(creators.to_vec(), annihilators.to_vec()).unwrap();
         let fermions = FermionProduct::new(creators.to_vec(), annihilators.to_vec()).unwrap();
         let pp = MixedDecoherenceProduct::new([spins], [bosons], [fermions]).unwrap();
 
         let sos = MixedLindbladNoiseOperatorSerialize {
             items: vec![(pp.clone(), pp.clone(), 0.5.into(), 0.0.into())],
             n_spins: 1,
             n_bosons: 1,
             n_fermions: 1,
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0-alpha.0".to_string(),
             },
         };
         let mut so = MixedLindbladNoiseOperator::new(1, 1, 1);
         so.set((pp.clone(), pp), CalculatorComplex::from(0.5))
             .unwrap();
 
-        assert_eq!(MixedLindbladNoiseOperator::from(sos.clone()), so);
+        assert_eq!(
+            MixedLindbladNoiseOperator::try_from(sos.clone()).unwrap(),
+            so
+        );
         assert_eq!(MixedLindbladNoiseOperatorSerialize::from(so), sos);
     }
-    // Test the Clone and PartialEq traits of SpinOperator
+    // Test the Clone and PartialEq traits of QubitOperator
     #[test]
     fn clone_partial_eq() {
         let spins = DecoherenceProduct::from_str("0X").unwrap();
         let creators = &[0];
         let annihilators = &[3];
         let bosons = BosonProduct::new(creators.to_vec(), annihilators.to_vec()).unwrap();
         let fermions = FermionProduct::new(creators.to_vec(), annihilators.to_vec()).unwrap();
         let pp = MixedDecoherenceProduct::new([spins], [bosons], [fermions]).unwrap();
         let sos = MixedLindbladNoiseOperatorSerialize {
             items: vec![(pp.clone(), pp, 0.5.into(), 0.0.into())],
             n_spins: 1,
             n_bosons: 1,
             n_fermions: 1,
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         // Test Clone trait
         assert_eq!(sos.clone(), sos);
 
         // Test PartialEq trait
@@ -790,84 +747,88 @@
         let fermions = FermionProduct::new(creators.to_vec(), annihilators.to_vec()).unwrap();
         let pp_1 = MixedDecoherenceProduct::new([spins], [bosons], [fermions]).unwrap();
         let sos_1 = MixedLindbladNoiseOperatorSerialize {
             items: vec![(pp_1.clone(), pp_1, 0.5.into(), 0.0.into())],
             n_spins: 1,
             n_bosons: 1,
             n_fermions: 1,
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
         let spins = DecoherenceProduct::from_str("0X").unwrap();
         let creators = &[0];
         let annihilators = &[4];
         let bosons = BosonProduct::new(creators.to_vec(), annihilators.to_vec()).unwrap();
         let fermions = FermionProduct::new(creators.to_vec(), annihilators.to_vec()).unwrap();
         let pp_2 = MixedDecoherenceProduct::new([spins], [bosons], [fermions]).unwrap();
         let sos_2 = MixedLindbladNoiseOperatorSerialize {
             items: vec![(pp_2.clone(), pp_2, 0.5.into(), 0.0.into())],
             n_spins: 1,
             n_bosons: 1,
             n_fermions: 1,
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
         assert!(sos_1 == sos);
         assert!(sos == sos_1);
         assert!(sos_2 != sos);
         assert!(sos != sos_2);
     }
 
-    // Test the Debug trait of SpinOperator
+    // Test the Debug trait of QubitOperator
     #[test]
     fn debug() {
         let spins = DecoherenceProduct::from_str("0X").unwrap();
         let creators = &[0];
         let annihilators = &[3];
         let bosons = BosonProduct::new(creators.to_vec(), annihilators.to_vec()).unwrap();
         let fermions = FermionProduct::new(creators.to_vec(), annihilators.to_vec()).unwrap();
         let pp = MixedDecoherenceProduct::new([spins], [bosons], [fermions]).unwrap();
         let sos = MixedLindbladNoiseOperatorSerialize {
             items: vec![(pp.clone(), pp, 0.5.into(), 0.0.into())],
             n_spins: 1,
             n_bosons: 1,
             n_fermions: 1,
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_eq!(
             format!("{:?}", sos),
-            "MixedLindbladNoiseOperatorSerialize { items: [(MixedDecoherenceProduct { spins: [DecoherenceProduct { items: [(0, X)] }], bosons: [BosonProduct { creators: [0], annihilators: [3] }], fermions: [FermionProduct { creators: [0], annihilators: [3] }] }, MixedDecoherenceProduct { spins: [DecoherenceProduct { items: [(0, X)] }], bosons: [BosonProduct { creators: [0], annihilators: [3] }], fermions: [FermionProduct { creators: [0], annihilators: [3] }] }, Float(0.5), Float(0.0))], n_spins: 1, n_bosons: 1, n_fermions: 1, _struqture_version: StruqtureVersionSerializable { major_version: 1, minor_version: 0 } }"
+            "MixedLindbladNoiseOperatorSerialize { items: [(MixedDecoherenceProduct { spins: [DecoherenceProduct { items: [(0, X)] }], bosons: [BosonProduct { creators: [0], annihilators: [3] }], fermions: [FermionProduct { creators: [0], annihilators: [3] }] }, MixedDecoherenceProduct { spins: [DecoherenceProduct { items: [(0, X)] }], bosons: [BosonProduct { creators: [0], annihilators: [3] }], fermions: [FermionProduct { creators: [0], annihilators: [3] }] }, Float(0.5), Float(0.0))], n_spins: 1, n_bosons: 1, n_fermions: 1, serialisation_meta: StruqtureSerialisationMeta { type_name: \"MixedLindbladNoiseOperator\", min_version: (2, 0, 0), version: \"2.0.0\" } }"
         );
     }
 
-    /// Test SpinOperator Serialization and Deserialization traits (readable)
+    /// Test QubitOperator Serialization and Deserialization traits (readable)
     #[test]
     fn serde_readable() {
         let spins = DecoherenceProduct::from_str("0X").unwrap();
         let creators = &[0];
         let annihilators = &[3];
         let bosons = BosonProduct::new(creators.to_vec(), annihilators.to_vec()).unwrap();
         let fermions = FermionProduct::new(creators.to_vec(), annihilators.to_vec()).unwrap();
         let pp = MixedDecoherenceProduct::new([spins], [bosons], [fermions]).unwrap();
         let sos = MixedLindbladNoiseOperatorSerialize {
             items: vec![(pp.clone(), pp, 0.5.into(), 0.0.into())],
             n_spins: 1,
             n_bosons: 1,
             n_fermions: 1,
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_tokens(
             &sos.readable(),
             &[
                 Token::Struct {
@@ -885,46 +846,53 @@
                 Token::SeqEnd,
                 Token::Str("n_spins"),
                 Token::U64(1),
                 Token::Str("n_bosons"),
                 Token::U64(1),
                 Token::Str("n_fermions"),
                 Token::U64(1),
-                Token::Str("_struqture_version"),
+                Token::Str("serialisation_meta"),
                 Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
                 },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(0),
+                Token::Str("type_name"),
+                Token::Str("MixedLindbladNoiseOperator"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
                 Token::StructEnd,
                 Token::StructEnd,
             ],
         );
     }
 
-    /// Test SpinOperator Serialization and Deserialization traits (compact)
+    /// Test QubitOperator Serialization and Deserialization traits (compact)
     #[test]
     fn serde_compact() {
         let spins = DecoherenceProduct::from_str("0X").unwrap();
         let creators = &[0];
         let annihilators = &[3];
         let bosons = BosonProduct::new(creators.to_vec(), annihilators.to_vec()).unwrap();
         let fermions = FermionProduct::new(creators.to_vec(), annihilators.to_vec()).unwrap();
         let pp = MixedDecoherenceProduct::new([spins], [bosons], [fermions]).unwrap();
         let sos = MixedLindbladNoiseOperatorSerialize {
             items: vec![(pp.clone(), pp, 0.5.into(), 0.0.into())],
             n_spins: 1,
             n_bosons: 1,
             n_fermions: 1,
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_tokens(
             &sos.compact(),
             &[
                 Token::Struct {
@@ -1014,22 +982,28 @@
                 Token::SeqEnd,
                 Token::Str("n_spins"),
                 Token::U64(1),
                 Token::Str("n_bosons"),
                 Token::U64(1),
                 Token::Str("n_fermions"),
                 Token::U64(1),
-                Token::Str("_struqture_version"),
+                Token::Str("serialisation_meta"),
                 Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
                 },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(0),
+                Token::Str("type_name"),
+                Token::Str("MixedLindbladNoiseOperator"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
                 Token::StructEnd,
                 Token::StructEnd,
             ],
         );
     }
 }
```

### Comparing `struqture_py-1.6.1/struqture/src/mixed_systems/mixed_operator.rs` & `struqture_py-2.0.0a0/struqture/src/mixed_systems/mixed_operator.rs`

 * *Files 8% similar despite different names*

```diff
@@ -7,32 +7,23 @@
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
 use super::{MixedIndex, MixedProduct, OperateOnMixedSystems};
-use crate::{
-    ModeIndex, OperateOnDensityMatrix, OperateOnState, SpinIndex, StruqtureError,
-    StruqtureVersionSerializable, MINIMUM_STRUQTURE_VERSION,
-};
+use crate::{ModeIndex, OperateOnDensityMatrix, OperateOnState, SpinIndex, StruqtureError};
 use qoqo_calculator::{CalculatorComplex, CalculatorFloat};
 use serde::{Deserialize, Serialize};
 use std::fmt::{self, Write};
 use std::iter::{FromIterator, IntoIterator};
 use std::ops;
 
-#[cfg(feature = "indexed_map_iterators")]
-use indexmap::map::{Entry, Iter, Keys, Values};
-#[cfg(feature = "indexed_map_iterators")]
+use indexmap::map::{Entry, Iter};
 use indexmap::IndexMap;
-#[cfg(not(feature = "indexed_map_iterators"))]
-use std::collections::hash_map::{Entry, Iter, Keys, Values};
-#[cfg(not(feature = "indexed_map_iterators"))]
-use std::collections::HashMap;
 
 /// MixedOperators are combinations of MixedProducts with specific CalculatorComplex coefficients.
 ///
 /// # Example
 ///
 /// ```
 /// use struqture::prelude::*;
@@ -51,32 +42,32 @@
 ///
 /// // Access what you set:
 /// assert_eq!(sh.get(&mp_1), &CalculatorComplex::from(0.5));
 /// assert_eq!(sh.get(&mp_0), &CalculatorComplex::from(0.2));
 /// ```
 ///
 #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
-#[serde(from = "MixedOperatorSerialize")]
+#[serde(try_from = "MixedOperatorSerialize")]
 #[serde(into = "MixedOperatorSerialize")]
 pub struct MixedOperator {
     /// The internal HashMap of MixedProducts and coefficients (CalculatorComplex)
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    internal_map: HashMap<MixedProduct, CalculatorComplex>,
-    #[cfg(feature = "indexed_map_iterators")]
     internal_map: IndexMap<MixedProduct, CalculatorComplex>,
     /// Number of Spin subsystems
     n_spins: usize,
     /// Number of Boson subsystems
     n_bosons: usize,
     /// Number of Fermion subsystems
     n_fermions: usize,
 }
 
-impl crate::MinSupportedVersion for MixedOperator {}
-
+impl crate::SerializationSupport for MixedOperator {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::MixedOperator
+    }
+}
 #[cfg(feature = "json_schema")]
 impl schemars::JsonSchema for MixedOperator {
     fn schema_name() -> String {
         "MixedOperator".to_string()
     }
 
     fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
@@ -88,91 +79,82 @@
 #[cfg_attr(feature = "json_schema", derive(schemars::JsonSchema))]
 #[cfg_attr(feature = "json_schema", schemars(deny_unknown_fields))]
 struct MixedOperatorSerialize {
     items: Vec<(MixedProduct, CalculatorFloat, CalculatorFloat)>,
     n_spins: usize,
     n_bosons: usize,
     n_fermions: usize,
-    _struqture_version: StruqtureVersionSerializable,
+    serialisation_meta: crate::StruqtureSerialisationMeta,
 }
 
-impl From<MixedOperatorSerialize> for MixedOperator {
-    fn from(value: MixedOperatorSerialize) -> Self {
+impl TryFrom<MixedOperatorSerialize> for MixedOperator {
+    type Error = StruqtureError;
+    fn try_from(value: MixedOperatorSerialize) -> Result<Self, Self::Error> {
+        let target_serialisation_meta =
+            <Self as crate::SerializationSupport>::target_serialisation_meta();
+        crate::check_can_be_deserialised(&target_serialisation_meta, &value.serialisation_meta)?;
         let mut new_noise_op = MixedOperator::new(value.n_spins, value.n_bosons, value.n_fermions);
         for (key, real, imag) in value.items.iter() {
             let _ =
                 new_noise_op.add_operator_product(key.clone(), CalculatorComplex::new(real, imag));
         }
-        new_noise_op
+        Ok(new_noise_op)
     }
 }
 
 impl From<MixedOperator> for MixedOperatorSerialize {
     fn from(value: MixedOperator) -> Self {
+        let serialisation_meta = crate::SerializationSupport::struqture_serialisation_meta(&value);
         let new_noise_op: Vec<(MixedProduct, CalculatorFloat, CalculatorFloat)> = value
             .clone()
             .into_iter()
             .map(|(key, val)| (key, val.re, val.im))
             .collect();
-        let current_version = StruqtureVersionSerializable {
-            major_version: MINIMUM_STRUQTURE_VERSION.0,
-            minor_version: MINIMUM_STRUQTURE_VERSION.1,
-        };
         Self {
             items: new_noise_op,
             n_spins: value.n_spins,
             n_bosons: value.n_bosons,
             n_fermions: value.n_fermions,
-            _struqture_version: current_version,
+            serialisation_meta,
         }
     }
 }
 
 impl<'a> OperateOnDensityMatrix<'a> for MixedOperator {
     type Index = MixedProduct;
     type Value = CalculatorComplex;
-    type IteratorType = Iter<'a, Self::Index, Self::Value>;
-    type KeyIteratorType = Keys<'a, Self::Index, Self::Value>;
-    type ValueIteratorType = Values<'a, Self::Index, Self::Value>;
 
     // From trait
     fn get(&self, key: &Self::Index) -> &Self::Value {
         match self.internal_map.get(key) {
             Some(value) => value,
             None => &CalculatorComplex::ZERO,
         }
     }
 
     // From trait
-    fn iter(&'a self) -> Self::IteratorType {
+    fn iter(&'a self) -> impl ExactSizeIterator<Item = (&'a Self::Index, &'a Self::Value)> {
         self.internal_map.iter()
     }
 
     // From trait
-    fn keys(&'a self) -> Self::KeyIteratorType {
+    fn keys(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Index> {
         self.internal_map.keys()
     }
 
     // From trait
-    fn values(&'a self) -> Self::ValueIteratorType {
+    fn values(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Value> {
         self.internal_map.values()
     }
 
-    #[cfg(feature = "indexed_map_iterators")]
     // From trait
     fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
         self.internal_map.shift_remove(key)
     }
 
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    // From trait
-    fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
-        self.internal_map.remove(key)
-    }
-
     // From trait
     fn empty_clone(&self, capacity: Option<usize>) -> Self {
         match capacity {
             Some(cap) => Self::with_capacity(self.n_spins, self.n_bosons, self.n_fermions, cap),
             None => Self::new(self.n_spins, self.n_bosons, self.n_fermions),
         }
     }
@@ -208,18 +190,15 @@
             });
         }
         if value.re != CalculatorFloat::ZERO || value.im != CalculatorFloat::ZERO {
             // Catch on diagonals with non-zero imaginary values
             Ok(self.internal_map.insert(key, value))
         } else {
             match self.internal_map.entry(key) {
-                #[cfg(feature = "indexed_map_iterators")]
                 Entry::Occupied(val) => Ok(Some(val.shift_remove())),
-                #[cfg(not(feature = "indexed_map_iterators"))]
-                Entry::Occupied(val) => Ok(Some(val.remove())),
                 Entry::Vacant(_) => Ok(None),
             }
         }
     }
 }
 
 impl<'a> OperateOnState<'a> for MixedOperator {
@@ -227,35 +206,25 @@
     fn hermitian_conjugate(&self) -> Self {
         self.clone()
     }
 }
 
 impl<'a> OperateOnMixedSystems<'a> for MixedOperator {
     // From trait
-    fn number_spins(&self) -> Vec<usize> {
-        self.current_number_spins()
-    }
-
-    // From trait
     fn current_number_spins(&self) -> Vec<usize> {
-        let mut number_spins: Vec<usize> = (0..self.n_spins).map(|_| 0).collect();
+        let mut current_number_spins: Vec<usize> = (0..self.n_spins).map(|_| 0).collect();
         for key in self.keys() {
             for (index, s) in key.spins().enumerate() {
                 let maxk = s.current_number_spins();
-                if maxk > number_spins[index] {
-                    number_spins[index] = maxk
+                if maxk > current_number_spins[index] {
+                    current_number_spins[index] = maxk
                 }
             }
         }
-        number_spins
-    }
-
-    // From trait
-    fn number_bosonic_modes(&self) -> Vec<usize> {
-        self.current_number_bosonic_modes()
+        current_number_spins
     }
 
     // From trait
     fn current_number_bosonic_modes(&self) -> Vec<usize> {
         let mut number_bosons: Vec<usize> = (0..self.n_bosons).map(|_| 0).collect();
         for key in self.keys() {
             for (index, s) in key.bosons().enumerate() {
@@ -265,19 +234,14 @@
                 }
             }
         }
         number_bosons
     }
 
     // From trait
-    fn number_fermionic_modes(&self) -> Vec<usize> {
-        self.current_number_fermionic_modes()
-    }
-
-    // From trait
     fn current_number_fermionic_modes(&self) -> Vec<usize> {
         let mut number_fermions: Vec<usize> = (0..self.n_fermions).map(|_| 0).collect();
         for key in self.keys() {
             for (index, s) in key.fermions().enumerate() {
                 let maxk = s.current_number_modes();
                 if maxk > number_fermions[index] {
                     number_fermions[index] = maxk
@@ -308,17 +272,14 @@
     /// * `n_fermions` - Number of fermionic sub-systems
     ///
     /// # Returns
     ///
     /// * `Self` - The new (empty) MixedOperator.
     pub fn new(n_spins: usize, n_bosons: usize, n_fermions: usize) -> Self {
         MixedOperator {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::new(),
-            #[cfg(feature = "indexed_map_iterators")]
             internal_map: IndexMap::new(),
             n_spins,
             n_bosons,
             n_fermions,
         }
     }
 
@@ -337,53 +298,64 @@
     pub fn with_capacity(
         n_spins: usize,
         n_bosons: usize,
         n_fermions: usize,
         capacity: usize,
     ) -> Self {
         Self {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::with_capacity(capacity),
-            #[cfg(feature = "indexed_map_iterators")]
             internal_map: IndexMap::with_capacity(capacity),
             n_spins,
             n_bosons,
             n_fermions,
         }
     }
 
-    // /// Separate self into an operator with the terms of given number of spins, bosons and fermions and an operator with the remaining operations
-    // ///
-    // /// # Arguments
-    // ///
-    // /// * `number_particles` - Number of spins, bosons and fermions to filter for in the keys.
-    // ///
-    // /// # Returns
-    // ///
-    // /// `Ok((separated, remainder))` - Operator with the noise terms where number_particles matches the number of spins the operator product acts on and Operator with all other contributions.
-    // pub fn separate_into_n_terms(
-    //     &self,
-    //     number_particles: (usize, usize, usize),
-    // ) -> Result<(Self, Self), StruqtureError> {
-    //     let mut separated = Self::default();
-    //     let mut remainder = Self::default();
-    //     for (prod, val) in self.iter() {
-    //         if (
-    //             prod.spins().len(),
-    //             prod.bosons().len(),
-    //             prod.fermions().len(),
-    //         ) == number_particles
-    //         {
-    //             separated.add_operator_product(prod.clone(), val.clone())?;
-    //         } else {
-    //             remainder.add_operator_product(prod.clone(), val.clone())?;
-    //         }
-    //     }
-    //     Ok((separated, remainder))
-    // }
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(
+        &self,
+    ) -> Result<struqture_one::mixed_systems::MixedSystem, StruqtureError> {
+        let mut new_mixed_system = struqture_one::mixed_systems::MixedSystem::new(
+            vec![None; self.n_spins],
+            vec![None; self.n_bosons],
+            vec![None; self.n_fermions],
+        );
+        for (key, val) in self.iter() {
+            let one_key = key.to_struqture_1()?;
+            let _ = struqture_one::OperateOnDensityMatrix::set(
+                &mut new_mixed_system,
+                one_key,
+                val.clone(),
+            );
+        }
+        Ok(new_mixed_system)
+    }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::mixed_systems::MixedSystem,
+    ) -> Result<Self, StruqtureError> {
+        let mut new_qubit_operator = Self::new(
+            struqture_one::mixed_systems::OperateOnMixedSystems::current_number_spins(value).len(),
+            struqture_one::mixed_systems::OperateOnMixedSystems::current_number_bosonic_modes(
+                value,
+            )
+            .len(),
+            struqture_one::mixed_systems::OperateOnMixedSystems::current_number_fermionic_modes(
+                value,
+            )
+            .len(),
+        );
+        for (key, val) in struqture_one::OperateOnDensityMatrix::iter(value) {
+            let self_key = MixedProduct::from_struqture_1(key)?;
+            let _ = new_qubit_operator.set(self_key, val.clone());
+        }
+        Ok(new_qubit_operator)
+    }
 }
 
 /// Implements the negative sign function of MixedOperator.
 ///
 impl ops::Neg for MixedOperator {
     type Output = MixedOperator;
     /// Implement minus sign for MixedOperator.
@@ -528,17 +500,14 @@
     }
 }
 
 /// Implements the into_iter function (IntoIterator trait) of MixedOperator.
 ///
 impl IntoIterator for MixedOperator {
     type Item = (MixedProduct, CalculatorComplex);
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    type IntoIter = std::collections::hash_map::IntoIter<MixedProduct, CalculatorComplex>;
-    #[cfg(feature = "indexed_map_iterators")]
     type IntoIter = indexmap::map::IntoIter<MixedProduct, CalculatorComplex>;
     /// Returns the MixedOperator in Iterator form.
     ///
     /// # Returns
     ///
     /// * `Self::IntoIter` - The MixedOperator in Iterator form.
     fn into_iter(self) -> Self::IntoIter {
@@ -647,56 +616,58 @@
 mod test {
     use super::*;
     use crate::bosons::BosonProduct;
     use crate::fermions::FermionProduct;
     use crate::spins::PauliProduct;
     use serde_test::{assert_tokens, Configure, Token};
 
-    // Test the Clone and PartialEq traits of SpinOperator
+    // Test the Clone and PartialEq traits of MixedOperator
     #[test]
     fn so_from_sos() {
         let pp: MixedProduct = MixedProduct::new(
             [PauliProduct::new().z(2)],
             [BosonProduct::new([0], [3]).unwrap()],
             [FermionProduct::new([0], [2]).unwrap()],
         )
         .unwrap();
         let sos = MixedOperatorSerialize {
             items: vec![(pp.clone(), 0.5.into(), 0.0.into())],
             n_spins: 1,
             n_bosons: 1,
             n_fermions: 1,
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0-alpha.0".to_string(),
             },
         };
         let mut so = MixedOperator::new(1, 1, 1);
         so.set(pp, CalculatorComplex::from(0.5)).unwrap();
 
-        assert_eq!(MixedOperator::from(sos.clone()), so);
+        assert_eq!(MixedOperator::try_from(sos.clone()).unwrap(), so);
         assert_eq!(MixedOperatorSerialize::from(so), sos);
     }
-    // Test the Clone and PartialEq traits of SpinOperator
+    // Test the Clone and PartialEq traits of MixedOperator
     #[test]
     fn clone_partial_eq() {
         let pp: MixedProduct = MixedProduct::new(
             [PauliProduct::new().z(2)],
             [BosonProduct::new([0], [3]).unwrap()],
             [FermionProduct::new([0], [2]).unwrap()],
         )
         .unwrap();
         let sos = MixedOperatorSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
             n_spins: 1,
             n_bosons: 1,
             n_fermions: 1,
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         // Test Clone trait
         assert_eq!(sos.clone(), sos);
 
         // Test PartialEq trait
@@ -707,84 +678,88 @@
         )
         .unwrap();
         let sos_1 = MixedOperatorSerialize {
             items: vec![(pp_1, 0.5.into(), 0.0.into())],
             n_spins: 1,
             n_bosons: 1,
             n_fermions: 1,
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
         let pp_2: MixedProduct = MixedProduct::new(
             [PauliProduct::new().z(0)],
             [BosonProduct::new([0], [3]).unwrap()],
             [FermionProduct::new([0], [2]).unwrap()],
         )
         .unwrap();
         let sos_2 = MixedOperatorSerialize {
             items: vec![(pp_2, 0.5.into(), 0.0.into())],
             n_spins: 1,
             n_bosons: 1,
             n_fermions: 1,
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
         assert!(sos_1 == sos);
         assert!(sos == sos_1);
         assert!(sos_2 != sos);
         assert!(sos != sos_2);
     }
 
-    // Test the Debug trait of SpinOperator
+    // Test the Debug trait of MixedOperator
     #[test]
     fn debug() {
         let pp: MixedProduct = MixedProduct::new(
             [PauliProduct::new().z(2)],
             [BosonProduct::new([0], [3]).unwrap()],
             [FermionProduct::new([0], [2]).unwrap()],
         )
         .unwrap();
         let sos = MixedOperatorSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
             n_spins: 1,
             n_bosons: 1,
             n_fermions: 1,
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_eq!(
             format!("{:?}", sos),
-            "MixedOperatorSerialize { items: [(MixedProduct { spins: [PauliProduct { items: [(2, Z)] }], bosons: [BosonProduct { creators: [0], annihilators: [3] }], fermions: [FermionProduct { creators: [0], annihilators: [2] }] }, Float(0.5), Float(0.0))], n_spins: 1, n_bosons: 1, n_fermions: 1, _struqture_version: StruqtureVersionSerializable { major_version: 1, minor_version: 0 } }"
+            "MixedOperatorSerialize { items: [(MixedProduct { spins: [PauliProduct { items: [(2, Z)] }], bosons: [BosonProduct { creators: [0], annihilators: [3] }], fermions: [FermionProduct { creators: [0], annihilators: [2] }] }, Float(0.5), Float(0.0))], n_spins: 1, n_bosons: 1, n_fermions: 1, serialisation_meta: StruqtureSerialisationMeta { type_name: \"MixedOperator\", min_version: (2, 0, 0), version: \"2.0.0\" } }"
         );
     }
 
-    /// Test SpinOperator Serialization and Deserialization traits (readable)
+    /// Test MixedOperator Serialization and Deserialization traits (readable)
     #[test]
     fn serde_readable() {
         let pp: MixedProduct = MixedProduct::new(
             [PauliProduct::new().z(2)],
             [BosonProduct::new([0], [3]).unwrap()],
             [FermionProduct::new([0], [2]).unwrap()],
         )
         .unwrap();
         let sos = MixedOperatorSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
             n_spins: 1,
             n_bosons: 1,
             n_fermions: 1,
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_tokens(
             &sos.readable(),
             &[
                 Token::Struct {
@@ -801,46 +776,53 @@
                 Token::SeqEnd,
                 Token::Str("n_spins"),
                 Token::U64(1),
                 Token::Str("n_bosons"),
                 Token::U64(1),
                 Token::Str("n_fermions"),
                 Token::U64(1),
-                Token::Str("_struqture_version"),
+                Token::Str("serialisation_meta"),
                 Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
                 },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(0),
+                Token::Str("type_name"),
+                Token::Str("MixedOperator"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
                 Token::StructEnd,
                 Token::StructEnd,
             ],
         );
     }
 
-    /// Test SpinOperator Serialization and Deserialization traits (compact)
+    /// Test MixedOperator Serialization and Deserialization traits (compact)
     #[test]
     fn serde_compact() {
         let pp: MixedProduct = MixedProduct::new(
             [PauliProduct::new().z(2)],
             [BosonProduct::new([0], [3]).unwrap()],
             [FermionProduct::new([0], [2]).unwrap()],
         )
         .unwrap();
         let sos = MixedOperatorSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
             n_spins: 1,
             n_bosons: 1,
             n_fermions: 1,
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "MixedOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_tokens(
             &sos.compact(),
             &[
                 Token::Struct {
@@ -852,15 +834,15 @@
                 Token::Tuple { len: 3 },
                 Token::Tuple { len: 3 },
                 Token::Seq { len: Some(1) },
                 Token::Seq { len: Some(1) },
                 Token::Tuple { len: 2 },
                 Token::U64(2),
                 Token::UnitVariant {
-                    name: "SingleSpinOperator",
+                    name: "SingleQubitOperator",
                     variant: "Z",
                 },
                 Token::TupleEnd,
                 Token::SeqEnd,
                 Token::SeqEnd,
                 Token::Seq { len: Some(1) },
                 Token::Tuple { len: 2 },
@@ -897,22 +879,28 @@
                 Token::SeqEnd,
                 Token::Str("n_spins"),
                 Token::U64(1),
                 Token::Str("n_bosons"),
                 Token::U64(1),
                 Token::Str("n_fermions"),
                 Token::U64(1),
-                Token::Str("_struqture_version"),
+                Token::Str("serialisation_meta"),
                 Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
                 },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(0),
+                Token::Str("type_name"),
+                Token::Str("MixedOperator"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
                 Token::StructEnd,
                 Token::StructEnd,
             ],
         );
     }
 }
```

### Comparing `struqture_py-1.6.1/struqture/src/mixed_systems/mixed_plus_minus_product.rs` & `struqture_py-2.0.0a0/struqture/src/mixed_systems/mixed_plus_minus_product.rs`

 * *Files 3% similar despite different names*

```diff
@@ -69,17 +69,17 @@
         let meta = obj.metadata();
         meta.description = Some("Represents products of Spin operators and Bosonic and Fermionic creators and annhilators by a string. Spin Operators  +, - and Z are preceeded and creators (c) and annihilators (a) are followed by the modes they are acting on. E.g. :S0+1+:Bc0a1:Fc0a2:.".to_string());
 
         schemars::schema::Schema::Object(obj)
     }
 }
 
-impl crate::MinSupportedVersion for MixedPlusMinusProduct {
-    fn min_supported_version() -> (usize, usize, usize) {
-        (1, 2, 0)
+impl crate::SerializationSupport for MixedPlusMinusProduct {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::MixedPlusMinusProduct
     }
 }
 
 impl Serialize for MixedPlusMinusProduct {
     /// Serialization function for MixedPlusMinusProduct according to string type.
     ///
     /// # Arguments
@@ -275,14 +275,39 @@
     ///
     /// # Returns
     ///
     /// * `Vec<usize>` - Number of fermions in each fermion sub-system.
     pub fn current_number_fermionic_modes(&self) -> Vec<usize> {
         self.fermions().map(|f| f.current_number_modes()).collect()
     }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(
+        &self,
+    ) -> Result<struqture_one::mixed_systems::MixedPlusMinusProduct, StruqtureError> {
+        let self_string = self.to_string();
+        let struqture_one_product = struqture_one::mixed_systems::MixedPlusMinusProduct::from_str(
+            &self_string,
+        )
+        .map_err(|err| StruqtureError::GenericError {
+            msg: format!("{}", err),
+        })?;
+        Ok(struqture_one_product)
+    }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::mixed_systems::MixedPlusMinusProduct,
+    ) -> Result<Self, StruqtureError> {
+        let value_string = value.to_string();
+        let pauli_product = Self::from_str(&value_string)?;
+        Ok(pauli_product)
+    }
 }
 
 impl From<MixedProduct> for Vec<(MixedPlusMinusProduct, Complex64)> {
     /// Converts a MixedProduct into a vector of tuples of (MixedPlusMinusProduct, Complex64).
     ///
     /// # Arguments
     ///
```

### Comparing `struqture_py-1.6.1/struqture/src/mixed_systems/mixed_product.rs` & `struqture_py-2.0.0a0/struqture/src/mixed_systems/mixed_product.rs`

 * *Files 4% similar despite different names*

```diff
@@ -68,15 +68,19 @@
         let meta = obj.metadata();
         meta.description = Some("Represents products of Spin operators and Bosonic and Fermionic creators and annhilators by a string. Spin Operators  X, Y and Z are preceeded and creators (c) and annihilators (a) are followed by the modes they are acting on. E.g. :S0X1Y:Bc0a0:Fc0a0:.".to_string());
 
         schemars::schema::Schema::Object(obj)
     }
 }
 
-impl crate::MinSupportedVersion for MixedProduct {}
+impl crate::SerializationSupport for MixedProduct {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::MixedProduct
+    }
+}
 
 impl Serialize for MixedProduct {
     /// Serialization function for MixedProduct according to string type.
     ///
     /// # Arguments
     ///
     /// * `self` - MixedProduct to be serialized.
@@ -191,14 +195,41 @@
             let pp_visitor = MixedProductVisitor;
 
             deserializer.deserialize_tuple(3, pp_visitor)
         }
     }
 }
 
+impl MixedProduct {
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(
+        &self,
+    ) -> Result<struqture_one::mixed_systems::MixedProduct, StruqtureError> {
+        let self_string = self.to_string();
+        let struqture_one_product =
+            struqture_one::mixed_systems::MixedProduct::from_str(&self_string).map_err(|err| {
+                StruqtureError::GenericError {
+                    msg: format!("{}", err),
+                }
+            })?;
+        Ok(struqture_one_product)
+    }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::mixed_systems::MixedProduct,
+    ) -> Result<Self, StruqtureError> {
+        let value_string = value.to_string();
+        let pauli_product = Self::from_str(&value_string)?;
+        Ok(pauli_product)
+    }
+}
+
 impl MixedIndex for MixedProduct {
     type SpinIndexType = PauliProduct;
     type BosonicIndexType = BosonProduct;
     type FermionicIndexType = FermionProduct;
 
     /// Creates a new MixedProduct.
     ///
```

### Comparing `struqture_py-1.6.1/struqture/src/mixed_systems/mixed_system.rs` & `struqture_py-2.0.0a0/struqture-py-macros/src/product_wrapper.rs`

 * *Files 26% similar despite different names*

```diff
@@ -6,803 +6,714 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
-use super::{HermitianOperateOnMixedSystems, MixedOperator, MixedProduct, OperateOnMixedSystems};
-#[cfg(feature = "json_schema")]
-use crate::mixed_systems::TinyVecDef;
-use crate::prelude::*;
-use crate::{OperateOnDensityMatrix, OperateOnState, StruqtureError};
-use qoqo_calculator::CalculatorComplex;
-use serde::{Deserialize, Serialize};
-use std::fmt::{self, Write};
-use std::iter::{FromIterator, IntoIterator};
-use std::ops;
-use tinyvec::TinyVec;
-
-#[cfg(feature = "indexed_map_iterators")]
-use indexmap::map::{Iter, Keys, Values};
-#[cfg(not(feature = "indexed_map_iterators"))]
-use std::collections::hash_map::{Iter, Keys, Values};
-
-/// MixedSystems are representations of physical systems of spins, with a MixedOperator to represent the hermitian hamiltonian of the system, and an optional number of spins.
-/// MixedSystems are MixedOperators with a certain number of spins, a certain number of bosonic modes and a certain number of fermionic modes. When constructing it, the `new`
-/// function takes a `number_spins` input, a `number_bosons` input and a `number_fermions` input, and therefore when the user adds a set of MixedProducts with specific CalculatorComplex coefficients,
-/// their indices must not exceed the number of modes in the MixedSystem.
-///
-/// # Example
-///
-/// ```
-/// use struqture::prelude::*;
-/// use qoqo_calculator::CalculatorComplex;
-/// use struqture::spins::PauliProduct;
-/// use struqture::bosons::BosonProduct;
-/// use struqture::fermions::FermionProduct;
-/// use struqture::mixed_systems::{MixedSystem, MixedProduct};
-///
-/// let mut ms = MixedSystem::new([Some(2_usize)], [Some(2_usize)], [Some(2_usize)]);
-///
-/// let pp_0x1x_a1_c0a1: MixedProduct = MixedProduct::new(
-///     [PauliProduct::new().x(0).x(1)],
-///     [BosonProduct::new([], [1]).unwrap()],
-///     [FermionProduct::new([0], [1]).unwrap()],
-/// )
-/// .unwrap();
-/// let pp_0z_c0a1_c0a0: MixedProduct = MixedProduct::new(
-///     [PauliProduct::new().z(0)],
-///     [BosonProduct::new([0], [1]).unwrap()],
-///     [FermionProduct::new([0], [0]).unwrap()],
-/// )
-/// .unwrap();
-/// ms.set(pp_0x1x_a1_c0a1.clone(), CalculatorComplex::from(0.5))
-///     .unwrap();
-/// ms.set(pp_0z_c0a1_c0a0.clone(), CalculatorComplex::from(0.2))
-///     .unwrap();
-///
-/// // Access what you set:
-/// assert_eq!(ms.get(&pp_0x1x_a1_c0a1), &CalculatorComplex::from(0.5));
-/// assert_eq!(ms.get(&pp_0z_c0a1_c0a0), &CalculatorComplex::from(0.2));
-///
-/// ```
-///
-#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]
-pub struct MixedSystem {
-    /// The number of spins in each subsystem
-    pub(crate) number_spins: TinyVec<[Option<usize>; 2]>,
-    /// The number of bosons in each subsystem
-    pub(crate) number_bosons: TinyVec<[Option<usize>; 2]>,
-    /// The number of fermions in each subsystem
-    pub(crate) number_fermions: TinyVec<[Option<usize>; 2]>,
-    /// The MixedOperator representing the Hamiltonian of the MixedSystem
-    pub(crate) operator: MixedOperator,
-}
-
-#[cfg(feature = "json_schema")]
-impl schemars::JsonSchema for MixedSystem {
-    fn schema_name() -> String {
-        "MixedSystem".to_string()
-    }
-
-    fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
-        <SchemaHelperMixedSystem>::json_schema(gen)
-    }
-}
-
-#[cfg(feature = "json_schema")]
-#[derive(schemars::JsonSchema)]
-#[schemars(deny_unknown_fields)]
-#[allow(dead_code)]
-struct SchemaHelperMixedSystem {
-    /// The number of spins in each subsystem
-    #[serde(with = "TinyVecDef")]
-    number_spins: TinyVec<[Option<usize>; 2]>,
-    /// The number of bosons in each subsystem
-    #[serde(with = "TinyVecDef")]
-    number_bosons: TinyVec<[Option<usize>; 2]>,
-    /// The number of fermions in each subsystem
-    #[serde(with = "TinyVecDef")]
-    number_fermions: TinyVec<[Option<usize>; 2]>,
-    /// The MixedOperator representing the Hamiltonian of the MixedSystem
-    pub(crate) operator: MixedOperator,
-}
-
-impl crate::MinSupportedVersion for MixedSystem {}
+//! struqture-py-macros
+//!
+//! Attribute proc-macros for the traits of struqture-py [struqture-py].
+
+use crate::{strip_python_wrapper_name, AttributeMacroArguments};
+use proc_macro2::TokenStream;
+use quote::quote;
+use syn::{parse_macro_input, ItemImpl};
+
+pub fn productwrapper(
+    metadata: proc_macro::TokenStream,
+    input: proc_macro::TokenStream,
+) -> proc_macro::TokenStream {
+    let parsed_input = parse_macro_input!(input as ItemImpl);
+    let ident = parsed_input.self_ty;
+    let items = parsed_input.items;
+    let attribute_arguments = parse_macro_input!(metadata as AttributeMacroArguments);
+    let (struct_name, struct_ident) = strip_python_wrapper_name(&ident);
+    let (struqture_one_module, struqture_one_ident) = if struct_name.contains("PauliProduct") {
+        (
+            quote::format_ident!("spins"),
+            quote::format_ident!("PauliProduct"),
+        )
+    } else if struct_name.contains("MixedDecoherenceProduct") {
+        (
+            quote::format_ident!("mixed_systems"),
+            quote::format_ident!("MixedDecoherenceProduct"),
+        )
+    } else if struct_name.contains("HermitianMixedProduct") {
+        (
+            quote::format_ident!("mixed_systems"),
+            quote::format_ident!("HermitianMixedProduct"),
+        )
+    } else if struct_name.contains("MixedPlusMinusProduct") {
+        (
+            quote::format_ident!("mixed_systems"),
+            quote::format_ident!("MixedPlusMinusProduct"),
+        )
+    } else if struct_name.contains("DecoherenceProduct") {
+        (
+            quote::format_ident!("spins"),
+            quote::format_ident!("DecoherenceProduct"),
+        )
+    } else if struct_name.contains("HermitianBosonProduct") {
+        (
+            quote::format_ident!("bosons"),
+            quote::format_ident!("HermitianBosonProduct"),
+        )
+    } else if struct_name.contains("BosonProduct") {
+        (
+            quote::format_ident!("bosons"),
+            quote::format_ident!("BosonProduct"),
+        )
+    } else if struct_name.contains("HermitianFermionProduct") {
+        (
+            quote::format_ident!("fermions"),
+            quote::format_ident!("HermitianFermionProduct"),
+        )
+    } else if struct_name.contains("FermionProduct") {
+        (
+            quote::format_ident!("fermions"),
+            quote::format_ident!("FermionProduct"),
+        )
+    } else if struct_name.contains("PlusMinusProduct") {
+        (
+            quote::format_ident!("spins"),
+            quote::format_ident!("PlusMinusProduct"),
+        )
+    } else {
+        (
+            quote::format_ident!("mixed_systems"),
+            quote::format_ident!("MixedProduct"),
+        )
+    };
+    // ------------
+    // Start the generating part of the macro
+    let symmetric_index_quote = if attribute_arguments.contains("SymmetricIndex") {
+        quote! {
+                /// Return the hermitian conjugate of self and its prefactor.
+                ///
+                /// Returns:
+                ///     (self, float): The hermitian conjugate of self and the potential sign it has picked up.
+                pub fn hermitian_conjugate(&self) -> (#ident, f64) {
+                    (#ident {
+                        internal: self.internal.hermitian_conjugate().0
+                    },
+                    self.internal.hermitian_conjugate().1
+                )
+                }
+
+                /// Return whether self is naturally hermitian.
+                ///
+                /// For spin objects, this is true when applying the hermitian conjugation does not change the sign.
+                /// For bosonic and fermionic objects, this is true when creators == annihilators.
+                /// For mixed objects, this is true when all of the spin, bosonic and fermionic parts' `is_naturally_hermitian` functions evaluate to true.
+                ///
+                /// Returns:
+                ///     bool: Whether self is naturally hermitian or not.
+                pub fn is_natural_hermitian(&self) -> bool {
+                    self.internal.is_natural_hermitian()
+                }
+        }
+    } else {
+        TokenStream::new()
+    };
+    let mode_index_quote = if attribute_arguments.contains("ModeIndex") {
+        quote! {
+                /// Get the number of creator indices of self.
+                ///
+                /// Returns:
+                ///     int: The number of creator indices in self.
+                pub fn number_creators(&self) -> usize {
+                    self.internal.number_creators()
+                }
+
+                /// Get the number of annihilator indices of self.
+                ///
+                /// Returns:
+                ///     int: The number of annihilator indices in self.
+                pub fn number_annihilators(&self) -> usize {
+                    self.internal.number_annihilators()
+                }
+
+                /// Returns the maximal number of modes self acts on.
+                ///
+                /// Self acts on a state space of unknown dimension.
+                /// There is only a lower bound of the dimension or number of modes based on the
+                /// maximal mode the product of operators in the index acts on.
+                /// For example an index consisting of one creator acting on mode 0 would have
+                /// a current_number_modes of one. An index consisting of one annhihilator acting on 3
+                /// would have current_number_modes of four.
+                ///
+                /// Returns:
+                ///     int: The maximal number of modes self acts on.
+                pub fn current_number_modes(&self) -> usize {
+                    self.internal.current_number_modes()
+                }
+
+                /// Return list of creator indices.
+                ///
+                /// Returns:
+                ///     list[int]: A list of the corresponding creator indices.
+                pub fn creators(&self) -> Vec<usize> {
+                    self.internal.creators().cloned().collect()
+                }
+
+                /// Return list of annihilator indices.
+                ///
+                /// Returns:
+                ///     list[int]: A list of the corresponding annihilator indices.
+                pub fn annihilators(&self) -> Vec<usize> {
+                    self.internal.annihilators().cloned().collect()
+                }
+
+                /// Remap modes according to an input dictionary.
+                ///
+                /// Args:
+                ///    reordering_dictionary (dict) - The dictionary specifying the remapping. It must represent a permutation.
+                ///
+                /// Returns:
+                ///   (Self, CalculatorComplex) - The instance of Self with modes remapped, and the sign resulting from symmetry/antisymmetry.
+                ///
+                /// Raises:
+                ///    ValueError: Input reordering dictionary is not a permutation of the indices.
+                pub fn remap_modes(&self, reordering_dictionary: &PyAny) -> PyResult<(#ident, qoqo_calculator_pyo3::CalculatorComplexWrapper)> {
+                    let remap_dict = reordering_dictionary.extract::<HashMap<usize, usize>>()?;
+                    let (index, value) = self.internal.remap_modes(&remap_dict).map_err(|err| PyValueError::new_err(format!("{:?}", err)))?;
+                    Ok((#ident{internal: index}, qoqo_calculator_pyo3::CalculatorComplexWrapper{internal: value}))
+                }
+
+
+                /// Create valid pair of index and value to be set in an operator.
+                ///
+                /// The first item is the valid instance of self created from the input creators and annihilators.
+                /// The second term is the input CalculatorComplex transformed according to the valid order of creators and annihilators.
+                ///
+                /// Args:
+                ///    creators (list[int]): The creator indices to have in the instance of self.
+                ///    annihilators (list[int]): The annihilators indices to have in the instance of self.
+                ///    value (CalculatorComplex): The CalculatorComplex to transform.
+                ///
+                /// Returns:
+                ///    (self, CalculatorComplex): The valid instance of self and the corresponding transformed CalculatorComplex.
+                ///
+                /// Raises:
+                ///     TypeError: Value is not CalculatorComplex.
+                ///     ValueError: Indices given in either creators or annihilators contain a double index specification (only applicable to fermionic objects).
+                #[classmethod]
+                pub fn create_valid_pair(_cls: &PyType, creators: Vec<usize>, annihilators: Vec<usize>, value: &PyAny) -> PyResult<(#ident, qoqo_calculator_pyo3::CalculatorComplexWrapper)> {
+                    let value = qoqo_calculator_pyo3::convert_into_calculator_complex(value).map_err(|_| PyTypeError::new_err("Value is not CalculatorComplex"))?;
+                    let (index, value) = #struct_ident::create_valid_pair(creators, annihilators, value).map_err(|err| PyValueError::new_err(format!("Valid pair could not be constructed: {:?}", err)))?;
+                    Ok((#ident{internal: index}, qoqo_calculator_pyo3::CalculatorComplexWrapper{internal: value}))
+                }
+        }
+    } else {
+        TokenStream::new()
+    };
+    let spin_index_quote = if attribute_arguments.contains("SpinIndex") {
+        quote! {
+                /// Get the pauli matrix corresponding to the index.
+                ///
+                /// Args:
+                ///     index (int): Index of get object.
+                ///
+                /// Returns:
+                ///     Optional[str]: The key's corresponding value (if it exists).
+                pub fn get(&self, index: usize) -> Option<String> {
+                    match self.internal.get(&index) {
+                        Some(x) => Some(format!("{}", x)),
+                        None => None
+                    }
+                }
+
+                /// Return a list of the unsorted keys in self.
+                ///
+                /// Returns:
+                ///     list[int]: The sequence of qubit index keys of self.
+                pub fn keys(&self) -> Vec<usize> {
+                    let keys: Vec<usize> = self.internal.iter().map(|(k, _)| k).copied().collect();
+                    keys
+                }
+
+                /// Return maximum index in self.
+                ///
+                /// Returns:
+                ///     int: Maximum index.
+                pub fn current_number_spins(&self) -> usize {
+                    self.internal.current_number_spins()
+                }
+
+                /// Return number of entries in object.
+                ///
+                /// Returns:
+                ///     int: The length of the content of the object.
+                pub fn __len__(&self) -> usize {
+                    self.internal.len()
+                }
+
+                /// Return whether self is empty or not.
+                ///
+                /// Returns:
+                ///     bool: Whether self is empty or not.
+                pub fn is_empty(&self) -> bool {
+                    self.internal.is_empty()
+                }
+
+                /// Remap the qubits in a new instance of self (returned).
+                ///
+                /// Args:
+                ///     mapping (dict[int, int]): The map containing the {qubit: qubit} mapping to use.
+                ///
+                /// Returns:
+                ///     self: The new instance of self with the qubits remapped.
+                pub fn remap_qubits(&self, mapping: HashMap<usize, usize>) -> #ident {
+                    #ident {
+                        internal: self.internal.remap_qubits(&mapping)
+                    }
+                }
+
+                /// Return the concatenation of two objects of type `self` with no overlapping qubits.
+                ///
+                /// Args:
+                ///     other (self): The object to concatenate self with.
+                ///
+                /// Returns:
+                ///     list[int]: A list of the corresponding creator indices.
+                ///
+                /// Raises:
+                ///     ValueError: The two objects could not be concatenated.
+                pub fn concatenate(&self, other: #ident) -> PyResult<#ident> {
+                    let concatenated = self.internal.concatenate(other.internal).map_err(|err| PyValueError::new_err(format!("The two objects could not be concatenated: {:?}", err)))?;
+                    Ok(#ident {
+                        internal: concatenated
+                    })
+                }
+        }
+    } else {
+        TokenStream::new()
+    };
+    let calculus_quote = if attribute_arguments.contains("Calculus") {
+        quote! {
+                /// Multiplication function for a self-typed object by a self-typed object.
+                ///
+                /// Args:
+                ///     left (self): Left-hand self typed object to be multiplied.
+                ///     right (self): Right-hand self typed object to be multiplied.
+                ///
+                /// Returns:
+                ///     (self, complex):  The multiplied objects and the resulting prefactor.
+                #[staticmethod]
+                pub fn multiply(left: #ident, right: #ident) -> (#ident, Complex64) {
+                    let (index, value) = #struct_ident::multiply(left.internal, right.internal);
+                    (#ident{internal: index}, value)
+                }
+        }
+    } else {
+        TokenStream::new()
+    };
+    let mixed_index_quote = if struct_name.contains("Mixed") {
+        let spin_type = if struct_name.contains("Decoherence") {
+            quote::format_ident!("DecoherenceProductWrapper")
+        } else if struct_name.contains("PlusMinus") {
+            quote::format_ident!("PlusMinusProductWrapper")
+        } else {
+            quote::format_ident!("PauliProductWrapper")
+        };
+        quote! {
+                /// Get the spin products of self.
+                ///
+                /// Returns:
+                ///     list[str]: The spin products of self.
+                pub fn spins(&self) -> Vec<#spin_type> {
+                    let spins: Vec<#spin_type> = self
+                        .internal
+                        .spins()
+                        .cloned()
+                        .map(|x| #spin_type { internal: x })
+                        .collect();
+                    spins
+                }
+
+                /// Get the boson products of self.
+                ///
+                /// Returns:
+                ///     list[str]: The boson products of self.
+                pub fn bosons(&self) -> Vec<BosonProductWrapper> {
+                    let bosons: Vec<BosonProductWrapper> = self
+                        .internal
+                        .bosons()
+                        .cloned()
+                        .map(|x| BosonProductWrapper { internal: x })
+                        .collect();
+                    bosons
+                }
+
+                /// Get the fermion products of self.
+                ///
+                /// Returns:
+                ///     list[str]: The fermion products of self.
+                pub fn fermions(&self) -> Vec<FermionProductWrapper> {
+                    let fermions: Vec<FermionProductWrapper> = self
+                        .internal
+                        .fermions()
+                        .cloned()
+                        .map(|x| FermionProductWrapper { internal: x })
+                        .collect();
+                    fermions
+                }
+
+                /// Return the current number of spins each subsystem acts upon.
+                ///
+                /// Returns:
+                ///     list[int]: Number of spins in each spin sub-system.
+                pub fn current_number_spins(&self) -> Vec<usize> {
+                    self.internal.current_number_spins()
+                }
+
+                /// Return the current number of bosonic modes each subsystem acts upon.
+                ///
+                /// Returns:
+                ///     list[int]: Number of bosonic modes in each spin sub-system.
+                pub fn current_number_bosonic_modes(&self) -> Vec<usize> {
+                    self.internal.current_number_bosonic_modes()
+                }
+
+                /// Return the current number of fermionic modes each subsystem acts upon.
+                ///
+                /// Returns:
+                ///     list[int]: Number of fermionic modes in each spin sub-system.
+                pub fn current_number_fermionic_modes(&self) -> Vec<usize> {
+                    self.internal.current_number_fermionic_modes()
+                }
+        }
+    } else {
+        TokenStream::new()
+    };
+    let q = quote! {
+
+        impl #ident {
+            /// Fallible conversion of generic python object..
+            pub fn from_pyany( input: Py<PyAny>) -> PyResult<#struct_ident> {
+                Python::with_gil(|py| -> PyResult<#struct_ident> {
+                    let input = input.as_ref(py);
+                    if let Ok(try_downcast) = input.extract::<#ident>() {
+                        return Ok(try_downcast.internal);
+                    } else {
+                        let get_str = input.call_method0("__str__").map_err(|_| {
+                            PyTypeError::new_err("Type conversion failed".to_string())
+                        })?;
+                        let string = get_str.extract::<String>().map_err(|_| {
+                            PyTypeError::new_err("Type conversion failed".to_string())
+                        })?;
+                        let res = #struct_ident::from_str(string.as_str()).map_err(|err|
+                            PyTypeError::new_err(format!(
+                                "Type conversion failed: {}",
+                                err
+                            )))?;
+                        let source_serialisation_meta = res.struqture_serialisation_meta();
+
+                        let target_serialisation_meta = <#struct_ident as struqture::SerializationSupport>::target_serialisation_meta();
+
+                        struqture::check_can_be_deserialised(&target_serialisation_meta, &source_serialisation_meta).map_err(|err| {
+                            PyTypeError::new_err(err.to_string())
+                        })?;
 
-impl<'a> OperateOnDensityMatrix<'a> for MixedSystem {
-    type Index = MixedProduct;
-    type Value = CalculatorComplex;
-    type IteratorType = Iter<'a, Self::Index, Self::Value>;
-    type KeyIteratorType = Keys<'a, Self::Index, Self::Value>;
-    type ValueIteratorType = Values<'a, Self::Index, Self::Value>;
-
-    // From trait
-    fn get(&self, key: &Self::Index) -> &Self::Value {
-        self.operator.get(key)
-    }
-
-    // From trait
-    fn iter(&'a self) -> Self::IteratorType {
-        self.operator.iter()
-    }
-
-    // From trait
-    fn keys(&'a self) -> Self::KeyIteratorType {
-        self.operator.keys()
-    }
-
-    // From trait
-    fn values(&'a self) -> Self::ValueIteratorType {
-        self.operator.values()
-    }
-
-    // From trait
-    fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
-        self.operator.remove(key)
-    }
-
-    // From trait
-    fn empty_clone(&self, capacity: Option<usize>) -> Self {
-        match capacity {
-            Some(cap) => Self {
-                number_spins: self.number_spins.clone(),
-                number_bosons: self.number_bosons.clone(),
-                number_fermions: self.number_fermions.clone(),
-                operator: MixedOperator::with_capacity(
-                    self.number_spins.len(),
-                    self.number_bosons.len(),
-                    self.number_fermions.len(),
-                    cap,
-                ),
-            },
-            None => Self {
-                number_spins: self.number_spins.clone(),
-                number_bosons: self.number_bosons.clone(),
-                number_fermions: self.number_fermions.clone(),
-                operator: MixedOperator::new(
-                    self.number_spins.len(),
-                    self.number_bosons.len(),
-                    self.number_fermions.len(),
-                ),
-            },
-        }
-    }
+                        Ok(res)
 
-    /// Overwrites an existing entry or sets a new entry in the MixedSystem with the given (MixedProduct key, CalculatorComplex value) pair.
-    ///
-    /// # Arguments
-    ///
-    /// * `key` - The MixedProduct key to set in the MixedSystem.
-    /// * `value` - The corresponding CalculatorComplex value to set for the key in the MixedSystem.
-    ///
-    /// # Returns
-    ///
-    /// * `Ok(Some(CalculatorComplex))` - The key existed, this is the value it had before it was set with the value input.
-    /// * `Ok(None)` - The key did not exist, it has been set with its corresponding value.
-    /// * `Err(StruqtureError::MissmatchedNumberSubsystems)` - Number of subsystems in system and key do not match.
-    fn set(
-        &mut self,
-        key: Self::Index,
-        value: Self::Value,
-    ) -> Result<Option<Self::Value>, StruqtureError> {
-        if key.spins().len() != self.number_spins.len()
-            || key.bosons().len() != self.number_bosons.len()
-            || key.fermions().len() != self.number_fermions.len()
-        {
-            return Err(StruqtureError::MissmatchedNumberSubsystems {
-                target_number_spin_subsystems: self.number_spins.len(),
-                target_number_boson_subsystems: self.number_bosons.len(),
-                target_number_fermion_subsystems: self.number_fermions.len(),
-                actual_number_spin_subsystems: key.spins().len(),
-                actual_number_boson_subsystems: key.bosons().len(),
-                actual_number_fermion_subsystems: key.fermions().len(),
-            });
-        }
-        for (x, y) in key.bosons().zip(self.number_bosons.clone()) {
-            if let Some(max_number) = y {
-                if x.current_number_modes() > max_number {
-                    return Err(StruqtureError::MissmatchedNumberModes);
-                }
-            }
-        }
-        for (x, y) in key.fermions().zip(self.number_fermions.clone()) {
-            if let Some(max_number) = y {
-                if x.current_number_modes() > max_number {
-                    return Err(StruqtureError::MissmatchedNumberModes);
-                }
-            }
-        }
-        for (x, y) in key.spins().zip(self.number_spins.clone()) {
-            if let Some(max_number) = y {
-                if x.current_number_spins() > max_number {
-                    return Err(StruqtureError::MissmatchedNumberSpins);
-                }
+                    }
+                })
             }
-        }
-        self.operator.set(key, value)
-    }
 
-    /// Adds a new (MixedProduct key, CalculatorComplex value) pair to the MixedSystem.
-    ///
-    /// # Arguments
-    ///
-    /// * `key` - The MixedProduct key to added to the MixedSystem.
-    /// * `value` - The corresponding CalculatorComplex value to add for the key in the MixedSystem.
-    ///
-    /// # Returns
-    ///
-    /// * `Ok(())` - The (key, value) pair was successfully added.
-    /// * `Err(StruqtureError::MissmatchedNumberSubsystems)` - Number of subsystems in system and key do not match.
-    fn add_operator_product(
-        &mut self,
-        key: Self::Index,
-        value: Self::Value,
-    ) -> Result<(), StruqtureError> {
-        if key.spins().len() != self.number_spins.len()
-            || key.bosons().len() != self.number_bosons.len()
-            || key.fermions().len() != self.number_fermions.len()
-        {
-            return Err(StruqtureError::MissmatchedNumberSubsystems {
-                target_number_spin_subsystems: self.number_spins.len(),
-                target_number_boson_subsystems: self.number_bosons.len(),
-                target_number_fermion_subsystems: self.number_fermions.len(),
-                actual_number_spin_subsystems: key.spins().len(),
-                actual_number_boson_subsystems: key.bosons().len(),
-                actual_number_fermion_subsystems: key.fermions().len(),
-            });
-        }
-        for (x, y) in key.bosons().zip(self.number_bosons.clone()) {
-            if let Some(max_number) = y {
-                if x.current_number_modes() > max_number {
-                    return Err(StruqtureError::MissmatchedNumberModes);
-                }
-            }
-        }
-        for (x, y) in key.fermions().zip(self.number_fermions.clone()) {
-            if let Some(max_number) = y {
-                if x.current_number_modes() > max_number {
-                    return Err(StruqtureError::MissmatchedNumberModes);
-                }
-            }
-        }
-        for (x, y) in key.spins().zip(self.number_spins.clone()) {
-            if let Some(max_number) = y {
-                if x.current_number_spins() > max_number {
-                    return Err(StruqtureError::MissmatchedNumberSpins);
-                }
+            /// Fallible conversion of generic python object that is implemented in struqture 1.x.
+            #[cfg(feature = "struqture_1_import")]
+            pub fn from_pyany_struqture_one(input: Py<PyAny>) -> PyResult<#struct_ident> {
+                Python::with_gil(|py| -> PyResult<#struct_ident> {
+                    let get_str = input.call_method0(py, "__str__").map_err(|_| {
+                        PyTypeError::new_err("Type conversion failed".to_string())
+                    })?;
+                    let string = get_str.extract::<String>(py).map_err(|_| {
+                        PyTypeError::new_err("Type conversion failed".to_string())
+                    })?;
+                    let one_import = struqture_one::#struqture_one_module::#struqture_one_ident::from_str(string.as_str()).map_err(|err|
+                        PyTypeError::new_err(format!(
+                            "Type conversion failed: {}",
+                            err
+                        )))?;
+
+                    let qubit_operator: #struct_ident = #struct_ident::from_struqture_1(&one_import).map_err(
+                        |err| PyValueError::new_err(format!("Trying to obtain struqture 2.x object from struqture 1.x object. Conversion failed. Was the right type passed to all functions? {:?}", err)
+                    ))?;
+                    Ok(qubit_operator)
+                })
             }
-        }
-        self.operator.add_operator_product(key, value)
-    }
-}
-
-impl<'a> OperateOnState<'a> for MixedSystem {
-    // From trait
-    fn hermitian_conjugate(&self) -> Self {
-        self.clone()
-    }
-}
 
-impl<'a> OperateOnMixedSystems<'a> for MixedSystem {
-    // From trait
-    fn number_spins(&self) -> Vec<usize> {
-        self.number_spins
-            .iter()
-            .zip(self.current_number_spins())
-            .map(|(target, current)| target.unwrap_or_else(|| current))
-            .collect()
-    }
-
-    // From trait
-    fn current_number_spins(&self) -> Vec<usize> {
-        let mut number_spins: Vec<usize> = (0..self.number_spins.len()).map(|_| 0).collect();
-        for key in self.keys() {
-            for (index, s) in key.spins().enumerate() {
-                let maxk = s.current_number_spins();
-                if maxk > number_spins[index] {
-                    number_spins[index] = maxk
-                }
+            /// Fallible conversion of generic python object that is implemented in struqture 1.x.
+            #[cfg(feature = "struqture_1_export")]
+            pub fn from_pyany_to_struqture_one(input: Py<PyAny>) -> PyResult<struqture_one::#struqture_one_module::#struqture_one_ident> {
+                let res = <#ident>::from_pyany(input)?;
+                <#struct_ident>::to_struqture_1(&res).map_err(
+                    |err| PyValueError::new_err(format!("Trying to obtain struqture 2.x object from struqture 1.x object. Conversion failed. Was the right type passed to all functions? Error message: {:?}", err)
+                ))
             }
         }
-        number_spins
-    }
 
-    // From trait
-    fn number_bosonic_modes(&self) -> Vec<usize> {
-        self.number_bosons
-            .iter()
-            .zip(self.current_number_bosonic_modes())
-            .map(|(target, current)| target.unwrap_or_else(|| current))
-            .collect()
-    }
-
-    // From trait
-    fn current_number_bosonic_modes(&self) -> Vec<usize> {
-        let mut number_bosons: Vec<usize> = (0..self.number_bosons.len()).map(|_| 0).collect();
-        for key in self.keys() {
-            for (index, s) in key.bosons().enumerate() {
-                let maxk = s.current_number_modes();
-                if maxk > number_bosons[index] {
-                    number_bosons[index] = maxk
-                }
+        #[pymethods]
+        impl #ident {
+
+            #(#items)*
+
+            #symmetric_index_quote
+            #mode_index_quote
+            #spin_index_quote
+            #mixed_index_quote
+            #calculus_quote
+
+            // ----------------------------------
+            // Default pyo3 implementations
+
+            // add in a function converting struqture_one (not py) to struqture 2
+            // take a pyany, implement from_pyany by hand (or use from_pyany_struqture_one internally) and wrap the result in a struqture 2 spin operator wrapper
+            #[cfg(feature = "struqture_1_import")]
+            #[staticmethod]
+            pub fn from_struqture_one(input: Py<PyAny>) -> PyResult<#ident> {
+                let qubit_operator: #struct_ident = #ident::from_pyany_struqture_one(input)?;
+                Ok(#ident {
+                    internal: qubit_operator,
+                })
             }
-        }
-        number_bosons
-    }
 
-    // From trait
-    fn number_fermionic_modes(&self) -> Vec<usize> {
-        self.number_fermions
-            .iter()
-            .zip(self.current_number_fermionic_modes())
-            .map(|(target, current)| target.unwrap_or_else(|| current))
-            .collect()
-    }
-
-    // From trait
-    fn current_number_fermionic_modes(&self) -> Vec<usize> {
-        let mut number_fermions: Vec<usize> = (0..self.number_fermions.len()).map(|_| 0).collect();
-        for key in self.keys() {
-            for (index, s) in key.fermions().enumerate() {
-                let maxk = s.current_number_modes();
-                if maxk > number_fermions[index] {
-                    number_fermions[index] = maxk
-                }
+            // add in a function converting struqture_one (not py) to struqture 2
+            // take a pyany, implement from_pyany by hand (or use from_pyany_struqture_one internally) and wrap the result in a struqture 2 spin operator wrapper
+            #[cfg(feature = "struqture_1_import")]
+            #[pyo3(text_signature = "(input)")]
+            #[staticmethod]
+            pub fn from_json_struqture_one(input: String) -> PyResult<#ident> {
+                let qubit_operator: struqture_one::#struqture_one_module::#struqture_one_ident =
+                    serde_json::from_str(&input).map_err(|err| {
+                        PyValueError::new_err(format!(
+                            "Input cannot be deserialized from json to struqture 1.x: {}",
+                            err
+                        ))
+                    })?;
+                Ok(#ident {
+                    internal: #struct_ident::from_struqture_1(&qubit_operator).map_err(|err| {
+                        PyValueError::new_err(format!(
+                            "Trying to obtain struqture 2.x object from struqture 1.x object. Conversion failed. Was the right type passed to all functions? {:?}", err
+                        ))
+                    })?,
+                })
             }
-        }
-        number_fermions
-    }
-}
-
-impl<'a> HermitianOperateOnMixedSystems<'a> for MixedSystem {}
 
-/// Functions for the MixedSystem
-///
-impl MixedSystem {
-    /// Creates a new MixedSystem.
-    ///
-    /// # Arguments
-    ///
-    /// * `number_spins` - The number of spins in each spin subsystem.
-    /// * `number_bosons` - The number of boson modes in each bosonic subsystem.
-    /// * `number_fermions` - The number of fermion modes in each fermionic subsystem.
-    ///
-    ///
-    /// # Returns
-    ///
-    /// * `Self` - The new MixedSystem with the input number of spins and modes.
-    pub fn new(
-        number_spins: impl IntoIterator<Item = Option<usize>>,
-        number_bosons: impl IntoIterator<Item = Option<usize>>,
-        number_fermions: impl IntoIterator<Item = Option<usize>>,
-    ) -> Self {
-        let number_spins: TinyVec<[Option<usize>; 2]> = number_spins.into_iter().collect();
-        let number_bosons: TinyVec<[Option<usize>; 2]> = number_bosons.into_iter().collect();
-        let number_fermions: TinyVec<[Option<usize>; 2]> = number_fermions.into_iter().collect();
-        let operator = MixedOperator::new(
-            number_spins.len(),
-            number_bosons.len(),
-            number_fermions.len(),
-        );
-        MixedSystem {
-            number_spins,
-            number_bosons,
-            number_fermions,
-            operator,
-        }
-    }
-
-    /// Creates a new MixedSystem with capacity pre-allocated capacity and given inputs.
-    ///
-    /// # Arguments
-    ///
-    /// * `number_spins` - The number of spins in each spin subsystem
-    /// * `number_bosons` - The number of boson modes in each bosonic subsystem
-    /// * `number_fermions` - The number of fermion modes in each fermionic subsystem
-    /// * `capacity` - The pre-allocated capacity of the system.
-    ///
-    /// # Returns
-    ///
-    /// * `Self` - The new MixedSystem with the input number of spins and modes.
-    pub fn with_capacity(
-        number_spins: impl IntoIterator<Item = Option<usize>>,
-        number_bosons: impl IntoIterator<Item = Option<usize>>,
-        number_fermions: impl IntoIterator<Item = Option<usize>>,
-        capacity: usize,
-    ) -> Self {
-        let number_spins: TinyVec<[Option<usize>; 2]> = number_spins.into_iter().collect();
-        let number_bosons: TinyVec<[Option<usize>; 2]> = number_bosons.into_iter().collect();
-        let number_fermions: TinyVec<[Option<usize>; 2]> = number_fermions.into_iter().collect();
-        let operator = MixedOperator::with_capacity(
-            number_spins.len(),
-            number_bosons.len(),
-            number_fermions.len(),
-            capacity,
-        );
-        MixedSystem {
-            number_spins,
-            number_bosons,
-            number_fermions,
-            operator,
-        }
-    }
-
-    /// Returns the MixedOperator of the MixedSystem.
-    ///
-    /// # Returns
-    ///
-    /// * `&MixedOperator` - The MixedOperator of the MixedSystem.
-    pub fn operator(&self) -> &MixedOperator {
-        &self.operator
-    }
-
-    /// Creates a MixedSystem from a MixedOperator and an optional number of spins/modes.
-    ///
-    /// # Arguments
-    ///
-    /// * `operator` - The MixedOperator to create the MixedSystem from.
-    /// * `number_spins` - The number of spins for each spin subsystem of the MixedSystem to be created.
-    /// * `number_bosons` - The number of boson modes for each bosonic subsystem of the MixedSystem to be created.
-    /// * `number_fermions` - The number of fermion modes for each fermionic subsystem of the MixedSystem to be created.
-    ///
-    /// # Returns
-    ///
-    /// * `Ok(Self)` - The MixedSystem created from the inputs.
-    /// * `Err(StruqtureError::NumberSpinsExceeded)` - Number of spins in entry exceeds number of spins in system.
-    pub fn from_operator(
-        operator: MixedOperator,
-        number_spins: impl IntoIterator<Item = Option<usize>>,
-        number_bosons: impl IntoIterator<Item = Option<usize>>,
-        number_fermions: impl IntoIterator<Item = Option<usize>>,
-    ) -> Result<Self, StruqtureError> {
-        let number_spins: TinyVec<[Option<usize>; 2]> = number_spins.into_iter().collect();
-        let number_bosons: TinyVec<[Option<usize>; 2]> = number_bosons.into_iter().collect();
-        let number_fermions: TinyVec<[Option<usize>; 2]> = number_fermions.into_iter().collect();
-
-        if operator
-            .current_number_spins()
-            .iter()
-            .zip(number_spins.iter())
-            .all(|(current, target)| match target {
-                Some(x) => current <= x,
-                None => true,
-            })
-            && operator
-                .current_number_bosonic_modes()
-                .iter()
-                .zip(number_bosons.iter())
-                .all(|(current, target)| match target {
-                    Some(x) => current <= x,
-                    None => true,
-                })
-            && operator
-                .current_number_fermionic_modes()
-                .iter()
-                .zip(number_fermions.iter())
-                .all(|(current, target)| match target {
-                    Some(x) => current <= x,
-                    None => true,
+            /// Return a copy of self (copy here produces a deepcopy).
+            ///
+            /// Returns:
+            ///     self: A deep copy of Self.
+            pub fn __copy__(&self) -> #ident {
+                self.clone()
+            }
+
+            /// Return a deep copy of self.
+            ///
+            /// Returns:
+            ///     self: A deep copy of Self.
+            pub fn __deepcopy__(&self, _memodict: Py<PyAny>) -> #ident {
+                self.clone()
+            }
+
+            /// Convert the bincode representation of the object to an instance using the [bincode] crate.
+            ///
+            /// Args:
+            ///     input (ByteArray): The serialized object (in [bincode] form).
+            ///
+            /// Returns:
+            ///    The deserialized Spin System.
+            ///
+            /// Raises:
+            ///     TypeError: Input cannot be converted to byte array.
+            ///     ValueError: Input cannot be deserialized.
+            #[staticmethod]
+            pub fn from_bincode(input: &PyAny) -> PyResult<#ident> {
+                let bytes = input
+                    .extract::<Vec<u8>>()
+                    .map_err(|_| PyTypeError::new_err("Input cannot be converted to byte array"))?;
+
+                Ok(#ident {
+                    internal: bincode::deserialize(&bytes[..]).map_err(|err| {
+                        PyValueError::new_err(format!(
+                            "Input cannot be deserialized from bytes. {}",
+                            err
+                        ))
+                    })?,
                 })
-        {
-            Ok(MixedSystem {
-                number_spins,
-                number_bosons,
-                number_fermions,
-                operator,
-            })
-        } else {
-            Err(StruqtureError::NumberSpinsExceeded)
-        }
-    }
-
-    // /// Separate self into an operator with the terms of given number of spins, bosons and fermions and an operator with the remaining operations
-    // ///
-    // /// # Arguments
-    // ///
-    // /// * `number_particles` - Number of spins, bosons and fermions to filter for in the keys.
-    // ///
-    // /// # Returns
-    // ///
-    // /// `Ok((separated, remainder))` - Operator with the noise terms where number_particles matches the number of spins the operator product acts on and Operator with all other contributions.
-    // pub fn separate_into_n_terms(
-    //     &self,
-    //     number_particles: (usize, usize, usize),
-    // ) -> Result<(Self, Self), StruqtureError> {
-    //     let mut separated = Self::default();
-    //     let mut remainder = Self::default();
-    //     for (prod, val) in self.iter() {
-    //         if (
-    //             prod.spins().len(),
-    //             prod.bosons().len(),
-    //             prod.fermions().len(),
-    //         ) == number_particles
-    //         {
-    //             separated.add_operator_product(prod.clone(), val.clone())?;
-    //         } else {
-    //             remainder.add_operator_product(prod.clone(), val.clone())?;
-    //         }
-    //     }
-    //     Ok((separated, remainder))
-    // }
-}
-
-/// Implements the negative sign function of MixedSystem.
-///
-impl ops::Neg for MixedSystem {
-    type Output = Self;
-    /// Implement minus sign for MixedSystem.
-    ///
-    /// # Returns
-    ///
-    /// * `Self` - The MixedSystem * -1.
-    fn neg(mut self) -> Self {
-        self.operator = self.operator.neg();
-        self
-    }
-}
-
-/// Implements the plus function of MixedSystem by MixedSystem.
-///
-impl<T, V> ops::Add<T> for MixedSystem
-where
-    T: IntoIterator<Item = (MixedProduct, V)>,
-    V: Into<CalculatorComplex>,
-{
-    type Output = Result<Self, StruqtureError>;
-    /// Implements `+` (add) for two MixedSystems.
-    ///
-    /// # Arguments
-    ///
-    /// * `other` - The MixedSystem to be added.
-    ///
-    /// # Returns
-    ///
-    /// * `Ok(Self)` - The two MixedSystems added together.
-    /// * `Err(StruqtureError::MissmatchedNumberSubsystems)` - Number of subsystems in system and key do not match.
-    fn add(mut self, other: T) -> Self::Output {
-        for (key, value) in other.into_iter() {
-            self.add_operator_product(key.clone(), Into::<CalculatorComplex>::into(value))?;
-        }
-        Ok(self)
-    }
-}
-
-/// Implements the minus function of MixedSystem by MixedSystem.
-///
-impl<T, V> ops::Sub<T> for MixedSystem
-where
-    T: IntoIterator<Item = (MixedProduct, V)>,
-    V: Into<CalculatorComplex>,
-{
-    type Output = Result<Self, StruqtureError>;
-    /// Implements `-` (subtract) for two MixedSystems.
-    ///
-    /// # Arguments
-    ///
-    /// * `other` - The MixedSystem to be subtracted.
-    ///
-    /// # Returns
-    ///
-    /// * `Ok(Self)` - The two MixedSystems subtracted.
-    /// * `Err(StruqtureError::MissmatchedNumberSubsystems)` - Number of subsystems in system and key do not match.
-    fn sub(mut self, other: T) -> Self::Output {
-        for (key, value) in other.into_iter() {
-            self.add_operator_product(key.clone(), Into::<CalculatorComplex>::into(value) * -1.0)?;
-        }
-        Ok(self)
-    }
-}
-
-/// Implements the multiplication function of MixedSystem by CalculatorComplex/CalculatorFloat.
-///
-impl<T> ops::Mul<T> for MixedSystem
-where
-    T: Into<CalculatorComplex>,
-{
-    type Output = Self;
-    /// Implement `*` for MixedSystem and CalculatorComplex/CalculatorFloat.
-    ///
-    /// # Arguments
-    ///
-    /// * `other` - The CalculatorComplex or CalculatorFloat by which to multiply.
-    ///
-    /// # Returns
-    ///
-    /// * `Self` - The MixedSystem multiplied by the CalculatorComplex/CalculatorFloat.
-    fn mul(mut self, other: T) -> Self {
-        let other_cc = Into::<CalculatorComplex>::into(other);
-        self.operator = self.operator * other_cc;
-        self
-    }
-}
-
-/// Implements the multiplication function of MixedSystem by MixedSystem.
-///
-impl ops::Mul<MixedSystem> for MixedSystem {
-    type Output = Result<MixedSystem, StruqtureError>;
-    /// Implement `*` for MixedSystem and MixedSystem.
-    ///
-    /// # Arguments
-    ///
-    /// * `other` - The MixedSystem to multiply by.
-    ///
-    /// # Returns
-    ///
-    /// * `Ok(Self)` - The two MixedSystems multiplied.
-    /// * `Err(StruqtureError::MissmatchedNumberSubsystems)` - Number of subsystems in system and key do not match.
-    fn mul(self, other: MixedSystem) -> Self::Output {
-        if self.number_spins.len() != other.number_spins.len()
-            || self.number_bosons.len() != other.number_bosons.len()
-            || self.number_fermions.len() != other.number_fermions.len()
-        {
-            return Err(StruqtureError::MissmatchedNumberSubsystems {
-                target_number_spin_subsystems: self.number_spins.len(),
-                target_number_boson_subsystems: self.number_bosons.len(),
-                target_number_fermion_subsystems: self.number_fermions.len(),
-                actual_number_spin_subsystems: other.number_spins.len(),
-                actual_number_boson_subsystems: other.number_bosons.len(),
-                actual_number_fermion_subsystems: other.number_fermions.len(),
-            });
-        }
-        let capacity = self.len() * other.len();
-        let mut spin_op = MixedSystem::with_capacity(
-            self.number_spins.clone(),
-            self.number_bosons.clone(),
-            self.number_fermions.clone(),
-            capacity,
-        );
-        for (pps, vals) in self {
-            for (ppo, valo) in other.iter() {
-                let products = (pps.clone() * ppo.clone())?;
-                for (ppp, coefficient) in products {
-                    let coefficient =
-                        Into::<CalculatorComplex>::into(valo) * vals.clone() * coefficient;
-                    spin_op.add_operator_product(ppp, coefficient)?;
-                }
             }
-        }
-        Ok(spin_op)
-    }
-}
-
-/// Implements the into_iter function (IntoIterator trait) of MixedSystem.
-///
-impl IntoIterator for MixedSystem {
-    type Item = (MixedProduct, CalculatorComplex);
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    type IntoIter = std::collections::hash_map::IntoIter<MixedProduct, CalculatorComplex>;
-    #[cfg(feature = "indexed_map_iterators")]
-    type IntoIter = indexmap::map::IntoIter<MixedProduct, CalculatorComplex>;
-    /// Returns the MixedSystem in Iterator form.
-    ///
-    /// # Returns
-    ///
-    /// * `Self::IntoIter` - The MixedSystem in Iterator form.
-    fn into_iter(self) -> Self::IntoIter {
-        self.operator.into_iter()
-    }
-}
-
-/// Implements the into_iter function (IntoIterator trait) of reference MixedSystem.
-///
-impl<'a> IntoIterator for &'a MixedSystem {
-    type Item = (&'a MixedProduct, &'a CalculatorComplex);
-    type IntoIter = Iter<'a, MixedProduct, CalculatorComplex>;
-
-    /// Returns the reference MixedSystem in Iterator form.
-    ///
-    /// # Returns
-    ///
-    /// * `Self::IntoIter` - The reference MixedSystem in Iterator form.
-    fn into_iter(self) -> Self::IntoIter {
-        self.operator.iter()
-    }
-}
 
-/// Implements the from_iter function (FromIterator trait) of MixedSystem.
-///
-impl FromIterator<(MixedProduct, CalculatorComplex)> for MixedSystem {
-    /// Returns the object in MixedSystem form, from an Iterator form of the object.
-    ///
-    /// # Arguments
-    ///
-    /// * `iter` - The iterator containing the information from which to create the MixedSystem.
-    ///
-    /// # Returns
-    ///
-    /// * `Self::IntoIter` - The iterator in MixedSystem form.
-    ///
-    /// # Panics
-    ///
-    /// * Internal error in set.
-    /// * Internal error in add_operator_product.
-    fn from_iter<I: IntoIterator<Item = (MixedProduct, CalculatorComplex)>>(iter: I) -> Self {
-        let mut iterator = iter.into_iter();
-        match iterator.next() {
-            Some(first_element) => {
-                let number_spins: Vec<Option<usize>> =
-                    (0..first_element.0.spins().len()).map(|_| None).collect();
-                let number_bosons: Vec<Option<usize>> =
-                    (0..first_element.0.bosons().len()).map(|_| None).collect();
-                let number_fermions: Vec<Option<usize>> = (0..first_element.0.fermions().len())
-                    .map(|_| None)
-                    .collect();
-                let mut slno = MixedSystem::new(number_spins, number_bosons, number_fermions);
-                slno.set(first_element.0, first_element.1)
-                    .expect("Internal error in set");
-                for (pair, cc) in iterator {
-                    slno.add_operator_product(pair, cc)
-                        .expect("Internal error in add_operator_product");
-                }
-                slno
+            /// Return the bincode representation of the object using the [bincode] crate.
+            ///
+            /// Returns:
+            ///     ByteArray: The serialized object (in [bincode] form).
+            ///
+            /// Raises:
+            ///     ValueError: Cannot serialize object to bytes.
+            pub fn to_bincode(&self) -> PyResult<Py<PyByteArray>> {
+                let serialized = bincode::serialize(&self.internal).map_err(|_| {
+                    PyValueError::new_err("Cannot serialize object to bytes")
+                })?;
+                let b: Py<PyByteArray> = Python::with_gil(|py| -> Py<PyByteArray> {
+                    PyByteArray::new(py, &serialized[..]).into()
+                });
+                Ok(b)
+            }
+
+            /// Return the json representation of the object.
+            ///
+            /// Returns:
+            ///     str: The serialized form of the object.
+            ///
+            /// Raises:
+            ///     ValueError: Cannot serialize object to json.
+            pub fn to_json(&self) -> PyResult<String> {
+                let serialized = serde_json::to_string(&self.internal)
+                    .map_err(|_| PyValueError::new_err("Cannot serialize object to json".to_string()))?;
+                Ok(serialized)
+            }
+
+            /// Convert the json representation of the object to an instance.
+            ///
+            /// Args:
+            ///     input (str): The serialized object in json form.
+            ///
+            /// Returns:
+            ///     The deserialized object.
+            ///
+            /// Raises:
+            ///     ValueError: Input cannot be deserialized.
+            #[staticmethod]
+            #[pyo3(text_signature = "(input)")]
+            pub fn from_json(input: String) -> PyResult<#ident> {
+                Ok(#ident {
+                    internal: serde_json::from_str(&input).map_err(|err| {
+                        PyValueError::new_err(format!(
+                            "Input cannot be deserialized {}",
+                            err
+                        ))
+                    })?,
+                })
             }
-            None => MixedSystem::new([], [], []),
-        }
-    }
-}
 
-/// Implements the extend function (Extend trait) of MixedSystem.
-///
-impl Extend<(MixedProduct, CalculatorComplex)> for MixedSystem {
-    /// Extends the MixedSystem by the specified operations (in Iterator form).
-    ///
-    /// # Arguments
-    ///
-    /// * `iter` - The iterator containing the operations by which to extend the MixedSystem.
-    ///
-    /// # Panics
-    ///
-    /// * Internal error in add_operator_product.
-    fn extend<I: IntoIterator<Item = (MixedProduct, CalculatorComplex)>>(&mut self, iter: I) {
-        for (pp, cc) in iter {
-            self.add_operator_product(pp, cc)
-                .expect("Internal error in add_operator_product");
-        }
-    }
-}
+            /// Convert a string representation of the object to an instance.
+            ///
+            /// Args:
+            ///     input (str): The serialized index in str representation.
+            ///
+            /// Returns:
+            ///     self: The converted object.
+            ///
+            /// Raises:
+            ///     ValueError: Input cannot be converted from str.
+            #[staticmethod]
+            #[pyo3(text_signature = "(input)")]
+            pub fn from_string(input: String) -> PyResult<#ident> {
+                Ok(#ident {
+                    internal: #struct_ident::from_str(&input).map_err(|err| {
+                        PyValueError::new_err(format!(
+                            "Input cannot be deserialized: {}",
+                            err
+                        ))
+                    })?,
+                })
+            }
 
-/// Implements the format function (Display trait) of MixedSystem.
-///
-impl fmt::Display for MixedSystem {
-    /// Formats the MixedSystem using the given formatter.
-    ///
-    /// # Arguments
-    ///
-    /// * `f` - The formatter to use.
-    ///
-    /// # Returns
-    ///
-    /// * `std::fmt::Result` - The formatted MixedSystem.
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        let mut output = "MixedSystem(\n".to_string();
-        output.push_str("number_spins: ");
-        for n in self.number_spins() {
-            write!(output, "{}, ", n)?;
-        }
-        output.push('\n');
-        output.push_str("number_bosons: ");
-        for n in self.number_bosonic_modes() {
-            write!(output, "{}, ", n)?;
-        }
-        output.push('\n');
-        output.push_str("number_fermions: ");
-        for n in self.number_fermionic_modes() {
-            write!(output, "{}, ", n)?;
-        }
-        output.push_str(")\n");
-        output.push('{');
-        let mut vec: Vec<(&MixedProduct, &CalculatorComplex)> = self.iter().collect();
-        vec.sort_unstable_by(|(left_index, _), (right_index, _)| {
-            left_index
-                .partial_cmp(right_index)
-                .expect("Cannot compare two unsigned integers internal error in struqture.spins")
-        });
-        for (key, val) in vec {
-            writeln!(output, "{}: {},", key, val)?;
+            /// Return a string containing a printable representation of the index.
+            ///
+            /// Returns:
+            ///     str: The printable string representation of the index.
+            pub fn __str__(&self) -> String {
+                format!("{}", self.internal)
+            }
+
+            /// Return a string containing a printable representation of the index.
+            ///
+            /// Returns:
+            ///     str: The printable string representation of the index.
+            pub fn __repr__(&self) -> String {
+                format!("{}", self.internal)
+            }
+
+            /// Return the __richcmp__ magic method to perform rich comparison operations on mixed index.
+            ///
+            /// Args:
+            ///     other: The object to compare self to.
+            ///     op: Whether they should be equal or not.
+            ///
+            /// Returns:
+            ///     Whether the two operations compared evaluated to True or False
+            ///
+            /// Raises:
+            ///     NotImplementedError: Other comparison not implemented.
+            pub fn __richcmp__(&self, other: Py<PyAny>, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
+                let other = Self::from_pyany(other);
+                    match op {
+                        pyo3::class::basic::CompareOp::Eq => match other {
+                            Ok(pauli) => Ok(self.internal == pauli),
+                            _ => Ok(false),
+                        },
+                        pyo3::class::basic::CompareOp::Ne => match other {
+                            Ok(pauli) => Ok(self.internal != pauli),
+                            _ => Ok(true),
+                        },
+                        _ => Err(pyo3::exceptions::PyNotImplementedError::new_err(
+                            "Other comparison not implemented",
+                        )),
+                    }
+
+            }
+
+            /// Return the __hash__ magic method.
+            ///
+            /// Returns:
+            ///     integer: Hash
+            pub fn __hash__(&self) -> PyResult<isize> {
+                let mut hasher = DefaultHasher::new();
+                self.internal.hash(&mut hasher);
+                Ok(hasher.finish() as isize)
+            }
+
+            #[cfg(feature = "json_schema")]
+            /// Returns the current version of the struqture library .
+            ///
+            /// Returns:
+            ///     str: The current version of the library.
+            #[staticmethod]
+            pub fn current_version() -> String {
+                return STRUQTURE_VERSION.to_string();
+            }
+
+            #[cfg(feature = "json_schema")]
+            /// Return the minimum version of struqture that supports this object.
+            ///
+            /// Returns:
+            ///     str: The minimum version of the struqture library to deserialize this object.
+            pub fn min_supported_version(&self) -> String {
+                let min_version: (usize, usize, usize) = struqture::SerializationSupport::min_supported_version(&self.internal);
+                return format!("{}.{}.{}", min_version.0, min_version.1, min_version.2);
+            }
+
+            /// Returns the StruqtureSerialisationMeta of the object.
+            fn _get_serialisation_meta(&self) -> PyResult<String>{
+                let meta = struqture::SerializationSupport::struqture_serialisation_meta(&self.internal);
+                let string = serde_json::to_string(&meta).map_err(|err| PyValueError::new_err(err.to_string()))?;
+                Ok(string)
+            }
+
+            #[cfg(feature = "json_schema")]
+            /// Return the JsonSchema for the json serialisation of the class.
+            ///
+            /// Returns:
+            ///     str: The json schema serialized to json
+            #[staticmethod]
+            pub fn json_schema() -> String {
+                let schema = schemars::schema_for!(#struct_ident);
+                serde_json::to_string_pretty(&schema).expect("Unexpected failure to serialize schema")
+            }
         }
-        output.push('}');
 
-        write!(f, "{}", output)
-    }
+    };
+    q.into()
 }
```

### Comparing `struqture_py-1.6.1/struqture/src/mixed_systems/mod.rs` & `struqture_py-2.0.0a0/struqture/src/mixed_systems/mod.rs`

 * *Files 18% similar despite different names*

```diff
@@ -13,55 +13,49 @@
 //! Module for representing mixed physical systems
 //!
 //! A mixed physical system can contain any combination of none, one, or several subsystems of spin, bosonic, or fermionic types.
 //! For example a mixed system with two spin-subsystems or a mixed system with a spin-subsystem and a bosonic-subsystem would both be valid.
 //!
 //! This module can be used to represent mixed quantum operators, mixed quantum Hamiltonians and mixed open quantum systems.
 //!
-//! In general the enduser should use the high-level [crate::mixed_systems::MixedSystem] and [crate::mixed_systems::MixedHamiltonianSystem] structs
+//! In general the enduser should use the high-level [crate::mixed_systems::MixedSystem] and [crate::mixed_systems::MixedHamiltonian] structs
 //! to represent mixed quantum Operators and mixed Hamiltonians respectively.
 //!
 //! Open Quantum Systems should be represented using [crate::mixed_systems::MixedLindbladOpenSystem].
 //!
 //!
 
 mod mixed_decoherence_product;
 mod mixed_hamiltonian;
-mod mixed_hamiltonian_system;
 mod mixed_hermitian_product;
 mod mixed_noise_operator;
-mod mixed_noise_system;
 mod mixed_open_system;
 mod mixed_operator;
 mod mixed_plus_minus_operator;
 mod mixed_plus_minus_product;
 mod mixed_product;
-mod mixed_system;
 
 use crate::{
     bosons::BosonIndex, fermions::FermionIndex, ModeIndex, OperateOnDensityMatrix, SpinIndex,
     StruqtureError,
 };
-#[cfg(feature = "json_schema")]
-use mixed_noise_system::TinyVecDef;
+// #[cfg(feature = "json_schema")]
+// use mixed_noise_system::TinyVecDef;
 use qoqo_calculator::CalculatorComplex;
 use std::str::FromStr;
 
 pub use mixed_decoherence_product::MixedDecoherenceProduct;
 pub use mixed_hamiltonian::MixedHamiltonian;
-pub use mixed_hamiltonian_system::MixedHamiltonianSystem;
 pub use mixed_hermitian_product::HermitianMixedProduct;
 pub use mixed_noise_operator::MixedLindbladNoiseOperator;
-pub use mixed_noise_system::MixedLindbladNoiseSystem;
 pub use mixed_open_system::MixedLindbladOpenSystem;
 pub use mixed_operator::MixedOperator;
 pub use mixed_plus_minus_operator::MixedPlusMinusOperator;
 pub use mixed_plus_minus_product::MixedPlusMinusProduct;
 pub use mixed_product::MixedProduct;
-pub use mixed_system::MixedSystem;
 
 /// Trait for all index types requires converting between index types
 pub trait MixedIndex:
     std::hash::Hash
     + Eq
     + Sized
     + Clone
@@ -173,69 +167,39 @@
 /// let mut sh = MixedOperator::new(1, 1, 1);
 ///
 /// let mp_1: MixedProduct = MixedProduct::new([PauliProduct::new().x(0),], [BosonProduct::new([0], [1]).unwrap()], [FermionProduct::new([0], [1]).unwrap()]).unwrap();
 /// let mp_0: MixedProduct = MixedProduct::new([PauliProduct::new().z(0),], [BosonProduct::new([0], [1]).unwrap()], [FermionProduct::new([0], [1]).unwrap()]).unwrap();
 /// sh.set(mp_1.clone(), CalculatorComplex::from(0.5)).unwrap();
 /// sh.set(mp_0.clone(), CalculatorComplex::from(0.2)).unwrap();
 ///
-/// assert_eq!(sh.number_spins(), vec![1]);
 /// assert_eq!(sh.current_number_spins(), vec![1]);
-/// assert_eq!(sh.number_bosonic_modes(), vec![2]);
 /// assert_eq!(sh.current_number_bosonic_modes(), vec![2]);
-/// assert_eq!(sh.number_fermionic_modes(), vec![2]);
 /// assert_eq!(sh.current_number_fermionic_modes(), vec![2]);
 /// ```
 ///
 pub trait OperateOnMixedSystems<'a>: PartialEq + Clone {
     /// Returns the number of spins in each spin sub-system of Self.
     ///
     /// # Returns
     ///
     /// * `Vec<usize>` - The number of spins in each sub-system of Self.
-    fn number_spins(&self) -> Vec<usize>;
-
-    /// Returns the number of spins a physical operator acts upon in each spin sub-system of Self.
-    ///
-    /// This corresponds to returning the maximum index the spin operator acts on in each sub-system.
-    ///
-    /// # Returns
-    ///
-    /// * `Vec<usize>` - Maximum spin index currently used in each sub-system of Self.
     fn current_number_spins(&self) -> Vec<usize>;
 
     /// Returns the number of bosonic modes in each boson sub-system of Self.
     ///
     /// # Returns
     ///
     /// * `Vec<usize>` - The number of bosonic modes in each sub-system of Self.
-    fn number_bosonic_modes(&self) -> Vec<usize>;
-
-    /// Returns the number of bosonic modes a physical operator acts upon in each boson sub-system of Self.
-    ///
-    /// This corresponds to returning the maximum index the boson operator acts on in each sub-system.
-    ///
-    /// # Returns
-    ///
-    /// * `Vec<usize>` - Maximum boson index currently used in each sub-system of Self.
     fn current_number_bosonic_modes(&self) -> Vec<usize>;
 
     /// Returns the number of fermionic modes in each fermion sub-system of Self.
     ///
     /// # Returns
     ///
     /// * `Vec<usize>` - The number of fermionic modes in each sub-system of Self.
-    fn number_fermionic_modes(&self) -> Vec<usize>;
-
-    /// Returns the number of fermionic modes a physical operator acts upon in each fermion sub-system of Self.
-    ///
-    /// This corresponds to returning the maximum index the fermion operator acts on in each sub-system.
-    ///
-    /// # Returns
-    ///
-    /// * `Vec<usize>` - Maximum fermion index currently used in each sub-system of Self.
     fn current_number_fermionic_modes(&self) -> Vec<usize>;
 }
 
 pub trait HermitianOperateOnMixedSystems<'a>:
     OperateOnMixedSystems<'a>
     + OperateOnDensityMatrix<'a>
     + IntoIterator
```

### Comparing `struqture_py-1.6.1/struqture/src/prelude.rs` & `struqture_py-2.0.0a0/struqture/src/prelude.rs`

 * *Files identical despite different names*

### Comparing `struqture_py-1.6.1/struqture/src/spins/decoherence_operator.rs` & `struqture_py-2.0.0a0/struqture/src/spins/decoherence_operator.rs`

 * *Files 10% similar despite different names*

```diff
@@ -6,36 +6,27 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
-use super::{OperateOnSpins, SpinOperator};
+use super::{OperateOnSpins, QubitOperator};
 use crate::fermions::FermionOperator;
 use crate::mappings::JordanWignerSpinToFermion;
 use crate::spins::DecoherenceProduct;
-use crate::{
-    OperateOnDensityMatrix, OperateOnState, SpinIndex, StruqtureError,
-    StruqtureVersionSerializable, SymmetricIndex, MINIMUM_STRUQTURE_VERSION,
-};
+use crate::{OperateOnDensityMatrix, OperateOnState, SpinIndex, StruqtureError, SymmetricIndex};
 use qoqo_calculator::{CalculatorComplex, CalculatorFloat};
 use serde::{Deserialize, Serialize};
 use std::fmt::{self, Write};
 use std::iter::{FromIterator, IntoIterator};
 use std::ops;
 
-#[cfg(feature = "indexed_map_iterators")]
-use indexmap::map::{Entry, Iter, Keys, Values};
-#[cfg(feature = "indexed_map_iterators")]
+use indexmap::map::{Entry, Iter};
 use indexmap::IndexMap;
-#[cfg(not(feature = "indexed_map_iterators"))]
-use std::collections::hash_map::{Entry, Iter, Keys, Values};
-#[cfg(not(feature = "indexed_map_iterators"))]
-use std::collections::HashMap;
 
 /// DecoherenceOperators are combinations of DecoherenceProducts with specific CalculatorComplex coefficients.
 ///
 /// This is a representation of sums of pauli products with weightings, in order to build a full hamiltonian.
 ///
 /// # Example
 ///
@@ -54,27 +45,27 @@
 ///
 /// // Access what you set:
 /// assert_eq!(so.get(&pp_01), &CalculatorComplex::from(0.5));
 /// assert_eq!(so.get(&pp_0), &CalculatorComplex::from(0.2));
 /// ```
 ///
 #[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
-#[serde(from = "DecoherenceOperatorSerialize")]
+#[serde(try_from = "DecoherenceOperatorSerialize")]
 #[serde(into = "DecoherenceOperatorSerialize")]
 
 pub struct DecoherenceOperator {
     /// The internal HashMap of DecoherenceProducts and coefficients (CalculatorComplex)
-    #[cfg(feature = "indexed_map_iterators")]
     internal_map: IndexMap<DecoherenceProduct, CalculatorComplex>,
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    internal_map: HashMap<DecoherenceProduct, CalculatorComplex>,
 }
 
-impl crate::MinSupportedVersion for DecoherenceOperator {}
-
+impl crate::SerializationSupport for DecoherenceOperator {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::DecoherenceOperator
+    }
+}
 #[cfg(feature = "json_schema")]
 impl schemars::JsonSchema for DecoherenceOperator {
     fn schema_name() -> String {
         "DecoherenceOperator".to_string()
     }
 
     fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
@@ -84,87 +75,80 @@
 
 #[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
 #[cfg_attr(feature = "json_schema", derive(schemars::JsonSchema))]
 #[cfg_attr(feature = "json_schema", schemars(deny_unknown_fields))]
 struct DecoherenceOperatorSerialize {
     /// The internal map representing the noise terms
     items: Vec<(DecoherenceProduct, CalculatorFloat, CalculatorFloat)>,
-    _struqture_version: StruqtureVersionSerializable,
+    serialisation_meta: crate::StruqtureSerialisationMeta,
 }
 
-impl From<DecoherenceOperatorSerialize> for DecoherenceOperator {
-    fn from(value: DecoherenceOperatorSerialize) -> Self {
+impl TryFrom<DecoherenceOperatorSerialize> for DecoherenceOperator {
+    type Error = StruqtureError;
+    fn try_from(value: DecoherenceOperatorSerialize) -> Result<Self, Self::Error> {
+        let target_serialisation_meta =
+            <Self as crate::SerializationSupport>::target_serialisation_meta();
+        crate::check_can_be_deserialised(&target_serialisation_meta, &value.serialisation_meta)?;
+
         let new_noise_op: DecoherenceOperator = value
             .items
             .into_iter()
             .map(|(key, real, imag)| (key, CalculatorComplex { re: real, im: imag }))
             .collect();
-        new_noise_op
+        Ok(new_noise_op)
     }
 }
 
 impl From<DecoherenceOperator> for DecoherenceOperatorSerialize {
     fn from(value: DecoherenceOperator) -> Self {
+        let serialisation_meta = crate::SerializationSupport::struqture_serialisation_meta(&value);
+
         let new_noise_op: Vec<(DecoherenceProduct, CalculatorFloat, CalculatorFloat)> = value
             .into_iter()
             .map(|(key, val)| (key, val.re, val.im))
             .collect();
-        let current_version = StruqtureVersionSerializable {
-            major_version: MINIMUM_STRUQTURE_VERSION.0,
-            minor_version: MINIMUM_STRUQTURE_VERSION.1,
-        };
         Self {
             items: new_noise_op,
-            _struqture_version: current_version,
+            serialisation_meta,
         }
     }
 }
 
 impl<'a> OperateOnDensityMatrix<'a> for DecoherenceOperator {
-    type IteratorType = Iter<'a, Self::Index, Self::Value>;
-    type KeyIteratorType = Keys<'a, Self::Index, Self::Value>;
-    type ValueIteratorType = Values<'a, Self::Index, Self::Value>;
     type Value = CalculatorComplex;
     type Index = DecoherenceProduct;
 
     // From trait
     fn get(&self, key: &Self::Index) -> &Self::Value {
         match self.internal_map.get(key) {
             Some(value) => value,
             None => &CalculatorComplex::ZERO,
         }
     }
 
     // From trait
-    fn iter(&'a self) -> Self::IteratorType {
+    fn iter(&'a self) -> impl ExactSizeIterator<Item = (&'a Self::Index, &'a Self::Value)> {
         self.internal_map.iter()
     }
 
     // From trait
-    fn keys(&'a self) -> Self::KeyIteratorType {
+    fn keys(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Index> {
         self.internal_map.keys()
     }
 
     // From trait
-    fn values(&'a self) -> Self::ValueIteratorType {
+    fn values(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Value> {
         self.internal_map.values()
     }
 
-    #[cfg(feature = "indexed_map_iterators")]
     // From trait
     fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
         self.internal_map.shift_remove(key)
     }
 
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    // From trait
-    fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
-        self.internal_map.remove(key)
-    }
-
     // From trait
     fn empty_clone(&self, capacity: Option<usize>) -> Self {
         match capacity {
             Some(cap) => Self::with_capacity(cap),
             None => Self::new(),
         }
     }
@@ -186,18 +170,15 @@
         key: Self::Index,
         value: Self::Value,
     ) -> Result<Option<Self::Value>, StruqtureError> {
         if value != CalculatorComplex::ZERO {
             Ok(self.internal_map.insert(key, value))
         } else {
             match self.internal_map.entry(key) {
-                #[cfg(feature = "indexed_map_iterators")]
                 Entry::Occupied(val) => Ok(Some(val.shift_remove())),
-                #[cfg(not(feature = "indexed_map_iterators"))]
-                Entry::Occupied(val) => Ok(Some(val.remove())),
                 Entry::Vacant(_) => Ok(None),
             }
         }
     }
 }
 
 impl<'a> OperateOnState<'a> for DecoherenceOperator {
@@ -211,39 +192,30 @@
                 .expect("Internal bug in add_operator_product");
         }
         new_operator
     }
 }
 
 impl<'a> OperateOnSpins<'a> for DecoherenceOperator {
-    /// Returns maximum index in DecoherenceOperator internal_map.
+    /// Gets the maximum index of the DecoherenceOperator.
     ///
     /// # Returns
     ///
-    /// * `usize` - Maximum index.
+    /// * `usize` - The number of spins in the DecoherenceOperator.
     fn current_number_spins(&self) -> usize {
         let mut max_mode: usize = 0;
         if !self.internal_map.is_empty() {
             for key in self.internal_map.keys() {
                 if key.current_number_spins() > max_mode {
                     max_mode = key.current_number_spins()
                 }
             }
         }
         max_mode
     }
-
-    /// Gets the maximum index of the DecoherenceOperator.
-    ///
-    /// # Returns
-    ///
-    /// * `usize` - The number of spins in the DecoherenceOperator.
-    fn number_spins(&self) -> usize {
-        self.current_number_spins()
-    }
 }
 
 // The following traits are intentionally not implemented:
 // impl<'a> ToSparseMatrixOperator<'a> for DecoherenceOperator {}
 // impl<'a> ToSparseMatrixSuperOperator<'a> for DecoherenceOperator {
 
 /// Implements the default function (Default trait) of DecoherenceOperator (an empty DecoherenceOperator).
@@ -260,17 +232,14 @@
     /// Creates a new DecoherenceOperator.
     ///
     /// # Returns
     ///
     /// * `Self` - The new (empty) DecoherenceOperator.
     pub fn new() -> Self {
         DecoherenceOperator {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::new(),
-            #[cfg(feature = "indexed_map_iterators")]
             internal_map: IndexMap::new(),
         }
     }
 
     /// Creates a new DecoherenceOperator with pre-allocated capacity.
     ///
     /// # Arguments
@@ -278,60 +247,59 @@
     /// * `capacity` - The pre-allocated capacity of the operator.
     ///
     /// # Returns
     ///
     /// * `Self` - The new (empty) DecoherenceOperator.
     pub fn with_capacity(capacity: usize) -> Self {
         DecoherenceOperator {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::with_capacity(capacity),
-            #[cfg(feature = "indexed_map_iterators")]
             internal_map: IndexMap::with_capacity(capacity),
         }
     }
 
-    /// Separate self into an operator with the terms of given number of spins and an operator with the remaining operations
-    ///
-    /// # Arguments
-    ///
-    /// * `number_spins` - Number of spins to filter for in the keys.
-    ///
-    /// # Returns
-    ///
-    /// `Ok((separated, remainder))` - Operator with the noise terms where number_spins matches the number of spins the operator product acts on and Operator with all other contributions.
-    pub fn separate_into_n_terms(
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(
         &self,
-        number_spins: usize,
-    ) -> Result<(Self, Self), StruqtureError> {
-        let mut separated = Self::default();
-        let mut remainder = Self::default();
-        for (prod, val) in self.iter() {
-            if prod.len() == number_spins {
-                separated.add_operator_product(prod.clone(), val.clone())?;
-            } else {
-                remainder.add_operator_product(prod.clone(), val.clone())?;
-            }
+    ) -> Result<struqture_one::spins::DecoherenceOperator, StruqtureError> {
+        let mut new_qubit_system = struqture_one::spins::DecoherenceOperator::new();
+        for (key, val) in self.iter() {
+            let one_key = key.to_struqture_1()?;
+            let _ = struqture_one::OperateOnDensityMatrix::set(
+                &mut new_qubit_system,
+                one_key,
+                val.clone(),
+            );
+        }
+        Ok(new_qubit_system)
+    }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::spins::DecoherenceOperator,
+    ) -> Result<Self, StruqtureError> {
+        let mut new_qubit_operator = Self::new();
+        for (key, val) in struqture_one::OperateOnDensityMatrix::iter(value) {
+            let self_key = DecoherenceProduct::from_struqture_1(key)?;
+            let _ = new_qubit_operator.set(self_key, val.clone());
         }
-        Ok((separated, remainder))
+        Ok(new_qubit_operator)
     }
 }
 
 /// Implements the negative sign function of DecoherenceOperator.
 ///
 impl ops::Neg for DecoherenceOperator {
     type Output = DecoherenceOperator;
     /// Implement minus sign for DecoherenceOperator.
     ///
     /// # Returns
     ///
     /// * `Self` - The DecoherenceOperator * -1.
     fn neg(self) -> Self {
-        #[cfg(not(feature = "indexed_map_iterators"))]
-        let mut internal = HashMap::with_capacity(self.len());
-        #[cfg(feature = "indexed_map_iterators")]
         let mut internal = IndexMap::with_capacity(self.len());
         for (key, val) in self {
             internal.insert(key.clone(), val.neg());
         }
         DecoherenceOperator {
             internal_map: internal,
         }
@@ -404,17 +372,14 @@
     /// * `other` - The CalculatorComplex or CalculatorFloat by which to multiply.
     ///
     /// # Returns
     ///
     /// * `Self` - The DecoherenceOperator multiplied by the CalculatorComplex/CalculatorFloat.
     fn mul(self, other: T) -> Self {
         let other_cc = Into::<CalculatorComplex>::into(other);
-        #[cfg(not(feature = "indexed_map_iterators"))]
-        let mut internal = HashMap::with_capacity(self.len());
-        #[cfg(feature = "indexed_map_iterators")]
         let mut internal = IndexMap::with_capacity(self.len());
         for (key, val) in self {
             internal.insert(key, val * other_cc.clone());
         }
         DecoherenceOperator {
             internal_map: internal,
         }
@@ -431,36 +396,33 @@
     ///
     /// * `other` - The DecoherenceOperator to multiply by.
     ///
     /// # Returns
     ///
     /// * `Self` - The two DecoherenceOperators multiplied.
     fn mul(self, other: DecoherenceOperator) -> Self {
-        let mut spin_op = DecoherenceOperator::with_capacity(self.len() * other.len());
+        let mut qubit_op = DecoherenceOperator::with_capacity(self.len() * other.len());
         for (pps, vals) in self {
             for (ppo, valo) in other.iter() {
                 let (ppp, coefficient) = pps.clone() * ppo.clone();
                 let coefficient =
                     Into::<CalculatorComplex>::into(valo) * coefficient * vals.clone();
-                spin_op
+                qubit_op
                     .add_operator_product(ppp, coefficient)
                     .expect("Internal bug in add_operator_product");
             }
         }
-        spin_op
+        qubit_op
     }
 }
 
 /// Implements the into_iter function (IntoIterator trait) of DecoherenceOperator.
 ///
 impl IntoIterator for DecoherenceOperator {
     type Item = (DecoherenceProduct, CalculatorComplex);
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    type IntoIter = std::collections::hash_map::IntoIter<DecoherenceProduct, CalculatorComplex>;
-    #[cfg(feature = "indexed_map_iterators")]
     type IntoIter = indexmap::map::IntoIter<DecoherenceProduct, CalculatorComplex>;
     /// Returns the DecoherenceOperator in Iterator form.
     ///
     /// # Returns
     ///
     /// * `Self::IntoIter` - The DecoherenceOperator in Iterator form.
     fn into_iter(self) -> Self::IntoIter {
@@ -541,29 +503,29 @@
         }
         output.push('}');
 
         write!(f, "{}", output)
     }
 }
 
-impl From<SpinOperator> for DecoherenceOperator {
-    /// Converts a SpinOperator into a DecoherenceProduct.
+impl From<QubitOperator> for DecoherenceOperator {
+    /// Converts a QubitOperator into a DecoherenceProduct.
     ///
     /// # Arguments
     ///
-    /// * `op` - The SpinOperator to convert.
+    /// * `op` - The QubitOperator to convert.
     ///
     /// # Returns
     ///
-    /// * `Self` - The SpinOperator converted into a DecoherenceProduct.
+    /// * `Self` - The QubitOperator converted into a DecoherenceProduct.
     ///
     /// # Panics
     ///
     /// * Internal error in add_operator_product.
-    fn from(op: SpinOperator) -> Self {
+    fn from(op: QubitOperator) -> Self {
         let mut out = DecoherenceOperator::new();
         for prod in op.keys() {
             let (new_prod, new_coeff) = DecoherenceProduct::spin_to_decoherence(prod.clone());
             out.add_operator_product(new_prod, op.get(prod).clone() * new_coeff)
                 .expect("Internal error in add_operator_product");
         }
         out
@@ -591,96 +553,102 @@
 }
 
 #[cfg(test)]
 mod test {
     use super::*;
     use serde_test::{assert_tokens, Configure, Token};
 
-    // Test the Clone and PartialEq traits of SpinOperator
+    // Test the Clone and PartialEq traits of QubitOperator
     #[test]
     fn so_from_sos() {
         let pp: DecoherenceProduct = DecoherenceProduct::new().z(0);
         let sos = DecoherenceOperatorSerialize {
             items: vec![(pp.clone(), 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "DecoherenceOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0-alpha.0".to_string(),
             },
         };
         let mut so = DecoherenceOperator::new();
         so.set(pp, CalculatorComplex::from(0.5)).unwrap();
 
-        assert_eq!(DecoherenceOperator::from(sos.clone()), so);
+        assert_eq!(DecoherenceOperator::try_from(sos.clone()).unwrap(), so);
         assert_eq!(DecoherenceOperatorSerialize::from(so), sos);
     }
-    // Test the Clone and PartialEq traits of SpinOperator
+    // Test the Clone and PartialEq traits of QubitOperator
     #[test]
     fn clone_partial_eq() {
         let pp: DecoherenceProduct = DecoherenceProduct::new().z(0);
         let sos = DecoherenceOperatorSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "DecoherenceOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         // Test Clone trait
         assert_eq!(sos.clone(), sos);
 
         // Test PartialEq trait
         let pp_1: DecoherenceProduct = DecoherenceProduct::new().z(0);
         let sos_1 = DecoherenceOperatorSerialize {
             items: vec![(pp_1, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "DecoherenceOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
         let pp_2: DecoherenceProduct = DecoherenceProduct::new().z(2);
         let sos_2 = DecoherenceOperatorSerialize {
             items: vec![(pp_2, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "DecoherenceOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
         assert!(sos_1 == sos);
         assert!(sos == sos_1);
         assert!(sos_2 != sos);
         assert!(sos != sos_2);
     }
 
-    // Test the Debug trait of SpinOperator
+    // Test the Debug trait of QubitOperator
     #[test]
     fn debug() {
         let pp: DecoherenceProduct = DecoherenceProduct::new().z(0);
         let sos = DecoherenceOperatorSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "DecoherenceOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_eq!(
             format!("{:?}", sos),
-            "DecoherenceOperatorSerialize { items: [(DecoherenceProduct { items: [(0, Z)] }, Float(0.5), Float(0.0))], _struqture_version: StruqtureVersionSerializable { major_version: 1, minor_version: 0 } }"
+            "DecoherenceOperatorSerialize { items: [(DecoherenceProduct { items: [(0, Z)] }, Float(0.5), Float(0.0))], serialisation_meta: StruqtureSerialisationMeta { type_name: \"DecoherenceOperator\", min_version: (2, 0, 0), version: \"2.0.0\" } }"
         );
     }
 
-    /// Test SpinOperator Serialization and Deserialization traits (readable)
+    /// Test QubitOperator Serialization and Deserialization traits (readable)
     #[test]
     fn serde_readable() {
         let pp = DecoherenceProduct::new().x(0);
         let sos = DecoherenceOperatorSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "DecoherenceOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_tokens(
             &sos.readable(),
             &[
                 Token::Struct {
@@ -691,38 +659,45 @@
                 Token::Seq { len: Some(1) },
                 Token::Tuple { len: 3 },
                 Token::Str("0X"),
                 Token::F64(0.5),
                 Token::F64(0.0),
                 Token::TupleEnd,
                 Token::SeqEnd,
-                Token::Str("_struqture_version"),
+                Token::Str("serialisation_meta"),
                 Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
                 },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(0),
+                Token::Str("type_name"),
+                Token::Str("DecoherenceOperator"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
                 Token::StructEnd,
                 Token::StructEnd,
             ],
         );
     }
 
-    /// Test SpinOperator Serialization and Deserialization traits (compact)
+    /// Test QubitOperator Serialization and Deserialization traits (compact)
     #[test]
     fn serde_compact() {
         let pp = DecoherenceProduct::new().x(0);
         let sos = DecoherenceOperatorSerialize {
             items: vec![(pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "DecoherenceOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_tokens(
             &sos.compact(),
             &[
                 Token::Struct {
@@ -749,22 +724,28 @@
                 Token::NewtypeVariant {
                     name: "CalculatorFloat",
                     variant: "Float",
                 },
                 Token::F64(0.0),
                 Token::TupleEnd,
                 Token::SeqEnd,
-                Token::Str("_struqture_version"),
+                Token::Str("serialisation_meta"),
                 Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
                 },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(0),
+                Token::Str("type_name"),
+                Token::Str("DecoherenceOperator"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
                 Token::StructEnd,
                 Token::StructEnd,
             ],
         );
     }
 }
```

### Comparing `struqture_py-1.6.1/struqture/src/spins/decoherence_product.rs` & `struqture_py-2.0.0a0/struqture/src/spins/decoherence_product.rs`

 * *Files 3% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
 use crate::fermions::FermionOperator;
 use crate::mappings::JordanWignerSpinToFermion;
-use crate::spins::SingleSpinOperator;
+use crate::spins::SingleQubitOperator;
 use crate::{CooSparseMatrix, CorrespondsTo, GetValue, SpinIndex, StruqtureError, SymmetricIndex};
 use num_complex::Complex64;
 use qoqo_calculator::CalculatorComplex;
 use serde::de::{Deserializer, Error, SeqAccess, Visitor};
 use serde::ser::{SerializeSeq, Serializer};
 use serde::{Deserialize, Serialize};
 use std::cmp::{self, Ordering};
@@ -161,54 +161,56 @@
             (SingleDecoherenceOperator::Z, SingleDecoherenceOperator::Z) => {
                 (SingleDecoherenceOperator::Identity, 1.0)
             }
         };
         result_vec
     }
 
-    /// Conversion function from SingleDecoherenceOperator to SingleSpinOperator.
+    /// Conversion function from SingleDecoherenceOperator to SingleQubitOperator.
     ///
     /// # Arguments
     ///
     /// * `decoherence` - SingleDecoherenceOperator to convert to SingleDecoherenceOperator type.
     ///
     /// # Returns
     ///
     /// * `Vec<(SingleDecoherenceOperator, Complex64)>` - Vector of tuples of SingleDecoherenceOperator with a corresponding Complex64 coefficient.
     pub fn decoherence_to_spin(
         decoherence: SingleDecoherenceOperator,
-    ) -> (SingleSpinOperator, Complex64) {
+    ) -> (SingleQubitOperator, Complex64) {
         match decoherence {
             SingleDecoherenceOperator::Identity => {
-                (SingleSpinOperator::Identity, Complex64::new(1.0, 0.0))
+                (SingleQubitOperator::Identity, Complex64::new(1.0, 0.0))
             }
-            SingleDecoherenceOperator::X => (SingleSpinOperator::X, Complex64::new(1.0, 0.0)),
-            SingleDecoherenceOperator::IY => (SingleSpinOperator::Y, Complex64::new(0.0, 1.0)),
-            SingleDecoherenceOperator::Z => (SingleSpinOperator::Z, Complex64::new(1.0, 0.0)),
+            SingleDecoherenceOperator::X => (SingleQubitOperator::X, Complex64::new(1.0, 0.0)),
+            SingleDecoherenceOperator::IY => (SingleQubitOperator::Y, Complex64::new(0.0, 1.0)),
+            SingleDecoherenceOperator::Z => (SingleQubitOperator::Z, Complex64::new(1.0, 0.0)),
         }
     }
 
-    /// Conversion function from SingleSpinOperator to SingleDecoherenceOperator.
+    /// Conversion function from SingleQubitOperator to SingleDecoherenceOperator.
     ///
     /// # Arguments
     ///
     /// * `spin` - SingleDecoherenceOperator to convert to SingleDecoherenceOperator type.
     ///
     /// # Returns
     ///
     /// * `Vec<(SingleDecoherenceOperator, Complex64)>` - Vector of tuples of SingleDecoherenceOperator with a corresponding Complex64 coefficient.
-    pub fn spin_to_decoherence(spin: SingleSpinOperator) -> (SingleDecoherenceOperator, Complex64) {
+    pub fn spin_to_decoherence(
+        spin: SingleQubitOperator,
+    ) -> (SingleDecoherenceOperator, Complex64) {
         match spin {
-            SingleSpinOperator::Identity => (
+            SingleQubitOperator::Identity => (
                 SingleDecoherenceOperator::Identity,
                 Complex64::new(1.0, 0.0),
             ),
-            SingleSpinOperator::X => (SingleDecoherenceOperator::X, Complex64::new(1.0, 0.0)),
-            SingleSpinOperator::Y => (SingleDecoherenceOperator::IY, Complex64::new(0.0, -1.0)),
-            SingleSpinOperator::Z => (SingleDecoherenceOperator::Z, Complex64::new(1.0, 0.0)),
+            SingleQubitOperator::X => (SingleDecoherenceOperator::X, Complex64::new(1.0, 0.0)),
+            SingleQubitOperator::Y => (SingleDecoherenceOperator::IY, Complex64::new(0.0, -1.0)),
+            SingleQubitOperator::Z => (SingleDecoherenceOperator::Z, Complex64::new(1.0, 0.0)),
         }
     }
 
     /// Returns the hermitian conjugate of the DecoherenceOperator.
     ///
     /// # Returns
     ///
@@ -266,15 +268,19 @@
         let meta = obj.metadata();
         meta.description = Some("Represents products of Decoherence Operators (X, iY, Z) by a string of spin numbers followed by pauli operators. E.g. 0X10iY13Z14X.".to_string());
 
         schemars::schema::Schema::Object(obj)
     }
 }
 
-impl crate::MinSupportedVersion for DecoherenceProduct {}
+impl crate::SerializationSupport for DecoherenceProduct {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::DecoherenceProduct
+    }
+}
 
 /// Implementing serde serialization writing directly to string.
 ///
 impl Serialize for DecoherenceProduct {
     /// Serialization function for DecoherenceProduct according to string type.
     ///
     /// # Arguments
@@ -678,14 +684,39 @@
         value
     }
 }
 
 /// Functions for the DecoherenceProduct
 ///
 impl DecoherenceProduct {
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(
+        &self,
+    ) -> Result<struqture_one::spins::DecoherenceProduct, StruqtureError> {
+        let self_string = self.to_string();
+        let struqture_one_product =
+            struqture_one::spins::DecoherenceProduct::from_str(&self_string).map_err(|err| {
+                StruqtureError::GenericError {
+                    msg: format!("{}", err),
+                }
+            })?;
+        Ok(struqture_one_product)
+    }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::spins::DecoherenceProduct,
+    ) -> Result<Self, StruqtureError> {
+        let value_string = value.to_string();
+        let decoh_product = Self::from_str(&value_string)?;
+        Ok(decoh_product)
+    }
+
     /// Sets a new entry for SingleDecoherenceOperator X in the internal dictionary. This function consumes Self.
     ///
     /// # Arguments
     ///
     /// * `index` - Index of set object.
     ///
     /// # Returns
```

### Comparing `struqture_py-1.6.1/struqture/src/spins/mod.rs` & `struqture_py-2.0.0a0/struqture/src/spins/mod.rs`

 * *Files 6% similar despite different names*

```diff
@@ -25,34 +25,25 @@
 
 mod pauli_product;
 pub use pauli_product::*;
 
 mod decoherence_operator;
 pub use decoherence_operator::*;
 
-mod spin_operator;
-pub use spin_operator::*;
+mod qubit_operator;
+pub use qubit_operator::*;
 
-mod spin_hamiltonian;
-pub use spin_hamiltonian::*;
+mod qubit_hamiltonian;
+pub use qubit_hamiltonian::*;
 
-mod spin_system;
-pub use spin_system::*;
+mod qubit_noise_operator;
+pub use qubit_noise_operator::*;
 
-mod spin_hamiltonian_system;
-pub use spin_hamiltonian_system::*;
-
-mod spin_noise_operator;
-pub use spin_noise_operator::*;
-
-mod spin_noise_system;
-pub use spin_noise_system::*;
-
-mod spin_open_system;
-pub use spin_open_system::*;
+mod qubit_open_system;
+pub use qubit_open_system::*;
 
 mod plus_minus_product;
 pub use plus_minus_product::*;
 
 mod plus_minus_operator;
 pub use plus_minus_operator::*;
 
@@ -64,17 +55,17 @@
 /// Trait for non-Hermitian operations on spins.
 ///
 /// # Example
 /// ```
 /// use struqture::prelude::*;
 /// use qoqo_calculator::CalculatorComplex;
 /// use std::collections::HashMap;
-/// use struqture::spins::{OperateOnSpins, PauliProduct, SpinOperator};
+/// use struqture::spins::{OperateOnSpins, PauliProduct, QubitOperator};
 ///
-/// let mut so = SpinOperator::new();
+/// let mut so = QubitOperator::new();
 /// let pp_0z = PauliProduct::new().z(0);
 /// so.add_operator_product(pp_0z.clone(), CalculatorComplex::from(0.2)).unwrap();
 /// let mut mapping: HashMap<PauliProduct, CalculatorComplex> = HashMap::new();
 /// mapping.insert(pp_0z.clone(), CalculatorComplex::from(0.2));
 ///
 /// // Functions provided in this :
 /// assert_eq!(so.get(&pp_0z), &CalculatorComplex::from(0.2));
@@ -90,33 +81,26 @@
 /// assert_eq!(so.len(), 1_usize);
 /// assert_eq!(so.is_empty(), false);
 /// ```
 ///
 ///
 pub trait OperateOnSpins<'a>: PartialEq + Clone + Mul<CalculatorFloat> + Add + Sub {
     // Document locally
-    fn number_spins(&self) -> usize;
-
-    /// Returns maximum index in Self.
-    ///
-    /// # Returns
-    ///
-    /// * `usize` - Maximum index.
     fn current_number_spins(&self) -> usize;
 }
 
 pub trait ToSparseMatrixOperator<'a>:
     ToSparseMatrixSuperOperator<'a>
     + OperateOnSpins<'a>
     + OperateOnDensityMatrix<'a>
     + IntoIterator<Item = (Self::Index, Self::Value)>
     + PartialEq
     + Clone
 where
-    SingleSpinOperator:
+    SingleQubitOperator:
         From<<<Self as OperateOnDensityMatrix<'a>>::Index as SpinIndex>::SingleSpinType>,
     CalculatorComplex: From<<Self as OperateOnDensityMatrix<'a>>::Value>,
     &'a Self: IntoIterator<Item = (&'a Self::Index, &'a Self::Value)>,
     Self::Index: SpinIndex,
     Self::Value: Into<CalculatorComplex>,
 {
     /// Constructs the sparse matrix representation of Self as a HashMap with a given number of spins.
@@ -130,15 +114,15 @@
     /// * `Ok(HashMap<(usize, usize), CalculatorComplex>)` - The matrix representation of the operator-like object.
     /// * `Err(CalculatorError)` - CalculatorFloat could not be converted to f64.
     fn sparse_matrix(
         &'a self,
         number_spins: Option<usize>,
     ) -> Result<HashMap<(usize, usize), Complex64>, StruqtureError> {
         let dimension = match number_spins {
-            None => 2usize.pow(self.number_spins() as u32),
+            None => 2usize.pow(self.current_number_spins() as u32),
             Some(num_spins) => 2usize.pow(num_spins as u32),
         };
         let mut matrix: HashMap<(usize, usize), Complex64> = HashMap::new();
         for row in 0..dimension {
             for (column, val) in self.sparse_matrix_entries_on_row(row)?.into_iter() {
                 matrix.insert((row, column), val);
             }
@@ -157,15 +141,15 @@
     /// * `Ok((Vec<Complex64>, (Vec<usize>, Vec<usize>)))` - The matrix representation of the operator-like object.
     /// * `Err(CalculatorError)` - CalculatorFloat could not be converted to f64.
     fn sparse_matrix_coo(
         &'a self,
         number_spins: Option<usize>,
     ) -> Result<CooSparseMatrix, StruqtureError> {
         let dimension = match number_spins {
-            None => 2usize.pow(self.number_spins() as u32),
+            None => 2usize.pow(self.current_number_spins() as u32),
             Some(num_spins) => 2usize.pow(num_spins as u32),
         };
 
         let capacity = dimension;
         let mut values: Vec<Complex64> = Vec::with_capacity(capacity);
         let mut rows: Vec<usize> = Vec::with_capacity(capacity);
         let mut columns: Vec<usize> = Vec::with_capacity(capacity);
@@ -196,47 +180,47 @@
         row: usize,
     ) -> Result<HashMap<usize, Complex<f64>>, StruqtureError> {
         let mut entries: HashMap<usize, Complex<f64>> = HashMap::with_capacity(self.len());
         for (index, value) in self.iter() {
             let mut column = row;
             let mut prefac: Complex<f64> = 1.0.into();
             for (spin_op_index, pauliop) in index.iter() {
-                match SingleSpinOperator::from(*pauliop) {
-                    SingleSpinOperator::X => {
+                match SingleQubitOperator::from(*pauliop) {
+                    SingleQubitOperator::X => {
                         match row.div_euclid(2usize.pow(*spin_op_index as u32)) % 2 {
                             0 => column += 2usize.pow(*spin_op_index as u32),
                             1 => column -= 2usize.pow(*spin_op_index as u32),
                             _ => panic!("Internal error in constructing matrix"),
                         }
                     }
-                    SingleSpinOperator::Y => {
+                    SingleQubitOperator::Y => {
                         match row.div_euclid(2usize.pow(*spin_op_index as u32)) % 2 {
                             0 => {
                                 column += 2usize.pow(*spin_op_index as u32);
                                 prefac *= Complex::<f64>::new(0.0, -1.0);
                             }
                             1 => {
                                 column -= 2usize.pow(*spin_op_index as u32);
                                 prefac *= Complex::<f64>::new(0.0, 1.0);
                             }
                             _ => panic!("Internal error in constructing matrix"),
                         };
                     }
-                    SingleSpinOperator::Z => {
+                    SingleQubitOperator::Z => {
                         match row.div_euclid(2usize.pow(*spin_op_index as u32)) % 2 {
                             0 => {
                                 prefac *= Complex::<f64>::new(1.0, 0.0);
                             }
                             1 => {
                                 prefac *= Complex::<f64>::new(-1.0, 0.0);
                             }
                             _ => panic!("Internal error in constructing matrix"),
                         };
                     }
-                    SingleSpinOperator::Identity => (),
+                    SingleQubitOperator::Identity => (),
                 }
             }
             let mut_value = entries.get_mut(&column);
             let ri_value = CalculatorComplex::from(value.clone());
             let real_value: f64 = ri_value.re.try_into()?;
             let imag_value: f64 = ri_value.im.try_into()?;
             let complex_value = Complex::<f64>::new(real_value, imag_value);
@@ -275,49 +259,49 @@
                 (row.div_euclid(dimension), 1.0, number_spins),
                 (row % dimension, -1.0, 0),
             ] {
                 let mut column = row;
                 let mut prefac: Complex<f64> = 1.0.into();
                 // first the terms corresponding to -i H p => -i H.kron(I) flatten(p)
                 for (spin_op_index, pauliop) in index.iter() {
-                    match SingleSpinOperator::from(*pauliop) {
-                        SingleSpinOperator::X => {
+                    match SingleQubitOperator::from(*pauliop) {
+                        SingleQubitOperator::X => {
                             match row_adjusted.div_euclid(2usize.pow(*spin_op_index as u32)) % 2 {
                                 0 => column += 2usize.pow((*spin_op_index + shift) as u32),
                                 1 => column -= 2usize.pow((*spin_op_index + shift) as u32),
                                 _ => panic!("Internal error in constructing matrix"),
                             }
                         }
-                        SingleSpinOperator::Y => {
+                        SingleQubitOperator::Y => {
                             match row_adjusted.div_euclid(2usize.pow(*spin_op_index as u32)) % 2 {
                                 0 => {
                                     column += 2usize.pow((*spin_op_index + shift) as u32);
                                     // due to the transpose in i p H => i I.kron(H.T) only the Y Pauli operator picks up an extra
                                     // sign equal to the commutator_prefactor
                                     prefac *= Complex::<f64>::new(0.0, -1.0) * commutator_prefactor;
                                 }
                                 1 => {
                                     column -= 2usize.pow((*spin_op_index + shift) as u32);
                                     prefac *= Complex::<f64>::new(0.0, 1.0) * commutator_prefactor;
                                 }
                                 _ => panic!("Internal error in constructing matrix"),
                             };
                         }
-                        SingleSpinOperator::Z => {
+                        SingleQubitOperator::Z => {
                             match row_adjusted.div_euclid(2usize.pow(*spin_op_index as u32)) % 2 {
                                 0 => {
                                     prefac *= Complex::<f64>::new(1.0, 0.0);
                                 }
                                 1 => {
                                     prefac *= Complex::<f64>::new(-1.0, 0.0);
                                 }
                                 _ => panic!("Internal error in constructing matrix"),
                             };
                         }
-                        SingleSpinOperator::Identity => (),
+                        SingleQubitOperator::Identity => (),
                     }
                 }
                 prefac *= commutator_prefactor * constant_prefactor;
                 let mut_value = entries.get_mut(&column);
                 let ri_value = CalculatorComplex::from(value.clone());
                 let real_value: f64 = ri_value.re.try_into()?;
                 let imag_value: f64 = ri_value.im.try_into()?;
@@ -358,19 +342,19 @@
     /// * `HashMap<(usize, usize), CalculatorComplex>` - The matrix representation of Self.
     /// * `Err(CalculatorError)` - CalculatorFloat could not be converted to f64.
     fn sparse_matrix_superoperator(
         &'a self,
         number_spins: Option<usize>,
     ) -> Result<HashMap<(usize, usize), Complex64>, StruqtureError> {
         let dimension = match number_spins {
-            None => 2usize.pow(self.number_spins() as u32),
+            None => 2usize.pow(self.current_number_spins() as u32),
             Some(num_spins) => 2usize.pow(num_spins as u32),
         };
         let number_spins = match number_spins {
-            None => self.number_spins(),
+            None => self.current_number_spins(),
             Some(num_spins) => num_spins,
         };
         let mut matrix: HashMap<(usize, usize), Complex64> = HashMap::new();
         for row in 0..dimension.pow(2) {
             for (column, val) in self
                 .sparse_matrix_superoperator_entries_on_row(row, number_spins)?
                 .into_iter()
@@ -400,15 +384,15 @@
         number_spins: Option<usize>,
     ) -> Result<CooSparseMatrix, StruqtureError> {
         let dimension = match number_spins {
             None => 2usize.pow(self.current_number_spins() as u32),
             Some(num_spins) => 2usize.pow(num_spins as u32),
         };
         let number_spins = match number_spins {
-            None => self.number_spins(),
+            None => self.current_number_spins(),
             Some(num_spins) => num_spins,
         };
         let capacity = dimension;
         let mut values: Vec<Complex64> = Vec::with_capacity(capacity);
         let mut rows: Vec<usize> = Vec::with_capacity(capacity);
         let mut columns: Vec<usize> = Vec::with_capacity(capacity);
 
@@ -464,17 +448,17 @@
 /// Trait for Hermitian operations on spins.
 ///
 /// # Example
 /// ```
 /// use struqture::prelude::*;
 /// use qoqo_calculator::CalculatorFloat;
 /// use std::collections::HashMap;
-/// use struqture::spins::{HermitianOperateOnSpins, PauliProduct, SpinHamiltonian};
+/// use struqture::spins::{HermitianOperateOnSpins, PauliProduct, QubitHamiltonian};
 ///
-/// let mut sh = SpinHamiltonian::new();
+/// let mut sh = QubitHamiltonian::new();
 /// let pp_0z = PauliProduct::new().z(0);
 /// sh.add_operator_product(pp_0z.clone(), CalculatorFloat::from(0.2)).unwrap();
 /// let mut mapping: HashMap<PauliProduct, CalculatorFloat> = HashMap::new();
 /// mapping.insert(pp_0z.clone(), CalculatorFloat::from(0.2));
 ///
 /// // Functions provided in this :
 /// assert_eq!(sh.get(&pp_0z), &CalculatorFloat::from(0.2));
@@ -496,14 +480,14 @@
     + OperateOnDensityMatrix<'a>
     + IntoIterator<Item = (Self::Index, Self::Value)>
     + PartialEq
     + Clone
 where
     &'a Self: IntoIterator<Item = (&'a Self::Index, &'a Self::Value)>,
 
-    SingleSpinOperator:
+    SingleQubitOperator:
         From<<<Self as OperateOnDensityMatrix<'a>>::Index as SpinIndex>::SingleSpinType>,
     <Self as OperateOnDensityMatrix<'a>>::Value: Into<CalculatorFloat>,
 
     Self::Index: SpinIndex,
 {
 }
```

### Comparing `struqture_py-1.6.1/struqture/src/spins/pauli_product.rs` & `struqture_py-2.0.0a0/struqture/src/spins/pauli_product.rs`

 * *Files 7% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
 use crate::fermions::FermionOperator;
 use crate::mappings::JordanWignerSpinToFermion;
 use crate::prelude::*;
-use crate::spins::{PlusMinusOperator, SpinOperator};
+use crate::spins::{PlusMinusOperator, QubitOperator};
 use crate::{CorrespondsTo, GetValue, SpinIndex, StruqtureError, SymmetricIndex};
 use num_complex::Complex64;
 use qoqo_calculator::CalculatorComplex;
 use serde::de::{Deserializer, Error, SeqAccess, Visitor};
 use serde::ser::{SerializeSeq, Serializer};
 use serde::{Deserialize, Serialize};
 use std::cmp::Ordering;
@@ -62,140 +62,140 @@
 /// 1 & 0\\\\
 /// 0 & -1
 /// \end{pmatrix}
 /// $$
 ///
 #[derive(Debug, Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
 #[cfg_attr(feature = "json_schema", derive(schemars::JsonSchema))]
-pub enum SingleSpinOperator {
+pub enum SingleQubitOperator {
     Identity,
     X,
     Y,
     Z,
 }
 
-/// Creates a SingleSpinOperator from an &str representation.
+/// Creates a SingleQubitOperator from an &str representation.
 ///
 /// # Arguments
 ///
-/// * `s` - The string (&str) to be converted to a SingleSpinOperator.
+/// * `s` - The string (&str) to be converted to a SingleQubitOperator.
 ///
 /// # Returns
 ///
-/// * `Ok(Self)` - The SingleSpinOperator of the input string.
+/// * `Ok(Self)` - The SingleQubitOperator of the input string.
 /// * `Err(StruqtureError::IncorrectPauliEntry)` - The pauli matrix being set is not in [\"I\", \"X\", \"Y\", \"Z\"].
 ///
-impl FromStr for SingleSpinOperator {
+impl FromStr for SingleQubitOperator {
     type Err = StruqtureError;
     fn from_str(s: &str) -> Result<Self, Self::Err> {
         match s {
-            "I" => Ok(SingleSpinOperator::Identity),
-            "X" => Ok(SingleSpinOperator::X),
-            "Y" => Ok(SingleSpinOperator::Y),
-            "Z" => Ok(SingleSpinOperator::Z),
+            "I" => Ok(SingleQubitOperator::Identity),
+            "X" => Ok(SingleQubitOperator::X),
+            "Y" => Ok(SingleQubitOperator::Y),
+            "Z" => Ok(SingleQubitOperator::Z),
             _ => Err(StruqtureError::IncorrectPauliEntry {
                 pauli: s.to_string(),
             }),
         }
     }
 }
 
-impl Default for SingleSpinOperator {
+impl Default for SingleQubitOperator {
     fn default() -> Self {
-        SingleSpinOperator::Identity
+        SingleQubitOperator::Identity
     }
 }
 
-/// Implements the fmt function (Display trait) of SingleSpinOperator.
+/// Implements the fmt function (Display trait) of SingleQubitOperator.
 ///
-impl fmt::Display for SingleSpinOperator {
+impl fmt::Display for SingleQubitOperator {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
         match self {
-            SingleSpinOperator::Identity => write!(f, "I"),
-            SingleSpinOperator::X => write!(f, "X"),
-            SingleSpinOperator::Y => write!(f, "Y"),
-            SingleSpinOperator::Z => write!(f, "Z"),
+            SingleQubitOperator::Identity => write!(f, "I"),
+            SingleQubitOperator::X => write!(f, "X"),
+            SingleQubitOperator::Y => write!(f, "Y"),
+            SingleQubitOperator::Z => write!(f, "Z"),
         }
     }
 }
 
-/// Functions for the SingleSpinOperator
+/// Functions for the SingleQubitOperator
 ///
-impl SingleSpinOperator {
-    /// Implements multiplication function for a SingleSpinOperator by a SingleSpinOperator.
+impl SingleQubitOperator {
+    /// Implements multiplication function for a SingleQubitOperator by a SingleQubitOperator.
     ///
     /// # Arguments
     ///
-    /// * `left` - left-hand SingleSpinOperator to be multiplied.
-    /// * `right` - right-hand SingleSpinOperator to be multiplied.
-    pub fn multiply(left: SingleSpinOperator, right: SingleSpinOperator) -> (Self, Complex64) {
-        let (result, coeff): (SingleSpinOperator, Complex64) = match (left, right) {
-            (SingleSpinOperator::Identity, x) => (x, Complex64::new(1.0, 0.0)),
-            (x, SingleSpinOperator::Identity) => (x, Complex64::new(1.0, 0.0)),
-            (SingleSpinOperator::X, SingleSpinOperator::X) => {
-                (SingleSpinOperator::Identity, Complex64::new(1.0, 0.0))
+    /// * `left` - left-hand SingleQubitOperator to be multiplied.
+    /// * `right` - right-hand SingleQubitOperator to be multiplied.
+    pub fn multiply(left: SingleQubitOperator, right: SingleQubitOperator) -> (Self, Complex64) {
+        let (result, coeff): (SingleQubitOperator, Complex64) = match (left, right) {
+            (SingleQubitOperator::Identity, x) => (x, Complex64::new(1.0, 0.0)),
+            (x, SingleQubitOperator::Identity) => (x, Complex64::new(1.0, 0.0)),
+            (SingleQubitOperator::X, SingleQubitOperator::X) => {
+                (SingleQubitOperator::Identity, Complex64::new(1.0, 0.0))
             }
-            (SingleSpinOperator::X, SingleSpinOperator::Y) => {
-                (SingleSpinOperator::Z, Complex64::new(0.0, 1.0))
+            (SingleQubitOperator::X, SingleQubitOperator::Y) => {
+                (SingleQubitOperator::Z, Complex64::new(0.0, 1.0))
             }
-            (SingleSpinOperator::X, SingleSpinOperator::Z) => {
-                (SingleSpinOperator::Y, Complex64::new(0.0, -1.0))
+            (SingleQubitOperator::X, SingleQubitOperator::Z) => {
+                (SingleQubitOperator::Y, Complex64::new(0.0, -1.0))
             }
-            (SingleSpinOperator::Y, SingleSpinOperator::X) => {
-                (SingleSpinOperator::Z, Complex64::new(0.0, -1.0))
+            (SingleQubitOperator::Y, SingleQubitOperator::X) => {
+                (SingleQubitOperator::Z, Complex64::new(0.0, -1.0))
             }
-            (SingleSpinOperator::Y, SingleSpinOperator::Y) => {
-                (SingleSpinOperator::Identity, Complex64::new(1.0, 0.0))
+            (SingleQubitOperator::Y, SingleQubitOperator::Y) => {
+                (SingleQubitOperator::Identity, Complex64::new(1.0, 0.0))
             }
-            (SingleSpinOperator::Y, SingleSpinOperator::Z) => {
-                (SingleSpinOperator::X, Complex64::new(0.0, 1.0))
+            (SingleQubitOperator::Y, SingleQubitOperator::Z) => {
+                (SingleQubitOperator::X, Complex64::new(0.0, 1.0))
             }
-            (SingleSpinOperator::Z, SingleSpinOperator::X) => {
-                (SingleSpinOperator::Y, Complex64::new(0.0, 1.0))
+            (SingleQubitOperator::Z, SingleQubitOperator::X) => {
+                (SingleQubitOperator::Y, Complex64::new(0.0, 1.0))
             }
-            (SingleSpinOperator::Z, SingleSpinOperator::Y) => {
-                (SingleSpinOperator::X, Complex64::new(0.0, -1.0))
+            (SingleQubitOperator::Z, SingleQubitOperator::Y) => {
+                (SingleQubitOperator::X, Complex64::new(0.0, -1.0))
             }
-            (SingleSpinOperator::Z, SingleSpinOperator::Z) => {
-                (SingleSpinOperator::Identity, Complex64::new(1.0, 0.0))
+            (SingleQubitOperator::Z, SingleQubitOperator::Z) => {
+                (SingleQubitOperator::Identity, Complex64::new(1.0, 0.0))
             }
         };
         (result, coeff)
     }
 }
 
-/// PauliProducts are combinations of SingleSpinOperators on specific qubits.
+/// PauliProducts are combinations of SingleQubitOperators on specific qubits.
 ///
 /// This is a representation of products of pauli matrices acting on qubits, in order to build the terms of a hamiltonian.
 /// For instance, to represent the term $ \sigma_0^{x} \sigma_2^{x} $ :
 /// ` PauliProduct::new().x(0).x(2) `
 ///
 /// # Example
 ///
 /// ```
 /// use struqture::prelude::*;
-/// use struqture::spins::{PauliProduct, SingleSpinOperator};
+/// use struqture::spins::{PauliProduct, SingleQubitOperator};
 ///
 /// let mut pp = PauliProduct::new();
 ///
 /// // Method 1 to add to PauliProduct:
-/// pp = pp.set_pauli(0, SingleSpinOperator::X);
+/// pp = pp.set_pauli(0, SingleQubitOperator::X);
 /// // Method 2 to add to PauliProduct:
 /// pp = pp.z(1);
 /// // These methods are equal:
-/// assert_eq!(pp.clone().x(2), pp.clone().set_pauli(2, SingleSpinOperator::X));
+/// assert_eq!(pp.clone().x(2), pp.clone().set_pauli(2, SingleQubitOperator::X));
 ///
 /// // Access what you set:
-/// assert_eq!(pp.get(&0).unwrap(), &SingleSpinOperator::X);
+/// assert_eq!(pp.get(&0).unwrap(), &SingleQubitOperator::X);
 /// ```
 ///
 #[derive(Debug, Clone, Hash, PartialEq, Eq)]
 pub struct PauliProduct {
     /// The internal dictionary of pauli matrices (I, X, Y, Z) and qubits
-    items: TinyVec<[(usize, SingleSpinOperator); 5]>,
+    items: TinyVec<[(usize, SingleQubitOperator); 5]>,
 }
 /// Implementing serde serialization writing directly to string.
 ///
 impl Serialize for PauliProduct {
     /// Serialization function for PauliProduct according to string type.
     ///
     /// # Arguments
@@ -237,15 +237,20 @@
         let mut obj = tmp_schema.into_object();
         let meta = obj.metadata();
         meta.description = Some("Represents products of Pauli Operators by a string of spin numbers followed by pauli operators. E.g. 0X10Y13Z14X.".to_string());
 
         schemars::schema::Schema::Object(obj)
     }
 }
-impl crate::MinSupportedVersion for PauliProduct {}
+
+impl crate::SerializationSupport for PauliProduct {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::PauliProduct
+    }
+}
 
 /// Deserializing directly from string.
 ///
 impl<'de> Deserialize<'de> for PauliProduct {
     /// Deserialization function for PauliProduct.
     ///
     /// # Arguments
@@ -305,34 +310,34 @@
                         pp = pp.set_pauli(entry.0 .0, entry.0 .1);
                     }
                     Ok(pp)
                 }
             }
             #[derive(Deserialize)]
             #[serde(transparent)]
-            struct Entry((usize, SingleSpinOperator));
+            struct Entry((usize, SingleQubitOperator));
             let pp_visitor = PauliProductVisitor;
 
             deserializer.deserialize_seq(pp_visitor)
         }
     }
 }
 
 impl SpinIndex for PauliProduct {
-    type SingleSpinType = SingleSpinOperator;
+    type SingleSpinType = SingleQubitOperator;
 
     // From trait
     fn new() -> Self {
         PauliProduct {
-            items: TinyVec::<[(usize, SingleSpinOperator); 5]>::with_capacity(5),
+            items: TinyVec::<[(usize, SingleQubitOperator); 5]>::with_capacity(5),
         }
     }
 
     // From trait
-    fn set_pauli(self, index: usize, pauli: SingleSpinOperator) -> Self {
+    fn set_pauli(self, index: usize, pauli: SingleQubitOperator) -> Self {
         let mut pp = self;
         if let Some((vecindex, insertindex, index_in_use)) =
             pp.items
                 .iter()
                 .enumerate()
                 .find_map(|(vecindex, (innerindex, _))| {
                     if innerindex >= &index {
@@ -340,57 +345,57 @@
                     } else {
                         None
                     }
                 })
         {
             if index_in_use {
                 match pauli {
-                    SingleSpinOperator::Identity => {
+                    SingleQubitOperator::Identity => {
                         let _x = pp.items.remove(vecindex);
                     }
                     _ => pp.items[vecindex] = (insertindex, pauli),
                 }
             } else {
                 match pauli {
-                    SingleSpinOperator::Identity => (),
+                    SingleQubitOperator::Identity => (),
                     _ => {
                         pp.items.insert(vecindex, (index, pauli));
                     }
                 }
             }
         } else {
             match pauli {
-                SingleSpinOperator::Identity => (),
+                SingleQubitOperator::Identity => (),
                 _ => {
                     pp.items.push((index, pauli));
                 }
             }
         }
         pp
     }
 
     // From trait
-    fn get(&self, index: &usize) -> Option<&SingleSpinOperator> {
+    fn get(&self, index: &usize) -> Option<&SingleQubitOperator> {
         self.items
             .iter()
             .find_map(|(key, value)| if key == index { Some(value) } else { None })
     }
 
     // From trait
-    fn iter(&self) -> std::slice::Iter<(usize, SingleSpinOperator)> {
+    fn iter(&self) -> std::slice::Iter<(usize, SingleQubitOperator)> {
         return match &self.items {
             TinyVec::Heap(x) => x.iter(),
             TinyVec::Inline(x) => x.iter(),
         };
     }
 
     // From trait
     fn remap_qubits(&self, mapping: &HashMap<usize, usize>) -> PauliProduct {
-        let mut mutable_internal: TinyVec<[(usize, SingleSpinOperator); 5]> =
-            TinyVec::<[(usize, SingleSpinOperator); 5]>::with_capacity(10);
+        let mut mutable_internal: TinyVec<[(usize, SingleQubitOperator); 5]> =
+            TinyVec::<[(usize, SingleQubitOperator); 5]>::with_capacity(10);
 
         for (key, val) in self.iter() {
             mutable_internal.push(match mapping.get(key) {
                 Some(x) => (*x, *val),
                 None => (*key, *val),
             });
         }
@@ -441,16 +446,16 @@
 /// * `self` - PauliProduct to be ordered.
 ///
 /// # Returns
 ///
 /// `Ordering` - The ordering result
 impl Ord for PauliProduct {
     fn cmp(&self, other: &Self) -> Ordering {
-        let me: &TinyVec<[(usize, SingleSpinOperator); 5]> = &(self.items);
-        let them: &TinyVec<[(usize, SingleSpinOperator); 5]> = &(other.items);
+        let me: &TinyVec<[(usize, SingleQubitOperator); 5]> = &(self.items);
+        let them: &TinyVec<[(usize, SingleQubitOperator); 5]> = &(other.items);
 
         match me.len().cmp(&them.len()) {
             Ordering::Less => Ordering::Less,
             Ordering::Equal => me.cmp(them), // If lengths are equal use lexicographic
             Ordering::Greater => Ordering::Greater,
         }
     }
@@ -506,15 +511,15 @@
     fn mul(self, rhs: PauliProduct) -> Self::Output {
         let mut factor = Complex64::new(1.0, 0.0);
         let mut return_product = PauliProduct::new();
         for (key, left_operator) in self.iter() {
             match rhs.get(key) {
                 Some(right_operator) => {
                     let (tmp_product, tmp_factor) =
-                        SingleSpinOperator::multiply(*left_operator, *right_operator);
+                        SingleQubitOperator::multiply(*left_operator, *right_operator);
                     factor *= tmp_factor;
                     return_product = return_product.set_pauli(*key, tmp_product);
                 }
                 None => {
                     return_product = return_product.set_pauli(*key, *left_operator);
                 }
             }
@@ -561,65 +566,86 @@
         value
     }
 }
 
 /// Functions for the PauliProduct
 ///
 impl PauliProduct {
-    /// Sets a new entry for SingleSpinOperator X in the internal dictionary. This function consumes Self.
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(&self) -> Result<struqture_one::spins::PauliProduct, StruqtureError> {
+        let self_string = self.to_string();
+        let struqture_one_product = struqture_one::spins::PauliProduct::from_str(&self_string)
+            .map_err(|err| StruqtureError::GenericError {
+                msg: format!("{}", err),
+            })?;
+        Ok(struqture_one_product)
+    }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::spins::PauliProduct,
+    ) -> Result<Self, StruqtureError> {
+        let value_string = value.to_string();
+        let pauli_product = Self::from_str(&value_string)?;
+        Ok(pauli_product)
+    }
+
+    /// Sets a new entry for SingleQubitOperator X in the internal dictionary. This function consumes Self.
     ///
     /// # Arguments
     ///
     /// * `index` - Index of set object.
     ///
     /// # Returns
     ///
     /// * `Self` - The entry was correctly set and the PauliProduct is returned.
     pub fn x(self, index: usize) -> Self {
-        self.set_pauli(index, SingleSpinOperator::X)
+        self.set_pauli(index, SingleQubitOperator::X)
     }
 
-    /// Sets a new entry for SingleSpinOperator Y in the internal dictionary. This function consumes Self.
+    /// Sets a new entry for SingleQubitOperator Y in the internal dictionary. This function consumes Self.
     ///
     /// # Arguments
     ///
     /// * `index` - Index of set object.
     ///
     /// # Returns
     ///
     /// * `Self` - The entry was correctly set and the PauliProduct is returned.
     pub fn y(self, index: usize) -> Self {
-        self.set_pauli(index, SingleSpinOperator::Y)
+        self.set_pauli(index, SingleQubitOperator::Y)
     }
 
-    /// Sets a new entry for SingleSpinOperator Z in the internal dictionary. This function consumes Self.
+    /// Sets a new entry for SingleQubitOperator Z in the internal dictionary. This function consumes Self.
     ///
     /// # Arguments
     ///
     /// * `index` - Index of set object.
     ///
     /// # Returns
     ///
     /// * `Self` - The entry was correctly set and the PauliProduct is returned.
     pub fn z(self, index: usize) -> Self {
-        self.set_pauli(index, SingleSpinOperator::Z)
+        self.set_pauli(index, SingleQubitOperator::Z)
     }
 
     /// Creates a new PauliProduct with pre-allocated capacity.
     ///
     /// # Arguments
     ///
     /// * `capacity` - The capacity of the PauliProduct to create.
     ///
     /// # Returns
     ///
     /// * `Self` - The new (empty) PauliProduct.
     pub fn with_capacity(cap: usize) -> Self {
         PauliProduct {
-            items: TinyVec::<[(usize, SingleSpinOperator); 5]>::with_capacity(cap),
+            items: TinyVec::<[(usize, SingleQubitOperator); 5]>::with_capacity(cap),
         }
     }
 }
 
 /// Implements the default function (Default trait) of PauliProduct (an empty PauliProduct).
 ///
 impl Default for PauliProduct {
@@ -646,27 +672,27 @@
     /// # Panics
     ///
     /// * Cannot compare two unsigned integers internal error in struqture.spins.
     fn from_str(s: &str) -> Result<Self, Self::Err> {
         if s == "I" {
             Ok(Self::new()) // If the string is identity then it's an empty PauliProduct
         } else {
-            let mut internal: TinyVec<[(usize, SingleSpinOperator); 5]> =
-                TinyVec::<[(usize, SingleSpinOperator); 5]>::with_capacity(10);
+            let mut internal: TinyVec<[(usize, SingleQubitOperator); 5]> =
+                TinyVec::<[(usize, SingleQubitOperator); 5]>::with_capacity(10);
 
             let value = s.to_string();
             let vec_paulis = value.split(char::is_numeric).filter(|s| !s.is_empty());
             let vec_indices = value.split(char::is_alphabetic).filter(|s| !s.is_empty());
 
             for (index, pauli) in vec_indices.zip(vec_paulis) {
                 match index.parse() {
                     Ok(num) => {
-                        let spin: SingleSpinOperator = SingleSpinOperator::from_str(pauli)?;
+                        let spin: SingleQubitOperator = SingleQubitOperator::from_str(pauli)?;
                         match spin {
-                            SingleSpinOperator::Identity => (),
+                            SingleQubitOperator::Identity => (),
                             _ => {
                                 internal.push((num, spin));
                             }
                         }
                     }
                     Err(_) => {
                         return Err(StruqtureError::FromStringFailed {
@@ -724,57 +750,57 @@
         write!(f, "{}", string)
     }
 }
 
 /// Implements the into_iter function (IntoIterator trait) of PauliProduct.
 ///
 impl IntoIterator for PauliProduct {
-    type Item = (usize, SingleSpinOperator);
+    type Item = (usize, SingleQubitOperator);
 
-    type IntoIter = TinyVecIterator<[(usize, SingleSpinOperator); 5]>;
+    type IntoIter = TinyVecIterator<[(usize, SingleQubitOperator); 5]>;
     /// Returns the PauliProduct in Iterator form.
     ///
     /// # Returns
     ///
     /// * `Self::IntoIter` - The PauliProduct in Iterator form.
     fn into_iter(self) -> Self::IntoIter {
         self.items.into_iter()
     }
 }
 
 /// Implements the from_iter function (FromIterator trait) of PauliProduct.
 ///
-impl FromIterator<(usize, SingleSpinOperator)> for PauliProduct {
+impl FromIterator<(usize, SingleQubitOperator)> for PauliProduct {
     /// Returns the object in PauliProduct form, from an Iterator form of the object.
     ///
     /// # Arguments
     ///
     /// * `iter` - The iterator containing the information from which to create the PauliProduct.
     ///
     /// # Returns
     ///
     /// * `Self::IntoIter` - The iterator in PauliProduct form.
-    fn from_iter<I: IntoIterator<Item = (usize, SingleSpinOperator)>>(iter: I) -> Self {
+    fn from_iter<I: IntoIterator<Item = (usize, SingleQubitOperator)>>(iter: I) -> Self {
         let mut pp = PauliProduct::new();
         for (index, pauli) in iter {
             pp = pp.set_pauli(index, pauli);
         }
         pp
     }
 }
 
 /// Implements the extend function (Extend trait) of PauliProduct.
 ///
-impl Extend<(usize, SingleSpinOperator)> for PauliProduct {
+impl Extend<(usize, SingleQubitOperator)> for PauliProduct {
     /// Extends the PauliProduct by the specified operations (in Iterator form).
     ///
     /// # Arguments
     ///
     /// * `iter` - The iterator containing the operations by which to extend the PauliProduct.
-    fn extend<I: IntoIterator<Item = (usize, SingleSpinOperator)>>(&mut self, iter: I) {
+    fn extend<I: IntoIterator<Item = (usize, SingleQubitOperator)>>(&mut self, iter: I) {
         let mut pp = self.clone();
         for (index, pauli) in iter {
             pp = pp.set_pauli(index, pauli);
         }
         *self = pp;
     }
 }
@@ -791,16 +817,16 @@
     ///
     /// `FermionOperator` - The fermion operator that results from the transformation.
     ///
     /// # Panics
     ///
     /// * Internal bug in `add_operator_product`
     fn jordan_wigner(&self) -> Self::Output {
-        let mut spin_operator = SpinOperator::new();
-        spin_operator
+        let mut qubit_operator = QubitOperator::new();
+        qubit_operator
             .add_operator_product(self.clone(), 1.0.into())
             .expect(INTERNAL_BUG_ADD_OPERATOR_PRODUCT);
 
-        let plus_minus_operator = PlusMinusOperator::from(spin_operator);
+        let plus_minus_operator = PlusMinusOperator::from(qubit_operator);
         plus_minus_operator.jordan_wigner()
     }
 }
```

### Comparing `struqture_py-1.6.1/struqture/src/spins/plus_minus_noise_operator.rs` & `struqture_py-2.0.0a0/struqture/src/spins/qubit_noise_operator.rs`

 * *Files 27% similar despite different names*

```diff
@@ -6,308 +6,373 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
-use super::{DecoherenceProduct, SpinLindbladNoiseOperator};
+use super::{OperateOnSpins, SingleDecoherenceOperator, ToSparseMatrixSuperOperator};
 use crate::fermions::FermionLindbladNoiseOperator;
 use crate::mappings::JordanWignerSpinToFermion;
-use crate::spins::{PlusMinusOperator, PlusMinusProduct};
-use crate::{OperateOnDensityMatrix, StruqtureError, StruqtureVersionSerializable};
+use crate::spins::{DecoherenceOperator, DecoherenceProduct};
+use crate::{CooSparseMatrix, OperateOnDensityMatrix, SpinIndex, StruqtureError, SymmetricIndex};
 use itertools::Itertools;
 use num_complex::Complex64;
 use qoqo_calculator::{CalculatorComplex, CalculatorFloat};
 use serde::{Deserialize, Serialize};
 use std::fmt::{self, Write};
 use std::iter::{FromIterator, IntoIterator};
 use std::ops;
 
-#[cfg(feature = "indexed_map_iterators")]
-use indexmap::map::{Entry, Iter, Keys, Values};
-#[cfg(feature = "indexed_map_iterators")]
+use indexmap::map::{Entry, Iter};
 use indexmap::IndexMap;
-#[cfg(not(feature = "indexed_map_iterators"))]
-use std::collections::hash_map::{Entry, Iter, Keys, Values};
 use std::collections::HashMap;
 
-/// PlusMinusLindbladNoiseOperators represent noise interactions in the Lindblad equation.
+/// QubitLindbladNoiseOperators represent noise interactions in the Lindblad equation.
 ///
-/// In the Lindblad equation, Linblad noise operator L_i are not limited to [crate::spins::PlusMinusProduct] style operators.
-/// We use ([crate::spins::PlusMinusProduct], [crate::spins::PlusMinusProduct]) as a unique basis.
+/// In the Lindblad equation, Linblad noise operator L_i are not limited to [crate::spins::DecoherenceProduct] style operators.
+/// We use ([crate::spins::DecoherenceProduct], [crate::spins::DecoherenceProduct]) as a unique basis.
 ///
 /// # Example
 ///
 /// ```
 /// use struqture::prelude::*;
 /// use qoqo_calculator::CalculatorComplex;
-/// use struqture::spins::{PlusMinusProduct, PlusMinusLindbladNoiseOperator};
+/// use struqture::spins::{DecoherenceProduct, QubitLindbladNoiseOperator};
 ///
-/// let mut system = PlusMinusLindbladNoiseOperator::new();
+/// let mut system = QubitLindbladNoiseOperator::new();
 ///
 /// // Set noise terms:
-/// let pp_01 = PlusMinusProduct::new().plus(0).plus(1);
-/// let pp_0 = PlusMinusProduct::new().z(0);
+/// let pp_01 = DecoherenceProduct::new().x(0).x(1);
+/// let pp_0 = DecoherenceProduct::new().z(0);
 /// system.set((pp_01.clone(), pp_01.clone()), CalculatorComplex::from(0.5)).unwrap();
 /// system.set((pp_0.clone(), pp_0.clone()), CalculatorComplex::from(0.2)).unwrap();
 ///
 /// // Access what you set:
+/// assert_eq!(system.current_number_spins(), 2_usize);
 /// assert_eq!(system.get(&(pp_01.clone(), pp_01.clone())), &CalculatorComplex::from(0.5));
 /// assert_eq!(system.get(&(pp_0.clone(), pp_0.clone())), &CalculatorComplex::from(0.2));
 /// ```
 ///
 #[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
-#[serde(from = "PlusMinusLindbladNoiseOperatorSerialize")]
-#[serde(into = "PlusMinusLindbladNoiseOperatorSerialize")]
-pub struct PlusMinusLindbladNoiseOperator {
-    /// The internal map representing the noise terms
-    #[cfg(feature = "indexed_map_iterators")]
-    internal_map: IndexMap<(PlusMinusProduct, PlusMinusProduct), CalculatorComplex>,
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    internal_map: HashMap<(PlusMinusProduct, PlusMinusProduct), CalculatorComplex>,
+#[serde(try_from = "QubitLindbladNoiseOperatorSerialize")]
+#[serde(into = "QubitLindbladNoiseOperatorSerialize")]
+pub struct QubitLindbladNoiseOperator {
+    // The internal map representing the noise terms
+    internal_map: IndexMap<(DecoherenceProduct, DecoherenceProduct), CalculatorComplex>,
 }
 
-impl crate::MinSupportedVersion for PlusMinusLindbladNoiseOperator {
-    fn min_supported_version() -> (usize, usize, usize) {
-        (1, 1, 0)
+impl crate::SerializationSupport for QubitLindbladNoiseOperator {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::QubitLindbladNoiseOperator
     }
 }
-
 #[cfg(feature = "json_schema")]
-impl schemars::JsonSchema for PlusMinusLindbladNoiseOperator {
+impl schemars::JsonSchema for QubitLindbladNoiseOperator {
     fn schema_name() -> String {
-        "PlusMinusLindbladNoiseOperator".to_string()
+        "PlusMinusOperator".to_string()
     }
 
     fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
-        <PlusMinusLindbladNoiseOperatorSerialize>::json_schema(gen)
+        <QubitLindbladNoiseOperatorSerialize>::json_schema(gen)
     }
 }
-
 #[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
 #[cfg_attr(feature = "json_schema", derive(schemars::JsonSchema))]
 #[cfg_attr(feature = "json_schema", schemars(deny_unknown_fields))]
-struct PlusMinusLindbladNoiseOperatorSerialize {
-    /// The vector representing the internal map of the PlusMinusLindbladNoiseOperator
+struct QubitLindbladNoiseOperatorSerialize {
+    /// The vector representing the internal map of the QubitLindbladNoiseOperator
     items: Vec<(
-        PlusMinusProduct,
-        PlusMinusProduct,
+        DecoherenceProduct,
+        DecoherenceProduct,
         CalculatorFloat,
         CalculatorFloat,
     )>,
-    /// The struqture version
-    _struqture_version: StruqtureVersionSerializable,
+    serialisation_meta: crate::StruqtureSerialisationMeta,
 }
 
-impl From<PlusMinusLindbladNoiseOperatorSerialize> for PlusMinusLindbladNoiseOperator {
-    fn from(value: PlusMinusLindbladNoiseOperatorSerialize) -> Self {
-        let new_noise_op: PlusMinusLindbladNoiseOperator = value
+impl TryFrom<QubitLindbladNoiseOperatorSerialize> for QubitLindbladNoiseOperator {
+    type Error = StruqtureError;
+    fn try_from(value: QubitLindbladNoiseOperatorSerialize) -> Result<Self, Self::Error> {
+        let target_serialisation_meta =
+            <Self as crate::SerializationSupport>::target_serialisation_meta();
+        crate::check_can_be_deserialised(&target_serialisation_meta, &value.serialisation_meta)?;
+        let new_noise_op: QubitLindbladNoiseOperator = value
             .items
             .into_iter()
             .map(|(left, right, real, imag)| {
                 ((left, right), CalculatorComplex { re: real, im: imag })
             })
             .collect();
-        new_noise_op
+        Ok(new_noise_op)
     }
 }
 
-impl From<PlusMinusLindbladNoiseOperator> for PlusMinusLindbladNoiseOperatorSerialize {
-    fn from(value: PlusMinusLindbladNoiseOperator) -> Self {
+impl From<QubitLindbladNoiseOperator> for QubitLindbladNoiseOperatorSerialize {
+    fn from(value: QubitLindbladNoiseOperator) -> Self {
+        let serialisation_meta = crate::SerializationSupport::struqture_serialisation_meta(&value);
+
         let new_noise_op: Vec<(
-            PlusMinusProduct,
-            PlusMinusProduct,
+            DecoherenceProduct,
+            DecoherenceProduct,
             CalculatorFloat,
             CalculatorFloat,
         )> = value
             .into_iter()
             .map(|((left, right), val)| (left, right, val.re, val.im))
             .collect();
-        let current_version = StruqtureVersionSerializable {
-            major_version: 1,
-            minor_version: 1,
-        };
         Self {
             items: new_noise_op,
-            _struqture_version: current_version,
+            serialisation_meta,
         }
     }
 }
 
-impl<'a> OperateOnDensityMatrix<'a> for PlusMinusLindbladNoiseOperator {
-    type Index = (PlusMinusProduct, PlusMinusProduct);
+impl<'a> OperateOnDensityMatrix<'a> for QubitLindbladNoiseOperator {
+    type Index = (DecoherenceProduct, DecoherenceProduct);
     type Value = CalculatorComplex;
-    type IteratorType = Iter<'a, (PlusMinusProduct, PlusMinusProduct), CalculatorComplex>;
-    type KeyIteratorType = Keys<'a, (PlusMinusProduct, PlusMinusProduct), CalculatorComplex>;
-    type ValueIteratorType = Values<'a, (PlusMinusProduct, PlusMinusProduct), CalculatorComplex>;
 
     // From trait
     fn get(&self, key: &Self::Index) -> &Self::Value {
         match self.internal_map.get(key) {
             Some(value) => value,
             None => &CalculatorComplex::ZERO,
         }
     }
 
     // From trait
-    fn iter(&'a self) -> Self::IteratorType {
+    fn iter(&'a self) -> impl ExactSizeIterator<Item = (&'a Self::Index, &'a Self::Value)> {
         self.internal_map.iter()
     }
 
     // From trait
-    fn keys(&'a self) -> Self::KeyIteratorType {
+    fn keys(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Index> {
         self.internal_map.keys()
     }
 
     // From trait
-    fn values(&'a self) -> Self::ValueIteratorType {
+    fn values(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Value> {
         self.internal_map.values()
     }
 
-    #[cfg(feature = "indexed_map_iterators")]
     // From trait
     fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
         self.internal_map.shift_remove(key)
     }
 
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    // From trait
-    fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
-        self.internal_map.remove(key)
-    }
-
     // From trait
     fn empty_clone(&self, capacity: Option<usize>) -> Self {
         match capacity {
             Some(cap) => Self::with_capacity(cap),
             None => Self::new(),
         }
     }
 
-    /// Overwrites an existing entry or sets a new entry in the PlusMinusLindbladNoiseOperator with the given ((PlusMinusProduct, PlusMinusProduct) key, CalculatorComplex value) pair.
+    /// Overwrites an existing entry or sets a new entry in the QubitLindbladNoiseOperator with the given ((DecoherenceProduct, DecoherenceProduct) key, CalculatorComplex value) pair.
     ///
     /// # Arguments
     ///
-    /// * `key` - The (PlusMinusProduct, PlusMinusProduct) key to set in the PlusMinusLindbladNoiseOperator.
-    /// * `value` - The corresponding CalculatorComplex value to set for the key in the PlusMinusLindbladNoiseOperator.
+    /// * `key` - The (DecoherenceProduct, DecoherenceProduct) key to set in the QubitLindbladNoiseOperator.
+    /// * `value` - The corresponding CalculatorComplex value to set for the key in the QubitLindbladNoiseOperator.
     ///
     /// # Returns
     ///
     /// * `Ok(Some(CalculatorComplex))` - The key existed, this is the value it had before it was set with the value input.
     /// * `Ok(None)` - The key did not exist, it has been set with its corresponding value.
+    /// * `Err(StruqtureError::InvalidLindbladTerms)` - The input contained identities, which are not allowed as Lindblad operators.
     fn set(
         &mut self,
         key: Self::Index,
         value: Self::Value,
     ) -> Result<Option<Self::Value>, StruqtureError> {
+        if key.0.is_empty() || key.1.is_empty() {
+            return Err(StruqtureError::InvalidLindbladTerms);
+        }
+
         if value != CalculatorComplex::ZERO {
             Ok(self.internal_map.insert(key, value))
         } else {
             match self.internal_map.entry(key) {
-                #[cfg(feature = "indexed_map_iterators")]
                 Entry::Occupied(val) => Ok(Some(val.shift_remove())),
-                #[cfg(not(feature = "indexed_map_iterators"))]
-                Entry::Occupied(val) => Ok(Some(val.remove())),
                 Entry::Vacant(_) => Ok(None),
             }
         }
     }
 }
 
-/// Implements the default function (Default trait) of PlusMinusLindbladNoiseOperator (an empty PlusMinusLindbladNoiseOperator).
+impl<'a> OperateOnSpins<'a> for QubitLindbladNoiseOperator {
+    /// Gets the maximum index of the QubitLindbladNoiseOperator.
+    ///
+    /// # Returns
+    ///
+    /// * `usize` - The number of spins in the QubitLindbladNoiseOperator.
+    fn current_number_spins(&self) -> usize {
+        let mut max_mode: usize = 0;
+        if !self.internal_map.is_empty() {
+            for key in self.internal_map.keys() {
+                let maxk = (key.0.current_number_spins()).max(key.1.current_number_spins());
+                if maxk > max_mode {
+                    max_mode = maxk
+                }
+            }
+        }
+        max_mode
+    }
+}
+
+impl<'a> ToSparseMatrixSuperOperator<'a> for QubitLindbladNoiseOperator {
+    // From trait
+    fn sparse_matrix_superoperator_entries_on_row(
+        &self,
+        row: usize,
+        number_spins: usize,
+    ) -> Result<HashMap<usize, Complex64>, StruqtureError> {
+        let mut entries: HashMap<usize, Complex64> = HashMap::new();
+        let dimension = 2_usize.pow(number_spins as u32);
+        for ((left, right), value) in self.iter() {
+            add_lindblad_terms(
+                left,
+                right,
+                row,
+                dimension,
+                number_spins,
+                &mut entries,
+                value,
+            )?;
+            // iterate over terms corresponding to - 1/2 right^dagger * left p => -1/2 (right^dagger * left).kron(I) flatten(p)
+            // and - 1/2 p right^dagger * left  => - 1/2 I.kron((right^dagger * left).T) flatten(p)
+            add_anti_commutator(
+                left,
+                right,
+                row,
+                dimension,
+                number_spins,
+                &mut entries,
+                value,
+            )?;
+        }
+        Ok(entries)
+    }
+
+    // From trait
+    fn unitary_sparse_matrix_coo(&'a self) -> Result<CooSparseMatrix, StruqtureError> {
+        Ok((vec![], (vec![], vec![])) as CooSparseMatrix)
+    }
+
+    // From trait
+    fn sparse_lindblad_entries(
+        &'a self,
+    ) -> Result<Vec<(CooSparseMatrix, CooSparseMatrix, Complex64)>, StruqtureError> {
+        let mut coo_matrices =
+            Vec::<(CooSparseMatrix, CooSparseMatrix, Complex64)>::with_capacity(self.len());
+        for ((left, right), val) in self.iter() {
+            coo_matrices.push((
+                left.to_coo(self.current_number_spins()).unwrap(),
+                right.to_coo(self.current_number_spins()).unwrap(),
+                Complex64 {
+                    re: *val.re.float()?,
+                    im: *val.im.float()?,
+                },
+            ))
+        }
+        Ok(coo_matrices)
+    }
+}
+
+/// Implements the default function (Default trait) of QubitLindbladNoiseOperator (an empty QubitLindbladNoiseOperator).
 ///
-impl Default for PlusMinusLindbladNoiseOperator {
+impl Default for QubitLindbladNoiseOperator {
     fn default() -> Self {
         Self::new()
     }
 }
 
-/// Functions for the PlusMinusLindbladNoiseOperator
+/// Functions for the QubitLindbladNoiseOperator
 ///
-impl PlusMinusLindbladNoiseOperator {
-    /// Creates a new PlusMinusLindbladNoiseOperator.
+impl QubitLindbladNoiseOperator {
+    /// Creates a new QubitLindbladNoiseOperator.
     ///
     /// # Returns
     ///
-    /// * `Self` - The new (empty) PlusMinusLindbladNoiseOperator.
+    /// * `Self` - The new (empty) QubitLindbladNoiseOperator.
     pub fn new() -> Self {
-        PlusMinusLindbladNoiseOperator {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::new(),
-            #[cfg(feature = "indexed_map_iterators")]
+        QubitLindbladNoiseOperator {
             internal_map: IndexMap::new(),
         }
     }
 
-    /// Creates a new PlusMinusLindbladNoiseOperator with pre-allocated capacity.
+    /// Creates a new QubitLindbladNoiseOperator with pre-allocated capacity.
     ///
     /// # Arguments
     ///
     /// * `capacity` - The pre-allocated capacity of the system.
     ///
     /// # Returns
     ///
-    /// * `Self` - The new (empty) PlusMinusLindbladNoiseOperator.
+    /// * `Self` - The new (empty) QubitLindbladNoiseOperator.
     pub fn with_capacity(capacity: usize) -> Self {
-        PlusMinusLindbladNoiseOperator {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::with_capacity(capacity),
-            #[cfg(feature = "indexed_map_iterators")]
+        QubitLindbladNoiseOperator {
             internal_map: IndexMap::with_capacity(capacity),
         }
     }
 
-    /// Adds all noise entries corresponding to a ((PlusMinusOperator, PlusMinusOperator), CalculatorFloat).
+    /// Adds all noise entries corresponding to a ((DecoherenceOperator, DecoherenceOperator), CalculatorFloat).
     ///
-    /// In the Lindblad equation, Linblad noise operator L_i are not limited to [crate::spins::PlusMinusProduct] style operators.
-    /// We use ([crate::spins::PlusMinusProduct], [crate::spins::PlusMinusProduct]) as a unique basis.
-    /// This function adds a Linblad-Term defined by a combination of Lindblad operators given as general [crate::spins::PlusMinusOperator]
+    /// In the Lindblad equation, Linblad noise operator L_i are not limited to [crate::spins::DecoherenceProduct] style operators.
+    /// We use ([crate::spins::DecoherenceProduct], [crate::spins::DecoherenceProduct]) as a unique basis.
+    /// This function adds a Linblad-Term defined by a combination of Lindblad operators given as general [crate::spins::DecoherenceOperator]
     ///
     /// # Arguments
     ///
-    /// * `left` - PlusMinusOperator that acts on the density matrix from the left in the Lindblad equation.
-    /// * `value` -  PlusMinusOperator that acts on the density matrix from the right and in hermitian conjugated form in the Lindblad equation.
+    /// * `left` - DecoherenceOperator that acts on the density matrix from the left in the Lindblad equation.
+    /// * `right` -  DecoherenceOperator that acts on the density matrix from the right and in hermitian conjugated form in the Lindblad equation.
+    /// * `value` - CalculatorComplex value representing the global coefficient of the noise term.
     ///
     /// # Returns
     ///
     /// * `Ok(())` - The noise was correctly added.
-    /// * `Err(StruqtureError::NumberSpinsExceeded)` - Number of spins in entry exceeds number of spins in system.
+    /// * `Err(StruqtureError::InvalidLindbladTerms)` - The input contained identities, which are not allowed as Lindblad operators.
     pub fn add_noise_from_full_operators(
         &mut self,
-        left: &PlusMinusOperator,
-        right: &PlusMinusOperator,
+        left: &DecoherenceOperator,
+        right: &DecoherenceOperator,
         value: CalculatorComplex,
     ) -> Result<(), StruqtureError> {
+        if left.is_empty() || right.is_empty() {
+            return Err(StruqtureError::InvalidLindbladTerms);
+        }
+
         for ((decoherence_product_left, value_left), (decoherence_product_right, value_right)) in
-            left.iter().cartesian_product(right.iter())
+            left.iter().cartesian_product(right.into_iter())
         {
-            let value_complex = value_right.conj() * value_left;
-            self.add_operator_product(
-                (
-                    decoherence_product_left.clone(),
-                    decoherence_product_right.clone(),
-                ),
-                value_complex * value.clone(),
-            )?;
+            if !decoherence_product_left.is_empty() && !decoherence_product_right.is_empty() {
+                let value_complex = value_right.conj() * value_left;
+                self.add_operator_product(
+                    (
+                        decoherence_product_left.clone(),
+                        decoherence_product_right.clone(),
+                    ),
+                    value_complex * value.clone(),
+                )?;
+            }
         }
         Ok(())
     }
 
-    /// Remaps the qubits in the PlusMinusLindbladNoiseOperator.
+    /// Remaps the qubits in the QubitLindbladNoiseOperator.
     ///
     /// # Arguments
     ///
     /// * `mapping` - HashMap containing the qubit remapping.
     ///
     /// # Returns
     ///
-    /// * `Self` - The remapped PlusMinusLindbladNoiseOperator.
+    /// * `Self` - The remapped QubitLindbladNoiseOperator.
     pub fn remap_qubits(&self, mapping: &HashMap<usize, usize>) -> Self {
-        let mut new_noise = PlusMinusLindbladNoiseOperator::new();
+        let mut new_noise = QubitLindbladNoiseOperator::new();
         for ((left, right), rate) in self.iter() {
             let new_left = left.remap_qubits(mapping);
             let new_right = right.remap_qubits(mapping);
             new_noise
                 .add_operator_product((new_left, new_right), rate.clone())
                 .expect("Internal bug in add_operator_product");
         }
@@ -324,337 +389,445 @@
     /// # Returns
     ///
     /// `Ok((separated, remainder))` - Operator with the noise terms where number_spins_left and number_spins_right match the number of spins the left and right noise operator product acts on and Operator with all other contributions.
     pub fn separate_into_n_terms(
         &self,
         number_spins_left: usize,
         number_spins_right: usize,
-    ) -> Result<
-        (
-            PlusMinusLindbladNoiseOperator,
-            PlusMinusLindbladNoiseOperator,
-        ),
-        StruqtureError,
-    > {
-        let mut separated = PlusMinusLindbladNoiseOperator::new();
-        let mut remainder = PlusMinusLindbladNoiseOperator::new();
+    ) -> Result<(Self, Self), StruqtureError> {
+        let mut separated = Self::default();
+        let mut remainder = Self::default();
         for ((prod_l, prod_r), val) in self.iter() {
             if prod_l.iter().len() == number_spins_left && prod_r.iter().len() == number_spins_right
             {
                 separated.add_operator_product((prod_l.clone(), prod_r.clone()), val.clone())?;
             } else {
                 remainder.add_operator_product((prod_l.clone(), prod_r.clone()), val.clone())?;
             }
         }
         Ok((separated, remainder))
     }
-}
 
-impl From<PlusMinusLindbladNoiseOperator> for SpinLindbladNoiseOperator {
-    /// Converts a PlusMinusLindbladNoiseOperator into a SpinLindbladNoiseOperator.
-    ///
-    /// # Arguments
-    ///
-    /// * `value` - The PlusMinusLindbladNoiseOperator to convert.
-    ///
-    /// # Returns
-    ///
-    /// * `Self` - The PlusMinusLindbladNoiseOperator converted into a SpinLindbladNoiseOperator.
-    fn from(value: PlusMinusLindbladNoiseOperator) -> Self {
-        let mut new_operator = SpinLindbladNoiseOperator::with_capacity(2 * value.len());
-        for ((product_left, product_right), val) in value.into_iter() {
-            let transscribed_vector_left: Vec<(DecoherenceProduct, Complex64)> =
-                product_left.into();
-            let transscribed_vector_right: Vec<(DecoherenceProduct, Complex64)> =
-                product_right.into();
-            for (transscribed_product_left, pref_left) in transscribed_vector_left {
-                for (transscribed_product_right, pref_right) in transscribed_vector_right.clone() {
-                    new_operator
-                        .add_operator_product(
-                            (
-                                transscribed_product_left.clone(),
-                                transscribed_product_right,
-                            ),
-                            val.clone() * pref_left * pref_right,
-                        )
-                        .expect("Unexpected error adding operators. Internal struqture error");
-                }
-            }
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(
+        &self,
+    ) -> Result<struqture_one::spins::SpinLindbladNoiseSystem, StruqtureError> {
+        let mut new_qubit_system = struqture_one::spins::SpinLindbladNoiseSystem::new(None);
+        for (key, val) in self.iter() {
+            let one_key_left = key.0.to_struqture_1()?;
+            let one_key_right = key.1.to_struqture_1()?;
+            let _ = struqture_one::OperateOnDensityMatrix::set(
+                &mut new_qubit_system,
+                (one_key_left, one_key_right),
+                val.clone(),
+            );
         }
-        new_operator
+        Ok(new_qubit_system)
     }
-}
 
-impl From<SpinLindbladNoiseOperator> for PlusMinusLindbladNoiseOperator {
-    /// Converts a SpinLindbladNoiseOperator into a PlusMinusLindbladNoiseOperator.
-    ///
-    /// # Arguments
-    ///
-    /// * `value` - The SpinLindbladNoiseOperator to convert.
-    ///
-    /// # Returns
-    ///
-    /// * `Self` - The SpinLindbladNoiseOperator converted into a PlusMinusLindbladNoiseOperator.
-    fn from(value: SpinLindbladNoiseOperator) -> Self {
-        let mut new_operator = PlusMinusLindbladNoiseOperator::with_capacity(2 * value.len());
-        for ((product_left, product_right), val) in value.into_iter() {
-            let transscribed_vector_left: Vec<(PlusMinusProduct, Complex64)> = product_left.into();
-            let transscribed_vector_right: Vec<(PlusMinusProduct, Complex64)> =
-                product_right.into();
-            for (transscribed_product_left, pref_left) in transscribed_vector_left {
-                for (transscribed_product_right, pref_right) in transscribed_vector_right.clone() {
-                    new_operator
-                        .add_operator_product(
-                            (
-                                transscribed_product_left.clone(),
-                                transscribed_product_right,
-                            ),
-                            val.clone() * pref_left * pref_right,
-                        )
-                        .expect("Unexpected error adding operators. Internal struqture error");
-                }
-            }
+    /// Import from struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::spins::SpinLindbladNoiseSystem,
+    ) -> Result<Self, StruqtureError> {
+        let mut new_qubit_operator = Self::new();
+        for (key, val) in struqture_one::OperateOnDensityMatrix::iter(value) {
+            let self_key_left = DecoherenceProduct::from_struqture_1(&key.0)?;
+            let self_key_right = DecoherenceProduct::from_struqture_1(&key.1)?;
+            let _ = new_qubit_operator.set((self_key_left, self_key_right), val.clone());
         }
-        new_operator
+        Ok(new_qubit_operator)
     }
 }
 
-/// Implements the negative sign function of PlusMinusLindbladNoiseOperator.
+/// Implements the negative sign function of QubitLindbladNoiseOperator.
 ///
-impl ops::Neg for PlusMinusLindbladNoiseOperator {
-    type Output = PlusMinusLindbladNoiseOperator;
-    /// Implement minus sign for PlusMinusLindbladNoiseOperator.
+impl ops::Neg for QubitLindbladNoiseOperator {
+    type Output = QubitLindbladNoiseOperator;
+    /// Implement minus sign for QubitLindbladNoiseOperator.
     ///
     /// # Returns
     ///
-    /// * `Self` - The PlusMinusLindbladNoiseOperator * -1.
+    /// * `Self` - The QubitLindbladNoiseOperator * -1.
     fn neg(self) -> Self {
-        let mut internal = self.internal_map.clone();
+        let mut internal = IndexMap::with_capacity(self.len());
         for (key, val) in self {
             internal.insert(key.clone(), val.neg());
         }
-        PlusMinusLindbladNoiseOperator {
+        QubitLindbladNoiseOperator {
             internal_map: internal,
         }
     }
 }
 
-/// Implements the plus function of PlusMinusLindbladNoiseOperator by PlusMinusLindbladNoiseOperator.
+/// Implements the plus function of QubitLindbladNoiseOperator by QubitLindbladNoiseOperator.
 ///
-impl<T, V> ops::Add<T> for PlusMinusLindbladNoiseOperator
+impl<T, V> ops::Add<T> for QubitLindbladNoiseOperator
 where
-    T: IntoIterator<Item = ((PlusMinusProduct, PlusMinusProduct), V)>,
+    T: IntoIterator<Item = ((DecoherenceProduct, DecoherenceProduct), V)>,
     V: Into<CalculatorComplex>,
 {
     type Output = Self;
-    /// Implements `+` (add) for two PlusMinusLindbladNoiseOperators.
+    /// Implements `+` (add) for two QubitLindbladNoiseOperators.
     ///
     /// # Arguments
     ///
-    /// * `other` - The PlusMinusLindbladNoiseOperator to be added.
+    /// * `other` - The QubitLindbladNoiseOperator to be added.
     ///
     /// # Returns
     ///
-    /// * `Self` - The two PlusMinusLindbladNoiseOperators added together.
+    /// * `Self` - The two QubitLindbladNoiseOperators added together.
     ///
     /// # Panics
     ///
     /// * Internal error in add_operator_product.
     fn add(mut self, other: T) -> Self {
         for (key, value) in other.into_iter() {
             self.add_operator_product(key.clone(), Into::<CalculatorComplex>::into(value))
                 .expect("Internal bug in add_operator_product");
         }
         self
     }
 }
 
-/// Implements the minus function of PlusMinusLindbladNoiseOperator by PlusMinusLindbladNoiseOperator.
+/// Implements the minus function of QubitLindbladNoiseOperator by QubitLindbladNoiseOperator.
 ///
-impl<T, V> ops::Sub<T> for PlusMinusLindbladNoiseOperator
+impl<T, V> ops::Sub<T> for QubitLindbladNoiseOperator
 where
-    T: IntoIterator<Item = ((PlusMinusProduct, PlusMinusProduct), V)>,
+    T: IntoIterator<Item = ((DecoherenceProduct, DecoherenceProduct), V)>,
     V: Into<CalculatorComplex>,
 {
     type Output = Self;
-    /// Implements `-` (subtract) for two PlusMinusLindbladNoiseOperators.
+    /// Implements `-` (subtract) for two QubitLindbladNoiseOperators.
     ///
     /// # Arguments
     ///
-    /// * `other` - The PlusMinusLindbladNoiseOperator to be subtracted.
+    /// * `other` - The QubitLindbladNoiseOperator to be subtracted.
     ///
     /// # Returns
     ///
-    /// * `Self` - The two PlusMinusLindbladNoiseOperators subtracted.
+    /// * `Self` - The two QubitLindbladNoiseOperators subtracted.
     ///
     /// # Panics
     ///
     /// * Internal error in add_operator_product.
     fn sub(mut self, other: T) -> Self {
         for (key, value) in other.into_iter() {
             self.add_operator_product(key.clone(), Into::<CalculatorComplex>::into(value) * -1.0)
                 .expect("Internal bug in add_operator_product");
         }
         self
     }
 }
 
-/// Implements the multiplication function of PlusMinusLindbladNoiseOperator by CalculatorComplex/CalculatorFloat.
+/// Implements the multiplication function of QubitLindbladNoiseOperator by CalculatorComplex/CalculatorFloat.
 ///
-impl<T> ops::Mul<T> for PlusMinusLindbladNoiseOperator
+impl<T> ops::Mul<T> for QubitLindbladNoiseOperator
 where
     T: Into<CalculatorComplex>,
 {
     type Output = Self;
-    /// Implement `*` for PlusMinusLindbladNoiseOperator and CalculatorComplex/CalculatorFloat.
+    /// Implement `*` for QubitLindbladNoiseOperator and CalculatorComplex/CalculatorFloat.
     ///
     /// # Arguments
     ///
     /// * `other` - The CalculatorComplex or CalculatorFloat by which to multiply.
     ///
     /// # Returns
     ///
-    /// * `Self` - The PlusMinusLindbladNoiseOperator multiplied by the CalculatorComplex/CalculatorFloat.
+    /// * `Self` - The QubitLindbladNoiseOperator multiplied by the CalculatorComplex/CalculatorFloat.
     fn mul(self, other: T) -> Self {
         let other_cc = Into::<CalculatorComplex>::into(other);
-        let mut internal = self.internal_map.clone();
+        let mut internal = IndexMap::with_capacity(self.len());
         for (key, val) in self {
             internal.insert(key, val * other_cc.clone());
         }
-        PlusMinusLindbladNoiseOperator {
+        QubitLindbladNoiseOperator {
             internal_map: internal,
         }
     }
 }
 
-/// Implements the into_iter function (IntoIterator trait) of PlusMinusLindbladNoiseOperator.
+/// Implements the into_iter function (IntoIterator trait) of QubitLindbladNoiseOperator.
 ///
-impl IntoIterator for PlusMinusLindbladNoiseOperator {
-    type Item = ((PlusMinusProduct, PlusMinusProduct), CalculatorComplex);
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    type IntoIter = std::collections::hash_map::IntoIter<
-        (PlusMinusProduct, PlusMinusProduct),
-        CalculatorComplex,
-    >;
-    #[cfg(feature = "indexed_map_iterators")]
+impl IntoIterator for QubitLindbladNoiseOperator {
+    type Item = ((DecoherenceProduct, DecoherenceProduct), CalculatorComplex);
     type IntoIter =
-        indexmap::map::IntoIter<(PlusMinusProduct, PlusMinusProduct), CalculatorComplex>;
-    /// Returns the PlusMinusLindbladNoiseOperator in Iterator form.
+        indexmap::map::IntoIter<(DecoherenceProduct, DecoherenceProduct), CalculatorComplex>;
+
+    /// Returns the QubitLindbladNoiseOperator in Iterator form.
     ///
     /// # Returns
     ///
-    /// * `Self::IntoIter` - The PlusMinusLindbladNoiseOperator in Iterator form.
+    /// * `Self::IntoIter` - The QubitLindbladNoiseOperator in Iterator form.
     fn into_iter(self) -> Self::IntoIter {
         self.internal_map.into_iter()
     }
 }
 
-/// Implements the into_iter function (IntoIterator trait) of reference PlusMinusLindbladNoiseOperator.
+/// Implements the into_iter function (IntoIterator trait) of reference QubitLindbladNoiseOperator.
 ///
-impl<'a> IntoIterator for &'a PlusMinusLindbladNoiseOperator {
+impl<'a> IntoIterator for &'a QubitLindbladNoiseOperator {
     type Item = (
-        &'a (PlusMinusProduct, PlusMinusProduct),
+        &'a (DecoherenceProduct, DecoherenceProduct),
         &'a CalculatorComplex,
     );
-    type IntoIter = Iter<'a, (PlusMinusProduct, PlusMinusProduct), CalculatorComplex>;
+    type IntoIter = Iter<'a, (DecoherenceProduct, DecoherenceProduct), CalculatorComplex>;
 
-    /// Returns the reference PlusMinusLindbladNoiseOperator in Iterator form.
+    /// Returns the reference QubitLindbladNoiseOperator in Iterator form.
     ///
     /// # Returns
     ///
-    /// * `Self::IntoIter` - The reference PlusMinusLindbladNoiseOperator in Iterator form.
+    /// * `Self::IntoIter` - The reference QubitLindbladNoiseOperator in Iterator form.
     fn into_iter(self) -> Self::IntoIter {
         self.internal_map.iter()
     }
 }
 
-/// Implements the from_iter function (FromIterator trait) of PlusMinusLindbladNoiseOperator.
+/// Implements the from_iter function (FromIterator trait) of QubitLindbladNoiseOperator.
 ///
-impl FromIterator<((PlusMinusProduct, PlusMinusProduct), CalculatorComplex)>
-    for PlusMinusLindbladNoiseOperator
+impl FromIterator<((DecoherenceProduct, DecoherenceProduct), CalculatorComplex)>
+    for QubitLindbladNoiseOperator
 {
-    /// Returns the object in PlusMinusLindbladNoiseOperator form, from an Iterator form of the object.
+    /// Returns the object in QubitLindbladNoiseOperator form, from an Iterator form of the object.
     ///
     /// # Arguments
     ///
-    /// * `iter` - The iterator containing the information from which to create the PlusMinusLindbladNoiseOperator.
+    /// * `iter` - The iterator containing the information from which to create the QubitLindbladNoiseOperator.
     ///
     /// # Returns
     ///
-    /// * `Self::IntoIter` - The iterator in PlusMinusLindbladNoiseOperator form.
+    /// * `Self::IntoIter` - The iterator in QubitLindbladNoiseOperator form.
     ///
     /// # Panics
     ///
     /// * Internal error in add_operator_product.
     fn from_iter<
-        I: IntoIterator<Item = ((PlusMinusProduct, PlusMinusProduct), CalculatorComplex)>,
+        I: IntoIterator<Item = ((DecoherenceProduct, DecoherenceProduct), CalculatorComplex)>,
     >(
         iter: I,
     ) -> Self {
-        let mut slno = PlusMinusLindbladNoiseOperator::new();
+        let mut slno = QubitLindbladNoiseOperator::new();
         for (pair, cc) in iter {
             slno.add_operator_product(pair, cc)
                 .expect("Internal bug in add_operator_product");
         }
         slno
     }
 }
 
-/// Implements the extend function (Extend trait) of PlusMinusLindbladNoiseOperator.
+/// Implements the extend function (Extend trait) of QubitLindbladNoiseOperator.
 ///
-impl Extend<((PlusMinusProduct, PlusMinusProduct), CalculatorComplex)>
-    for PlusMinusLindbladNoiseOperator
+impl Extend<((DecoherenceProduct, DecoherenceProduct), CalculatorComplex)>
+    for QubitLindbladNoiseOperator
 {
-    /// Extends the PlusMinusLindbladNoiseOperator by the specified operations (in Iterator form).
+    /// Extends the QubitLindbladNoiseOperator by the specified operations (in Iterator form).
     ///
     /// # Arguments
     ///
-    /// * `iter` - The iterator containing the operations by which to extend the PlusMinusLindbladNoiseOperator.
+    /// * `iter` - The iterator containing the operations by which to extend the QubitLindbladNoiseOperator.
     ///
     /// # Panics
     ///
     /// * Internal error in add_operator_product.
-    fn extend<I: IntoIterator<Item = ((PlusMinusProduct, PlusMinusProduct), CalculatorComplex)>>(
+    fn extend<
+        I: IntoIterator<Item = ((DecoherenceProduct, DecoherenceProduct), CalculatorComplex)>,
+    >(
         &mut self,
         iter: I,
     ) {
         for (pair, cc) in iter {
             self.add_operator_product(pair, cc)
                 .expect("Internal bug in add_operator_product");
         }
     }
 }
 
-/// Implements the format function (Display trait) of PlusMinusLindbladNoiseOperator.
+/// Implements the format function (Display trait) of QubitLindbladNoiseOperator.
 ///
-impl fmt::Display for PlusMinusLindbladNoiseOperator {
-    /// Formats the PlusMinusLindbladNoiseOperator using the given formatter.
+impl fmt::Display for QubitLindbladNoiseOperator {
+    /// Formats the QubitLindbladNoiseOperator using the given formatter.
     ///
     /// # Arguments
     ///
     /// * `f` - The formatter to use.
     ///
     /// # Returns
     ///
-    /// * `std::fmt::Result` - The formatted PlusMinusLindbladNoiseOperator.
+    /// * `std::fmt::Result` - The formatted QubitLindbladNoiseOperator.
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        let mut output = "PlusMinusLindbladNoiseOperator{\n".to_string();
+        let mut output = "QubitLindbladNoiseOperator{\n".to_string();
         for (key, val) in self.iter() {
             writeln!(output, "({}, {}): {},", key.0, key.1, val)?;
         }
         output.push('}');
 
         write!(f, "{}", output)
     }
 }
 
-impl JordanWignerSpinToFermion for PlusMinusLindbladNoiseOperator {
+/// Add anti-commutator Lindblad contributions
+fn add_anti_commutator(
+    left: &DecoherenceProduct,
+    right: &DecoherenceProduct,
+    row: usize,
+    dimension: usize,
+    number_spins: usize,
+    entries: &mut HashMap<usize, Complex64>,
+    value: &CalculatorComplex,
+) -> Result<(), StruqtureError> {
+    let constant_prefactor = -0.5;
+    let (right_conj, conjugate_prefactor) = right.hermitian_conjugate();
+    let (product, product_prefactor) = DecoherenceProduct::multiply(right_conj, left.clone());
+    for (row_adjusted, shift, (operator, transpose_prefactor)) in [
+        (
+            row.div_euclid(dimension),
+            number_spins,
+            (product.clone(), 1.0),
+        ),
+        (row % dimension, 0, product.hermitian_conjugate()),
+    ] {
+        let mut column = row;
+        let mut prefac = Complex64::new(1.0, 0.0);
+        // iterate over Lindblad terms
+        for (spin_op_index, dec_op) in operator.iter() {
+            match dec_op {
+                SingleDecoherenceOperator::X => {
+                    match row_adjusted.div_euclid(2usize.pow(*spin_op_index as u32)) % 2 {
+                        0 => column += 2usize.pow((*spin_op_index + shift) as u32),
+                        1 => column -= 2usize.pow((*spin_op_index + shift) as u32),
+                        _ => panic!("Internal error in constructing matrix"),
+                    }
+                }
+                SingleDecoherenceOperator::IY => {
+                    match row_adjusted.div_euclid(2usize.pow(*spin_op_index as u32)) % 2 {
+                        0 => {
+                            column += 2usize.pow((*spin_op_index + shift) as u32);
+                            // due to the transpose in i p H => i I.kron(H.T) only the Y Pauli operator picks up an extra
+                            // sign equal to the commutato_prefactor
+                            prefac *= 1.0;
+                        }
+                        1 => {
+                            column -= 2usize.pow((*spin_op_index + shift) as u32);
+                            prefac *= -1.0;
+                        }
+                        _ => panic!("Internal error in constructing matrix"),
+                    };
+                }
+                SingleDecoherenceOperator::Z => {
+                    match row_adjusted.div_euclid(2usize.pow(*spin_op_index as u32)) % 2 {
+                        0 => {
+                            prefac *= 1.0;
+                        }
+                        1 => {
+                            prefac *= -1.0;
+                        }
+                        _ => panic!("Internal error in constructing matrix"),
+                    };
+                }
+                SingleDecoherenceOperator::Identity => (),
+            }
+        }
+        prefac *=
+            transpose_prefactor * conjugate_prefactor * product_prefactor * constant_prefactor;
+        let mut_value = entries.get_mut(&column);
+        let value = Complex64 {
+            re: *value.re.float()?,
+            im: *value.im.float()?,
+        };
+        match mut_value {
+            Some(x) => *x += value * prefac,
+            None => {
+                entries.insert(column, value * prefac);
+            }
+        }
+    }
+    Ok(())
+}
+
+/// Add Lindblad terms that are not part of the anti-commutator
+fn add_lindblad_terms(
+    left: &DecoherenceProduct,
+    right: &DecoherenceProduct,
+    row: usize,
+    dimension: usize,
+    number_spins: usize,
+    entries: &mut HashMap<usize, Complex64>,
+    value: &CalculatorComplex,
+) -> Result<(), StruqtureError> {
+    let mut column = row;
+    let mut prefac = 1.0;
+    // first the terms corresponding to -i H p => -i H.kron(I) flatten(p)
+    for (index_operator_iter, shift, div_euclid) in
+        [(left.iter(), number_spins, true), (right.iter(), 0, false)]
+    {
+        for (index, operator) in index_operator_iter {
+            let row_adjusted = if div_euclid {
+                row.div_euclid(dimension)
+            } else {
+                row % dimension
+            };
+
+            match operator {
+                SingleDecoherenceOperator::X => {
+                    match row_adjusted.div_euclid(2usize.pow(*index as u32)) % 2 {
+                        0 => column += 2usize.pow((*index + shift) as u32),
+                        1 => column -= 2usize.pow((*index + shift) as u32),
+                        _ => panic!("Internal error in constructing matrix"),
+                    }
+                }
+                SingleDecoherenceOperator::IY => {
+                    match row_adjusted.div_euclid(2usize.pow(*index as u32)) % 2 {
+                        0 => {
+                            column += 2usize.pow((*index + shift) as u32);
+                            // due to the transpose in i p H => i I.kron(H.T) only the Y Pauli operator picks up an extra
+                            // sign equal to the commutator_prefactor
+                            prefac *= 1.0;
+                        }
+                        1 => {
+                            column -= 2usize.pow((*index + shift) as u32);
+                            prefac *= -1.0;
+                        }
+                        _ => panic!("Internal error in constructing matrix"),
+                    };
+                }
+                SingleDecoherenceOperator::Z => {
+                    match row_adjusted.div_euclid(2usize.pow(*index as u32)) % 2 {
+                        0 => {
+                            prefac *= 1.0;
+                        }
+                        1 => {
+                            prefac *= -1.0;
+                        }
+                        _ => panic!("Internal error in constructing matrix"),
+                    };
+                }
+                SingleDecoherenceOperator::Identity => (),
+            }
+        }
+    }
+    let mut_value = entries.get_mut(&column);
+    let value = Complex64 {
+        re: *value.re.float()?,
+        im: *value.im.float()?,
+    };
+    match mut_value {
+        Some(x) => *x += value * prefac,
+        None => {
+            entries.insert(column, value * prefac);
+        }
+    }
+    Ok(())
+}
+
+impl JordanWignerSpinToFermion for QubitLindbladNoiseOperator {
     type Output = FermionLindbladNoiseOperator;
 
-    /// Implements JordanWignerSpinToFermion for a PlusMinusLindbladNoiseOperator.
+    /// Implements JordanWignerSpinToFermion for a QubitLindbladNoiseOperator.
     ///
     /// The convention used is that |0> represents an empty fermionic state (spin-orbital),
     /// and |1> represents an occupied fermionic state.
     ///
     /// # Returns
     ///
     /// `FermionLindbladNoiseOperator` - The fermionic noise operator that results from the transformation.
@@ -677,168 +850,184 @@
 }
 
 #[cfg(test)]
 mod test {
     use super::*;
     use serde_test::{assert_tokens, Configure, Token};
 
-    // Test the Clone and PartialEq traits of SpinOperator
+    // Test the Clone and PartialEq traits of QubitOperator
     #[test]
     fn so_from_sos() {
-        let pp: PlusMinusProduct = PlusMinusProduct::new().z(0);
-        let sos = PlusMinusLindbladNoiseOperatorSerialize {
+        let pp: DecoherenceProduct = DecoherenceProduct::new().z(0);
+        let sos = QubitLindbladNoiseOperatorSerialize {
             items: vec![(pp.clone(), pp.clone(), 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 1,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "QubitLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0-alpha.0".to_string(),
             },
         };
-        let mut so = PlusMinusLindbladNoiseOperator::new();
+        let mut so = QubitLindbladNoiseOperator::new();
         so.set((pp.clone(), pp), CalculatorComplex::from(0.5))
             .unwrap();
 
-        assert_eq!(PlusMinusLindbladNoiseOperator::from(sos.clone()), so);
-        assert_eq!(PlusMinusLindbladNoiseOperatorSerialize::from(so), sos);
+        assert_eq!(
+            QubitLindbladNoiseOperator::try_from(sos.clone()).unwrap(),
+            so
+        );
+        assert_eq!(QubitLindbladNoiseOperatorSerialize::from(so), sos);
     }
-    // Test the Clone and PartialEq traits of SpinOperator
+    // Test the Clone and PartialEq traits of QubitOperator
     #[test]
     fn clone_partial_eq() {
-        let pp: PlusMinusProduct = PlusMinusProduct::new().z(0);
-        let sos = PlusMinusLindbladNoiseOperatorSerialize {
+        let pp: DecoherenceProduct = DecoherenceProduct::new().z(0);
+        let sos = QubitLindbladNoiseOperatorSerialize {
             items: vec![(pp.clone(), pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 1,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "QubitLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         // Test Clone trait
         assert_eq!(sos.clone(), sos);
 
         // Test PartialEq trait
-        let pp_1: PlusMinusProduct = PlusMinusProduct::new().z(0);
-        let sos_1 = PlusMinusLindbladNoiseOperatorSerialize {
+        let pp_1: DecoherenceProduct = DecoherenceProduct::new().z(0);
+        let sos_1 = QubitLindbladNoiseOperatorSerialize {
             items: vec![(pp_1.clone(), pp_1, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 1,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "QubitLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
-        let pp_2: PlusMinusProduct = PlusMinusProduct::new().z(2);
-        let sos_2 = PlusMinusLindbladNoiseOperatorSerialize {
+        let pp_2: DecoherenceProduct = DecoherenceProduct::new().z(2);
+        let sos_2 = QubitLindbladNoiseOperatorSerialize {
             items: vec![(pp_2.clone(), pp_2, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 1,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "QubitLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
         assert!(sos_1 == sos);
         assert!(sos == sos_1);
         assert!(sos_2 != sos);
         assert!(sos != sos_2);
     }
 
-    // Test the Debug trait of SpinOperator
+    // Test the Debug trait of QubitOperator
     #[test]
     fn debug() {
-        let pp: PlusMinusProduct = PlusMinusProduct::new().z(0);
-        let sos = PlusMinusLindbladNoiseOperatorSerialize {
+        let pp: DecoherenceProduct = DecoherenceProduct::new().z(0);
+        let sos = QubitLindbladNoiseOperatorSerialize {
             items: vec![(pp.clone(), pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 1,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "QubitLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_eq!(
             format!("{:?}", sos),
-            "PlusMinusLindbladNoiseOperatorSerialize { items: [(PlusMinusProduct { items: [(0, Z)] }, PlusMinusProduct { items: [(0, Z)] }, Float(0.5), Float(0.0))], _struqture_version: StruqtureVersionSerializable { major_version: 1, minor_version: 1 } }"
+            "QubitLindbladNoiseOperatorSerialize { items: [(DecoherenceProduct { items: [(0, Z)] }, DecoherenceProduct { items: [(0, Z)] }, Float(0.5), Float(0.0))], serialisation_meta: StruqtureSerialisationMeta { type_name: \"QubitLindbladNoiseOperator\", min_version: (2, 0, 0), version: \"2.0.0\" } }"
         );
     }
 
-    /// Test SpinOperator Serialization and Deserialization traits (readable)
+    /// Test QubitOperator Serialization and Deserialization traits (readable)
     #[test]
     fn serde_readable() {
-        let pp = PlusMinusProduct::new().minus(0);
-        let sos = PlusMinusLindbladNoiseOperatorSerialize {
+        let pp = DecoherenceProduct::new().x(0);
+        let sos = QubitLindbladNoiseOperatorSerialize {
             items: vec![(pp.clone(), pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 1,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "QubitLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_tokens(
             &sos.readable(),
             &[
                 Token::Struct {
-                    name: "PlusMinusLindbladNoiseOperatorSerialize",
+                    name: "QubitLindbladNoiseOperatorSerialize",
                     len: 2,
                 },
                 Token::Str("items"),
                 Token::Seq { len: Some(1) },
                 Token::Tuple { len: 4 },
-                Token::Str("0-"),
-                Token::Str("0-"),
+                Token::Str("0X"),
+                Token::Str("0X"),
                 Token::F64(0.5),
                 Token::F64(0.0),
                 Token::TupleEnd,
                 Token::SeqEnd,
-                Token::Str("_struqture_version"),
+                Token::Str("serialisation_meta"),
                 Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
                 },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(1),
+                Token::Str("type_name"),
+                Token::Str("QubitLindbladNoiseOperator"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
                 Token::StructEnd,
                 Token::StructEnd,
             ],
         );
     }
 
-    /// Test SpinOperator Serialization and Deserialization traits (compact)
+    /// Test QubitOperator Serialization and Deserialization traits (compact)
     #[test]
     fn serde_compact() {
-        let pp = PlusMinusProduct::new().plus(0);
-        let sos = PlusMinusLindbladNoiseOperatorSerialize {
+        let pp = DecoherenceProduct::new().x(0);
+        let sos = QubitLindbladNoiseOperatorSerialize {
             items: vec![(pp.clone(), pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 1,
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "QubitLindbladNoiseOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_tokens(
             &sos.compact(),
             &[
                 Token::Struct {
-                    name: "PlusMinusLindbladNoiseOperatorSerialize",
+                    name: "QubitLindbladNoiseOperatorSerialize",
                     len: 2,
                 },
                 Token::Str("items"),
                 Token::Seq { len: Some(1) },
                 Token::Tuple { len: 4 },
                 Token::Seq { len: Some(1) },
                 Token::Tuple { len: 2 },
                 Token::U64(0),
                 Token::UnitVariant {
-                    name: "SinglePlusMinusOperator",
-                    variant: "Plus",
+                    name: "SingleDecoherenceOperator",
+                    variant: "X",
                 },
                 Token::TupleEnd,
                 Token::SeqEnd,
                 Token::Seq { len: Some(1) },
                 Token::Tuple { len: 2 },
                 Token::U64(0),
                 Token::UnitVariant {
-                    name: "SinglePlusMinusOperator",
-                    variant: "Plus",
+                    name: "SingleDecoherenceOperator",
+                    variant: "X",
                 },
                 Token::TupleEnd,
                 Token::SeqEnd,
                 Token::NewtypeVariant {
                     name: "CalculatorFloat",
                     variant: "Float",
                 },
@@ -846,22 +1035,28 @@
                 Token::NewtypeVariant {
                     name: "CalculatorFloat",
                     variant: "Float",
                 },
                 Token::F64(0.0),
                 Token::TupleEnd,
                 Token::SeqEnd,
-                Token::Str("_struqture_version"),
+                Token::Str("serialisation_meta"),
                 Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
                 },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(1),
+                Token::Str("type_name"),
+                Token::Str("QubitLindbladNoiseOperator"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
                 Token::StructEnd,
                 Token::StructEnd,
             ],
         );
     }
 }
```

### Comparing `struqture_py-1.6.1/struqture/src/spins/plus_minus_operator.rs` & `struqture_py-2.0.0a0/struqture/src/spins/qubit_hamiltonian.rs`

 * *Files 26% similar despite different names*

```diff
@@ -6,841 +6,814 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
-use super::{DecoherenceOperator, DecoherenceProduct, PauliProduct, SpinOperator};
-use crate::fermions::FermionOperator;
+use super::{OperateOnSpins, QubitOperator, ToSparseMatrixOperator, ToSparseMatrixSuperOperator};
+use crate::fermions::{FermionHamiltonian, FermionOperator};
 use crate::mappings::JordanWignerSpinToFermion;
-use crate::spins::{PlusMinusProduct, SpinHamiltonian};
-use crate::{
-    OperateOnDensityMatrix, OperateOnState, StruqtureError, StruqtureVersionSerializable,
-    SymmetricIndex,
-};
+use crate::prelude::*;
+use crate::spins::{HermitianOperateOnSpins, PauliProduct, SpinIndex};
+use crate::{CooSparseMatrix, GetValue, OperateOnDensityMatrix, OperateOnState, StruqtureError};
+use indexmap::map::{Entry, Iter};
+use indexmap::IndexMap;
 use num_complex::Complex64;
 use qoqo_calculator::{CalculatorComplex, CalculatorFloat};
 use serde::{Deserialize, Serialize};
-
-#[cfg(feature = "indexed_map_iterators")]
-use indexmap::map::{Entry, Iter, Keys, Values};
-#[cfg(feature = "indexed_map_iterators")]
-use indexmap::IndexMap;
-#[cfg(not(feature = "indexed_map_iterators"))]
-use std::collections::hash_map::{Entry, Iter, Keys, Values};
-#[cfg(not(feature = "indexed_map_iterators"))]
-use std::collections::HashMap;
-
 use std::fmt::{self, Write};
 use std::iter::{FromIterator, IntoIterator};
 use std::ops;
 
-/// PlusMinusOperators are combinations of PlusMinusProducts with specific CalculatorComplex coefficients.
+/// QubitHamiltonians are combinations of PauliProducts with specific CalculatorFloat coefficients.
 ///
 /// This is a representation of sums of pauli products with weightings, in order to build a full hamiltonian.
+/// QubitHamiltonian is the hermitian equivalent of QubitOperator.
 ///
 /// # Example
 ///
 /// ```
 /// use struqture::prelude::*;
-/// use qoqo_calculator::CalculatorComplex;
-/// use struqture::spins::{OperateOnSpins, PlusMinusProduct, PlusMinusOperator};
+/// use qoqo_calculator::CalculatorFloat;
+/// use struqture::spins::{HermitianOperateOnSpins, PauliProduct, QubitHamiltonian};
 ///
-/// let mut so = PlusMinusOperator::new();
+/// let mut sh = QubitHamiltonian::new();
 ///
-/// // Representing the hamiltonian $ 1/2 \sigma_0^{+} \sigma_1^{+} + 1/5 \sigma_0^{z} $
-/// let pp_0x1x = PlusMinusProduct::new().plus(0).plus(1);
-/// let pp_0z = PlusMinusProduct::new().z(0);
-/// so.add_operator_product(pp_0x1x.clone(), CalculatorComplex::from(0.5)).unwrap();
-/// so.add_operator_product(pp_0z.clone(), CalculatorComplex::from(0.2)).unwrap();
+/// // Representing the hamiltonian $ 1/2 \sigma_0^{x} \sigma_1^{x} + 1/5 \sigma_0^{z} $
+/// let pp_0x1x = PauliProduct::new().x(0).x(1);
+/// let pp_0z = PauliProduct::new().z(0);
+/// sh.add_operator_product(pp_0x1x.clone(), CalculatorFloat::from(0.5)).unwrap();
+/// sh.add_operator_product(pp_0z.clone(), CalculatorFloat::from(0.2)).unwrap();
 ///
 /// // Access what you set:
-/// assert_eq!(so.get(&pp_0x1x), &CalculatorComplex::from(0.5));
-/// assert_eq!(so.get(&pp_0z), &CalculatorComplex::from(0.2));
+/// assert_eq!(sh.get(&pp_0x1x), &CalculatorFloat::from(0.5));
+/// assert_eq!(sh.get(&pp_0z), &CalculatorFloat::from(0.2));
 /// ```
 ///
 #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
-#[serde(from = "PlusMinusOperatorSerialize")]
-#[serde(into = "PlusMinusOperatorSerialize")]
-pub struct PlusMinusOperator {
-    // The internal HashMap of PlusMinusProducts and coefficients (CalculatorComplex)
-    #[cfg(feature = "indexed_map_iterators")]
-    internal_map: IndexMap<PlusMinusProduct, CalculatorComplex>,
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    internal_map: HashMap<PlusMinusProduct, CalculatorComplex>,
+#[serde(try_from = "QubitHamiltonianSerialize")]
+#[serde(into = "QubitHamiltonianSerialize")]
+pub struct QubitHamiltonian {
+    // The internal HashMap of PauliProducts and coefficients (CalculatorFloat)
+    internal_map: IndexMap<PauliProduct, CalculatorFloat>,
 }
 
-impl crate::MinSupportedVersion for PlusMinusOperator {
-    fn min_supported_version() -> (usize, usize, usize) {
-        (1, 1, 0)
+impl crate::SerializationSupport for QubitHamiltonian {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::QubitHamiltonian
     }
 }
-
 #[cfg(feature = "json_schema")]
-impl schemars::JsonSchema for PlusMinusOperator {
+impl schemars::JsonSchema for QubitHamiltonian {
     fn schema_name() -> String {
-        "PlusMinusOperator".to_string()
+        "struqture::spins::QubitHamiltonian".to_string()
     }
 
     fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
-        <PlusMinusOperatorSerialize>::json_schema(gen)
+        <QubitHamiltonianSerialize>::json_schema(gen)
     }
 }
 
 #[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
 #[cfg_attr(feature = "json_schema", derive(schemars::JsonSchema))]
 #[cfg_attr(feature = "json_schema", schemars(deny_unknown_fields))]
-struct PlusMinusOperatorSerialize {
-    items: Vec<(PlusMinusProduct, CalculatorFloat, CalculatorFloat)>,
-    _struqture_version: StruqtureVersionSerializable,
-}
-
-impl From<PlusMinusOperatorSerialize> for PlusMinusOperator {
-    fn from(value: PlusMinusOperatorSerialize) -> Self {
-        let new_noise_op: PlusMinusOperator = value
-            .items
-            .into_iter()
-            .map(|(key, real, imag)| (key, CalculatorComplex { re: real, im: imag }))
-            .collect();
-        new_noise_op
+/// # QubitHamiltonian
+/// QubitHamiltonians are combinations of PauliProducts with specific CalculatorFloat coefficients.
+///
+/// This is a representation of sums of pauli products with weightings, in order to build a full hamiltonian.
+/// QubitHamiltonian is the hermitian equivalent of QubitOperator.
+struct QubitHamiltonianSerialize {
+    /// List of all non-zero entries in the QubitHamiltonian in the form (PauliProduct, real weight).
+    items: Vec<(PauliProduct, CalculatorFloat)>,
+    serialisation_meta: crate::StruqtureSerialisationMeta,
+}
+
+impl TryFrom<QubitHamiltonianSerialize> for QubitHamiltonian {
+    type Error = StruqtureError;
+    fn try_from(value: QubitHamiltonianSerialize) -> Result<Self, Self::Error> {
+        let target_serialisation_meta =
+            <Self as crate::SerializationSupport>::target_serialisation_meta();
+        crate::check_can_be_deserialised(&target_serialisation_meta, &value.serialisation_meta)?;
+        let new_noise_op: QubitHamiltonian = value.items.into_iter().collect();
+        Ok(new_noise_op)
     }
 }
 
-impl From<PlusMinusOperator> for PlusMinusOperatorSerialize {
-    fn from(value: PlusMinusOperator) -> Self {
-        let new_noise_op: Vec<(PlusMinusProduct, CalculatorFloat, CalculatorFloat)> = value
-            .into_iter()
-            .map(|(key, val)| (key, val.re, val.im))
-            .collect();
-        let current_version = StruqtureVersionSerializable {
-            major_version: 1,
-            minor_version: 1,
-        };
+impl From<QubitHamiltonian> for QubitHamiltonianSerialize {
+    fn from(value: QubitHamiltonian) -> Self {
+        let serialisation_meta = crate::SerializationSupport::struqture_serialisation_meta(&value);
+
+        let new_noise_op: Vec<(PauliProduct, CalculatorFloat)> = value.into_iter().collect();
         Self {
             items: new_noise_op,
-            _struqture_version: current_version,
+            serialisation_meta,
         }
     }
 }
 
-impl<'a> OperateOnDensityMatrix<'a> for PlusMinusOperator {
-    type IteratorType = Iter<'a, Self::Index, Self::Value>;
-    type KeyIteratorType = Keys<'a, Self::Index, Self::Value>;
-    type ValueIteratorType = Values<'a, Self::Index, Self::Value>;
-    type Value = CalculatorComplex;
-    type Index = PlusMinusProduct;
+impl<'a> OperateOnDensityMatrix<'a> for QubitHamiltonian {
+    type Index = PauliProduct;
+    type Value = CalculatorFloat;
 
     // From trait
     fn get(&self, key: &Self::Index) -> &Self::Value {
         match self.internal_map.get(key) {
             Some(value) => value,
-            None => &CalculatorComplex::ZERO,
+            None => &CalculatorFloat::ZERO,
         }
     }
 
     // From trait
-    fn iter(&'a self) -> Self::IteratorType {
+    fn iter(&'a self) -> impl ExactSizeIterator<Item = (&'a Self::Index, &'a Self::Value)> {
         self.internal_map.iter()
     }
 
     // From trait
-    fn keys(&'a self) -> Self::KeyIteratorType {
+    fn keys(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Index> {
         self.internal_map.keys()
     }
 
     // From trait
-    fn values(&'a self) -> Self::ValueIteratorType {
+    fn values(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Value> {
         self.internal_map.values()
     }
 
-    #[cfg(feature = "indexed_map_iterators")]
     // From trait
     fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
         self.internal_map.shift_remove(key)
     }
 
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    // From trait
-    fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
-        self.internal_map.remove(key)
-    }
-
     // From trait
     fn empty_clone(&self, capacity: Option<usize>) -> Self {
         match capacity {
             Some(cap) => Self::with_capacity(cap),
             None => Self::new(),
         }
     }
 
-    /// Overwrites an existing entry or sets a new entry in the PlusMinusOperator with the given (PlusMinusProduct key, CalculatorComplex value) pair.
+    /// Overwrites an existing entry or sets a new entry in the QubitHamiltonian with the given (PauliProduct key, CalculatorFloat value) pair.
     ///
     /// # Arguments
     ///
-    /// * `key` - The PlusMinusProduct key to set in the PlusMinusOperator.
-    /// * `value` - The corresponding CalculatorComplex value to set for the key in the PlusMinusOperator.
+    /// * `key` - The PauliProduct key to set in the QubitHamiltonian.
+    /// * `value` - The corresponding CalculatorFloat value to set for the key in the QubitHamiltonian.
     ///
     /// # Returns
     ///
-    /// * `Ok(Some(CalculatorComplex))` - The key existed, this is the value it had before it was set with the value input.
+    /// * `Ok(Some(CalculatorFloat))` - The key existed, this is the value it had before it was set with the value input.
     /// * `Ok(None)` - The key did not exist, it has been set with its corresponding value.
     fn set(
         &mut self,
         key: Self::Index,
         value: Self::Value,
     ) -> Result<Option<Self::Value>, StruqtureError> {
-        if value != CalculatorComplex::ZERO {
+        if value != CalculatorFloat::ZERO {
             Ok(self.internal_map.insert(key, value))
         } else {
             match self.internal_map.entry(key) {
-                #[cfg(feature = "indexed_map_iterators")]
                 Entry::Occupied(val) => Ok(Some(val.shift_remove())),
-                #[cfg(not(feature = "indexed_map_iterators"))]
-                Entry::Occupied(val) => Ok(Some(val.remove())),
                 Entry::Vacant(_) => Ok(None),
             }
         }
     }
 }
 
-impl<'a> OperateOnState<'a> for PlusMinusOperator {
+impl<'a> OperateOnState<'a> for QubitHamiltonian {
     // From trait
     fn hermitian_conjugate(&self) -> Self {
-        let mut new_operator = Self::with_capacity(self.len());
-        for (pauli_product, value) in self.iter() {
-            let (new_boson_product, prefactor) = pauli_product.hermitian_conjugate();
-            new_operator
-                .add_operator_product(new_boson_product, value.conj() * prefactor)
-                .expect("Internal bug in add_operator_product");
+        self.clone()
+    }
+}
+
+impl<'a> OperateOnSpins<'a> for QubitHamiltonian {
+    /// Gets the maximum index of the QubitHamiltonian.
+    ///
+    /// # Returns
+    ///
+    /// * `usize` - The number of spins in the QubitHamiltonian.
+    fn current_number_spins(&self) -> usize {
+        let mut max_mode: usize = 0;
+        if !self.internal_map.is_empty() {
+            for key in self.internal_map.keys() {
+                if key.current_number_spins() > max_mode {
+                    max_mode = key.current_number_spins()
+                }
+            }
         }
-        new_operator
+        max_mode
     }
 }
 
-/// Implements the default function (Default trait) of PlusMinusOperator (an empty PlusMinusOperator).
+impl<'a> HermitianOperateOnSpins<'a> for QubitHamiltonian {}
+
+impl<'a> ToSparseMatrixOperator<'a> for QubitHamiltonian {}
+impl<'a> ToSparseMatrixSuperOperator<'a> for QubitHamiltonian {
+    // From trait
+    fn sparse_matrix_superoperator_entries_on_row(
+        &'a self,
+        row: usize,
+        number_spins: usize,
+    ) -> Result<std::collections::HashMap<usize, Complex64>, StruqtureError> {
+        <Self as ToSparseMatrixOperator>::sparse_matrix_superoperator_entries_on_row(
+            self,
+            row,
+            number_spins,
+        )
+    }
+
+    // From trait
+    fn unitary_sparse_matrix_coo(&'a self) -> Result<crate::CooSparseMatrix, StruqtureError> {
+        self.sparse_matrix_coo(None)
+    }
+
+    // From trait
+    fn sparse_lindblad_entries(
+        &'a self,
+    ) -> Result<Vec<(CooSparseMatrix, CooSparseMatrix, Complex64)>, StruqtureError> {
+        let rate = Complex64::default();
+        let left: CooSparseMatrix = (vec![], (vec![], vec![]));
+        let right: CooSparseMatrix = (vec![], (vec![], vec![]));
+        Ok(vec![(left, right, rate)])
+    }
+}
+
+/// Implements the default function (Default trait) of QubitHamiltonian (an empty QubitHamiltonian).
 ///
-impl Default for PlusMinusOperator {
+impl Default for QubitHamiltonian {
     fn default() -> Self {
         Self::new()
     }
 }
 
-/// Functions for the PlusMinusOperator
+/// Functions for the QubitHamiltonian
 ///
-impl PlusMinusOperator {
-    /// Creates a new PlusMinusOperator.
+impl QubitHamiltonian {
+    /// Creates a new QubitHamiltonian.
     ///
     /// # Returns
     ///
-    /// * `Self` - The new (empty) PlusMinusOperator.
+    /// * `Self` - The new (empty) QubitHamiltonian.
     pub fn new() -> Self {
-        PlusMinusOperator {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::new(),
-            #[cfg(feature = "indexed_map_iterators")]
+        QubitHamiltonian {
             internal_map: IndexMap::new(),
         }
     }
 
-    /// Creates a new PlusMinusOperator with pre-allocated capacity.
+    /// Creates a new QubitHamiltonian with pre-allocated capacity.
     ///
     /// # Arguments
     ///
     /// * `capacity` - The pre-allocated capacity of the system.
     ///
     /// # Returns
     ///
-    /// * `Self` - The new (empty) PlusMinusOperator.
+    /// * `Self` - The new (empty) QubitHamiltonian.
     pub fn with_capacity(capacity: usize) -> Self {
-        PlusMinusOperator {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::with_capacity(capacity),
-            #[cfg(feature = "indexed_map_iterators")]
+        Self {
             internal_map: IndexMap::with_capacity(capacity),
         }
     }
 
-    /// Separate self into an operator with the terms of given number of spins and an operator with the remaining operations
-    ///
-    /// # Arguments
-    ///
-    /// * `number_spins` - Number of spins to filter for in the keys.
-    ///
-    /// # Returns
-    ///
-    /// `Ok((separated, remainder))` - Operator with the noise terms where number_spins matches the number of spins the operator product acts on and Operator with all other contributions.
-    pub fn separate_into_n_terms(
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(
         &self,
-        number_spins: usize,
-    ) -> Result<(PlusMinusOperator, PlusMinusOperator), StruqtureError> {
-        let mut separated = PlusMinusOperator::new();
-        let mut remainder = PlusMinusOperator::new();
-        for (prod, val) in self.iter() {
-            if prod.iter().len() == number_spins {
-                separated.add_operator_product(prod.clone(), val.clone())?;
-            } else {
-                remainder.add_operator_product(prod.clone(), val.clone())?;
-            }
-        }
-        Ok((separated, remainder))
-    }
-}
-
-impl From<PlusMinusOperator> for SpinOperator {
-    /// Converts a PlusMinusOperator into a SpinOperator.
-    ///
-    /// # Arguments
-    ///
-    /// * `value` - The PlusMinusOperator to convert.
-    ///
-    /// # Returns
-    ///
-    /// * `Self` - The PlusMinusOperator converted into a SpinOperator.
-    fn from(value: PlusMinusOperator) -> Self {
-        let mut new_operator = SpinOperator::with_capacity(2 * value.len());
-        for (product, val) in value.into_iter() {
-            let transscribed_vector: Vec<(PauliProduct, Complex64)> = product.into();
-            for (transscribed_product, prefactor) in transscribed_vector {
-                new_operator
-                    .add_operator_product(transscribed_product, val.clone() * prefactor)
-                    .expect("Unexpected error adding operators. Internal struqture error");
-            }
-        }
-        new_operator
-    }
-}
-
-impl From<SpinOperator> for PlusMinusOperator {
-    /// Converts a SpinOperator into a PlusMinusOperator.
-    ///
-    /// # Arguments
-    ///
-    /// * `value` - The SpinOperator to convert.
-    ///
-    /// # Returns
-    ///
-    /// * `Self` - The SpinOperator converted into a PlusMinusOperator.
-    fn from(value: SpinOperator) -> Self {
-        let mut new_operator = PlusMinusOperator::with_capacity(2 * value.len());
-        for (product, val) in value.into_iter() {
-            let transscribed_vector: Vec<(PlusMinusProduct, Complex64)> = product.into();
-            for (transscribed_product, prefactor) in transscribed_vector {
-                new_operator
-                    .add_operator_product(transscribed_product, val.clone() * prefactor)
-                    .expect("Unexpected error adding operators. Internal struqture error");
-            }
-        }
-        new_operator
-    }
-}
-
-impl From<PlusMinusOperator> for DecoherenceOperator {
-    /// Converts a PlusMinusOperator into a DecoherenceOperator.
-    ///
-    /// # Arguments
-    ///
-    /// * `value` - The PlusMinusOperator to convert.
-    ///
-    /// # Returns
-    ///
-    /// * `Self` - The PlusMinusOperator converted into a DecoherenceOperator.
-    fn from(value: PlusMinusOperator) -> Self {
-        let mut new_operator = DecoherenceOperator::with_capacity(2 * value.len());
-        for (product, val) in value.into_iter() {
-            let transscribed_vector: Vec<(DecoherenceProduct, Complex64)> = product.into();
-            for (transscribed_product, prefactor) in transscribed_vector {
-                new_operator
-                    .add_operator_product(transscribed_product, val.clone() * prefactor)
-                    .expect("Unexpected error adding operators. Internal struqture error");
-            }
+    ) -> Result<struqture_one::spins::SpinHamiltonianSystem, StruqtureError> {
+        let mut new_qubit_system = struqture_one::spins::SpinHamiltonianSystem::new(None);
+        for (key, val) in self.iter() {
+            let one_key = key.to_struqture_1()?;
+            let _ = struqture_one::OperateOnDensityMatrix::set(
+                &mut new_qubit_system,
+                one_key,
+                val.clone(),
+            );
         }
-        new_operator
+        Ok(new_qubit_system)
     }
-}
 
-impl From<DecoherenceOperator> for PlusMinusOperator {
-    /// Converts a DecoherenceOperator into a PlusMinusOperator.
-    ///
-    /// # Arguments
-    ///
-    /// * `value` - The DecoherenceOperator to convert.
-    ///
-    /// # Returns
-    ///
-    /// * `Self` - The DecoherenceOperator converted into a PlusMinusOperator.
-    fn from(value: DecoherenceOperator) -> Self {
-        let mut new_operator = PlusMinusOperator::with_capacity(2 * value.len());
-        for (product, val) in value.into_iter() {
-            let transscribed_vector: Vec<(PlusMinusProduct, Complex64)> = product.into();
-            for (transscribed_product, prefactor) in transscribed_vector {
-                new_operator
-                    .add_operator_product(transscribed_product, val.clone() * prefactor)
-                    .expect("Unexpected error adding operators. Internal struqture error");
-            }
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::spins::SpinHamiltonianSystem,
+    ) -> Result<Self, StruqtureError> {
+        let mut new_qubit_operator = Self::new();
+        for (key, val) in struqture_one::OperateOnDensityMatrix::iter(value) {
+            let self_key = PauliProduct::from_struqture_1(key)?;
+            let _ = new_qubit_operator.set(self_key, val.clone());
         }
-        new_operator
+        Ok(new_qubit_operator)
     }
 }
 
-impl TryFrom<PlusMinusOperator> for SpinHamiltonian {
+impl TryFrom<QubitOperator> for QubitHamiltonian {
     type Error = StruqtureError;
-
-    /// Tries to converts a PlusMinusOperator into a SpinHamiltonian.
+    /// Tries to convert a QubitOperator into a QubitHamiltonian.
     ///
     /// # Arguments
     ///
-    /// * `value` - The PlusMinusOperator to try to convert.
+    /// * `hamiltonian` - The QubitOperator to try to convert.
     ///
     /// # Returns
     ///
-    /// * `Ok(Self)` - The PlusMinusOperator converted into a SpinHamiltonian.
+    /// * `Ok(Self)` - The QubitOperator converted into a QubitHamiltonian.
     /// * `Err(StruqtureError::NonHermitianOperator)` - Key is naturally hermitian (on-diagonal term), but its corresponding value is not real.
-    fn try_from(value: PlusMinusOperator) -> Result<Self, Self::Error> {
-        let tmp_operator = SpinOperator::from(value).truncate(1e-16);
-        SpinHamiltonian::try_from(tmp_operator)
-    }
-}
-
-impl From<SpinHamiltonian> for PlusMinusOperator {
-    /// Converts a SpinHamiltonian into a PlusMinusOperator.
-    ///
-    /// # Arguments
-    ///
-    /// * `value` - The SpinHamiltonian to convert.
-    ///
-    /// # Returns
-    ///
-    /// * `Self` - The SpinHamiltonian converted into a PlusMinusOperator.
-    fn from(value: SpinHamiltonian) -> Self {
-        let mut new_operator = PlusMinusOperator::with_capacity(2 * value.len());
-        for (product, val) in value.into_iter() {
-            let transscribed_vector: Vec<(PlusMinusProduct, Complex64)> = product.into();
-            for (transscribed_product, prefactor) in transscribed_vector {
-                new_operator
-                    .add_operator_product(
-                        transscribed_product,
-                        CalculatorComplex::from(val.clone()) * prefactor,
-                    )
-                    .expect("Unexpected error adding operators. Internal struqture error");
+    fn try_from(hamiltonian: QubitOperator) -> Result<Self, StruqtureError> {
+        let mut internal = QubitHamiltonian::new();
+        for (key, value) in hamiltonian.into_iter() {
+            if value.im != CalculatorFloat::ZERO {
+                return Err(StruqtureError::NonHermitianOperator {});
+            } else {
+                let pp = PauliProduct::get_key(&key);
+                internal.add_operator_product(pp, value.re)?;
             }
         }
-        new_operator.truncate(1e-16)
+        Ok(internal)
     }
 }
 
-/// Implements the negative sign function of PlusMinusOperator.
+/// Implements the negative sign function of QubitOperator.
 ///
-impl ops::Neg for PlusMinusOperator {
-    type Output = PlusMinusOperator;
-    /// Implement minus sign for PlusMinusOperator.
+impl ops::Neg for QubitHamiltonian {
+    type Output = QubitHamiltonian;
+    /// Implement minus sign for QubitHamiltonian.
     ///
     /// # Returns
     ///
-    /// * `Self` - The PlusMinusOperator * -1.
+    /// * `Self` - The QubitHamiltonian * -1.
     fn neg(self) -> Self {
-        #[cfg(not(feature = "indexed_map_iterators"))]
-        let mut internal = HashMap::with_capacity(self.len());
-        #[cfg(feature = "indexed_map_iterators")]
-        let mut internal = IndexMap::with_capacity(self.len());
-        for (key, val) in self {
-            internal.insert(key.clone(), val.neg());
+        let mut internal = self.internal_map.clone();
+        for key in self.keys() {
+            internal.insert(key.clone(), internal[key].clone() * -1.0);
         }
-        PlusMinusOperator {
+        QubitHamiltonian {
             internal_map: internal,
         }
     }
 }
 
-/// Implements the plus function of PlusMinusOperator by PlusMinusOperator.
+/// Implements the plus function of QubitHamiltonian by QubitHamiltonian.
 ///
-impl<T, V> ops::Add<T> for PlusMinusOperator
+impl<T, V> ops::Add<T> for QubitHamiltonian
 where
-    T: IntoIterator<Item = (PlusMinusProduct, V)>,
-    V: Into<CalculatorComplex>,
+    T: IntoIterator<Item = (PauliProduct, V)>,
+    V: Into<CalculatorFloat>,
 {
     type Output = Self;
-    /// Implements `+` (add) for two PlusMinusOperators.
+    /// Implements `+` (add) for two QubitHamiltonians.
     ///
     /// # Arguments
     ///
-    /// * `other` - The PlusMinusOperator to be added.
+    /// * `other` - The QubitHamiltonian to be added.
     ///
     /// # Returns
     ///
-    /// * `Self` - The two PlusMinusOperators added together.
+    /// * `Self` - The two QubitHamiltonians added together.
     ///
     /// # Panics
     ///
-    /// * Internal error in add_operator_product.
+    /// * Internal bug in add_operator_product.
     fn add(mut self, other: T) -> Self {
         for (key, value) in other.into_iter() {
-            self.add_operator_product(key.clone(), Into::<CalculatorComplex>::into(value))
+            self.add_operator_product(key.clone(), Into::<CalculatorFloat>::into(value))
                 .expect("Internal bug in add_operator_product");
         }
         self
     }
 }
 
-/// Implements the minus function of PlusMinusOperator by PlusMinusOperator.
+/// Implements the minus function of QubitHamiltonian by QubitHamiltonian.
 ///
-impl<T, V> ops::Sub<T> for PlusMinusOperator
+impl<T, V> ops::Sub<T> for QubitHamiltonian
 where
-    T: IntoIterator<Item = (PlusMinusProduct, V)>,
-    V: Into<CalculatorComplex>,
+    T: IntoIterator<Item = (PauliProduct, V)>,
+    V: Into<CalculatorFloat>,
 {
     type Output = Self;
-    /// Implements `-` (subtract) for two PlusMinusOperators.
+    /// Implements `-` (subtract) for two QubitHamiltonians.
     ///
     /// # Arguments
     ///
-    /// * `other` - The PlusMinusOperator to be subtracted.
+    /// * `other` - The QubitHamiltonian to be subtracted.
     ///
     /// # Returns
     ///
-    /// * `Self` - The two PlusMinusOperators subtracted.
+    /// * `Self` - The two QubitHamiltonians subtracted.
     ///
     /// # Panics
     ///
-    /// * Internal error in add_operator_product.
+    /// * Internal bug in add_operator_product.
     fn sub(mut self, other: T) -> Self {
         for (key, value) in other.into_iter() {
-            self.add_operator_product(key.clone(), Into::<CalculatorComplex>::into(value) * -1.0)
+            self.add_operator_product(key.clone(), Into::<CalculatorFloat>::into(value) * -1.0)
                 .expect("Internal bug in add_operator_product");
         }
         self
     }
 }
 
-/// Implements the multiplication function of PlusMinusOperator by CalculatorComplex/CalculatorFloat.
+/// Implements the multiplication function of QubitHamiltonian by CalculatorFloat.
 ///
-impl<T> ops::Mul<T> for PlusMinusOperator
-where
-    T: Into<CalculatorComplex>,
-{
+impl ops::Mul<CalculatorFloat> for QubitHamiltonian {
     type Output = Self;
-    /// Implement `*` for PlusMinusOperator and CalculatorComplex/CalculatorFloat.
+    /// Implement `*` for QubitHamiltonian and CalculatorFloat.
     ///
     /// # Arguments
     ///
-    /// * `other` - The CalculatorComplex or CalculatorFloat by which to multiply.
+    /// * `other` - The CalculatorFloat by which to multiply.
     ///
     /// # Returns
     ///
-    /// * `Self` - The PlusMinusOperator multiplied by the CalculatorComplex/CalculatorFloat.
-    fn mul(self, other: T) -> Self {
-        let other_cc = Into::<CalculatorComplex>::into(other);
-        #[cfg(not(feature = "indexed_map_iterators"))]
-        let mut internal = HashMap::with_capacity(self.len());
-        #[cfg(feature = "indexed_map_iterators")]
-        let mut internal = IndexMap::with_capacity(self.len());
-        for (key, val) in self {
-            internal.insert(key, val * other_cc.clone());
+    /// * `Self` - The QubitHamiltonian multiplied by the CalculatorFloat.
+    fn mul(self, other: CalculatorFloat) -> Self {
+        let mut internal = self.internal_map.clone();
+        for key in self.keys() {
+            internal.insert(key.clone(), internal[key].clone() * other.clone());
         }
-        PlusMinusOperator {
+        QubitHamiltonian {
             internal_map: internal,
         }
     }
 }
 
-/// Implements the into_iter function (IntoIterator trait) of PlusMinusOperator.
+/// Implements the multiplication function of QubitHamiltonian by CalculatorComplex.
 ///
-impl IntoIterator for PlusMinusOperator {
-    type Item = (PlusMinusProduct, CalculatorComplex);
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    type IntoIter = std::collections::hash_map::IntoIter<PlusMinusProduct, CalculatorComplex>;
-    #[cfg(feature = "indexed_map_iterators")]
-    type IntoIter = indexmap::map::IntoIter<PlusMinusProduct, CalculatorComplex>;
+impl ops::Mul<CalculatorComplex> for QubitHamiltonian {
+    type Output = QubitOperator;
+    /// Implement `*` for QubitHamiltonian and CalculatorComplex.
+    ///
+    /// # Arguments
+    ///
+    /// * `other` - The CalculatorComplex by which to multiply.
+    ///
+    /// # Returns
+    ///
+    /// * `QubitOperator` - The QubitHamiltonian multiplied by the CalculatorFloat.
+    ///
+    /// # Panics
+    ///
+    /// * Internal bug in set.
+    fn mul(self, other: CalculatorComplex) -> Self::Output {
+        let mut new_out = QubitOperator::with_capacity(self.len());
+        for (key, val) in self {
+            new_out
+                .set(key, other.clone() * val)
+                .expect("Internal bug in set");
+        }
+        new_out
+    }
+}
 
-    /// Returns the PlusMinusOperator in Iterator form.
+/// Implement `*` for QubitHamiltonian and QubitHamiltonian.
+///
+impl ops::Mul<QubitHamiltonian> for QubitHamiltonian {
+    type Output = QubitOperator;
+    /// Implement `*` for QubitHamiltonian and QubitHamiltonian.
+    ///
+    /// # Arguments
+    ///
+    /// * `other` - The QubitHamiltonian to multiply by.
     ///
     /// # Returns
     ///
-    /// * `Self::IntoIter` - The PlusMinusOperator in Iterator form.
+    /// * `QubitOperator` - The two QubitHamiltonians multiplied.
+    ///
+    /// # Panics
+    ///
+    /// * Internal bug in add_operator_product.
+    fn mul(self, other: QubitHamiltonian) -> Self::Output {
+        let mut qubit_op = QubitOperator::with_capacity(self.len() * other.len());
+        for (pps, vals) in self {
+            for (ppo, valo) in other.iter() {
+                let (ppp, coefficient) = pps.clone() * ppo.clone();
+                let coefficient =
+                    Into::<CalculatorComplex>::into(valo) * vals.clone() * coefficient;
+                qubit_op
+                    .add_operator_product(ppp, coefficient)
+                    .expect("Internal bug in add_operator_product");
+            }
+        }
+        qubit_op
+    }
+}
+
+/// Implements the into_iter function (IntoIterator trait) of QubitHamiltonian.
+///
+impl IntoIterator for QubitHamiltonian {
+    type Item = (PauliProduct, CalculatorFloat);
+    type IntoIter = indexmap::map::IntoIter<PauliProduct, CalculatorFloat>;
+
+    /// Returns the QubitHamiltonian in Iterator form.
+    ///
+    /// # Returns
+    ///
+    /// * `Self::IntoIter` - The QubitHamiltonian in Iterator form.
     fn into_iter(self) -> Self::IntoIter {
         self.internal_map.into_iter()
     }
 }
 
-/// Implements the into_iter function (IntoIterator trait) of reference PlusMinusOperator.
+/// Implements the into_iter function (IntoIterator trait) of reference QubitHamiltonian.
 ///
-impl<'a> IntoIterator for &'a PlusMinusOperator {
-    type Item = (&'a PlusMinusProduct, &'a CalculatorComplex);
-    type IntoIter = Iter<'a, PlusMinusProduct, CalculatorComplex>;
+impl<'a> IntoIterator for &'a QubitHamiltonian {
+    type Item = (&'a PauliProduct, &'a CalculatorFloat);
+    type IntoIter = Iter<'a, PauliProduct, CalculatorFloat>;
 
-    /// Returns the reference PlusMinusOperator in Iterator form.
+    /// Returns the reference QubitHamiltonian in Iterator form.
     ///
     /// # Returns
     ///
-    /// * `Self::IntoIter` - The reference PlusMinusOperator in Iterator form.
+    /// * `Self::IntoIter` - The reference QubitHamiltonian in Iterator form.
     fn into_iter(self) -> Self::IntoIter {
         self.internal_map.iter()
     }
 }
 
-/// Implements the from_iter function (FromIterator trait) of PlusMinusOperator.
+/// Implements the from_iter function (FromIterator trait) of QubitHamiltonian.
 ///
-impl FromIterator<(PlusMinusProduct, CalculatorComplex)> for PlusMinusOperator {
-    /// Returns the object in PlusMinusOperator form, from an Iterator form of the object.
+impl FromIterator<(PauliProduct, CalculatorFloat)> for QubitHamiltonian {
+    /// Returns the object in QubitHamiltonian form, from an Iterator form of the object.
     ///
     /// # Arguments
     ///
-    /// * `iter` - The iterator containing the information from which to create the PlusMinusOperator.
+    /// * `iter` - The iterator containing the information from which to create the QubitHamiltonian.
     ///
     /// # Returns
     ///
-    /// * `Self::IntoIter` - The iterator in PlusMinusOperator form.
+    /// * `Self::IntoIter` - The iterator in QubitHamiltonian form.
     ///
     /// # Panics
     ///
-    /// * Internal error in add_operator_product.
-    fn from_iter<I: IntoIterator<Item = (PlusMinusProduct, CalculatorComplex)>>(iter: I) -> Self {
-        let mut so = PlusMinusOperator::new();
+    /// * Internal bug in add_operator_product.
+    fn from_iter<I: IntoIterator<Item = (PauliProduct, CalculatorFloat)>>(iter: I) -> Self {
+        let mut so = QubitHamiltonian::new();
         for (pp, cc) in iter {
             so.add_operator_product(pp, cc)
                 .expect("Internal bug in add_operator_product");
         }
         so
     }
 }
 
-/// Implements the extend function (Extend trait) of PlusMinusOperator.
+/// Implements the extend function (Extend trait) of QubitHamiltonian.
 ///
-impl Extend<(PlusMinusProduct, CalculatorComplex)> for PlusMinusOperator {
-    /// Extends the PlusMinusOperator by the specified operations (in Iterator form).
+impl Extend<(PauliProduct, CalculatorFloat)> for QubitHamiltonian {
+    /// Extends the QubitHamiltonian by the specified operations (in Iterator form).
     ///
     /// # Arguments
     ///
-    /// * `iter` - The iterator containing the operations by which to extend the PlusMinusOperator.
+    /// * `iter` - The iterator containing the operations by which to extend the QubitHamiltonian.
     ///
     /// # Panics
     ///
-    /// * Internal error in add_operator_product.
-    fn extend<I: IntoIterator<Item = (PlusMinusProduct, CalculatorComplex)>>(&mut self, iter: I) {
+    /// * Internal bug in add_operator_product.
+    fn extend<I: IntoIterator<Item = (PauliProduct, CalculatorFloat)>>(&mut self, iter: I) {
         for (pp, cc) in iter {
             self.add_operator_product(pp, cc)
                 .expect("Internal bug in add_operator_product");
         }
     }
 }
 
-/// Implements the format function (Display trait) of PlusMinusOperator.
+/// Implements the format function (Display trait) of QubitHamiltonian.
 ///
-impl fmt::Display for PlusMinusOperator {
-    /// Formats the PlusMinusOperator using the given formatter.
+impl fmt::Display for QubitHamiltonian {
+    /// Formats the QubitHamiltonian using the given formatter.
     ///
     /// # Arguments
     ///
     /// * `f` - The formatter to use.
     ///
     /// # Returns
     ///
-    /// * `std::fmt::Result` - The formatted PlusMinusOperator.
+    /// * `std::fmt::Result` - The formatted QubitHamiltonian.
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        let mut output = "PlusMinusOperator{\n".to_string();
+        let mut output = "QubitHamiltonian{\n".to_string();
         for (key, val) in self.iter() {
             writeln!(output, "{}: {},", key, val)?;
         }
         output.push('}');
 
         write!(f, "{}", output)
     }
 }
 
-impl JordanWignerSpinToFermion for PlusMinusOperator {
-    type Output = FermionOperator;
+impl JordanWignerSpinToFermion for QubitHamiltonian {
+    type Output = FermionHamiltonian;
 
-    /// Implements JordanWignerSpinToFermion for a PlusMinusOperator.
+    /// Implements JordanWignerSpinToFermion for a QubitHamiltonian.
     ///
     /// The convention used is that |0> represents an empty fermionic state (spin-orbital),
     /// and |1> represents an occupied fermionic state.
     ///
     /// # Returns
     ///
-    /// `FermionOperator` - The fermion operator that results from the transformation.
+    /// `FermionHamiltonian` - The fermionic Hamiltonian that results from the transformation.
+    ///
+    /// # Panics
+    ///
+    /// * Failed conversion of FermionOperator into FermionHamiltonian. Internal bug in jordan_wigner().
     fn jordan_wigner(&self) -> Self::Output {
         let mut out = FermionOperator::new();
-        for pmp in self.keys() {
-            out = out + pmp.jordan_wigner() * self.get(pmp);
-        }
-        out
+        for pp in self.keys() {
+            let mut new_term = pp.jordan_wigner();
+            new_term = new_term * self.get(pp);
+            out = out + new_term;
+        }
+        let filtered_fermion_operator = FermionOperator::from_iter(out.into_iter().filter(|x| {
+            x.0.is_natural_hermitian() || x.0.creators().min() < x.0.annihilators().min()
+        }));
+        FermionHamiltonian::try_from(filtered_fermion_operator)
+            .expect("Failed to convert FermionOperator into FermionHamiltonian.")
     }
 }
 
 #[cfg(test)]
 mod test {
     use super::*;
     use serde_test::{assert_tokens, Configure, Token};
 
-    // Test the Clone and PartialEq traits of PlusMinusOperator
+    // Test the Clone and PartialEq traits of QubitHamiltonian
     #[test]
-    fn so_from_sos() {
-        let pp: PlusMinusProduct = PlusMinusProduct::new().z(0);
-        let sos = PlusMinusOperatorSerialize {
-            items: vec![(pp.clone(), 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 1,
+    fn sh_from_shs() {
+        let pp: PauliProduct = PauliProduct::new().z(0);
+        let shs = QubitHamiltonianSerialize {
+            items: vec![(pp.clone(), 0.5.into())],
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "QubitHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0-alpha.0".to_string(),
             },
         };
-        let mut so = PlusMinusOperator::new();
-        so.set(pp, CalculatorComplex::from(0.5)).unwrap();
+        let mut sh = QubitHamiltonian::new();
+        sh.set(pp, CalculatorFloat::from(0.5)).unwrap();
 
-        assert_eq!(PlusMinusOperator::from(sos.clone()), so);
-        assert_eq!(PlusMinusOperatorSerialize::from(so), sos);
+        assert_eq!(QubitHamiltonianSerialize::from(sh), shs);
     }
-    // Test the Clone and PartialEq traits of PlusMinusOperator
+    // Test the Clone and PartialEq traits of QubitHamiltonian
     #[test]
     fn clone_partial_eq() {
-        let pp: PlusMinusProduct = PlusMinusProduct::new().z(0);
-        let sos = PlusMinusOperatorSerialize {
-            items: vec![(pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 1,
+        let pp: PauliProduct = PauliProduct::new().z(0);
+        let shs = QubitHamiltonianSerialize {
+            items: vec![(pp, 0.5.into())],
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "QubitHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         // Test Clone trait
-        assert_eq!(sos.clone(), sos);
+        assert_eq!(shs.clone(), shs);
 
         // Test PartialEq trait
-        let pp_1: PlusMinusProduct = PlusMinusProduct::new().z(0);
-        let sos_1 = PlusMinusOperatorSerialize {
-            items: vec![(pp_1, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 1,
+        let pp_1: PauliProduct = PauliProduct::new().z(0);
+        let shs_1 = QubitHamiltonianSerialize {
+            items: vec![(pp_1, 0.5.into())],
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "QubitHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
-        let pp_2: PlusMinusProduct = PlusMinusProduct::new().z(2);
-        let sos_2 = PlusMinusOperatorSerialize {
-            items: vec![(pp_2, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 1,
+        let pp_2: PauliProduct = PauliProduct::new().z(2);
+        let shs_2 = QubitHamiltonianSerialize {
+            items: vec![(pp_2, 0.5.into())],
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "QubitHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
-        assert!(sos_1 == sos);
-        assert!(sos == sos_1);
-        assert!(sos_2 != sos);
-        assert!(sos != sos_2);
+        assert!(shs_1 == shs);
+        assert!(shs == shs_1);
+        assert!(shs_2 != shs);
+        assert!(shs != shs_2);
     }
 
-    // Test the Debug trait of PlusMinusOperator
+    // Test the Debug trait of QubitHamiltonian
     #[test]
     fn debug() {
-        let pp: PlusMinusProduct = PlusMinusProduct::new().z(0);
-        let sos = PlusMinusOperatorSerialize {
-            items: vec![(pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 1,
+        let pp: PauliProduct = PauliProduct::new().z(0);
+        let shs = QubitHamiltonianSerialize {
+            items: vec![(pp, 0.5.into())],
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "QubitHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_eq!(
-            format!("{:?}", sos),
-            "PlusMinusOperatorSerialize { items: [(PlusMinusProduct { items: [(0, Z)] }, Float(0.5), Float(0.0))], _struqture_version: StruqtureVersionSerializable { major_version: 1, minor_version: 1 } }"
+            format!("{:?}", shs),
+            "QubitHamiltonianSerialize { items: [(PauliProduct { items: [(0, Z)] }, Float(0.5))], serialisation_meta: StruqtureSerialisationMeta { type_name: \"QubitHamiltonian\", min_version: (2, 0, 0), version: \"2.0.0\" } }"
         );
     }
 
-    /// Test PlusMinusOperator Serialization and Deserialization traits (readable)
+    /// Test QubitHamiltonian Serialization and Deserialization traits (readable)
     #[test]
     fn serde_readable() {
-        let pp = PlusMinusProduct::new().plus(0);
-        let sos = PlusMinusOperatorSerialize {
-            items: vec![(pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 1,
+        let pp = PauliProduct::new().x(0);
+        let shs = QubitHamiltonianSerialize {
+            items: vec![(pp, 0.5.into())],
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "QubitHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_tokens(
-            &sos.readable(),
+            &shs.readable(),
             &[
                 Token::Struct {
-                    name: "PlusMinusOperatorSerialize",
+                    name: "QubitHamiltonianSerialize",
                     len: 2,
                 },
                 Token::Str("items"),
                 Token::Seq { len: Some(1) },
-                Token::Tuple { len: 3 },
-                Token::Str("0+"),
+                Token::Tuple { len: 2 },
+                Token::Str("0X"),
                 Token::F64(0.5),
-                Token::F64(0.0),
                 Token::TupleEnd,
                 Token::SeqEnd,
-                Token::Str("_struqture_version"),
+                Token::Str("serialisation_meta"),
                 Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
                 },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(1),
+                Token::Str("type_name"),
+                Token::Str("QubitHamiltonian"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
                 Token::StructEnd,
                 Token::StructEnd,
             ],
         );
     }
 
-    /// Test PlusMinusOperator Serialization and Deserialization traits (compact)
+    /// Test QubitHamiltonian Serialization and Deserialization traits (compact)
     #[test]
     fn serde_compact() {
-        let pp = PlusMinusProduct::new().plus(0);
-        let sos = PlusMinusOperatorSerialize {
-            items: vec![(pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 1,
+        let pp = PauliProduct::new().x(0);
+        let shs = QubitHamiltonianSerialize {
+            items: vec![(pp, 0.5.into())],
+            serialisation_meta: crate::StruqtureSerialisationMeta {
+                type_name: "QubitHamiltonian".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_tokens(
-            &sos.compact(),
+            &shs.compact(),
             &[
                 Token::Struct {
-                    name: "PlusMinusOperatorSerialize",
+                    name: "QubitHamiltonianSerialize",
                     len: 2,
                 },
                 Token::Str("items"),
                 Token::Seq { len: Some(1) },
-                Token::Tuple { len: 3 },
+                Token::Tuple { len: 2 },
                 Token::Seq { len: Some(1) },
                 Token::Tuple { len: 2 },
                 Token::U64(0),
                 Token::UnitVariant {
-                    name: "SinglePlusMinusOperator",
-                    variant: "Plus",
+                    name: "SingleQubitOperator",
+                    variant: "X",
                 },
                 Token::TupleEnd,
                 Token::SeqEnd,
                 Token::NewtypeVariant {
                     name: "CalculatorFloat",
                     variant: "Float",
                 },
                 Token::F64(0.5),
-                Token::NewtypeVariant {
-                    name: "CalculatorFloat",
-                    variant: "Float",
-                },
-                Token::F64(0.0),
                 Token::TupleEnd,
                 Token::SeqEnd,
-                Token::Str("_struqture_version"),
+                Token::Str("serialisation_meta"),
                 Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
                 },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(1),
+                Token::Str("type_name"),
+                Token::Str("QubitHamiltonian"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
                 Token::StructEnd,
                 Token::StructEnd,
             ],
         );
     }
 }
```

### Comparing `struqture_py-1.6.1/struqture/src/spins/plus_minus_product.rs` & `struqture_py-2.0.0a0/struqture/src/spins/plus_minus_product.rs`

 * *Files 3% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 use std::collections::HashMap;
 use std::fmt;
 use std::hash::Hash;
 use std::iter::{FromIterator, IntoIterator};
 use std::str::FromStr;
 use tinyvec::{TinyVec, TinyVecIterator};
 
-use super::{DecoherenceProduct, PauliProduct, SingleDecoherenceOperator, SingleSpinOperator};
+use super::{DecoherenceProduct, PauliProduct, SingleDecoherenceOperator, SingleQubitOperator};
 
 const INTERNAL_BUG_ADD_OPERATOR_PRODUCT: &str =
     "Internal bug in add_operator_product for FermionOperator.";
 const INTERNAL_BUG_NEW_FERMION_PRODUCT: &str = "Internal bug in FermionProduct::new";
 
 /// Single Spin operators for PlusMinusProducts:
 ///
@@ -171,66 +171,66 @@
             (SinglePlusMinusOperator::Z, SinglePlusMinusOperator::Z) => {
                 vec![(SinglePlusMinusOperator::Identity, Complex64::new(1.0, 0.0))]
             }
         }
     }
 }
 
-impl From<SinglePlusMinusOperator> for Vec<(SingleSpinOperator, Complex64)> {
-    /// Converts a SinglePlusMinusOperator into a vector of tuples of (SingleSpinOperator, Complex64).
+impl From<SinglePlusMinusOperator> for Vec<(SingleQubitOperator, Complex64)> {
+    /// Converts a SinglePlusMinusOperator into a vector of tuples of (SingleQubitOperator, Complex64).
     ///
     /// # Arguments
     ///
     /// * `val` - The SinglePlusMinusOperator to convert.
     ///
     /// # Returns
     ///
-    /// * `Self` - The SinglePlusMinusOperator converted into a vector of tuples of (SingleSpinOperator, Complex64).
+    /// * `Self` - The SinglePlusMinusOperator converted into a vector of tuples of (SingleQubitOperator, Complex64).
     fn from(val: SinglePlusMinusOperator) -> Self {
         match val {
             SinglePlusMinusOperator::Identity => {
-                vec![(SingleSpinOperator::Identity, Complex64::new(1.0, 0.0))]
+                vec![(SingleQubitOperator::Identity, Complex64::new(1.0, 0.0))]
             }
             SinglePlusMinusOperator::Plus => vec![
-                (SingleSpinOperator::X, Complex64::new(0.5, 0.0)),
-                (SingleSpinOperator::Y, Complex64::new(0.0, 0.5)),
+                (SingleQubitOperator::X, Complex64::new(0.5, 0.0)),
+                (SingleQubitOperator::Y, Complex64::new(0.0, 0.5)),
             ],
             SinglePlusMinusOperator::Minus => vec![
-                (SingleSpinOperator::X, Complex64::new(0.5, 0.0)),
-                (SingleSpinOperator::Y, Complex64::new(0.0, -0.5)),
+                (SingleQubitOperator::X, Complex64::new(0.5, 0.0)),
+                (SingleQubitOperator::Y, Complex64::new(0.0, -0.5)),
             ],
-            SinglePlusMinusOperator::Z => vec![(SingleSpinOperator::Z, Complex64::new(1.0, 0.0))],
+            SinglePlusMinusOperator::Z => vec![(SingleQubitOperator::Z, Complex64::new(1.0, 0.0))],
         }
     }
 }
 
-impl From<SingleSpinOperator> for Vec<(SinglePlusMinusOperator, Complex64)> {
-    /// Converts a SingleSpinOperator into a vector of tuples of (SinglePlusMinusOperator, Complex64).
+impl From<SingleQubitOperator> for Vec<(SinglePlusMinusOperator, Complex64)> {
+    /// Converts a SingleQubitOperator into a vector of tuples of (SinglePlusMinusOperator, Complex64).
     ///
     /// # Arguments
     ///
-    /// * `val` - The SingleSpinOperator to convert.
+    /// * `val` - The SingleQubitOperator to convert.
     ///
     /// # Returns
     ///
-    /// * `Self` - The SingleSpinOperator converted into a vector of tuples of (SinglePlusMinusOperator, Complex64).
-    fn from(val: SingleSpinOperator) -> Self {
+    /// * `Self` - The SingleQubitOperator converted into a vector of tuples of (SinglePlusMinusOperator, Complex64).
+    fn from(val: SingleQubitOperator) -> Self {
         match val {
-            SingleSpinOperator::Identity => {
+            SingleQubitOperator::Identity => {
                 vec![(SinglePlusMinusOperator::Identity, Complex64::new(1.0, 0.0))]
             }
-            SingleSpinOperator::X => vec![
+            SingleQubitOperator::X => vec![
                 (SinglePlusMinusOperator::Plus, Complex64::new(1.0, 0.0)),
                 (SinglePlusMinusOperator::Minus, Complex64::new(1.0, 0.0)),
             ],
-            SingleSpinOperator::Y => vec![
+            SingleQubitOperator::Y => vec![
                 (SinglePlusMinusOperator::Plus, Complex64::new(0.0, -1.0)),
                 (SinglePlusMinusOperator::Minus, Complex64::new(0.0, 1.0)),
             ],
-            SingleSpinOperator::Z => vec![(SinglePlusMinusOperator::Z, Complex64::new(1.0, 0.0))],
+            SingleQubitOperator::Z => vec![(SinglePlusMinusOperator::Z, Complex64::new(1.0, 0.0))],
         }
     }
 }
 
 impl From<SinglePlusMinusOperator> for Vec<(SingleDecoherenceOperator, Complex64)> {
     /// Converts a SinglePlusMinusOperator into a vector of tuples of (SingleDecoherenceOperator, Complex64).
     ///
@@ -358,15 +358,15 @@
     /// # Returns
     ///
     /// * `Self` - The PlusMinusProduct converted into a vector of tuples of (PauliProduct, Complex64).
     fn from(value: PlusMinusProduct) -> Self {
         let mut new_vec: Vec<(PauliProduct, Complex64)> =
             vec![(PauliProduct::new(), Complex64::new(1.0, 0.0))];
         for (index, single) in value.iter() {
-            let temp_vec: Vec<(SingleSpinOperator, Complex64)> = (*single).into();
+            let temp_vec: Vec<(SingleQubitOperator, Complex64)> = (*single).into();
             let mut temp_new_vec: Vec<(PauliProduct, Complex64)> = Vec::new();
             for (new_op, new_prefactor) in temp_vec {
                 for (product, prefactor) in new_vec.iter() {
                     let product = product.clone().set_pauli(*index, new_op);
                     temp_new_vec.push((product, new_prefactor * prefactor))
                 }
             }
@@ -447,17 +447,17 @@
         let meta = obj.metadata();
         meta.description = Some("Represents products of Plus Minus Spin Operators (Plus, Minus, Z) by a string of spin numbers followed by pauli operators. E.g. 0+10-13Z14+.".to_string());
 
         schemars::schema::Schema::Object(obj)
     }
 }
 
-impl crate::MinSupportedVersion for PlusMinusProduct {
-    fn min_supported_version() -> (usize, usize, usize) {
-        (1, 1, 0)
+impl crate::SerializationSupport for PlusMinusProduct {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::PlusMinusProduct
     }
 }
 
 /// Implementing serde serialization writing directly to string.
 ///
 impl Serialize for PlusMinusProduct {
     /// Serialization function for PlusMinusProduct according to string type.
@@ -827,14 +827,34 @@
     ///
     /// * `Self` - The new (empty) PlusMinusProduct.
     pub fn with_capacity(cap: usize) -> Self {
         PlusMinusProduct {
             items: TinyVec::<[(usize, SinglePlusMinusOperator); 5]>::with_capacity(cap),
         }
     }
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(&self) -> Result<struqture_one::spins::PlusMinusProduct, StruqtureError> {
+        let self_string = self.to_string();
+        let struqture_one_product = struqture_one::spins::PlusMinusProduct::from_str(&self_string)
+            .map_err(|err| StruqtureError::GenericError {
+                msg: format!("{}", err),
+            })?;
+        Ok(struqture_one_product)
+    }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::spins::PlusMinusProduct,
+    ) -> Result<Self, StruqtureError> {
+        let value_string = value.to_string();
+        let pauli_product = Self::from_str(&value_string)?;
+        Ok(pauli_product)
+    }
 }
 
 impl SymmetricIndex for PlusMinusProduct {
     // From trait
     fn hermitian_conjugate(&self) -> (Self, f64) {
         let mut new_plus_minus = PlusMinusProduct::with_capacity(self.items.len());
         for (index, single) in self.iter() {
```

### Comparing `struqture_py-1.6.1/struqture/src/spins/spin_hamiltonian.rs` & `struqture_py-2.0.0a0/struqture/src/spins/qubit_operator.rs`

 * *Files 19% similar despite different names*

```diff
@@ -6,824 +6,856 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
-use super::{OperateOnSpins, SpinOperator, ToSparseMatrixOperator, ToSparseMatrixSuperOperator};
-use crate::fermions::{FermionHamiltonian, FermionOperator};
+use super::{ToSparseMatrixOperator, ToSparseMatrixSuperOperator};
+use crate::fermions::FermionOperator;
 use crate::mappings::JordanWignerSpinToFermion;
-use crate::prelude::*;
-use crate::spins::{HermitianOperateOnSpins, PauliProduct, SpinIndex};
+use crate::spins::{OperateOnSpins, PauliProduct, QubitHamiltonian, SpinIndex};
 use crate::{
     CooSparseMatrix, GetValue, OperateOnDensityMatrix, OperateOnState, StruqtureError,
-    StruqtureVersionSerializable, MINIMUM_STRUQTURE_VERSION,
+    SymmetricIndex,
 };
-#[cfg(feature = "indexed_map_iterators")]
-use indexmap::map::{Entry, Iter, Keys, Values};
-#[cfg(feature = "indexed_map_iterators")]
+use indexmap::map::{Entry, Iter};
 use indexmap::IndexMap;
 use num_complex::Complex64;
 use qoqo_calculator::{CalculatorComplex, CalculatorFloat};
 use serde::{Deserialize, Serialize};
-#[cfg(not(feature = "indexed_map_iterators"))]
-use std::collections::hash_map::{Entry, Iter, Keys, Values};
-#[cfg(not(feature = "indexed_map_iterators"))]
-use std::collections::HashMap;
 use std::fmt::{self, Write};
 use std::iter::{FromIterator, IntoIterator};
 use std::ops;
 
-/// SpinHamiltonians are combinations of PauliProducts with specific CalculatorFloat coefficients.
+/// QubitOperators are combinations of PauliProducts with specific CalculatorComplex coefficients.
 ///
 /// This is a representation of sums of pauli products with weightings, in order to build a full hamiltonian.
-/// SpinHamiltonian is the hermitian equivalent of SpinOperator.
 ///
 /// # Example
 ///
 /// ```
 /// use struqture::prelude::*;
-/// use qoqo_calculator::CalculatorFloat;
-/// use struqture::spins::{HermitianOperateOnSpins, PauliProduct, SpinHamiltonian};
+/// use qoqo_calculator::CalculatorComplex;
+/// use struqture::spins::{OperateOnSpins, PauliProduct, QubitOperator};
 ///
-/// let mut sh = SpinHamiltonian::new();
+/// let mut so = QubitOperator::new();
 ///
 /// // Representing the hamiltonian $ 1/2 \sigma_0^{x} \sigma_1^{x} + 1/5 \sigma_0^{z} $
 /// let pp_0x1x = PauliProduct::new().x(0).x(1);
 /// let pp_0z = PauliProduct::new().z(0);
-/// sh.add_operator_product(pp_0x1x.clone(), CalculatorFloat::from(0.5)).unwrap();
-/// sh.add_operator_product(pp_0z.clone(), CalculatorFloat::from(0.2)).unwrap();
+/// so.add_operator_product(pp_0x1x.clone(), CalculatorComplex::from(0.5)).unwrap();
+/// so.add_operator_product(pp_0z.clone(), CalculatorComplex::from(0.2)).unwrap();
 ///
 /// // Access what you set:
-/// assert_eq!(sh.get(&pp_0x1x), &CalculatorFloat::from(0.5));
-/// assert_eq!(sh.get(&pp_0z), &CalculatorFloat::from(0.2));
+/// assert_eq!(so.get(&pp_0x1x), &CalculatorComplex::from(0.5));
+/// assert_eq!(so.get(&pp_0z), &CalculatorComplex::from(0.2));
 /// ```
 ///
 #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
-#[serde(from = "SpinHamiltonianSerialize")]
-#[serde(into = "SpinHamiltonianSerialize")]
-pub struct SpinHamiltonian {
-    // The internal HashMap of PauliProducts and coefficients (CalculatorFloat)
-    #[cfg(feature = "indexed_map_iterators")]
-    internal_map: IndexMap<PauliProduct, CalculatorFloat>,
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    internal_map: HashMap<PauliProduct, CalculatorFloat>,
+#[serde(try_from = "QubitOperatorSerialize")]
+#[serde(into = "QubitOperatorSerialize")]
+pub struct QubitOperator {
+    // The internal HashMap of PauliProducts and coefficients (CalculatorComplex)
+    internal_map: IndexMap<PauliProduct, CalculatorComplex>,
 }
 
-impl crate::MinSupportedVersion for SpinHamiltonian {}
-
+impl crate::SerializationSupport for QubitOperator {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::QubitOperator
+    }
+}
 #[cfg(feature = "json_schema")]
-impl schemars::JsonSchema for SpinHamiltonian {
+impl schemars::JsonSchema for QubitOperator {
     fn schema_name() -> String {
-        "struqture::spins::SpinHamiltonian".to_string()
+        "QubitOperator".to_string()
     }
 
     fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
-        <SpinHamiltonianSerialize>::json_schema(gen)
+        <QubitOperatorSerialize>::json_schema(gen)
     }
 }
 
 #[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
 #[cfg_attr(feature = "json_schema", derive(schemars::JsonSchema))]
-/// # SpinHamiltonian
-/// SpinHamiltonians are combinations of PauliProducts with specific CalculatorFloat coefficients.
+#[cfg_attr(feature = "json_schema", schemars(deny_unknown_fields))]
+///# QubitOperator
 ///
 /// This is a representation of sums of pauli products with weightings, in order to build a full hamiltonian.
-/// SpinHamiltonian is the hermitian equivalent of SpinOperator.
-struct SpinHamiltonianSerialize {
-    /// List of all non-zero entries in the SpinHamiltonian in the form (PauliProduct, real weight).
-    items: Vec<(PauliProduct, CalculatorFloat)>,
-    _struqture_version: StruqtureVersionSerializable,
-}
-
-impl From<SpinHamiltonianSerialize> for SpinHamiltonian {
-    fn from(value: SpinHamiltonianSerialize) -> Self {
-        let new_noise_op: SpinHamiltonian = value.items.into_iter().collect();
-        new_noise_op
+struct QubitOperatorSerialize {
+    /// List of all non-zero entries in the QubitOperator in the form (PauliProduct, real part of weight, imaginary part of weight).
+    items: Vec<(PauliProduct, CalculatorFloat, CalculatorFloat)>,
+    /// Minimum struqture version required to de-serialize object
+    serialisation_meta: crate::StruqtureSerialisationMeta,
+}
+
+impl TryFrom<QubitOperatorSerialize> for QubitOperator {
+    type Error = StruqtureError;
+    fn try_from(value: QubitOperatorSerialize) -> Result<Self, Self::Error> {
+        let target_serialisation_meta =
+            <Self as crate::SerializationSupport>::target_serialisation_meta();
+        crate::check_can_be_deserialised(&target_serialisation_meta, &value.serialisation_meta)?;
+        let new_noise_op: QubitOperator = value
+            .items
+            .into_iter()
+            .map(|(key, real, imag)| (key, CalculatorComplex { re: real, im: imag }))
+            .collect();
+        Ok(new_noise_op)
     }
 }
 
-impl From<SpinHamiltonian> for SpinHamiltonianSerialize {
-    fn from(value: SpinHamiltonian) -> Self {
-        let new_noise_op: Vec<(PauliProduct, CalculatorFloat)> = value.into_iter().collect();
-        let current_version = StruqtureVersionSerializable {
-            major_version: MINIMUM_STRUQTURE_VERSION.0,
-            minor_version: MINIMUM_STRUQTURE_VERSION.1,
-        };
+impl From<QubitOperator> for QubitOperatorSerialize {
+    fn from(value: QubitOperator) -> Self {
+        let serialisation_meta = crate::SerializationSupport::struqture_serialisation_meta(&value);
+        let new_noise_op: Vec<(PauliProduct, CalculatorFloat, CalculatorFloat)> = value
+            .into_iter()
+            .map(|(key, val)| (key, val.re, val.im))
+            .collect();
         Self {
             items: new_noise_op,
-            _struqture_version: current_version,
+            serialisation_meta,
         }
     }
 }
 
-impl<'a> OperateOnDensityMatrix<'a> for SpinHamiltonian {
+impl<'a> OperateOnDensityMatrix<'a> for QubitOperator {
+    type Value = CalculatorComplex;
     type Index = PauliProduct;
-    type Value = CalculatorFloat;
-    type IteratorType = Iter<'a, Self::Index, Self::Value>;
-    type KeyIteratorType = Keys<'a, Self::Index, Self::Value>;
-    type ValueIteratorType = Values<'a, Self::Index, Self::Value>;
 
     // From trait
     fn get(&self, key: &Self::Index) -> &Self::Value {
         match self.internal_map.get(key) {
             Some(value) => value,
-            None => &CalculatorFloat::ZERO,
+            None => &CalculatorComplex::ZERO,
         }
     }
 
     // From trait
-    fn iter(&'a self) -> Self::IteratorType {
+    fn iter(&'a self) -> impl ExactSizeIterator<Item = (&'a Self::Index, &'a Self::Value)> {
         self.internal_map.iter()
     }
 
     // From trait
-    fn keys(&'a self) -> Self::KeyIteratorType {
+    fn keys(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Index> {
         self.internal_map.keys()
     }
 
     // From trait
-    fn values(&'a self) -> Self::ValueIteratorType {
+    fn values(&'a self) -> impl ExactSizeIterator<Item = &'a Self::Value> {
         self.internal_map.values()
     }
 
-    #[cfg(feature = "indexed_map_iterators")]
     // From trait
     fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
         self.internal_map.shift_remove(key)
     }
 
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    // From trait
-    fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
-        self.internal_map.remove(key)
-    }
-
     // From trait
     fn empty_clone(&self, capacity: Option<usize>) -> Self {
         match capacity {
             Some(cap) => Self::with_capacity(cap),
             None => Self::new(),
         }
     }
 
-    /// Overwrites an existing entry or sets a new entry in the SpinHamiltonian with the given (PauliProduct key, CalculatorFloat value) pair.
+    /// Overwrites an existing entry or sets a new entry in the QubitOperator with the given (PauliProduct key, CalculatorComplex value) pair.
     ///
     /// # Arguments
     ///
-    /// * `key` - The PauliProduct key to set in the SpinHamiltonian.
-    /// * `value` - The corresponding CalculatorFloat value to set for the key in the SpinHamiltonian.
+    /// * `key` - The PauliProduct key to set in the QubitOperator.
+    /// * `value` - The corresponding CalculatorComplex value to set for the key in the QubitOperator.
     ///
     /// # Returns
     ///
-    /// * `Ok(Some(CalculatorFloat))` - The key existed, this is the value it had before it was set with the value input.
+    /// * `Ok(Some(CalculatorComplex))` - The key existed, this is the value it had before it was set with the value input.
     /// * `Ok(None)` - The key did not exist, it has been set with its corresponding value.
     fn set(
         &mut self,
         key: Self::Index,
         value: Self::Value,
     ) -> Result<Option<Self::Value>, StruqtureError> {
-        if value != CalculatorFloat::ZERO {
+        if value != CalculatorComplex::ZERO {
             Ok(self.internal_map.insert(key, value))
         } else {
             match self.internal_map.entry(key) {
-                #[cfg(feature = "indexed_map_iterators")]
                 Entry::Occupied(val) => Ok(Some(val.shift_remove())),
-                #[cfg(not(feature = "indexed_map_iterators"))]
-                Entry::Occupied(val) => Ok(Some(val.remove())),
                 Entry::Vacant(_) => Ok(None),
             }
         }
     }
 }
 
-impl<'a> OperateOnState<'a> for SpinHamiltonian {
+impl<'a> OperateOnState<'a> for QubitOperator {
     // From trait
     fn hermitian_conjugate(&self) -> Self {
-        self.clone()
+        let mut new_operator = Self::with_capacity(self.len());
+        for (pauli_product, value) in self.iter() {
+            let (new_boson_product, prefactor) = pauli_product.hermitian_conjugate();
+            new_operator
+                .add_operator_product(new_boson_product, value.conj() * prefactor)
+                .expect("Internal bug in add_operator_product");
+        }
+        new_operator
     }
 }
 
-impl<'a> OperateOnSpins<'a> for SpinHamiltonian {
-    /// Gets the maximum index of the SpinHamiltonian.
+impl<'a> OperateOnSpins<'a> for QubitOperator {
+    /// Gets the maximum index of the QubitOperator.
     ///
     /// # Returns
     ///
-    /// * `usize` - The number of spins in the SpinHamiltonian.
-    fn number_spins(&self) -> usize {
-        self.current_number_spins()
-    }
-
-    // From trait
+    /// * `usize` - The number of spins in the QubitOperator.
     fn current_number_spins(&self) -> usize {
         let mut max_mode: usize = 0;
         if !self.internal_map.is_empty() {
             for key in self.internal_map.keys() {
                 if key.current_number_spins() > max_mode {
                     max_mode = key.current_number_spins()
                 }
             }
         }
         max_mode
     }
 }
 
-impl<'a> HermitianOperateOnSpins<'a> for SpinHamiltonian {}
-
-impl<'a> ToSparseMatrixOperator<'a> for SpinHamiltonian {}
-impl<'a> ToSparseMatrixSuperOperator<'a> for SpinHamiltonian {
+impl<'a> ToSparseMatrixOperator<'a> for QubitOperator {}
+impl<'a> ToSparseMatrixSuperOperator<'a> for QubitOperator {
     // From trait
     fn sparse_matrix_superoperator_entries_on_row(
         &'a self,
         row: usize,
         number_spins: usize,
     ) -> Result<std::collections::HashMap<usize, Complex64>, StruqtureError> {
         <Self as ToSparseMatrixOperator>::sparse_matrix_superoperator_entries_on_row(
             self,
             row,
             number_spins,
         )
     }
 
     // From trait
-    fn unitary_sparse_matrix_coo(&'a self) -> Result<crate::CooSparseMatrix, StruqtureError> {
+    fn unitary_sparse_matrix_coo(&'a self) -> Result<CooSparseMatrix, StruqtureError> {
         self.sparse_matrix_coo(None)
     }
 
     // From trait
     fn sparse_lindblad_entries(
         &'a self,
     ) -> Result<Vec<(CooSparseMatrix, CooSparseMatrix, Complex64)>, StruqtureError> {
         let rate = Complex64::default();
         let left: CooSparseMatrix = (vec![], (vec![], vec![]));
         let right: CooSparseMatrix = (vec![], (vec![], vec![]));
         Ok(vec![(left, right, rate)])
     }
 }
 
-/// Implements the default function (Default trait) of SpinHamiltonian (an empty SpinHamiltonian).
+/// Implements the default function (Default trait) of QubitOperator (an empty QubitOperator).
 ///
-impl Default for SpinHamiltonian {
+impl Default for QubitOperator {
     fn default() -> Self {
         Self::new()
     }
 }
 
-/// Functions for the SpinHamiltonian
+/// Functions for the QubitOperator
 ///
-impl SpinHamiltonian {
-    /// Creates a new SpinHamiltonian.
+impl QubitOperator {
+    /// Creates a new QubitOperator.
     ///
     /// # Returns
     ///
-    /// * `Self` - The new (empty) SpinHamiltonian.
+    /// * `Self` - The new (empty) QubitOperator.
     pub fn new() -> Self {
-        SpinHamiltonian {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::new(),
-            #[cfg(feature = "indexed_map_iterators")]
+        QubitOperator {
             internal_map: IndexMap::new(),
         }
     }
 
-    /// Creates a new SpinHamiltonian with pre-allocated capacity.
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(&self) -> Result<struqture_one::spins::SpinSystem, StruqtureError> {
+        let mut new_qubit_system = struqture_one::spins::SpinSystem::new(None);
+        for (key, val) in self.iter() {
+            let one_key = key.to_struqture_1()?;
+            let _ = struqture_one::OperateOnDensityMatrix::set(
+                &mut new_qubit_system,
+                one_key,
+                val.clone(),
+            );
+        }
+        Ok(new_qubit_system)
+    }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::spins::SpinSystem,
+    ) -> Result<Self, StruqtureError> {
+        let mut new_qubit_operator = Self::new();
+        for (key, val) in struqture_one::OperateOnDensityMatrix::iter(value) {
+            let self_key = PauliProduct::from_struqture_1(key)?;
+            let _ = new_qubit_operator.set(self_key, val.clone());
+        }
+        Ok(new_qubit_operator)
+    }
+
+    /// Creates a new QubitOperator with pre-allocated capacity.
     ///
     /// # Arguments
     ///
     /// * `capacity` - The pre-allocated capacity of the system.
     ///
     /// # Returns
     ///
-    /// * `Self` - The new (empty) SpinHamiltonian.
+    /// * `Self` - The new (empty) QubitOperator.
     pub fn with_capacity(capacity: usize) -> Self {
-        Self {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::with_capacity(capacity),
-            #[cfg(feature = "indexed_map_iterators")]
+        QubitOperator {
             internal_map: IndexMap::with_capacity(capacity),
         }
     }
+}
 
-    /// Separate self into an operator with the terms of given number of spins and an operator with the remaining operations
+impl From<QubitHamiltonian> for QubitOperator {
+    /// Converts a QubitHamiltonian into a QubitOperator.
     ///
     /// # Arguments
     ///
-    /// * `number_spins` - Number of spins to filter for in the keys.
+    /// * `hamiltonian` - The QubitHamiltonian to convert.
     ///
     /// # Returns
     ///
-    /// `Ok((separated, remainder))` - Operator with the noise terms where number_spins matches the number of spins the operator product acts on and Operator with all other contributions.
-    pub fn separate_into_n_terms(
-        &self,
-        number_spins: usize,
-    ) -> Result<(Self, Self), StruqtureError> {
-        let mut separated = Self::default();
-        let mut remainder = Self::default();
-        for (prod, val) in self.iter() {
-            if prod.len() == number_spins {
-                separated.add_operator_product(prod.clone(), val.clone())?;
-            } else {
-                remainder.add_operator_product(prod.clone(), val.clone())?;
-            }
-        }
-        Ok((separated, remainder))
-    }
-}
-
-impl TryFrom<SpinOperator> for SpinHamiltonian {
-    type Error = StruqtureError;
-    /// Tries to convert a SpinOperator into a SpinHamiltonian.
-    ///
-    /// # Arguments
+    /// * `Self` - The QubitHamiltonian converted into a QubitOperator.
     ///
-    /// * `hamiltonian` - The SpinOperator to try to convert.
-    ///
-    /// # Returns
+    /// # Panics
     ///
-    /// * `Ok(Self)` - The SpinOperator converted into a SpinHamiltonian.
-    /// * `Err(StruqtureError::NonHermitianOperator)` - Key is naturally hermitian (on-diagonal term), but its corresponding value is not real.
-    fn try_from(hamiltonian: SpinOperator) -> Result<Self, StruqtureError> {
-        let mut internal = SpinHamiltonian::new();
+    /// * Internal error in add_operator_product.
+    fn from(hamiltonian: QubitHamiltonian) -> Self {
+        let mut internal = QubitOperator::new();
         for (key, value) in hamiltonian.into_iter() {
-            if value.im != CalculatorFloat::ZERO {
-                return Err(StruqtureError::NonHermitianOperator {});
-            } else {
-                let pp = PauliProduct::get_key(&key);
-                internal.add_operator_product(pp, value.re)?;
-            }
+            let bp = PauliProduct::get_key(&key);
+            internal
+                .add_operator_product(bp, CalculatorComplex::from(value))
+                .expect("Internal bug in add_operator_product");
         }
-        Ok(internal)
+        internal
     }
 }
 
-/// Implements the negative sign function of SpinOperator.
+/// Implements the negative sign function of QubitOperator.
 ///
-impl ops::Neg for SpinHamiltonian {
-    type Output = SpinHamiltonian;
-    /// Implement minus sign for SpinHamiltonian.
+impl ops::Neg for QubitOperator {
+    type Output = QubitOperator;
+    /// Implement minus sign for QubitOperator.
     ///
     /// # Returns
     ///
-    /// * `Self` - The SpinHamiltonian * -1.
+    /// * `Self` - The QubitOperator * -1.
     fn neg(self) -> Self {
-        let mut internal = self.internal_map.clone();
-        for key in self.keys() {
-            internal.insert(key.clone(), internal[key].clone() * -1.0);
+        let mut internal = IndexMap::with_capacity(self.len());
+        for (key, val) in self {
+            internal.insert(key.clone(), val.neg());
         }
-        SpinHamiltonian {
+        QubitOperator {
             internal_map: internal,
         }
     }
 }
 
-/// Implements the plus function of SpinHamiltonian by SpinHamiltonian.
+/// Implements the plus function of QubitOperator by QubitOperator.
 ///
-impl<T, V> ops::Add<T> for SpinHamiltonian
+impl<T, V> ops::Add<T> for QubitOperator
 where
     T: IntoIterator<Item = (PauliProduct, V)>,
-    V: Into<CalculatorFloat>,
+    V: Into<CalculatorComplex>,
 {
     type Output = Self;
-    /// Implements `+` (add) for two SpinHamiltonians.
+    /// Implements `+` (add) for two QubitOperators.
     ///
     /// # Arguments
     ///
-    /// * `other` - The SpinHamiltonian to be added.
+    /// * `other` - The QubitOperator to be added.
     ///
     /// # Returns
     ///
-    /// * `Self` - The two SpinHamiltonians added together.
+    /// * `Self` - The two QubitOperators added together.
     ///
     /// # Panics
     ///
-    /// * Internal bug in add_operator_product.
+    /// * Internal error in add_operator_product.
     fn add(mut self, other: T) -> Self {
         for (key, value) in other.into_iter() {
-            self.add_operator_product(key.clone(), Into::<CalculatorFloat>::into(value))
+            self.add_operator_product(key.clone(), Into::<CalculatorComplex>::into(value))
                 .expect("Internal bug in add_operator_product");
         }
         self
     }
 }
 
-/// Implements the minus function of SpinHamiltonian by SpinHamiltonian.
+/// Implements the minus function of QubitOperator by QubitOperator.
 ///
-impl<T, V> ops::Sub<T> for SpinHamiltonian
+impl<T, V> ops::Sub<T> for QubitOperator
 where
     T: IntoIterator<Item = (PauliProduct, V)>,
-    V: Into<CalculatorFloat>,
+    V: Into<CalculatorComplex>,
 {
     type Output = Self;
-    /// Implements `-` (subtract) for two SpinHamiltonians.
+    /// Implements `-` (subtract) for two QubitOperators.
     ///
     /// # Arguments
     ///
-    /// * `other` - The SpinHamiltonian to be subtracted.
+    /// * `other` - The QubitOperator to be subtracted.
     ///
     /// # Returns
     ///
-    /// * `Self` - The two SpinHamiltonians subtracted.
+    /// * `Self` - The two QubitOperators subtracted.
     ///
     /// # Panics
     ///
-    /// * Internal bug in add_operator_product.
+    /// * Internal error in add_operator_product.
     fn sub(mut self, other: T) -> Self {
         for (key, value) in other.into_iter() {
-            self.add_operator_product(key.clone(), Into::<CalculatorFloat>::into(value) * -1.0)
+            self.add_operator_product(key.clone(), Into::<CalculatorComplex>::into(value) * -1.0)
                 .expect("Internal bug in add_operator_product");
         }
         self
     }
 }
 
-/// Implements the multiplication function of SpinHamiltonian by CalculatorFloat.
+/// Implements the multiplication function of QubitOperator by CalculatorComplex/CalculatorFloat.
 ///
-impl ops::Mul<CalculatorFloat> for SpinHamiltonian {
+impl<T> ops::Mul<T> for QubitOperator
+where
+    T: Into<CalculatorComplex>,
+{
     type Output = Self;
-    /// Implement `*` for SpinHamiltonian and CalculatorFloat.
+    /// Implement `*` for QubitOperator and CalculatorComplex/CalculatorFloat.
     ///
     /// # Arguments
     ///
-    /// * `other` - The CalculatorFloat by which to multiply.
+    /// * `other` - The CalculatorComplex or CalculatorFloat by which to multiply.
     ///
     /// # Returns
     ///
-    /// * `Self` - The SpinHamiltonian multiplied by the CalculatorFloat.
-    fn mul(self, other: CalculatorFloat) -> Self {
+    /// * `Self` - The QubitOperator multiplied by the CalculatorComplex/CalculatorFloat.
+    fn mul(self, other: T) -> Self {
+        let other_cc = Into::<CalculatorComplex>::into(other);
         let mut internal = self.internal_map.clone();
-        for key in self.keys() {
-            internal.insert(key.clone(), internal[key].clone() * other.clone());
+        for (key, val) in self {
+            internal.insert(key, val * other_cc.clone());
         }
-        SpinHamiltonian {
+        QubitOperator {
             internal_map: internal,
         }
     }
 }
 
-/// Implements the multiplication function of SpinHamiltonian by CalculatorComplex.
+/// Implements the multiplication function of QubitOperator by QubitOperator.
 ///
-impl ops::Mul<CalculatorComplex> for SpinHamiltonian {
-    type Output = SpinOperator;
-    /// Implement `*` for SpinHamiltonian and CalculatorComplex.
+impl ops::Mul<QubitOperator> for QubitOperator {
+    type Output = Self;
+    /// Implement `*` for QubitOperator and QubitOperator.
     ///
     /// # Arguments
     ///
-    /// * `other` - The CalculatorComplex by which to multiply.
+    /// * `other` - The QubitOperator to multiply by.
     ///
     /// # Returns
     ///
-    /// * `SpinOperator` - The SpinHamiltonian multiplied by the CalculatorFloat.
+    /// * `Self` - The two QubitOperators multiplied.
     ///
     /// # Panics
     ///
-    /// * Internal bug in set.
-    fn mul(self, other: CalculatorComplex) -> Self::Output {
-        let mut new_out = SpinOperator::with_capacity(self.len());
-        for (key, val) in self {
-            new_out
-                .set(key, other.clone() * val)
-                .expect("Internal bug in set");
+    /// * Internal error in add_operator_product.
+    fn mul(self, other: QubitOperator) -> Self {
+        let mut qubit_op = QubitOperator::with_capacity(self.len() * other.len());
+        for (pps, vals) in self {
+            for (ppo, valo) in other.iter() {
+                let (ppp, coefficient) = pps.clone() * ppo.clone();
+                let coefficient =
+                    Into::<CalculatorComplex>::into(valo) * coefficient * vals.clone();
+                qubit_op
+                    .add_operator_product(ppp, coefficient)
+                    .expect("Internal bug in add_operator_product");
+            }
         }
-        new_out
+        qubit_op
     }
 }
 
-/// Implement `*` for SpinHamiltonian and SpinHamiltonian.
+/// Implements the multiplication function of QubitOperator by PauliProduct.
 ///
-impl ops::Mul<SpinHamiltonian> for SpinHamiltonian {
-    type Output = SpinOperator;
-    /// Implement `*` for SpinHamiltonian and SpinHamiltonian.
+impl ops::Mul<PauliProduct> for QubitOperator {
+    type Output = Self;
+    /// Implement `*` for QubitOperator and PauliProduct.
     ///
     /// # Arguments
     ///
-    /// * `other` - The SpinHamiltonian to multiply by.
+    /// * `other` - PauliProduct
     ///
     /// # Returns
     ///
-    /// * `SpinOperator` - The two SpinHamiltonians multiplied.
+    /// * `Self` - The QubitOperator multiplied by the PauliProduct.
     ///
     /// # Panics
     ///
-    /// * Internal bug in add_operator_product.
-    fn mul(self, other: SpinHamiltonian) -> Self::Output {
-        let mut spin_op = SpinOperator::with_capacity(self.len() * other.len());
+    /// * Internal error in add_operator_product.
+    fn mul(self, ppo: PauliProduct) -> Self {
+        let mut qubit_op = QubitOperator::with_capacity(self.len());
         for (pps, vals) in self {
-            for (ppo, valo) in other.iter() {
-                let (ppp, coefficient) = pps.clone() * ppo.clone();
-                let coefficient =
-                    Into::<CalculatorComplex>::into(valo) * vals.clone() * coefficient;
-                spin_op
-                    .add_operator_product(ppp, coefficient)
-                    .expect("Internal bug in add_operator_product");
-            }
+            let (ppp, coefficient) = pps.clone() * ppo.clone();
+            let coefficient = CalculatorComplex::from(coefficient) * vals.clone();
+            qubit_op
+                .add_operator_product(ppp, coefficient)
+                .expect("Internal bug in add_operator_product");
         }
-        spin_op
+        qubit_op
     }
 }
 
-/// Implements the into_iter function (IntoIterator trait) of SpinHamiltonian.
+/// Implements the multiplication function of PauliProduct by QubitOperator.
 ///
-impl IntoIterator for SpinHamiltonian {
-    type Item = (PauliProduct, CalculatorFloat);
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    type IntoIter = std::collections::hash_map::IntoIter<PauliProduct, CalculatorFloat>;
-    #[cfg(feature = "indexed_map_iterators")]
-    type IntoIter = indexmap::map::IntoIter<PauliProduct, CalculatorFloat>;
+impl ops::Mul<QubitOperator> for PauliProduct {
+    type Output = QubitOperator;
+    /// Implement `*` for PauliProduct and QubitOperator.
+    ///
+    /// # Arguments
+    ///
+    /// * `other` - The QubitOperator to multiply by.
+    ///
+    /// # Returns
+    ///
+    /// * `Self` - A QubitOperator derived from the PauliProduct, QubitOperator multiplication.
+    ///
+    /// # Panics
+    ///
+    /// * Internal error in add_operator_product.
+    fn mul(self, other: QubitOperator) -> QubitOperator {
+        let mut qubit_op = QubitOperator::with_capacity(other.len());
+        for (ppo, valo) in other.iter() {
+            let (ppp, coefficient) = self.clone() * ppo.clone();
+            let coefficient = valo.clone() * CalculatorComplex::from(coefficient);
+            qubit_op
+                .add_operator_product(ppp, coefficient)
+                .expect("Internal bug in add_operator_product");
+        }
+        qubit_op
+    }
+}
 
-    /// Returns the SpinHamiltonian in Iterator form.
+/// Implements the into_iter function (IntoIterator trait) of QubitOperator.
+///
+impl IntoIterator for QubitOperator {
+    type Item = (PauliProduct, CalculatorComplex);
+    type IntoIter = indexmap::map::IntoIter<PauliProduct, CalculatorComplex>;
+    /// Returns the QubitOperator in Iterator form.
     ///
     /// # Returns
     ///
-    /// * `Self::IntoIter` - The SpinHamiltonian in Iterator form.
+    /// * `Self::IntoIter` - The QubitOperator in Iterator form.
     fn into_iter(self) -> Self::IntoIter {
         self.internal_map.into_iter()
     }
 }
 
-/// Implements the into_iter function (IntoIterator trait) of reference SpinHamiltonian.
+/// Implements the into_iter function (IntoIterator trait) of reference QubitOperator.
 ///
-impl<'a> IntoIterator for &'a SpinHamiltonian {
-    type Item = (&'a PauliProduct, &'a CalculatorFloat);
-    type IntoIter = Iter<'a, PauliProduct, CalculatorFloat>;
+impl<'a> IntoIterator for &'a QubitOperator {
+    type Item = (&'a PauliProduct, &'a CalculatorComplex);
+    type IntoIter = Iter<'a, PauliProduct, CalculatorComplex>;
 
-    /// Returns the reference SpinHamiltonian in Iterator form.
+    /// Returns the reference QubitOperator in Iterator form.
     ///
     /// # Returns
     ///
-    /// * `Self::IntoIter` - The reference SpinHamiltonian in Iterator form.
+    /// * `Self::IntoIter` - The reference QubitOperator in Iterator form.
     fn into_iter(self) -> Self::IntoIter {
         self.internal_map.iter()
     }
 }
 
-/// Implements the from_iter function (FromIterator trait) of SpinHamiltonian.
+/// Implements the from_iter function (FromIterator trait) of QubitOperator.
 ///
-impl FromIterator<(PauliProduct, CalculatorFloat)> for SpinHamiltonian {
-    /// Returns the object in SpinHamiltonian form, from an Iterator form of the object.
+impl FromIterator<(PauliProduct, CalculatorComplex)> for QubitOperator {
+    /// Returns the object in QubitOperator form, from an Iterator form of the object.
     ///
     /// # Arguments
     ///
-    /// * `iter` - The iterator containing the information from which to create the SpinHamiltonian.
+    /// * `iter` - The iterator containing the information from which to create the QubitOperator.
     ///
     /// # Returns
     ///
-    /// * `Self::IntoIter` - The iterator in SpinHamiltonian form.
+    /// * `Self::IntoIter` - The iterator in QubitOperator form.
     ///
     /// # Panics
     ///
-    /// * Internal bug in add_operator_product.
-    fn from_iter<I: IntoIterator<Item = (PauliProduct, CalculatorFloat)>>(iter: I) -> Self {
-        let mut so = SpinHamiltonian::new();
+    /// * Internal error in add_operator_product.
+    fn from_iter<I: IntoIterator<Item = (PauliProduct, CalculatorComplex)>>(iter: I) -> Self {
+        let mut so = QubitOperator::new();
         for (pp, cc) in iter {
             so.add_operator_product(pp, cc)
                 .expect("Internal bug in add_operator_product");
         }
         so
     }
 }
 
-/// Implements the extend function (Extend trait) of SpinHamiltonian.
+/// Implements the extend function (Extend trait) of QubitOperator.
 ///
-impl Extend<(PauliProduct, CalculatorFloat)> for SpinHamiltonian {
-    /// Extends the SpinHamiltonian by the specified operations (in Iterator form).
+impl Extend<(PauliProduct, CalculatorComplex)> for QubitOperator {
+    /// Extends the QubitOperator by the specified operations (in Iterator form).
     ///
     /// # Arguments
     ///
-    /// * `iter` - The iterator containing the operations by which to extend the SpinHamiltonian.
+    /// * `iter` - The iterator containing the operations by which to extend the QubitOperator.
     ///
     /// # Panics
     ///
-    /// * Internal bug in add_operator_product.
-    fn extend<I: IntoIterator<Item = (PauliProduct, CalculatorFloat)>>(&mut self, iter: I) {
+    /// * Internal error in add_operator_product.
+    fn extend<I: IntoIterator<Item = (PauliProduct, CalculatorComplex)>>(&mut self, iter: I) {
         for (pp, cc) in iter {
             self.add_operator_product(pp, cc)
                 .expect("Internal bug in add_operator_product");
         }
     }
 }
 
-/// Implements the format function (Display trait) of SpinHamiltonian.
+/// Implements the format function (Display trait) of QubitOperator.
 ///
-impl fmt::Display for SpinHamiltonian {
-    /// Formats the SpinHamiltonian using the given formatter.
+impl fmt::Display for QubitOperator {
+    /// Formats the QubitOperator using the given formatter.
     ///
     /// # Arguments
     ///
     /// * `f` - The formatter to use.
     ///
     /// # Returns
     ///
-    /// * `std::fmt::Result` - The formatted SpinHamiltonian.
+    /// * `std::fmt::Result` - The formatted QubitOperator.
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        let mut output = "SpinHamiltonian{\n".to_string();
+        let mut output = "QubitOperator{\n".to_string();
         for (key, val) in self.iter() {
             writeln!(output, "{}: {},", key, val)?;
         }
         output.push('}');
 
         write!(f, "{}", output)
     }
 }
 
-impl JordanWignerSpinToFermion for SpinHamiltonian {
-    type Output = FermionHamiltonian;
+impl JordanWignerSpinToFermion for QubitOperator {
+    type Output = FermionOperator;
 
-    /// Implements JordanWignerSpinToFermion for a SpinHamiltonian.
+    /// Implements JordanWignerSpinToFermion for a QubitOperator.
     ///
     /// The convention used is that |0> represents an empty fermionic state (spin-orbital),
     /// and |1> represents an occupied fermionic state.
     ///
     /// # Returns
     ///
-    /// `FermionHamiltonian` - The fermionic Hamiltonian that results from the transformation.
-    ///
-    /// # Panics
-    ///
-    /// * Failed conversion of FermionOperator into FermionHamiltonian. Internal bug in jordan_wigner().
+    /// `FermionOperator` - The fermionic operator that results from the transformation.
     fn jordan_wigner(&self) -> Self::Output {
         let mut out = FermionOperator::new();
         for pp in self.keys() {
-            let mut new_term = pp.jordan_wigner();
-            new_term = new_term * self.get(pp);
-            out = out + new_term;
-        }
-        let filtered_fermion_operator = FermionOperator::from_iter(out.into_iter().filter(|x| {
-            x.0.is_natural_hermitian() || x.0.creators().min() < x.0.annihilators().min()
-        }));
-        FermionHamiltonian::try_from(filtered_fermion_operator)
-            .expect("Failed to convert FermionOperator into FermionHamiltonian.")
+            out = out + pp.jordan_wigner() * self.get(pp);
+        }
+        out
     }
 }
 
 #[cfg(test)]
 mod test {
     use super::*;
+    use crate::StruqtureSerialisationMeta;
     use serde_test::{assert_tokens, Configure, Token};
 
-    // Test the Clone and PartialEq traits of SpinHamiltonian
+    // Test the Clone and PartialEq traits of QubitOperator
     #[test]
-    fn sh_from_shs() {
+    fn so_from_sos() {
         let pp: PauliProduct = PauliProduct::new().z(0);
-        let shs = SpinHamiltonianSerialize {
-            items: vec![(pp.clone(), 0.5.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+        let sos = QubitOperatorSerialize {
+            items: vec![(pp.clone(), 0.5.into(), 0.0.into())],
+            serialisation_meta: StruqtureSerialisationMeta {
+                type_name: "QubitOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0-alpha.0".to_string(),
             },
         };
-        let mut sh = SpinHamiltonian::new();
-        sh.set(pp, CalculatorFloat::from(0.5)).unwrap();
+        let mut so = QubitOperator::new();
+        so.set(pp, CalculatorComplex::from(0.5)).unwrap();
 
-        assert_eq!(SpinHamiltonian::from(shs.clone()), sh);
-        assert_eq!(SpinHamiltonianSerialize::from(sh), shs);
+        assert_eq!(QubitOperator::try_from(sos.clone()).unwrap(), so);
+        assert_eq!(QubitOperatorSerialize::from(so), sos);
     }
-    // Test the Clone and PartialEq traits of SpinHamiltonian
+    // Test the Clone and PartialEq traits of QubitOperator
     #[test]
     fn clone_partial_eq() {
         let pp: PauliProduct = PauliProduct::new().z(0);
-        let shs = SpinHamiltonianSerialize {
-            items: vec![(pp, 0.5.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+        let sos = QubitOperatorSerialize {
+            items: vec![(pp, 0.5.into(), 0.0.into())],
+            serialisation_meta: StruqtureSerialisationMeta {
+                type_name: "QubitOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         // Test Clone trait
-        assert_eq!(shs.clone(), shs);
+        assert_eq!(sos.clone(), sos);
 
         // Test PartialEq trait
         let pp_1: PauliProduct = PauliProduct::new().z(0);
-        let shs_1 = SpinHamiltonianSerialize {
-            items: vec![(pp_1, 0.5.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+        let sos_1 = QubitOperatorSerialize {
+            items: vec![(pp_1, 0.5.into(), 0.0.into())],
+            serialisation_meta: StruqtureSerialisationMeta {
+                type_name: "QubitOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
         let pp_2: PauliProduct = PauliProduct::new().z(2);
-        let shs_2 = SpinHamiltonianSerialize {
-            items: vec![(pp_2, 0.5.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+        let sos_2 = QubitOperatorSerialize {
+            items: vec![(pp_2, 0.5.into(), 0.0.into())],
+            serialisation_meta: StruqtureSerialisationMeta {
+                type_name: "QubitOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
-        assert!(shs_1 == shs);
-        assert!(shs == shs_1);
-        assert!(shs_2 != shs);
-        assert!(shs != shs_2);
+        assert!(sos_1 == sos);
+        assert!(sos == sos_1);
+        assert!(sos_2 != sos);
+        assert!(sos != sos_2);
     }
 
-    // Test the Debug trait of SpinHamiltonian
+    // Test the Debug trait of QubitOperator
     #[test]
     fn debug() {
         let pp: PauliProduct = PauliProduct::new().z(0);
-        let shs = SpinHamiltonianSerialize {
-            items: vec![(pp, 0.5.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+        let sos = QubitOperatorSerialize {
+            items: vec![(pp, 0.5.into(), 0.0.into())],
+            serialisation_meta: StruqtureSerialisationMeta {
+                type_name: "QubitOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_eq!(
-            format!("{:?}", shs),
-            "SpinHamiltonianSerialize { items: [(PauliProduct { items: [(0, Z)] }, Float(0.5))], _struqture_version: StruqtureVersionSerializable { major_version: 1, minor_version: 0 } }"
+            format!("{:?}", sos),
+            "QubitOperatorSerialize { items: [(PauliProduct { items: [(0, Z)] }, Float(0.5), Float(0.0))], serialisation_meta: StruqtureSerialisationMeta { type_name: \"QubitOperator\", min_version: (2, 0, 0), version: \"2.0.0\" } }"
         );
     }
 
-    /// Test SpinHamiltonian Serialization and Deserialization traits (readable)
+    /// Test QubitOperator Serialization and Deserialization traits (readable)
     #[test]
     fn serde_readable() {
         let pp = PauliProduct::new().x(0);
-        let shs = SpinHamiltonianSerialize {
-            items: vec![(pp, 0.5.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+        let sos = QubitOperatorSerialize {
+            items: vec![(pp, 0.5.into(), 0.0.into())],
+            serialisation_meta: StruqtureSerialisationMeta {
+                type_name: "QubitOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_tokens(
-            &shs.readable(),
+            &sos.readable(),
             &[
                 Token::Struct {
-                    name: "SpinHamiltonianSerialize",
+                    name: "QubitOperatorSerialize",
                     len: 2,
                 },
                 Token::Str("items"),
                 Token::Seq { len: Some(1) },
-                Token::Tuple { len: 2 },
+                Token::Tuple { len: 3 },
                 Token::Str("0X"),
                 Token::F64(0.5),
+                Token::F64(0.0),
                 Token::TupleEnd,
                 Token::SeqEnd,
-                Token::Str("_struqture_version"),
+                Token::Str("serialisation_meta"),
                 Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
                 },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(0),
+                Token::Str("type_name"),
+                Token::Str("QubitOperator"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
                 Token::StructEnd,
                 Token::StructEnd,
             ],
         );
     }
 
-    /// Test SpinHamiltonian Serialization and Deserialization traits (compact)
+    /// Test QubitOperator Serialization and Deserialization traits (compact)
     #[test]
     fn serde_compact() {
         let pp = PauliProduct::new().x(0);
-        let shs = SpinHamiltonianSerialize {
-            items: vec![(pp, 0.5.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
+        let sos = QubitOperatorSerialize {
+            items: vec![(pp, 0.5.into(), 0.0.into())],
+            serialisation_meta: StruqtureSerialisationMeta {
+                type_name: "QubitOperator".to_string(),
+                min_version: (2, 0, 0),
+                version: "2.0.0".to_string(),
             },
         };
 
         assert_tokens(
-            &shs.compact(),
+            &sos.compact(),
             &[
                 Token::Struct {
-                    name: "SpinHamiltonianSerialize",
+                    name: "QubitOperatorSerialize",
                     len: 2,
                 },
                 Token::Str("items"),
                 Token::Seq { len: Some(1) },
-                Token::Tuple { len: 2 },
+                Token::Tuple { len: 3 },
                 Token::Seq { len: Some(1) },
                 Token::Tuple { len: 2 },
                 Token::U64(0),
                 Token::UnitVariant {
-                    name: "SingleSpinOperator",
+                    name: "SingleQubitOperator",
                     variant: "X",
                 },
                 Token::TupleEnd,
                 Token::SeqEnd,
                 Token::NewtypeVariant {
                     name: "CalculatorFloat",
                     variant: "Float",
                 },
                 Token::F64(0.5),
+                Token::NewtypeVariant {
+                    name: "CalculatorFloat",
+                    variant: "Float",
+                },
+                Token::F64(0.0),
                 Token::TupleEnd,
                 Token::SeqEnd,
-                Token::Str("_struqture_version"),
+                Token::Str("serialisation_meta"),
                 Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
+                    name: "StruqtureSerialisationMeta",
+                    len: 3,
                 },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(0),
+                Token::Str("type_name"),
+                Token::Str("QubitOperator"),
+                Token::Str("min_version"),
+                Token::Tuple { len: 3 },
+                Token::U64(2),
+                Token::U64(0),
+                Token::U64(0),
+                Token::TupleEnd,
+                Token::Str("version"),
+                Token::Str("2.0.0"),
                 Token::StructEnd,
                 Token::StructEnd,
             ],
         );
     }
 }
```

### Comparing `struqture_py-1.6.1/struqture/src/spins/spin_noise_operator.rs` & `struqture_py-2.0.0a0/struqture-py-macros/src/noiseless_system_wrapper.rs`

 * *Files 25% similar despite different names*

```diff
@@ -6,1046 +6,873 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
-use super::{OperateOnSpins, SingleDecoherenceOperator, ToSparseMatrixSuperOperator};
-use crate::fermions::FermionLindbladNoiseOperator;
-use crate::mappings::JordanWignerSpinToFermion;
-use crate::spins::{DecoherenceOperator, DecoherenceProduct};
-use crate::{
-    CooSparseMatrix, OperateOnDensityMatrix, SpinIndex, StruqtureError,
-    StruqtureVersionSerializable, SymmetricIndex, MINIMUM_STRUQTURE_VERSION,
-};
-use itertools::Itertools;
-use num_complex::Complex64;
-use qoqo_calculator::{CalculatorComplex, CalculatorFloat};
-use serde::{Deserialize, Serialize};
-use std::fmt::{self, Write};
-use std::iter::{FromIterator, IntoIterator};
-use std::ops;
-
-#[cfg(feature = "indexed_map_iterators")]
-use indexmap::map::{Entry, Iter, Keys, Values};
-#[cfg(feature = "indexed_map_iterators")]
-use indexmap::IndexMap;
-#[cfg(not(feature = "indexed_map_iterators"))]
-use std::collections::hash_map::{Entry, Iter, Keys, Values};
-use std::collections::HashMap;
-
-/// SpinLindbladNoiseOperators represent noise interactions in the Lindblad equation.
-///
-/// In the Lindblad equation, Linblad noise operator L_i are not limited to [crate::spins::DecoherenceProduct] style operators.
-/// We use ([crate::spins::DecoherenceProduct], [crate::spins::DecoherenceProduct]) as a unique basis.
-///
-/// # Example
-///
-/// ```
-/// use struqture::prelude::*;
-/// use qoqo_calculator::CalculatorComplex;
-/// use struqture::spins::{DecoherenceProduct, SpinLindbladNoiseOperator};
-///
-/// let mut system = SpinLindbladNoiseOperator::new();
-///
-/// // Set noise terms:
-/// let pp_01 = DecoherenceProduct::new().x(0).x(1);
-/// let pp_0 = DecoherenceProduct::new().z(0);
-/// system.set((pp_01.clone(), pp_01.clone()), CalculatorComplex::from(0.5)).unwrap();
-/// system.set((pp_0.clone(), pp_0.clone()), CalculatorComplex::from(0.2)).unwrap();
-///
-/// // Access what you set:
-/// assert_eq!(system.current_number_spins(), 2_usize);
-/// assert_eq!(system.get(&(pp_01.clone(), pp_01.clone())), &CalculatorComplex::from(0.5));
-/// assert_eq!(system.get(&(pp_0.clone(), pp_0.clone())), &CalculatorComplex::from(0.2));
-/// ```
-///
-#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
-#[serde(from = "SpinLindbladNoiseOperatorSerialize")]
-#[serde(into = "SpinLindbladNoiseOperatorSerialize")]
-pub struct SpinLindbladNoiseOperator {
-    // The internal map representing the noise terms
-    #[cfg(feature = "indexed_map_iterators")]
-    internal_map: IndexMap<(DecoherenceProduct, DecoherenceProduct), CalculatorComplex>,
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    internal_map: HashMap<(DecoherenceProduct, DecoherenceProduct), CalculatorComplex>,
-}
+//! struqture-py-macros
+//!
+//! Attribute proc-macros for the traits of struqture-py [struqture-py].
+use crate::{strip_python_wrapper_name, AttributeMacroArguments};
+use proc_macro2::TokenStream;
+use quote::quote;
+use syn::{parse_macro_input, ItemImpl};
+
+pub fn noiselesswrapper(
+    metadata: proc_macro::TokenStream,
+    input: proc_macro::TokenStream,
+) -> proc_macro::TokenStream {
+    let parsed_input = parse_macro_input!(input as ItemImpl);
+    let ident = parsed_input.self_ty;
+    let items = parsed_input.items;
+    let attribute_arguments = parse_macro_input!(metadata as AttributeMacroArguments);
+    let (struct_name, struct_ident) = strip_python_wrapper_name(&ident);
+    let (index_type, struqture_one_module, struqture_one_ident) =
+        if struct_name.contains("QubitOperator") {
+            (
+                quote::format_ident!("PauliProductWrapper"),
+                quote::format_ident!("spins"),
+                quote::format_ident!("SpinSystem"),
+            )
+        } else if struct_name.contains("QubitHamiltonian") {
+            (
+                quote::format_ident!("PauliProductWrapper"),
+                quote::format_ident!("spins"),
+                quote::format_ident!("SpinHamiltonianSystem"),
+            )
+        } else if struct_name.contains("MixedPlusMinusOperator") {
+            (
+                quote::format_ident!("MixedPlusMinusProductWrapper"),
+                quote::format_ident!("mixed_systems"),
+                quote::format_ident!("MixedPlusMinusOperator"),
+            )
+        } else if struct_name.contains("PlusMinusOperator") {
+            (
+                quote::format_ident!("PlusMinusProductWrapper"),
+                quote::format_ident!("spins"),
+                quote::format_ident!("PlusMinusOperator"),
+            )
+        } else if struct_name.contains("BosonHamiltonian") {
+            (
+                quote::format_ident!("HermitianBosonProductWrapper"),
+                quote::format_ident!("bosons"),
+                quote::format_ident!("BosonHamiltonianSystem"),
+            )
+        } else if struct_name.contains("BosonOperator") {
+            (
+                quote::format_ident!("BosonProductWrapper"),
+                quote::format_ident!("bosons"),
+                quote::format_ident!("BosonSystem"),
+            )
+        } else if struct_name.contains("FermionHamiltonian") {
+            (
+                quote::format_ident!("HermitianFermionProductWrapper"),
+                quote::format_ident!("fermions"),
+                quote::format_ident!("FermionHamiltonianSystem"),
+            )
+        } else if struct_name.contains("FermionOperator") {
+            (
+                quote::format_ident!("FermionProductWrapper"),
+                quote::format_ident!("fermions"),
+                quote::format_ident!("FermionSystem"),
+            )
+        } else if struct_name.contains("MixedHamiltonian") {
+            (
+                quote::format_ident!("HermitianMixedProductWrapper"),
+                quote::format_ident!("mixed_systems"),
+                quote::format_ident!("MixedHamiltonianSystem"),
+            )
+        } else {
+            (
+                quote::format_ident!("MixedProductWrapper"),
+                quote::format_ident!("mixed_systems"),
+                quote::format_ident!("MixedSystem"),
+            )
+        };
+    let value_type = if struct_name.contains("QubitHamiltonian") {
+        quote::format_ident!("CalculatorFloatWrapper")
+    } else {
+        quote::format_ident!("CalculatorComplexWrapper")
+    };
+    // ------------
+    // Start the generating part of the macro
+    let operate_on_density_matrix_quote = if attribute_arguments.contains("OperateOnDensityMatrix")
+    {
+        quote! {
+                /// Return a list of the unsorted keys in self.
+                ///
+                /// Returns:
+                ///     list[OperatorProduct]: The sequence of keys of the self.
+                pub fn keys(&self) -> Vec<#index_type> {
+                    let mut system_keys: Vec<#index_type> = Vec::new();
+                    for key in self.internal.keys() {
+                        system_keys.push(
+                            #index_type { internal: key.clone() },
+                        );
+                    }
+                    system_keys
+                }
 
-impl crate::MinSupportedVersion for SpinLindbladNoiseOperator {}
+                /// Return number of entries in self.
+                ///
+                /// Returns:
+                ///     int: The length of the content of self.
+                pub fn __len__(&self) -> usize {
+                    self.internal.len()
+                }
 
-#[cfg(feature = "json_schema")]
-impl schemars::JsonSchema for SpinLindbladNoiseOperator {
-    fn schema_name() -> String {
-        "PlusMinusOperator".to_string()
-    }
-
-    fn json_schema(gen: &mut schemars::gen::SchemaGenerator) -> schemars::schema::Schema {
-        <SpinLindbladNoiseOperatorSerialize>::json_schema(gen)
-    }
-}
-#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
-#[cfg_attr(feature = "json_schema", derive(schemars::JsonSchema))]
-#[cfg_attr(feature = "json_schema", schemars(deny_unknown_fields))]
-struct SpinLindbladNoiseOperatorSerialize {
-    /// The vector representing the internal map of the SpinLindbladNoiseOperator
-    items: Vec<(
-        DecoherenceProduct,
-        DecoherenceProduct,
-        CalculatorFloat,
-        CalculatorFloat,
-    )>,
-    /// The struqture version
-    _struqture_version: StruqtureVersionSerializable,
-}
+                /// Return an instance of self that has no entries but clones all other properties, with the given capacity.
+                ///
+                /// Args:
+                ///     capacity (Optional[int]): The capacity of the new instance to create.
+                ///
+                /// Returns:
+                ///     self: An empty clone with the same properties as self, with the given capacity.
+                #[pyo3(signature = (capacity = None))]
+                pub fn empty_clone(&self, capacity: Option<usize>) -> #ident {
+                    #ident {
+                        internal: self.internal.empty_clone(capacity)
+                    }
+                }
 
-impl From<SpinLindbladNoiseOperatorSerialize> for SpinLindbladNoiseOperator {
-    fn from(value: SpinLindbladNoiseOperatorSerialize) -> Self {
-        let new_noise_op: SpinLindbladNoiseOperator = value
-            .items
-            .into_iter()
-            .map(|(left, right, real, imag)| {
-                ((left, right), CalculatorComplex { re: real, im: imag })
-            })
-            .collect();
-        new_noise_op
-    }
-}
+                /// Return true if self contains no values.
+                ///
+                /// Returns:
+                ///     bool: Whether self is empty or not.
+                pub fn is_empty(&self) -> bool {
+                    self.internal.is_empty()
+                }
 
-impl From<SpinLindbladNoiseOperator> for SpinLindbladNoiseOperatorSerialize {
-    fn from(value: SpinLindbladNoiseOperator) -> Self {
-        let new_noise_op: Vec<(
-            DecoherenceProduct,
-            DecoherenceProduct,
-            CalculatorFloat,
-            CalculatorFloat,
-        )> = value
-            .into_iter()
-            .map(|((left, right), val)| (left, right, val.re, val.im))
-            .collect();
-        let current_version = StruqtureVersionSerializable {
-            major_version: MINIMUM_STRUQTURE_VERSION.0,
-            minor_version: MINIMUM_STRUQTURE_VERSION.1,
-        };
-        Self {
-            items: new_noise_op,
-            _struqture_version: current_version,
-        }
-    }
-}
+                /// Truncate self by returning a copy without entries under a threshold.
+                ///
+                /// Args:
+                ///     threshold: The threshold for inclusion.
+                ///
+                /// Returns:
+                ///     self: The truncated version of self.
+                pub fn truncate(&self, threshold: f64) -> #ident {
+                    #ident { internal: self.internal.truncate(threshold) }
+                }
 
-impl<'a> OperateOnDensityMatrix<'a> for SpinLindbladNoiseOperator {
-    type Index = (DecoherenceProduct, DecoherenceProduct);
-    type Value = CalculatorComplex;
-    type IteratorType = Iter<'a, (DecoherenceProduct, DecoherenceProduct), CalculatorComplex>;
-    type KeyIteratorType = Keys<'a, (DecoherenceProduct, DecoherenceProduct), CalculatorComplex>;
-    type ValueIteratorType =
-        Values<'a, (DecoherenceProduct, DecoherenceProduct), CalculatorComplex>;
-
-    // From trait
-    fn get(&self, key: &Self::Index) -> &Self::Value {
-        match self.internal_map.get(key) {
-            Some(value) => value,
-            None => &CalculatorComplex::ZERO,
-        }
-    }
+                /// Get the coefficient corresponding to the key.
+                ///
+                /// Args:
+                ///     key: Product to get the value of.
+                ///
+                /// Returns:
+                ///     CalculatorComplex: Value at key (or 0.0).
+                ///
+                /// Raises:
+                ///     ValueError: Product could not be constructed from key.
+                pub fn get(&self, key: Py<PyAny>) -> PyResult<#value_type> {
+                    let converted_key = #index_type::from_pyany(key).map_err(|err| {
+                        PyValueError::new_err(format!(
+                            "Product could not be constructed: {:?}",
+                            err
+                        ))
+                    })?;
+                    Ok(#value_type {
+                        internal: self.clone().internal.get(&converted_key).clone(),
+                    })
+                }
 
-    // From trait
-    fn iter(&'a self) -> Self::IteratorType {
-        self.internal_map.iter()
-    }
-
-    // From trait
-    fn keys(&'a self) -> Self::KeyIteratorType {
-        self.internal_map.keys()
-    }
-
-    // From trait
-    fn values(&'a self) -> Self::ValueIteratorType {
-        self.internal_map.values()
-    }
-
-    #[cfg(feature = "indexed_map_iterators")]
-    // From trait
-    fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
-        self.internal_map.shift_remove(key)
-    }
-
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    // From trait
-    fn remove(&mut self, key: &Self::Index) -> Option<Self::Value> {
-        self.internal_map.remove(key)
-    }
-
-    // From trait
-    fn empty_clone(&self, capacity: Option<usize>) -> Self {
-        match capacity {
-            Some(cap) => Self::with_capacity(cap),
-            None => Self::new(),
-        }
-    }
+                /// Remove the value of the input key.
+                ///
+                /// Returns:
+                ///     Optional[Union[CalculatorComplex, CalculatorFloat]]: Key existed if this is not None, and this is the value it had before it was removed.
+                ///
+                /// Raises:
+                ///     ValueError: Product could not be constructed.
+                pub fn remove(&mut self, key: Py<PyAny>) -> PyResult<Option<#value_type>> {
+                    let converted_key = #index_type::from_pyany(key).map_err(|err| {
+                        PyValueError::new_err(format!(
+                            "Product could not be constructed: {:?}",
+                            err
+                        ))
+                    })?;
+                    match self.internal.remove(&converted_key) {
+                        Some(x) => Ok(Some(#value_type { internal: x })),
+                        None => Ok(None),
+                    }
+                }
 
-    /// Overwrites an existing entry or sets a new entry in the SpinLindbladNoiseOperator with the given ((DecoherenceProduct, DecoherenceProduct) key, CalculatorComplex value) pair.
-    ///
-    /// # Arguments
-    ///
-    /// * `key` - The (DecoherenceProduct, DecoherenceProduct) key to set in the SpinLindbladNoiseOperator.
-    /// * `value` - The corresponding CalculatorComplex value to set for the key in the SpinLindbladNoiseOperator.
-    ///
-    /// # Returns
-    ///
-    /// * `Ok(Some(CalculatorComplex))` - The key existed, this is the value it had before it was set with the value input.
-    /// * `Ok(None)` - The key did not exist, it has been set with its corresponding value.
-    /// * `Err(StruqtureError::InvalidLindbladTerms)` - The input contained identities, which are not allowed as Lindblad operators.
-    fn set(
-        &mut self,
-        key: Self::Index,
-        value: Self::Value,
-    ) -> Result<Option<Self::Value>, StruqtureError> {
-        if key.0.is_empty() || key.1.is_empty() {
-            return Err(StruqtureError::InvalidLindbladTerms);
-        }
+                /// Overwrite an existing entry or set a new entry in self.
+                ///
+                /// Returns:
+                ///     Optional[Union[CalculatorComplex, CalculatorFloat]]: Key existed if this is not None, and this is the value it had before it was overwritten.
+                ///
+                /// Raises:
+                ///     ValueError: Product could not be constructed.
+                pub fn set(
+                    &mut self,
+                    key: Py<PyAny>,
+                    value: Py<PyAny>,
+                ) -> PyResult<Option<#value_type>> {
+                    let value = #value_type::from_pyany(value)
+                        .map_err(|_| PyTypeError::new_err("Value is not CalculatorComplex or CalculatorFloat"))?;
+                    let converted_key = #index_type::from_pyany(key).map_err(|err| {
+                        PyValueError::new_err(format!(
+                            "Product could not be constructed: {:?}",
+                            err
+                        ))
+                    })?;
+                    match self.internal.set(converted_key, value).map_err(|err| {
+                        PyValueError::new_err(format!(
+                            "Error in set function of Operator: {:?}",
+                            err
+                        ))
+                    })? {
+                        Some(x) => Ok(Some(#value_type { internal: x })),
+                        None => Ok(None),
+                    }
+                }
 
-        if value != CalculatorComplex::ZERO {
-            Ok(self.internal_map.insert(key, value))
-        } else {
-            match self.internal_map.entry(key) {
-                #[cfg(feature = "indexed_map_iterators")]
-                Entry::Occupied(val) => Ok(Some(val.shift_remove())),
-                #[cfg(not(feature = "indexed_map_iterators"))]
-                Entry::Occupied(val) => Ok(Some(val.remove())),
-                Entry::Vacant(_) => Ok(None),
-            }
-        }
-    }
-}
+                /// Add a new (key object, value Union[CalculatorComplex, CalculatorFloat]) pair to existing entries.
+                ///
+                /// Raises:
+                ///     TypeError: Value is not CalculatorComplex or CalculatorFloat.
+                ///     ValueError: Product could not be constructed.
+                ///     ValueError: Error in add_operator_product function of self.
+                pub fn add_operator_product(&mut self, key: Py<PyAny>, value: Py<PyAny>) -> PyResult<()> {
+                    let value = #value_type::from_pyany(value)
+                        .map_err(|_| PyTypeError::new_err("Value is not CalculatorComplex or CalculatorFloat"))?;
+                    let converted_key = #index_type::from_pyany(key).map_err(|err| {
+                        PyValueError::new_err(format!(
+                            "Product could not be constructed: {:?}",
+                            err
+                        ))
+                    })?;
+                    self.internal
+                        .add_operator_product(converted_key, value)
+                        .map_err(|err| {
+                            PyValueError::new_err(format!(
+                                "Error in add_operator_product function of Operator: {:?}",
+                                err
+                            ))
+                        })
+                }
 
-impl<'a> OperateOnSpins<'a> for SpinLindbladNoiseOperator {
-    /// Gets the maximum index of the SpinLindbladNoiseOperator.
-    ///
-    /// # Returns
-    ///
-    /// * `usize` - The number of spins in the SpinLindbladNoiseOperator.
-    fn number_spins(&self) -> usize {
-        self.current_number_spins()
-    }
-
-    // From trait
-    fn current_number_spins(&self) -> usize {
-        let mut max_mode: usize = 0;
-        if !self.internal_map.is_empty() {
-            for key in self.internal_map.keys() {
-                let maxk = (key.0.current_number_spins()).max(key.1.current_number_spins());
-                if maxk > max_mode {
-                    max_mode = maxk
+                /// Return unsorted values in self.
+                ///
+                /// Returns:
+                ///     list[Union[CalculatorComplex, CalculatorFloat]]: The sequence of values of self.
+                pub fn values(&self) -> Vec<#value_type> {
+                    let mut system_values: Vec<#value_type> = Vec::new();
+                    for val in self.internal.values() {
+                        system_values.push(
+                            #value_type { internal: val.clone() },
+                        );
+                    }
+                    system_values
+                }
+        }
+    } else {
+        TokenStream::new()
+    };
+    let operate_on_state_quote = if attribute_arguments.contains("OperateOnState") {
+        quote! {
+                /// Return the hermitian conjugate of self.
+                ///
+                /// Returns:
+                ///     self: The hermitian conjugate of self.
+                pub fn hermitian_conjugate(&self) -> #ident {
+                    #ident {
+                        internal: self.internal.hermitian_conjugate()
+                    }
                 }
+        }
+    } else {
+        TokenStream::new()
+    };
+    let operate_on_modes_quote = if attribute_arguments.contains("OperateOnModes") {
+        quote! {
+            /// Return the current_number_modes input of self.
+            ///
+            /// Returns:
+            ///     int: The number of modes in self.
+            pub fn current_number_modes(&self) -> usize {
+                self.internal.current_number_modes()
             }
         }
-        max_mode
-    }
-}
-
-impl<'a> ToSparseMatrixSuperOperator<'a> for SpinLindbladNoiseOperator {
-    // From trait
-    fn sparse_matrix_superoperator_entries_on_row(
-        &self,
-        row: usize,
-        number_spins: usize,
-    ) -> Result<HashMap<usize, Complex64>, StruqtureError> {
-        let mut entries: HashMap<usize, Complex64> = HashMap::new();
-        let dimension = 2_usize.pow(number_spins as u32);
-        for ((left, right), value) in self.iter() {
-            add_lindblad_terms(
-                left,
-                right,
-                row,
-                dimension,
-                number_spins,
-                &mut entries,
-                value,
-            )?;
-            // iterate over terms corresponding to - 1/2 right^dagger * left p => -1/2 (right^dagger * left).kron(I) flatten(p)
-            // and - 1/2 p right^dagger * left  => - 1/2 I.kron((right^dagger * left).T) flatten(p)
-            add_anti_commutator(
-                left,
-                right,
-                row,
-                dimension,
-                number_spins,
-                &mut entries,
-                value,
-            )?;
+    } else {
+        TokenStream::new()
+    };
+    let operate_on_spins_quote = if attribute_arguments.contains("OperateOnSpins") {
+        quote! {
+            /// Return the current_number_spins input of self.
+            ///
+            /// Returns:
+            ///     int: The number of spins in self.
+            pub fn current_number_spins(&self) -> usize {
+                self.internal.current_number_spins()
+            }
         }
-        Ok(entries)
-    }
-
-    // From trait
-    fn unitary_sparse_matrix_coo(&'a self) -> Result<CooSparseMatrix, StruqtureError> {
-        Ok((vec![], (vec![], vec![])) as CooSparseMatrix)
-    }
-
-    // From trait
-    fn sparse_lindblad_entries(
-        &'a self,
-    ) -> Result<Vec<(CooSparseMatrix, CooSparseMatrix, Complex64)>, StruqtureError> {
-        let mut coo_matrices =
-            Vec::<(CooSparseMatrix, CooSparseMatrix, Complex64)>::with_capacity(self.len());
-        for ((left, right), val) in self.iter() {
-            coo_matrices.push((
-                left.to_coo(self.number_spins()).unwrap(),
-                right.to_coo(self.number_spins()).unwrap(),
-                Complex64 {
-                    re: *val.re.float()?,
-                    im: *val.im.float()?,
-                },
-            ))
+    } else {
+        TokenStream::new()
+    };
+    let to_sparse_matrix_operator_quote = if attribute_arguments.contains("ToSparseMatrixOperator")
+    {
+        quote! {
+                /// Constructs the sparse matrix representation of self as a scipy COO matrix with a given number of spins.
+                ///
+                /// Args:
+                ///     number_spins: The number of spins in self.
+                ///
+                /// Returns:
+                ///     Tuple[np.ndarray, Tuple[np.ndarray, np.ndarray]]: The matrix representation of self.
+                ///
+                /// Raises:
+                ///     ValueError: CalculatorError.
+                ///     RuntimeError: Could not convert to complex superoperator matrix.
+                #[pyo3(signature = (number_spins = None))]
+                pub fn sparse_matrix_coo(&self, number_spins: Option<usize>) -> PyResult<PyCooMatrix> {
+                    let coo = self
+                        .internal
+                        .sparse_matrix_coo(number_spins)
+                        .map_err(|err| match err {
+                            StruqtureError::CalculatorError(c_err) => {
+                                PyValueError::new_err(format!("{}", c_err))
+                            }
+                            _ => PyRuntimeError::new_err(
+                                "Could not convert to complex superoperator matrix".to_string(),
+                            ),
+                        })?;
+                    to_py_coo(coo)
+                }
         }
-        Ok(coo_matrices)
-    }
-}
+    } else {
+        TokenStream::new()
+    };
+    let to_sparse_matrix_superoperator_quote = if attribute_arguments
+        .contains("ToSparseMatrixSuperOperator")
+    {
+        quote! {
+                /// Construct the sparse matrix representation of the superoperator in COO representation.
+                ///
+                /// The superoperator for the operator O is defined as the Matrix S so that
+                /// `flatten(-i [O, p]) = S flatten(p)` wher `[,]` is the commutator, `p` is a matrix
+                /// and `flatten` flattens a matrix into a vector in row-major form.
+                ///
+                /// Args:
+                ///     number_spins: The number of spins to construct the matrix for.
+                ///
+                /// Returns:
+                ///     Tuple[np.ndarray, Tuple[np.ndarray, np.ndarray]]: The matrix representation of self.
+                ///
+                /// Raises:
+                ///     ValueError: CalculatorError.
+                ///     RuntimeError: Could not convert to complex superoperator matrix.
+                #[pyo3(signature = (number_spins = None))]
+                pub fn sparse_matrix_superoperator_coo(&self, number_spins: Option<usize>) -> PyResult<PyCooMatrix> {
+                    let coo = self
+                        .internal
+                        .sparse_matrix_superoperator_coo(number_spins)
+                        .map_err(|err| match err {
+                            StruqtureError::CalculatorError(c_err) => {
+                                PyValueError::new_err(format!("{}", c_err))
+                            }
+                            _ => PyRuntimeError::new_err(
+                                "Could not convert to complex superoperator matrix".to_string(),
+                            ),
+                        })?;
+                    to_py_coo(coo)
+                }
 
-/// Implements the default function (Default trait) of SpinLindbladNoiseOperator (an empty SpinLindbladNoiseOperator).
-///
-impl Default for SpinLindbladNoiseOperator {
-    fn default() -> Self {
-        Self::new()
-    }
-}
+                /// Return the unitary part of the superoperator in the sparse COO format.
+                ///
+                /// Returns:
+                ///     Tuple[np.ndarray, Tuple[np.ndarray, np.ndarray]]: The matrix representation of the unitary part of self.
+                ///
+                /// Raises:
+                ///     ValueError: CalculatorError.
+                ///     RuntimeError: Could not convert to complex superoperator matrix.
+                pub fn unitary_sparse_matrix_coo(&self) -> PyResult<PyCooMatrix> {
+                    let coo = self
+                        .internal
+                        .unitary_sparse_matrix_coo()
+                        .map_err(|err| match err {
+                            StruqtureError::CalculatorError(c_err) => {
+                                PyValueError::new_err(format!("{}", c_err))
+                            }
+                            _ => PyRuntimeError::new_err(
+                                "Could not convert to complex superoperator matrix".to_string(),
+                            ),
+                        })?;
+                    to_py_coo(coo)
+                }
 
-/// Functions for the SpinLindbladNoiseOperator
-///
-impl SpinLindbladNoiseOperator {
-    /// Creates a new SpinLindbladNoiseOperator.
-    ///
-    /// # Returns
-    ///
-    /// * `Self` - The new (empty) SpinLindbladNoiseOperator.
-    pub fn new() -> Self {
-        SpinLindbladNoiseOperator {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::new(),
-            #[cfg(feature = "indexed_map_iterators")]
-            internal_map: IndexMap::new(),
+                /// Output the Lindblad entries in the form (left, right, rate) where left/right are the left and right lindblad operators, and rate is the lindblad rate respectively.
+                ///
+                /// Returns:
+                ///     list[Tuple[Tuple[np.ndarray, Tuple[np.ndarray, np.ndarray]], Tuple[np.ndarray, Tuple[np.ndarray, np.ndarray], complex]]: The matrix representation of the noise part of self.
+                ///
+                /// Raises:
+                ///     ValueError: CalculatorError.
+                ///     RuntimeError: Could not convert to complex superoperator matrix.
+                pub fn sparse_lindblad_entries(&self) -> PyResult<Vec<(PyCooMatrix, PyCooMatrix, Complex64)>> {
+                    let coo = self
+                        .internal
+                        .sparse_lindblad_entries()
+                        .map_err(|err| match err {
+                            StruqtureError::CalculatorError(c_err) => {
+                                PyValueError::new_err(format!("{}", c_err))
+                            }
+                            _ => PyRuntimeError::new_err(
+                                "Could not convert to complex superoperator matrix".to_string(),
+                            ),
+                        })?;
+                    let mut res_vec: Vec<(PyCooMatrix, PyCooMatrix, Complex64)> = Vec::new();
+                    for mat in coo {
+                        let left = to_py_coo(mat.0).map_err(|err| match err {
+                            _ => PyRuntimeError::new_err(
+                                "Could not convert to complex superoperator matrix".to_string(),
+                            ),
+                        })?;
+                        let right = to_py_coo(mat.1).map_err(|err| match err {
+                            _ => PyRuntimeError::new_err(
+                                "Could not convert to complex superoperator matrix".to_string(),
+                            ),
+                        })?;
+                        res_vec.push((left, right, mat.2));
+                    }
+                    Ok(res_vec)
+                }
         }
-    }
+    } else {
+        TokenStream::new()
+    };
+    let operate_on_mixedsystems_quote = if attribute_arguments.contains("OperateOnMixedSystems") {
+        quote! {
+                /// Return the current_number_spins input of each spin subsystem of self.
+                ///
+                /// Returns:
+                ///     int: The number of spins in each spin subsystem of self.
+                pub fn current_number_spins(&self) -> Vec<usize> {
+                    self.internal.current_number_spins()
+                }
 
-    /// Creates a new SpinLindbladNoiseOperator with pre-allocated capacity.
-    ///
-    /// # Arguments
-    ///
-    /// * `capacity` - The pre-allocated capacity of the system.
-    ///
-    /// # Returns
-    ///
-    /// * `Self` - The new (empty) SpinLindbladNoiseOperator.
-    pub fn with_capacity(capacity: usize) -> Self {
-        SpinLindbladNoiseOperator {
-            #[cfg(not(feature = "indexed_map_iterators"))]
-            internal_map: HashMap::with_capacity(capacity),
-            #[cfg(feature = "indexed_map_iterators")]
-            internal_map: IndexMap::with_capacity(capacity),
-        }
-    }
+                /// Return the number of bosonic modes in each bosonic subsystem of self.
+                ///
+                /// Returns:
+                ///     list[int]: The number of bosonic modes in each bosonic subsystem of self.
+                pub fn current_number_bosonic_modes(&self) -> Vec<usize> {
+                    self.internal.current_number_bosonic_modes()
+                }
 
-    /// Adds all noise entries corresponding to a ((DecoherenceOperator, DecoherenceOperator), CalculatorFloat).
-    ///
-    /// In the Lindblad equation, Linblad noise operator L_i are not limited to [crate::spins::DecoherenceProduct] style operators.
-    /// We use ([crate::spins::DecoherenceProduct], [crate::spins::DecoherenceProduct]) as a unique basis.
-    /// This function adds a Linblad-Term defined by a combination of Lindblad operators given as general [crate::spins::DecoherenceOperator]
-    ///
-    /// # Arguments
-    ///
-    /// * `left` - DecoherenceOperator that acts on the density matrix from the left in the Lindblad equation.
-    /// * `right` -  DecoherenceOperator that acts on the density matrix from the right and in hermitian conjugated form in the Lindblad equation.
-    /// * `value` - CalculatorComplex value representing the global coefficient of the noise term.
-    ///
-    /// # Returns
-    ///
-    /// * `Ok(())` - The noise was correctly added.
-    /// * `Err(StruqtureError::InvalidLindbladTerms)` - The input contained identities, which are not allowed as Lindblad operators.
-    pub fn add_noise_from_full_operators(
-        &mut self,
-        left: &DecoherenceOperator,
-        right: &DecoherenceOperator,
-        value: CalculatorComplex,
-    ) -> Result<(), StruqtureError> {
-        if left.is_empty() || right.is_empty() {
-            return Err(StruqtureError::InvalidLindbladTerms);
+                /// Return the number of fermionic modes in each fermionic subsystem of self.
+                ///
+                /// Returns:
+                ///     list[int]: The number of fermionic modes in each fermionic subsystem of self.
+                pub fn current_number_fermionic_modes(&self) -> Vec<usize> {
+                    self.internal.current_number_fermionic_modes()
+                }
         }
+    } else {
+        TokenStream::new()
+    };
+    let calculus_quote = if attribute_arguments.contains("Calculus") {
+        quote! {
+            /// Implement `-1` for self.
+            ///
+            /// Returns:
+            ///     self: The object * -1.
+            pub fn __neg__(&self) -> #ident {
+                #ident {
+                    internal: -self.clone().internal
+                }
+            }
 
-        for ((decoherence_product_left, value_left), (decoherence_product_right, value_right)) in
-            left.iter().cartesian_product(right.iter())
-        {
-            if !decoherence_product_left.is_empty() && !decoherence_product_right.is_empty() {
-                let value_complex = value_right.conj() * value_left;
-                self.add_operator_product(
-                    (
-                        decoherence_product_left.clone(),
-                        decoherence_product_right.clone(),
-                    ),
-                    value_complex * value.clone(),
-                )?;
+            /// Implement `+` for self with self-type.
+            ///
+            /// Args:
+            ///     other (self): value by which to add to self.
+            ///
+            /// Returns:
+            ///     self: The two objects added.
+            ///
+            /// Raises:
+            ///     ValueError: Objects could not be added.
+            pub fn __add__(&self, other: #ident) -> PyResult<#ident> {
+                let new_self = (self.clone().internal + other.internal);
+                Ok(#ident {
+                    internal: new_self
+                })
             }
-        }
-        Ok(())
-    }
 
-    /// Remaps the qubits in the SpinLindbladNoiseOperator.
-    ///
-    /// # Arguments
-    ///
-    /// * `mapping` - HashMap containing the qubit remapping.
-    ///
-    /// # Returns
-    ///
-    /// * `Self` - The remapped SpinLindbladNoiseOperator.
-    pub fn remap_qubits(&self, mapping: &HashMap<usize, usize>) -> Self {
-        let mut new_noise = SpinLindbladNoiseOperator::new();
-        for ((left, right), rate) in self.iter() {
-            let new_left = left.remap_qubits(mapping);
-            let new_right = right.remap_qubits(mapping);
-            new_noise
-                .add_operator_product((new_left, new_right), rate.clone())
-                .expect("Internal bug in add_operator_product");
+            /// Implement `-` for self with self-type.
+            ///
+            /// Args:
+            ///     other (self): value by which to subtract from self.
+            ///
+            /// Returns:
+            ///     self: The two objects subtracted.
+            ///
+            /// Raises:
+            ///     ValueError: Objects could not be subtracted.
+            pub fn __sub__(&self, other: #ident) -> PyResult<#ident> {
+                let new_self = (self.clone().internal - other.internal);
+                Ok(#ident {
+                    internal: new_self
+                })
+            }
         }
-        new_noise
-    }
+    } else {
+        TokenStream::new()
+    };
+    let hermitian_calculus_quote = if attribute_arguments.contains("HermitianCalculus") {
+        quote! {
+            /// Implement `-1` for self.
+            ///
+            /// Returns:
+            ///     self: The object * -1.
+            pub fn __neg__(&self) -> #ident {
+                #ident {
+                    internal: -self.clone().internal
+                }
+            }
 
-    /// Separate self into an operator with the terms of given number of spins and an operator with the remaining operations
-    ///
-    /// # Arguments
-    ///
-    /// * `number_spins_left` - Number of spins to filter for in the left term of the keys.
-    /// * `number_spins_right` - Number of spins to filter for in the right term of the keys.
-    ///
-    /// # Returns
-    ///
-    /// `Ok((separated, remainder))` - Operator with the noise terms where number_spins_left and number_spins_right match the number of spins the left and right noise operator product acts on and Operator with all other contributions.
-    pub fn separate_into_n_terms(
-        &self,
-        number_spins_left: usize,
-        number_spins_right: usize,
-    ) -> Result<(Self, Self), StruqtureError> {
-        let mut separated = Self::default();
-        let mut remainder = Self::default();
-        for ((prod_l, prod_r), val) in self.iter() {
-            if prod_l.iter().len() == number_spins_left && prod_r.iter().len() == number_spins_right
-            {
-                separated.add_operator_product((prod_l.clone(), prod_r.clone()), val.clone())?;
-            } else {
-                remainder.add_operator_product((prod_l.clone(), prod_r.clone()), val.clone())?;
+            /// Implement `+` for self with self-type.
+            ///
+            /// Args:
+            ///     other (self): value by which to add to self.
+            ///
+            /// Returns:
+            ///     self: The two objects added.
+            ///
+            /// Raises:
+            ///     ValueError: Objects could not be added.
+            pub fn __add__(&self, other: #ident) -> PyResult<#ident> {
+                let new_self = (self.clone().internal + other.internal).map_err(|err| PyValueError::new_err(format!("Objects could not be added: {:?}", err)))?;
+                Ok(#ident {
+                    internal: new_self
+                })
             }
-        }
-        Ok((separated, remainder))
-    }
-}
 
-/// Implements the negative sign function of SpinLindbladNoiseOperator.
-///
-impl ops::Neg for SpinLindbladNoiseOperator {
-    type Output = SpinLindbladNoiseOperator;
-    /// Implement minus sign for SpinLindbladNoiseOperator.
-    ///
-    /// # Returns
-    ///
-    /// * `Self` - The SpinLindbladNoiseOperator * -1.
-    fn neg(self) -> Self {
-        #[cfg(not(feature = "indexed_map_iterators"))]
-        let mut internal = HashMap::with_capacity(self.len());
-        #[cfg(feature = "indexed_map_iterators")]
-        let mut internal = IndexMap::with_capacity(self.len());
-        for (key, val) in self {
-            internal.insert(key.clone(), val.neg());
-        }
-        SpinLindbladNoiseOperator {
-            internal_map: internal,
+            /// Implement `-` for self with self-type.
+            ///
+            /// Args:
+            ///     other (self): value by which to subtract from self.
+            ///
+            /// Returns:
+            ///     self: The two objects subtracted.
+            ///
+            /// Raises:
+            ///     ValueError: Objects could not be subtracted.
+            pub fn __sub__(&self, other: #ident) -> PyResult<#ident> {
+                let new_self = (self.clone().internal - other.internal).map_err(|err| PyValueError::new_err(format!("Objects could not be subtracted: {:?}", err)))?;
+                Ok(#ident {
+                    internal: new_self
+                })
+            }
         }
-    }
-}
+    } else {
+        TokenStream::new()
+    };
+    let q = quote! {
 
-/// Implements the plus function of SpinLindbladNoiseOperator by SpinLindbladNoiseOperator.
-///
-impl<T, V> ops::Add<T> for SpinLindbladNoiseOperator
-where
-    T: IntoIterator<Item = ((DecoherenceProduct, DecoherenceProduct), V)>,
-    V: Into<CalculatorComplex>,
-{
-    type Output = Self;
-    /// Implements `+` (add) for two SpinLindbladNoiseOperators.
-    ///
-    /// # Arguments
-    ///
-    /// * `other` - The SpinLindbladNoiseOperator to be added.
-    ///
-    /// # Returns
-    ///
-    /// * `Self` - The two SpinLindbladNoiseOperators added together.
-    ///
-    /// # Panics
-    ///
-    /// * Internal error in add_operator_product.
-    fn add(mut self, other: T) -> Self {
-        for (key, value) in other.into_iter() {
-            self.add_operator_product(key.clone(), Into::<CalculatorComplex>::into(value))
-                .expect("Internal bug in add_operator_product");
-        }
-        self
-    }
-}
+        impl #ident {
+            /// Fallible conversion of generic python object.
+            pub fn from_pyany(input: Py<PyAny>) -> PyResult<#struct_ident> {
+                Python::with_gil(|py| -> PyResult<#struct_ident> {
+                    let source_serialisation_meta = input.call_method0(py, "_get_serialisation_meta").map_err(|_| {
+                        PyTypeError::new_err("Trying to use Python object as a struqture-py object that does not behave as struqture-py object. Are you sure you have the right type to all functions?".to_string())
+                    })?;
+                    let source_serialisation_meta: String = source_serialisation_meta.extract(py).map_err(|_| {
+                        PyTypeError::new_err("Trying to use Python object as a struqture-py object that does not behave as struqture-py object. Are you sure you have the right type to all functions?".to_string())
+                    })?;
+
+                    let source_serialisation_meta: struqture::StruqtureSerialisationMeta = serde_json::from_str(&source_serialisation_meta).map_err(|_| {
+                        PyTypeError::new_err("Trying to use Python object as a struqture-py object that does not behave as struqture-py object. Are you sure you have the right type to all functions?".to_string())
+                    })?;
+
+                    let target_serialisation_meta = <#struct_ident as struqture::SerializationSupport>::target_serialisation_meta();
+
+                    struqture::check_can_be_deserialised(&target_serialisation_meta, &source_serialisation_meta).map_err(|err| {
+                        PyTypeError::new_err(err.to_string())
+                    })?;
+
+                    let input = input.as_ref(py);
+                    if let Ok(try_downcast) = input.extract::<#ident>() {
+                        return Ok(try_downcast.internal);
+                    } else {
+                        let get_bytes = input.call_method0("to_bincode").map_err(|_| {
+                            PyTypeError::new_err("Serialisation failed".to_string())
+                        })?;
+                        let bytes = get_bytes.extract::<Vec<u8>>().map_err(|_| {
+                            PyTypeError::new_err("Deserialisation failed".to_string())
+                        })?;
+                        deserialize(&bytes[..]).map_err(|err| {
+                            PyTypeError::new_err(format!(
+                                "Type conversion failed: {}",
+                                err
+                            ))}
+                        )
+                    }
+                })
+            }
 
-/// Implements the minus function of SpinLindbladNoiseOperator by SpinLindbladNoiseOperator.
-///
-impl<T, V> ops::Sub<T> for SpinLindbladNoiseOperator
-where
-    T: IntoIterator<Item = ((DecoherenceProduct, DecoherenceProduct), V)>,
-    V: Into<CalculatorComplex>,
-{
-    type Output = Self;
-    /// Implements `-` (subtract) for two SpinLindbladNoiseOperators.
-    ///
-    /// # Arguments
-    ///
-    /// * `other` - The SpinLindbladNoiseOperator to be subtracted.
-    ///
-    /// # Returns
-    ///
-    /// * `Self` - The two SpinLindbladNoiseOperators subtracted.
-    ///
-    /// # Panics
-    ///
-    /// * Internal error in add_operator_product.
-    fn sub(mut self, other: T) -> Self {
-        for (key, value) in other.into_iter() {
-            self.add_operator_product(key.clone(), Into::<CalculatorComplex>::into(value) * -1.0)
-                .expect("Internal bug in add_operator_product");
-        }
-        self
-    }
-}
+            /// Fallible conversion of generic python object that is implemented in struqture 1.x.
+            #[cfg(feature = "struqture_1_import")]
+            pub fn from_pyany_struqture_one(input: Py<PyAny>) -> PyResult<#struct_ident> {
+                Python::with_gil(|py| -> PyResult<#struct_ident> {
+                    let input = input.as_ref(py);
+                    let get_bytes = input
+                        .call_method0("to_bincode")
+                        .map_err(|_| PyTypeError::new_err("Serialisation failed".to_string()))?;
+                    let bytes = get_bytes
+                        .extract::<Vec<u8>>()
+                        .map_err(|_| PyTypeError::new_err("Deserialisation failed".to_string()))?;
+                    let one_import = deserialize(&bytes[..])
+                        .map_err(|err| PyTypeError::new_err(format!("Type conversion failed: {}", err)))?;
+                    let qubit_operator: #struct_ident = #struct_ident::from_struqture_1(&one_import).map_err(
+                        |err| PyValueError::new_err(format!("Trying to obtain struqture 2.x object from struqture 1.x object. Conversion failed. Was the right type passed to all functions? {:?}", err)
+                    ))?;
+                    Ok(qubit_operator)
+                })
+            }
 
-/// Implements the multiplication function of SpinLindbladNoiseOperator by CalculatorComplex/CalculatorFloat.
-///
-impl<T> ops::Mul<T> for SpinLindbladNoiseOperator
-where
-    T: Into<CalculatorComplex>,
-{
-    type Output = Self;
-    /// Implement `*` for SpinLindbladNoiseOperator and CalculatorComplex/CalculatorFloat.
-    ///
-    /// # Arguments
-    ///
-    /// * `other` - The CalculatorComplex or CalculatorFloat by which to multiply.
-    ///
-    /// # Returns
-    ///
-    /// * `Self` - The SpinLindbladNoiseOperator multiplied by the CalculatorComplex/CalculatorFloat.
-    fn mul(self, other: T) -> Self {
-        let other_cc = Into::<CalculatorComplex>::into(other);
-        #[cfg(not(feature = "indexed_map_iterators"))]
-        let mut internal = HashMap::with_capacity(self.len());
-        #[cfg(feature = "indexed_map_iterators")]
-        let mut internal = IndexMap::with_capacity(self.len());
-        for (key, val) in self {
-            internal.insert(key, val * other_cc.clone());
-        }
-        SpinLindbladNoiseOperator {
-            internal_map: internal,
+            /// Fallible conversion of generic python object that is implemented in struqture 1.x.
+            #[cfg(feature = "struqture_1_export")]
+            pub fn from_pyany_to_struqture_one(
+                input: Py<PyAny>,
+            ) -> PyResult<struqture_one::#struqture_one_module::#struqture_one_ident> {
+                let res = #ident::from_pyany(input)?;
+                let one_export = #struct_ident::to_struqture_1(&res).map_err(
+                    |err| PyValueError::new_err(format!("Trying to obtain struqture 2.x object from struqture 1.x object. Conversion failed. Was the right type passed to all functions? {:?}", err)
+                ))?;
+                Ok(one_export)
+            }
         }
-    }
-}
+        #[pymethods]
+        impl #ident {
 
-/// Implements the into_iter function (IntoIterator trait) of SpinLindbladNoiseOperator.
-///
-impl IntoIterator for SpinLindbladNoiseOperator {
-    type Item = ((DecoherenceProduct, DecoherenceProduct), CalculatorComplex);
-    #[cfg(not(feature = "indexed_map_iterators"))]
-    type IntoIter = std::collections::hash_map::IntoIter<
-        (DecoherenceProduct, DecoherenceProduct),
-        CalculatorComplex,
-    >;
-    #[cfg(feature = "indexed_map_iterators")]
-    type IntoIter =
-        indexmap::map::IntoIter<(DecoherenceProduct, DecoherenceProduct), CalculatorComplex>;
-
-    /// Returns the SpinLindbladNoiseOperator in Iterator form.
-    ///
-    /// # Returns
-    ///
-    /// * `Self::IntoIter` - The SpinLindbladNoiseOperator in Iterator form.
-    fn into_iter(self) -> Self::IntoIter {
-        self.internal_map.into_iter()
-    }
-}
+            #(#items)*
 
-/// Implements the into_iter function (IntoIterator trait) of reference SpinLindbladNoiseOperator.
-///
-impl<'a> IntoIterator for &'a SpinLindbladNoiseOperator {
-    type Item = (
-        &'a (DecoherenceProduct, DecoherenceProduct),
-        &'a CalculatorComplex,
-    );
-    type IntoIter = Iter<'a, (DecoherenceProduct, DecoherenceProduct), CalculatorComplex>;
-
-    /// Returns the reference SpinLindbladNoiseOperator in Iterator form.
-    ///
-    /// # Returns
-    ///
-    /// * `Self::IntoIter` - The reference SpinLindbladNoiseOperator in Iterator form.
-    fn into_iter(self) -> Self::IntoIter {
-        self.internal_map.iter()
-    }
-}
+            #operate_on_density_matrix_quote
+            #operate_on_state_quote
+            #operate_on_modes_quote
+            #operate_on_spins_quote
+            #to_sparse_matrix_operator_quote
+            #to_sparse_matrix_superoperator_quote
+            #operate_on_mixedsystems_quote
+            #calculus_quote
+            #hermitian_calculus_quote
+
+            // ----------------------------------
+            // Default pyo3 implementations
+
+            // add in a function converting struqture_one (not py) to struqture 2
+            // take a pyany, implement from_pyany by hand (or use from_pyany_struqture_one internally) and wrap the result in a struqture 2 spin operator wrapper
+            #[cfg(feature = "struqture_1_import")]
+            #[staticmethod]
+            pub fn from_struqture_one(input: Py<PyAny>) -> PyResult<#ident> {
+                let qubit_operator: #struct_ident =
+                    #ident::from_pyany_struqture_one(input)?;
+                Ok(#ident {
+                    internal: qubit_operator,
+                })
+            }
 
-/// Implements the from_iter function (FromIterator trait) of SpinLindbladNoiseOperator.
-///
-impl FromIterator<((DecoherenceProduct, DecoherenceProduct), CalculatorComplex)>
-    for SpinLindbladNoiseOperator
-{
-    /// Returns the object in SpinLindbladNoiseOperator form, from an Iterator form of the object.
-    ///
-    /// # Arguments
-    ///
-    /// * `iter` - The iterator containing the information from which to create the SpinLindbladNoiseOperator.
-    ///
-    /// # Returns
-    ///
-    /// * `Self::IntoIter` - The iterator in SpinLindbladNoiseOperator form.
-    ///
-    /// # Panics
-    ///
-    /// * Internal error in add_operator_product.
-    fn from_iter<
-        I: IntoIterator<Item = ((DecoherenceProduct, DecoherenceProduct), CalculatorComplex)>,
-    >(
-        iter: I,
-    ) -> Self {
-        let mut slno = SpinLindbladNoiseOperator::new();
-        for (pair, cc) in iter {
-            slno.add_operator_product(pair, cc)
-                .expect("Internal bug in add_operator_product");
-        }
-        slno
-    }
-}
+            // add in a function converting struqture_one (not py) to struqture 2
+            // take a pyany, implement from_pyany by hand (or use from_pyany_struqture_one internally) and wrap the result in a struqture 2 spin operator wrapper
+            #[cfg(feature = "struqture_1_import")]
+            #[staticmethod]
+            pub fn from_json_struqture_one(input: String) -> PyResult<#ident> {
+                let qubit_operator: struqture_one::#struqture_one_module::#struqture_one_ident =
+                    serde_json::from_str(&input).map_err(|err| {
+                        PyValueError::new_err(format!(
+                            "Input cannot be deserialized from json to struqture 1.x: {}",
+                            err
+                        ))
+                    })?;
+                Ok(#ident {
+                    internal: #struct_ident::from_struqture_1(&qubit_operator).map_err(|err| {
+                        PyValueError::new_err(format!(
+                            "Trying to obtain struqture 2.x object from struqture 1.x object. Conversion failed. Was the right type passed to all functions? {:?}", err
+                        ))
+                    })?,
+                })
+            }
 
-/// Implements the extend function (Extend trait) of SpinLindbladNoiseOperator.
-///
-impl Extend<((DecoherenceProduct, DecoherenceProduct), CalculatorComplex)>
-    for SpinLindbladNoiseOperator
-{
-    /// Extends the SpinLindbladNoiseOperator by the specified operations (in Iterator form).
-    ///
-    /// # Arguments
-    ///
-    /// * `iter` - The iterator containing the operations by which to extend the SpinLindbladNoiseOperator.
-    ///
-    /// # Panics
-    ///
-    /// * Internal error in add_operator_product.
-    fn extend<
-        I: IntoIterator<Item = ((DecoherenceProduct, DecoherenceProduct), CalculatorComplex)>,
-    >(
-        &mut self,
-        iter: I,
-    ) {
-        for (pair, cc) in iter {
-            self.add_operator_product(pair, cc)
-                .expect("Internal bug in add_operator_product");
-        }
-    }
-}
+            /// Return a copy of self (copy here produces a deepcopy).
+            ///
+            /// Returns:
+            ///     self: A deep copy of self.
+            pub fn __copy__(&self) -> #ident {
+                self.clone()
+            }
 
-/// Implements the format function (Display trait) of SpinLindbladNoiseOperator.
-///
-impl fmt::Display for SpinLindbladNoiseOperator {
-    /// Formats the SpinLindbladNoiseOperator using the given formatter.
-    ///
-    /// # Arguments
-    ///
-    /// * `f` - The formatter to use.
-    ///
-    /// # Returns
-    ///
-    /// * `std::fmt::Result` - The formatted SpinLindbladNoiseOperator.
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        let mut output = "SpinLindbladNoiseOperator{\n".to_string();
-        for (key, val) in self.iter() {
-            writeln!(output, "({}, {}): {},", key.0, key.1, val)?;
-        }
-        output.push('}');
+            /// Return a deep copy of self.
+            ///
+            /// Returns:
+            ///     self: A deep copy of self.
+            pub fn __deepcopy__(&self, _memodict: Py<PyAny>) -> #ident {
+                self.clone()
+            }
 
-        write!(f, "{}", output)
-    }
-}
+            /// Convert the bincode representation of self to an instance using the [bincode] crate.
+            ///
+            /// Args:
+            ///     input (ByteArray): The serialized object (in [bincode] form).
+            ///
+            /// Returns:
+            ///    The deserialized object.
+            ///
+            /// Raises:
+            ///     TypeError: Input cannot be converted to byte array.
+            ///     ValueError: Input cannot be deserialized.
+            #[staticmethod]
+            pub fn from_bincode(input: &PyAny) -> PyResult<#ident> {
+                let bytes = input
+                    .extract::<Vec<u8>>()
+                    .map_err(|_| PyTypeError::new_err("Input cannot be converted to byte array"))?;
+
+                Ok(#ident {
+                    internal: bincode::deserialize(&bytes[..]).map_err(|err| {
+                        PyValueError::new_err(format!(
+                            "Input cannot be deserialized from bytes. {}",
+                            err
+                        ))
+                    })?,
+                })
+            }
 
-/// Add anti-commutator Lindblad contributions
-fn add_anti_commutator(
-    left: &DecoherenceProduct,
-    right: &DecoherenceProduct,
-    row: usize,
-    dimension: usize,
-    number_spins: usize,
-    entries: &mut HashMap<usize, Complex64>,
-    value: &CalculatorComplex,
-) -> Result<(), StruqtureError> {
-    let constant_prefactor = -0.5;
-    let (right_conj, conjugate_prefactor) = right.hermitian_conjugate();
-    let (product, product_prefactor) = DecoherenceProduct::multiply(right_conj, left.clone());
-    for (row_adjusted, shift, (operator, transpose_prefactor)) in [
-        (
-            row.div_euclid(dimension),
-            number_spins,
-            (product.clone(), 1.0),
-        ),
-        (row % dimension, 0, product.hermitian_conjugate()),
-    ] {
-        let mut column = row;
-        let mut prefac = Complex64::new(1.0, 0.0);
-        // iterate over Lindblad terms
-        for (spin_op_index, dec_op) in operator.iter() {
-            match dec_op {
-                SingleDecoherenceOperator::X => {
-                    match row_adjusted.div_euclid(2usize.pow(*spin_op_index as u32)) % 2 {
-                        0 => column += 2usize.pow((*spin_op_index + shift) as u32),
-                        1 => column -= 2usize.pow((*spin_op_index + shift) as u32),
-                        _ => panic!("Internal error in constructing matrix"),
-                    }
-                }
-                SingleDecoherenceOperator::IY => {
-                    match row_adjusted.div_euclid(2usize.pow(*spin_op_index as u32)) % 2 {
-                        0 => {
-                            column += 2usize.pow((*spin_op_index + shift) as u32);
-                            // due to the transpose in i p H => i I.kron(H.T) only the Y Pauli operator picks up an extra
-                            // sign equal to the commutato_prefactor
-                            prefac *= 1.0;
-                        }
-                        1 => {
-                            column -= 2usize.pow((*spin_op_index + shift) as u32);
-                            prefac *= -1.0;
-                        }
-                        _ => panic!("Internal error in constructing matrix"),
-                    };
-                }
-                SingleDecoherenceOperator::Z => {
-                    match row_adjusted.div_euclid(2usize.pow(*spin_op_index as u32)) % 2 {
-                        0 => {
-                            prefac *= 1.0;
-                        }
-                        1 => {
-                            prefac *= -1.0;
-                        }
-                        _ => panic!("Internal error in constructing matrix"),
-                    };
-                }
-                SingleDecoherenceOperator::Identity => (),
+            /// Return the bincode representation of self using the [bincode] crate.
+            ///
+            /// Returns:
+            ///     ByteArray: The serialized object (in [bincode] form).
+            ///
+            /// Raises:
+            ///     ValueError: Cannot serialize object to bytes.
+            pub fn to_bincode(&self) -> PyResult<Py<PyByteArray>> {
+                let serialized = bincode::serialize(&self.internal).map_err(|_| {
+                    PyValueError::new_err("Cannot serialize object to bytes")
+                })?;
+                let b: Py<PyByteArray> = Python::with_gil(|py| -> Py<PyByteArray> {
+                    PyByteArray::new(py, &serialized[..]).into()
+                });
+                Ok(b)
             }
-        }
-        prefac *=
-            transpose_prefactor * conjugate_prefactor * product_prefactor * constant_prefactor;
-        let mut_value = entries.get_mut(&column);
-        let value = Complex64 {
-            re: *value.re.float()?,
-            im: *value.im.float()?,
-        };
-        match mut_value {
-            Some(x) => *x += value * prefac,
-            None => {
-                entries.insert(column, value * prefac);
+
+            /// Return the json representation of self.
+            ///
+            /// Returns:
+            ///     str: The serialized form of self.
+            ///
+            /// Raises:
+            ///     ValueError: Cannot serialize object to json.
+            pub fn to_json(&self) -> PyResult<String> {
+                let serialized = serde_json::to_string(&self.internal)
+                    .map_err(|_| PyValueError::new_err("Cannot serialize object to json".to_string()))?;
+                Ok(serialized)
             }
-        }
-    }
-    Ok(())
-}
 
-/// Add Lindblad terms that are not part of the anti-commutator
-fn add_lindblad_terms(
-    left: &DecoherenceProduct,
-    right: &DecoherenceProduct,
-    row: usize,
-    dimension: usize,
-    number_spins: usize,
-    entries: &mut HashMap<usize, Complex64>,
-    value: &CalculatorComplex,
-) -> Result<(), StruqtureError> {
-    let mut column = row;
-    let mut prefac = 1.0;
-    // first the terms corresponding to -i H p => -i H.kron(I) flatten(p)
-    for (index_operator_iter, shift, div_euclid) in
-        [(left.iter(), number_spins, true), (right.iter(), 0, false)]
-    {
-        for (index, operator) in index_operator_iter {
-            let row_adjusted = if div_euclid {
-                row.div_euclid(dimension)
-            } else {
-                row % dimension
-            };
-
-            match operator {
-                SingleDecoherenceOperator::X => {
-                    match row_adjusted.div_euclid(2usize.pow(*index as u32)) % 2 {
-                        0 => column += 2usize.pow((*index + shift) as u32),
-                        1 => column -= 2usize.pow((*index + shift) as u32),
-                        _ => panic!("Internal error in constructing matrix"),
-                    }
-                }
-                SingleDecoherenceOperator::IY => {
-                    match row_adjusted.div_euclid(2usize.pow(*index as u32)) % 2 {
-                        0 => {
-                            column += 2usize.pow((*index + shift) as u32);
-                            // due to the transpose in i p H => i I.kron(H.T) only the Y Pauli operator picks up an extra
-                            // sign equal to the commutator_prefactor
-                            prefac *= 1.0;
-                        }
-                        1 => {
-                            column -= 2usize.pow((*index + shift) as u32);
-                            prefac *= -1.0;
-                        }
-                        _ => panic!("Internal error in constructing matrix"),
-                    };
-                }
-                SingleDecoherenceOperator::Z => {
-                    match row_adjusted.div_euclid(2usize.pow(*index as u32)) % 2 {
-                        0 => {
-                            prefac *= 1.0;
-                        }
-                        1 => {
-                            prefac *= -1.0;
-                        }
-                        _ => panic!("Internal error in constructing matrix"),
-                    };
-                }
-                SingleDecoherenceOperator::Identity => (),
+            /// Convert the json representation of self to an instance.
+            ///
+            /// Args:
+            ///     input (str): The serialized object in json form.
+            ///
+            /// Returns:
+            ///     The deserialized object.
+            ///
+            /// Raises:
+            ///     ValueError: Input cannot be deserialized.
+            #[staticmethod]
+            #[pyo3(text_signature = "(input)")]
+            pub fn from_json(input: String) -> PyResult<#ident> {
+                Ok(#ident {
+                    internal: serde_json::from_str(&input).map_err(|err| {
+                        PyValueError::new_err(format!(
+                            "Input cannot be deserialized: {}",
+                            err
+                        ))
+                    })?,
+                })
             }
-        }
-    }
-    let mut_value = entries.get_mut(&column);
-    let value = Complex64 {
-        re: *value.re.float()?,
-        im: *value.im.float()?,
-    };
-    match mut_value {
-        Some(x) => *x += value * prefac,
-        None => {
-            entries.insert(column, value * prefac);
-        }
-    }
-    Ok(())
-}
 
-impl JordanWignerSpinToFermion for SpinLindbladNoiseOperator {
-    type Output = FermionLindbladNoiseOperator;
+            /// Return a string containing a printable representation of self.
+            ///
+            /// Returns:
+            ///     str: The printable string representation of self.
+            pub fn __str__(&self) -> String {
+                format!("{}", self.internal)
+            }
 
-    /// Implements JordanWignerSpinToFermion for a SpinLindbladNoiseOperator.
-    ///
-    /// The convention used is that |0> represents an empty fermionic state (spin-orbital),
-    /// and |1> represents an occupied fermionic state.
-    ///
-    /// # Returns
-    ///
-    /// `FermionLindbladNoiseOperator` - The fermionic noise operator that results from the transformation.
-    fn jordan_wigner(&self) -> Self::Output {
-        let mut out = FermionLindbladNoiseOperator::new();
-
-        for key in self.keys() {
-            let fermion_operator_left = key.0.jordan_wigner();
-            let fermion_operator_right = key.1.jordan_wigner();
-
-            out.add_noise_from_full_operators(
-                &fermion_operator_left,
-                &fermion_operator_right,
-                self.get(key).into(),
-            )
-            .expect("Internal bug in add_noise_from_full_operators");
-        }
-        out
-    }
-}
+            /// Return a string containing a printable representation of self.
+            ///
+            /// Returns:
+            ///     str: The printable string representation of self.
+            pub fn __repr__(&self) -> String {
+                format!("{}", self.internal)
+            }
 
-#[cfg(test)]
-mod test {
-    use super::*;
-    use serde_test::{assert_tokens, Configure, Token};
-
-    // Test the Clone and PartialEq traits of SpinOperator
-    #[test]
-    fn so_from_sos() {
-        let pp: DecoherenceProduct = DecoherenceProduct::new().z(0);
-        let sos = SpinLindbladNoiseOperatorSerialize {
-            items: vec![(pp.clone(), pp.clone(), 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
-            },
-        };
-        let mut so = SpinLindbladNoiseOperator::new();
-        so.set((pp.clone(), pp), CalculatorComplex::from(0.5))
-            .unwrap();
-
-        assert_eq!(SpinLindbladNoiseOperator::from(sos.clone()), so);
-        assert_eq!(SpinLindbladNoiseOperatorSerialize::from(so), sos);
-    }
-    // Test the Clone and PartialEq traits of SpinOperator
-    #[test]
-    fn clone_partial_eq() {
-        let pp: DecoherenceProduct = DecoherenceProduct::new().z(0);
-        let sos = SpinLindbladNoiseOperatorSerialize {
-            items: vec![(pp.clone(), pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
-            },
-        };
+            /// Return the __richcmp__ magic method to perform rich comparison operations on object.
+            ///
+            /// Args:
+            ///     other: The object to compare self to.
+            ///     op: Whether they should be equal or not.
+            ///
+            /// Returns:
+            ///     Whether the two operations compared evaluated to True or False
+            ///
+            /// Raises:
+            ///     NotImplementedError: Other comparison not implemented.
+            pub fn __richcmp__(&self, other: Py<PyAny>, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
+                let other = Self::from_pyany(other);
+                match op {
+                    pyo3::class::basic::CompareOp::Eq => match other {
+                        Ok(pauli) => Ok(self.internal == pauli),
+                        _ => Ok(false),
+                    },
+                    pyo3::class::basic::CompareOp::Ne => match other {
+                        Ok(pauli) => Ok(self.internal != pauli),
+                        _ => Ok(true),
+                    },
+                    _ => Err(pyo3::exceptions::PyNotImplementedError::new_err(
+                        "Other comparison not implemented",
+                    )),
+                }
+            }
 
-        // Test Clone trait
-        assert_eq!(sos.clone(), sos);
+            #[cfg(feature = "json_schema")]
+            /// Returns the current version of the struqture library .
+            ///
+            /// Returns:
+            ///     str: The current version of the library.
+            #[staticmethod]
+            pub fn current_version() -> String {
+                return STRUQTURE_VERSION.to_string();
+            }
 
-        // Test PartialEq trait
-        let pp_1: DecoherenceProduct = DecoherenceProduct::new().z(0);
-        let sos_1 = SpinLindbladNoiseOperatorSerialize {
-            items: vec![(pp_1.clone(), pp_1, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
-            },
-        };
-        let pp_2: DecoherenceProduct = DecoherenceProduct::new().z(2);
-        let sos_2 = SpinLindbladNoiseOperatorSerialize {
-            items: vec![(pp_2.clone(), pp_2, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
-            },
-        };
-        assert!(sos_1 == sos);
-        assert!(sos == sos_1);
-        assert!(sos_2 != sos);
-        assert!(sos != sos_2);
-    }
-
-    // Test the Debug trait of SpinOperator
-    #[test]
-    fn debug() {
-        let pp: DecoherenceProduct = DecoherenceProduct::new().z(0);
-        let sos = SpinLindbladNoiseOperatorSerialize {
-            items: vec![(pp.clone(), pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
-            },
-        };
+            #[cfg(feature = "json_schema")]
+            /// Return the minimum version of struqture that supports this object.
+            ///
+            /// Returns:
+            ///     str: The minimum version of the struqture library to deserialize this object.
+            pub fn min_supported_version(&self) -> String {
+                let min_version: (usize, usize, usize) = struqture::SerializationSupport::min_supported_version(&self.internal);
+                return format!("{}.{}.{}", min_version.0, min_version.1, min_version.2);
+            }
 
-        assert_eq!(
-            format!("{:?}", sos),
-            "SpinLindbladNoiseOperatorSerialize { items: [(DecoherenceProduct { items: [(0, Z)] }, DecoherenceProduct { items: [(0, Z)] }, Float(0.5), Float(0.0))], _struqture_version: StruqtureVersionSerializable { major_version: 1, minor_version: 0 } }"
-        );
-    }
-
-    /// Test SpinOperator Serialization and Deserialization traits (readable)
-    #[test]
-    fn serde_readable() {
-        let pp = DecoherenceProduct::new().x(0);
-        let sos = SpinLindbladNoiseOperatorSerialize {
-            items: vec![(pp.clone(), pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
-            },
-        };
+            /// Returns the StruqtureSerialisationMeta of the object.
+            fn _get_serialisation_meta(&self) -> PyResult<String>{
+                let meta = struqture::SerializationSupport::struqture_serialisation_meta(&self.internal);
+                let string = serde_json::to_string(&meta).map_err(|err| PyValueError::new_err(err.to_string()))?;
+                Ok(string)
+            }
 
-        assert_tokens(
-            &sos.readable(),
-            &[
-                Token::Struct {
-                    name: "SpinLindbladNoiseOperatorSerialize",
-                    len: 2,
-                },
-                Token::Str("items"),
-                Token::Seq { len: Some(1) },
-                Token::Tuple { len: 4 },
-                Token::Str("0X"),
-                Token::Str("0X"),
-                Token::F64(0.5),
-                Token::F64(0.0),
-                Token::TupleEnd,
-                Token::SeqEnd,
-                Token::Str("_struqture_version"),
-                Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
-                },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(0),
-                Token::StructEnd,
-                Token::StructEnd,
-            ],
-        );
-    }
-
-    /// Test SpinOperator Serialization and Deserialization traits (compact)
-    #[test]
-    fn serde_compact() {
-        let pp = DecoherenceProduct::new().x(0);
-        let sos = SpinLindbladNoiseOperatorSerialize {
-            items: vec![(pp.clone(), pp, 0.5.into(), 0.0.into())],
-            _struqture_version: StruqtureVersionSerializable {
-                major_version: 1,
-                minor_version: 0,
-            },
-        };
+            #[cfg(feature = "json_schema")]
+            /// Return the JsonSchema for the json serialisation of the class.
+            ///
+            /// Returns:
+            ///     str: The json schema serialized to json
+            #[staticmethod]
+            pub fn json_schema() -> String {
+                let schema = schemars::schema_for!(#struct_ident);
+                serde_json::to_string_pretty(&schema).expect("Unexpected failure to serialize schema")
+            }
+        }
 
-        assert_tokens(
-            &sos.compact(),
-            &[
-                Token::Struct {
-                    name: "SpinLindbladNoiseOperatorSerialize",
-                    len: 2,
-                },
-                Token::Str("items"),
-                Token::Seq { len: Some(1) },
-                Token::Tuple { len: 4 },
-                Token::Seq { len: Some(1) },
-                Token::Tuple { len: 2 },
-                Token::U64(0),
-                Token::UnitVariant {
-                    name: "SingleDecoherenceOperator",
-                    variant: "X",
-                },
-                Token::TupleEnd,
-                Token::SeqEnd,
-                Token::Seq { len: Some(1) },
-                Token::Tuple { len: 2 },
-                Token::U64(0),
-                Token::UnitVariant {
-                    name: "SingleDecoherenceOperator",
-                    variant: "X",
-                },
-                Token::TupleEnd,
-                Token::SeqEnd,
-                Token::NewtypeVariant {
-                    name: "CalculatorFloat",
-                    variant: "Float",
-                },
-                Token::F64(0.5),
-                Token::NewtypeVariant {
-                    name: "CalculatorFloat",
-                    variant: "Float",
-                },
-                Token::F64(0.0),
-                Token::TupleEnd,
-                Token::SeqEnd,
-                Token::Str("_struqture_version"),
-                Token::Struct {
-                    name: "StruqtureVersionSerializable",
-                    len: 2,
-                },
-                Token::Str("major_version"),
-                Token::U32(1),
-                Token::Str("minor_version"),
-                Token::U32(0),
-                Token::StructEnd,
-                Token::StructEnd,
-            ],
-        );
-    }
+    };
+    q.into()
 }
```

### Comparing `struqture_py-1.6.1/struqture/src/spins/spin_open_system.rs` & `struqture_py-2.0.0a0/struqture/src/spins/qubit_open_system.rs`

 * *Files 12% similar despite different names*

```diff
@@ -6,36 +6,36 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
-use super::SpinLindbladNoiseSystem;
+use super::QubitLindbladNoiseOperator;
 use crate::fermions::FermionLindbladOpenSystem;
 use crate::mappings::JordanWignerSpinToFermion;
-use crate::spins::{OperateOnSpins, SpinHamiltonianSystem, ToSparseMatrixSuperOperator};
+use crate::spins::{OperateOnSpins, QubitHamiltonian, ToSparseMatrixSuperOperator};
 use crate::{CooSparseMatrix, OpenSystem, OperateOnDensityMatrix, StruqtureError};
 use num_complex::Complex64;
 use qoqo_calculator::CalculatorFloat;
 use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
 use std::fmt::{self, Write};
 use std::ops;
 
-/// SpinLindbladOpenSystems are representations of open systems of spins, where a system (SpinHamiltonianSystem) interacts with the environment via noise (SpinLindbladNoiseSystem).
+/// QubitLindbladOpenSystems are representations of open systems of spins, where a system (QubitHamiltonian) interacts with the environment via noise (QubitLindbladNoiseOperator).
 ///
 /// # Example
 ///
 /// ```
 /// use struqture::prelude::*;
 /// use qoqo_calculator::CalculatorComplex;
-/// use struqture::spins::{DecoherenceProduct, SpinLindbladOpenSystem, SpinLindbladNoiseSystem, SpinHamiltonianSystem};
+/// use struqture::spins::{DecoherenceProduct, QubitLindbladOpenSystem, QubitLindbladNoiseOperator, QubitHamiltonian};
 ///
-/// let mut system = SpinLindbladOpenSystem::new(None);
+/// let mut system = QubitLindbladOpenSystem::new();
 ///
 /// // Representing the hamiltonian $ 1/2 \sigma_0^{X} \sigma_1^{X} + 1/5 \sigma_0^{z} $
 /// let pp_01 = DecoherenceProduct::new().x(0).x(1);
 /// let pp_0 = DecoherenceProduct::new().z(0);
 /// system.noise_mut().set((pp_01.clone(), pp_01.clone()), CalculatorComplex::from(0.5)).unwrap();
 /// system.noise_mut().set((pp_0.clone(), pp_0.clone()), CalculatorComplex::from(0.2)).unwrap();
 ///
@@ -43,26 +43,29 @@
 /// assert_eq!(system.noise().get(&(pp_01.clone(), pp_01.clone())), &CalculatorComplex::from(0.5));
 /// assert_eq!(system.noise().get(&(pp_0.clone(), pp_0.clone())), &CalculatorComplex::from(0.2));
 /// ```
 ///
 #[derive(Debug, Clone, PartialEq, Deserialize, Serialize, Default)]
 #[cfg_attr(feature = "json_schema", derive(schemars::JsonSchema))]
 #[cfg_attr(feature = "json_schema", schemars(deny_unknown_fields))]
-pub struct SpinLindbladOpenSystem {
-    /// The SpinHamiltonianSystem representing the system terms of the open system
-    system: SpinHamiltonianSystem,
-    /// The SpinLindbladNoiseSystem representing the noise terms of the open system
-    noise: SpinLindbladNoiseSystem,
+pub struct QubitLindbladOpenSystem {
+    /// The QubitHamiltonian representing the system terms of the open system
+    system: QubitHamiltonian,
+    /// The QubitLindbladNoiseOperator representing the noise terms of the open system
+    noise: QubitLindbladNoiseOperator,
 }
 
-impl crate::MinSupportedVersion for SpinLindbladOpenSystem {}
-
-impl<'a> OpenSystem<'a> for SpinLindbladOpenSystem {
-    type System = SpinHamiltonianSystem;
-    type Noise = SpinLindbladNoiseSystem;
+impl crate::SerializationSupport for QubitLindbladOpenSystem {
+    fn struqture_type() -> crate::StruqtureType {
+        crate::StruqtureType::QubitLindbladOpenSystem
+    }
+}
+impl<'a> OpenSystem<'a> for QubitLindbladOpenSystem {
+    type System = QubitHamiltonian;
+    type Noise = QubitLindbladNoiseOperator;
 
     // From trait
     fn noise(&self) -> &Self::Noise {
         &self.noise
     }
 
     // From trait
@@ -81,84 +84,51 @@
     }
 
     // From trait
     fn ungroup(self) -> (Self::System, Self::Noise) {
         (self.system, self.noise)
     }
 
-    /// Takes a tuple of a system (SpinHamiltonianSystem) and a noise term (SpinLindbladNoiseSystem) and combines them to be a SpinLindbladOpenSystem.
+    /// Takes a tuple of a system (QubitHamiltonian) and a noise term (QubitLindbladNoiseOperator) and combines them to be a QubitLindbladOpenSystem.
     ///
     /// # Arguments
     ///
-    /// * `system` - The SpinHamiltonianSystem to have in the SpinLindbladOpenSystem.
-    /// * `noise` - The SpinLindbladNoiseSystem to have in the SpinLindbladOpenSystem.
+    /// * `system` - The QubitHamiltonian to have in the QubitLindbladOpenSystem.
+    /// * `noise` - The QubitLindbladNoiseOperator to have in the QubitLindbladOpenSystem.
     ///
     /// # Returns
     ///
-    /// * `Ok(Self)` - The SpinLindbladOpenSystem with input system and noise terms.
+    /// * `Ok(Self)` - The QubitLindbladOpenSystem with input system and noise terms.
     /// * `Err(StruqtureError::MissmatchedNumberSpins)` - The system and noise do not have the same number of modes.
     fn group(system: Self::System, noise: Self::Noise) -> Result<Self, StruqtureError> {
-        let (system, noise) = if system.number_spins != noise.number_spins {
-            match (system.number_spins, noise.number_spins) {
-                (Some(n), None) => {
-                    if n >= noise.number_spins() {
-                        let mut noise = noise;
-                        noise.number_spins = Some(n);
-                        (system, noise)
-                    } else {
-                        return Err(StruqtureError::MissmatchedNumberSpins);
-                    }
-                }
-                (None, Some(n)) => {
-                    if n >= system.number_spins() {
-                        let mut system = system;
-                        system.number_spins = Some(n);
-                        (system, noise)
-                    } else {
-                        return Err(StruqtureError::MissmatchedNumberSpins);
-                    }
-                }
-                (Some(_), Some(_)) => {
-                    return Err(StruqtureError::MissmatchedNumberSpins);
-                }
-                _ => panic!("Unexpected missmatch of number spins"),
-            }
-        } else {
-            (system, noise)
-        };
         Ok(Self { system, noise })
     }
 
     // From trait
     fn empty_clone(&self) -> Self {
         Self::group(self.system.empty_clone(None), self.noise.empty_clone(None)).expect(
             "Internal error: Number of spins in system and noise unexpectedly does not match.",
         )
     }
 }
 
-impl<'a> OperateOnSpins<'a> for SpinLindbladOpenSystem {
-    /// Gets the maximum number_spins of the SpinHamiltonianSystem/SpinLindbladNoiseSystem.
+impl<'a> OperateOnSpins<'a> for QubitLindbladOpenSystem {
+    /// Gets the maximum number_spins of the QubitHamiltonian/QubitLindbladNoiseOperator.
     ///
     /// # Returns
     ///
-    /// * `usize` - The number of spins in the SpinLindbladOpenSystem.
-    fn number_spins(&self) -> usize {
-        self.system.number_spins().max(self.noise.number_spins())
-    }
-
-    // From trait
+    /// * `usize` - The number of spins in the QubitLindbladOpenSystem.
     fn current_number_spins(&self) -> usize {
         self.system
             .current_number_spins()
             .max(self.noise.current_number_spins())
     }
 }
 
-impl<'a> ToSparseMatrixSuperOperator<'a> for SpinLindbladOpenSystem {
+impl<'a> ToSparseMatrixSuperOperator<'a> for QubitLindbladOpenSystem {
     // From trait
     fn sparse_matrix_superoperator_entries_on_row(
         &'a self,
         row: usize,
         number_spins: usize,
     ) -> Result<HashMap<usize, Complex64>, StruqtureError> {
         let mut system_row = self
@@ -189,144 +159,166 @@
     fn sparse_lindblad_entries(
         &'a self,
     ) -> Result<Vec<(CooSparseMatrix, CooSparseMatrix, Complex64)>, StruqtureError> {
         let mut coo_matrices =
             Vec::<(CooSparseMatrix, CooSparseMatrix, Complex64)>::with_capacity(self.noise.len());
         for ((left, right), val) in self.noise.iter() {
             coo_matrices.push((
-                left.to_coo(self.number_spins()).unwrap(),
-                right.to_coo(self.number_spins()).unwrap(),
+                left.to_coo(self.current_number_spins()).unwrap(),
+                right.to_coo(self.current_number_spins()).unwrap(),
                 Complex64 {
                     re: *val.re.float()?,
                     im: *val.im.float()?,
                 },
             ))
         }
         Ok(coo_matrices)
     }
 }
 
-/// Functions for the SpinLindbladOpenSystem
+/// Functions for the QubitLindbladOpenSystem
 ///
-impl SpinLindbladOpenSystem {
-    /// Creates a new SpinLindbladOpenSystem.
-    ///
-    /// # Arguments
-    ///
-    /// * `number_spins` - The number of spins in the system.
+impl QubitLindbladOpenSystem {
+    /// Creates a new QubitLindbladOpenSystem.
     ///
     /// # Returns
     ///
-    /// * `Self` - The new (empty) SpinLindbladOpenSystem.
-    pub fn new(number_spins: Option<usize>) -> Self {
-        SpinLindbladOpenSystem {
-            system: SpinHamiltonianSystem::new(number_spins),
-            noise: SpinLindbladNoiseSystem::new(number_spins),
+    /// * `Self` - The new (empty) QubitLindbladOpenSystem.
+    pub fn new() -> Self {
+        QubitLindbladOpenSystem {
+            system: QubitHamiltonian::new(),
+            noise: QubitLindbladNoiseOperator::new(),
         }
     }
+
+    /// Export to struqture_1 format.
+    #[cfg(feature = "struqture_1_export")]
+    pub fn to_struqture_1(
+        &self,
+    ) -> Result<struqture_one::spins::SpinLindbladOpenSystem, StruqtureError> {
+        let new_system = self.system().to_struqture_1()?;
+        let new_noise = self.noise().to_struqture_1()?;
+
+        struqture_one::OpenSystem::group(new_system, new_noise).map_err(
+            |err| StruqtureError::GenericError { msg:
+                format!("Could not convert struqture 2.x QubitLindbladOpenSystem to 1.x SpinLindbladOpenSystem, group function failed: {:?}.", err)
+            }
+        )
+    }
+
+    /// Import from struqture_1 format.
+    #[cfg(feature = "struqture_1_import")]
+    pub fn from_struqture_1(
+        value: &struqture_one::spins::SpinLindbladOpenSystem,
+    ) -> Result<Self, StruqtureError> {
+        let (system_one, noise_one) = struqture_one::OpenSystem::ungroup(value.clone());
+        let new_system = QubitHamiltonian::from_struqture_1(&system_one)?;
+        let new_noise = QubitLindbladNoiseOperator::from_struqture_1(&noise_one)?;
+        Self::group(new_system, new_noise)
+    }
 }
 
-/// Implements the negative sign function of SpinLindbladOpenSystem.
+/// Implements the negative sign function of QubitLindbladOpenSystem.
 ///
-impl ops::Neg for SpinLindbladOpenSystem {
+impl ops::Neg for QubitLindbladOpenSystem {
     type Output = Self;
-    /// Implement minus sign for SpinLindbladOpenSystem.
+    /// Implement minus sign for QubitLindbladOpenSystem.
     ///
     /// # Returns
     ///
-    /// * `Self` - The SpinLindbladOpenSystem * -1.
+    /// * `Self` - The QubitLindbladOpenSystem * -1.
     fn neg(self) -> Self {
         let (self_sys, self_noise) = self.ungroup();
         Self {
             system: self_sys.neg(),
             noise: self_noise.neg(),
         }
     }
 }
 
-/// Implements the plus function of SpinLindbladOpenSystem by SpinLindbladOpenSystem.
+/// Implements the plus function of QubitLindbladOpenSystem by QubitLindbladOpenSystem.
 ///
-impl ops::Add<SpinLindbladOpenSystem> for SpinLindbladOpenSystem {
+impl ops::Add<QubitLindbladOpenSystem> for QubitLindbladOpenSystem {
     type Output = Result<Self, StruqtureError>;
-    /// Implements `+` (add) for two SpinLindbladOpenSystems.
+    /// Implements `+` (add) for two QubitLindbladOpenSystems.
     ///
     /// # Arguments
     ///
-    /// * `other` - The SpinLindbladOpenSystem to be added.
+    /// * `other` - The QubitLindbladOpenSystem to be added.
     ///
     /// # Returns
     ///
-    /// * `Ok(Self)` - The two SpinLindbladOpenSystems added together.
-    /// * `Err(StruqtureError::NumberSpinsExceeded)` - Index of PauliProduct exceeds that of the SpinHamiltonianSystem.
-    /// * `Err(StruqtureError::NumberSpinsExceeded)` - Index of (DecoherenceProduct, DecoherenceProduct) exceeds that of the SpinLindbladNoiseSystem.
-    fn add(self, other: SpinLindbladOpenSystem) -> Self::Output {
+    /// * `Ok(Self)` - The two QubitLindbladOpenSystems added together.
+    /// * `Err(StruqtureError::NumberSpinsExceeded)` - Index of PauliProduct exceeds that of the QubitHamiltonian.
+    /// * `Err(StruqtureError::NumberSpinsExceeded)` - Index of (DecoherenceProduct, DecoherenceProduct) exceeds that of the QubitLindbladNoiseOperator.
+    fn add(self, other: QubitLindbladOpenSystem) -> Self::Output {
         let (self_sys, self_noise) = self.ungroup();
         let (other_sys, other_noise) = other.ungroup();
-        Self::group((self_sys + other_sys)?, (self_noise + other_noise)?)
+        Self::group(self_sys + other_sys, self_noise + other_noise)
     }
 }
 
-/// Implements the minus function of SpinLindbladOpenSystem by SpinLindbladOpenSystem.
+/// Implements the minus function of QubitLindbladOpenSystem by QubitLindbladOpenSystem.
 ///
-impl ops::Sub<SpinLindbladOpenSystem> for SpinLindbladOpenSystem {
+impl ops::Sub<QubitLindbladOpenSystem> for QubitLindbladOpenSystem {
     type Output = Result<Self, StruqtureError>;
-    /// Implements `-` (subtract) for two SpinLindbladOpenSystems.
+    /// Implements `-` (subtract) for two QubitLindbladOpenSystems.
     ///
     /// # Arguments
     ///
-    /// * `other` - The SpinLindbladOpenSystem to be subtracted.
+    /// * `other` - The QubitLindbladOpenSystem to be subtracted.
     ///
     /// # Returns
     ///
-    /// * `Ok(Self)` - The two SpinLindbladOpenSystems subtracted.
-    /// * `Err(StruqtureError::NumberSpinsExceeded)` - Index of PauliProduct exceeds that of the SpinHamiltonianSystem.
-    /// * `Err(StruqtureError::NumberSpinsExceeded)` - Index of (DecoherenceProduct, DecoherenceProduct) exceeds that of the SpinLindbladNoiseSystem.
-    fn sub(self, other: SpinLindbladOpenSystem) -> Self::Output {
+    /// * `Ok(Self)` - The two QubitLindbladOpenSystems subtracted.
+    /// * `Err(StruqtureError::NumberSpinsExceeded)` - Index of PauliProduct exceeds that of the QubitHamiltonian.
+    /// * `Err(StruqtureError::NumberSpinsExceeded)` - Index of (DecoherenceProduct, DecoherenceProduct) exceeds that of the QubitLindbladNoiseOperator.
+    fn sub(self, other: QubitLindbladOpenSystem) -> Self::Output {
         let (self_sys, self_noise) = self.ungroup();
         let (other_sys, other_noise) = other.ungroup();
-        Self::group((self_sys - other_sys)?, (self_noise - other_noise)?)
+        Self::group(self_sys - other_sys, self_noise - other_noise)
     }
 }
 
-/// Implements the multiplication function of SpinLindbladOpenSystem by CalculatorFloat.
+/// Implements the multiplication function of QubitLindbladOpenSystem by CalculatorFloat.
 ///
-impl ops::Mul<CalculatorFloat> for SpinLindbladOpenSystem {
+impl ops::Mul<CalculatorFloat> for QubitLindbladOpenSystem {
     type Output = Self;
 
-    /// Implement `*` for SpinLindbladOpenSystem and CalculatorFloat.
+    /// Implement `*` for QubitLindbladOpenSystem and CalculatorFloat.
     ///
     /// # Arguments
     ///
     /// * `other` - The CalculatorFloat by which to multiply..
     ///
     /// # Returns
     ///
-    /// * `Self` - The SpinLindbladOpenSystem multiplied by the CalculatorFloat.
+    /// * `Self` - The QubitLindbladOpenSystem multiplied by the CalculatorFloat.
     fn mul(self, rhs: CalculatorFloat) -> Self::Output {
         Self {
             system: self.system * rhs.clone(),
             noise: self.noise * rhs,
         }
     }
 }
 
-/// Implements the format function (Display trait) of SpinLindbladOpenSystem.
+/// Implements the format function (Display trait) of QubitLindbladOpenSystem.
 ///
-impl fmt::Display for SpinLindbladOpenSystem {
-    /// Formats the SpinLindbladOpenSystem using the given formatter.
+impl fmt::Display for QubitLindbladOpenSystem {
+    /// Formats the QubitLindbladOpenSystem using the given formatter.
     ///
     /// # Arguments
     ///
     /// * `f` - The formatter to use.
     ///
     /// # Returns
     ///
-    /// * `std::fmt::Result` - The formatted SpinLindbladOpenSystem.
+    /// * `std::fmt::Result` - The formatted QubitLindbladOpenSystem.
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        let mut output = format!("SpinLindbladOpenSystem({}){{\n", self.number_spins());
+        let mut output = "QubitLindbladOpenSystem{\n".to_string();
         output.push_str("System: {\n");
         for (key, val) in self.system.iter() {
             writeln!(output, "{}: {},", key, val)?;
         }
         output.push_str("}\n");
         output.push_str("Noise: {\n");
         for ((row, column), val) in self.noise.iter() {
@@ -335,29 +327,29 @@
         output.push_str("}\n");
         output.push('}');
 
         write!(f, "{}", output)
     }
 }
 
-impl JordanWignerSpinToFermion for SpinLindbladOpenSystem {
+impl JordanWignerSpinToFermion for QubitLindbladOpenSystem {
     type Output = FermionLindbladOpenSystem;
 
-    /// Implements JordanWignerSpinToSpin for a SpinLindbladOpenSystem.
+    /// Implements JordanWignerSpinToSpin for a QubitLindbladOpenSystem.
     ///
     /// The convention used is that |0> represents an empty fermionic state (spin-orbital),
     /// and |1> represents an occupied fermionic state.
     ///
     /// # Returns
     ///
     /// `FermionLindbladOpenSystem` - The fermion open system that results from the transformation.
     ///
     /// # Panics
     ///
-    /// * Internal error in jordan_wigner() for SpinHamiltonianSystem or SpinLindbladNoiseSystem.
+    /// * Internal error in jordan_wigner() for QubitHamiltonian or QubitLindbladNoiseOperator.
     fn jordan_wigner(&self) -> Self::Output {
         let jw_system = self.system().jordan_wigner();
         let jw_noise = self.noise().jordan_wigner();
         FermionLindbladOpenSystem::group(jw_system, jw_noise)
-            .expect("Internal bug in jordan_wigner() for SpinHamiltonianSystem or SpinLindbladNoiseSystem. The number of modes in the fermionic system should equal the number of spins in the spin system.")
+            .expect("Internal bug in jordan_wigner() for QubitHamiltonian or QubitLindbladNoiseOperator. The number of modes in the fermionic system should equal the number of spins in the spin system.")
     }
 }
```

### Comparing `struqture_py-1.6.1/README.md` & `struqture_py-2.0.0a0/README.md`

 * *Files 0% similar despite different names*

```diff
@@ -10,15 +10,15 @@
 * Support for arbitrary spin, bosonic, fermionic and mixed systems
 * Full serialisation support to json and other formats
 * Preventing construction of unphysical objects by using well defined types for all objects in struqture
 * Support of symbolic values in operators, Hamiltonians and open systems
 
 Following these design goals, we prioritize using distinctive types to construct objects over a less verbose syntax.
 Similarly the support of symbolic expression leads to a trade-off in speed compared to an implementation using only floating point values.
-Struqture is designed to also support the construction and (de)serialisation of large systems but for the use in numeric algorithms we recommend transforming Operators and Hamiltonians into a sparse matrix form.
+Struqture is designed to also support the construction and (de)serialisation of large operators but for the use in numeric algorithms we recommend transforming Operators and Hamiltonians into a sparse matrix form.
 
 ## Documentation
 
 We recommend users to start with the [user documentation](https://hqsquantumsimulations.github.io/struqture/) for stuqture and struqture-py.
 The user documentation is intended to give a high level overview of the design and usage of struqture. For a full list of the available data types and functions see the API-Documentation of [struqture](https://docs.rs/struqture/) and [struqture-py](https://hqsquantumsimulations.github.io/struqture/pyapi/index.html).
 
 ## Installation
```

### Comparing `struqture_py-1.6.1/struqture-py-macros/LICENSE` & `struqture_py-2.0.0a0/struqture-py-macros/LICENSE`

 * *Files identical despite different names*

### Comparing `struqture_py-1.6.1/struqture-py-macros/src/lib.rs` & `struqture_py-2.0.0a0/struqture-py-macros/src/lib.rs`

 * *Files identical despite different names*

### Comparing `struqture_py-1.6.1/struqture-py-macros/src/mappings.rs` & `struqture_py-2.0.0a0/struqture-py-macros/src/mappings.rs`

 * *Files 10% similar despite different names*

```diff
@@ -50,19 +50,22 @@
 
 fn jordan_wigner_spin_to_fermion_quote(
     attribute_arguments: &AttributeMacroArguments,
     struct_name: &str,
 ) -> TokenStream {
     if attribute_arguments.contains("JordanWignerSpinToFermion") {
         let output_wrapper_type;
-        let output_type;
 
-        if struct_name.contains("System") {
+        if struct_name == "QubitHamiltonian"
+            || struct_name == "QubitOperator"
+            || struct_name == "QubitLindbladNoiseOperator"
+            || struct_name == "QubitLindbladOpenSystem"
+        {
             let mut output_wrapper_name = format!("{}Wrapper", struct_name);
-            output_wrapper_name = output_wrapper_name.replace("Spin", "Fermion");
+            output_wrapper_name = output_wrapper_name.replace("Qubit", "Fermion");
             output_wrapper_type = quote::format_ident!("{}", output_wrapper_name);
 
             quote! {
                 /// Transform the given spin object into a fermionic object using
                 /// the Jordan Wigner mapping.
                 pub fn jordan_wigner(&self) -> #output_wrapper_type {
                     #output_wrapper_type {
@@ -72,31 +75,27 @@
             }
         } else {
             if struct_name == "PauliProduct"
                 || struct_name == "DecoherenceProduct"
                 || struct_name == "PlusMinusProduct"
                 || struct_name == "PlusMinusOperator"
             {
-                output_wrapper_type = quote::format_ident!("FermionSystemWrapper");
-                output_type = quote::format_ident!("FermionSystem");
+                output_wrapper_type = quote::format_ident!("FermionOperatorWrapper");
             } else if struct_name == "PlusMinusLindbladNoiseOperator" {
-                output_wrapper_type = quote::format_ident!("FermionLindbladNoiseSystemWrapper");
-                output_type = quote::format_ident!("FermionLindbladNoiseSystem");
+                output_wrapper_type = quote::format_ident!("FermionLindbladNoiseOperatorWrapper");
             } else {
                 panic!("JordanWignerSpinToFermion can only be implemented for spin types!")
             };
 
             quote! {
                 /// Transform the given spin object into a fermionic object using
                 /// the Jordan Wigner mapping.
                 pub fn jordan_wigner(&self) -> #output_wrapper_type {
                     #output_wrapper_type {
-                        internal: #output_type::from_operator(
-                            self.internal.jordan_wigner(), None)
-                            .expect("Internal bug when creating fermionic system object from fermionic operator object.")
+                        internal: self.internal.jordan_wigner()
                     }
                 }
             }
         }
     } else {
         TokenStream::new()
     }
@@ -104,52 +103,47 @@
 
 fn jordan_wigner_fermion_to_spin_quote(
     attribute_arguments: &AttributeMacroArguments,
     struct_name: &str,
 ) -> TokenStream {
     if attribute_arguments.contains("JordanWignerFermionToSpin") {
         let output_wrapper_type;
-        let output_type;
-        let from_method;
 
-        if struct_name.contains("System") {
+        if struct_name.contains("Operator")
+            || struct_name.contains("Hamiltonian")
+            || struct_name.contains("System")
+        {
             let mut output_wrapper_name = format!("{}Wrapper", struct_name);
-            output_wrapper_name = output_wrapper_name.replace("Fermion", "Spin");
+            output_wrapper_name = output_wrapper_name.replace("Fermion", "Qubit");
             output_wrapper_type = quote::format_ident!("{}", output_wrapper_name);
 
             quote! {
                 /// Transform the given fermionic object into a spin object using
                 /// the Jordan Wigner mapping.
                 pub fn jordan_wigner(&self) -> #output_wrapper_type {
                     #output_wrapper_type {
                         internal: self.internal.jordan_wigner()
                     }
                 }
             }
         } else {
             if struct_name == "FermionProduct" {
-                output_wrapper_type = quote::format_ident!("SpinSystemWrapper");
-                output_type = quote::format_ident!("SpinSystem");
-                from_method = quote::format_ident!("from_operator");
+                output_wrapper_type = quote::format_ident!("QubitOperatorWrapper");
             } else if struct_name == "HermitianFermionProduct" {
-                output_wrapper_type = quote::format_ident!("SpinHamiltonianSystemWrapper");
-                output_type = quote::format_ident!("SpinHamiltonianSystem");
-                from_method = quote::format_ident!("from_hamiltonian");
+                output_wrapper_type = quote::format_ident!("QubitHamiltonianWrapper");
             } else {
                 panic!("JordanWignerFermionToSpin can only be implemented for fermionic types!")
             };
 
             quote! {
                 /// Transform the given fermionic object into a spin object using
                 /// the Jordan Wigner mapping.
                 pub fn jordan_wigner(&self) -> #output_wrapper_type {
                     #output_wrapper_type {
-                        internal: #output_type::#from_method(
-                            self.internal.jordan_wigner(), None)
-                            .expect("Internal bug when creating spin system object from spin operator object.")
+                        internal: self.internal.jordan_wigner()
                     }
                 }
             }
         }
     } else {
         TokenStream::new()
     }
```

### Comparing `struqture_py-1.6.1/struqture-py-macros/src/noiseless_system_wrapper.rs` & `struqture_py-2.0.0a0/struqture-py-macros/src/noisy_system_wrapper.rs`

 * *Files 21% similar despite different names*

```diff
@@ -9,349 +9,357 @@
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
 //! struqture-py-macros
 //!
 //! Attribute proc-macros for the traits of struqture-py [struqture-py].
+
 use crate::{strip_python_wrapper_name, AttributeMacroArguments};
 use proc_macro2::TokenStream;
 use quote::quote;
 use syn::{parse_macro_input, ItemImpl};
 
-pub fn noiselesswrapper(
+pub fn noisywrapper(
     metadata: proc_macro::TokenStream,
     input: proc_macro::TokenStream,
 ) -> proc_macro::TokenStream {
     let parsed_input = parse_macro_input!(input as ItemImpl);
     let ident = parsed_input.self_ty;
     let items = parsed_input.items;
     let attribute_arguments = parse_macro_input!(metadata as AttributeMacroArguments);
     let (struct_name, struct_ident) = strip_python_wrapper_name(&ident);
-    let index_type = if struct_name.contains("Spin") {
-        quote::format_ident!("PauliProductWrapper")
-    } else if struct_name.contains("MixedPlusMinusOperator") {
-        quote::format_ident!("MixedPlusMinusProductWrapper")
-    } else if struct_name.contains("PlusMinusOperator") {
-        quote::format_ident!("PlusMinusProductWrapper")
-    } else if struct_name.contains("BosonHamiltonian") {
-        quote::format_ident!("HermitianBosonProductWrapper")
-    } else if struct_name.contains("Boson") {
-        quote::format_ident!("BosonProductWrapper")
-    } else if struct_name.contains("FermionHamiltonian") {
-        quote::format_ident!("HermitianFermionProductWrapper")
-    } else if struct_name.contains("Fermion") {
-        quote::format_ident!("FermionProductWrapper")
-    } else if struct_name.contains("MixedHamiltonian") {
-        quote::format_ident!("HermitianMixedProductWrapper")
-    } else {
-        quote::format_ident!("MixedProductWrapper")
-    };
-    let value_type = if struct_name.contains("SpinHamiltonian") {
-        quote::format_ident!("CalculatorFloatWrapper")
-    } else {
-        quote::format_ident!("CalculatorComplexWrapper")
-    };
+    let (index_type, struqture_one_module, struqture_one_ident) =
+        if struct_name.contains("QubitLindbladNoiseOperator") {
+            (
+                quote::format_ident!("DecoherenceProductWrapper"),
+                quote::format_ident!("spins"),
+                quote::format_ident!("SpinLindbladNoiseSystem"),
+            )
+        } else if struct_name.contains("QubitLindbladOpenSystem") {
+            (
+                quote::format_ident!("DecoherenceProductWrapper"),
+                quote::format_ident!("spins"),
+                quote::format_ident!("SpinLindbladOpenSystem"),
+            )
+        } else if struct_name.contains("PlusMinusLindbladNoiseOperator") {
+            (
+                quote::format_ident!("PlusMinusProductWrapper"),
+                quote::format_ident!("spins"),
+                quote::format_ident!("PlusMinusLindbladNoiseOperator"),
+            )
+        } else if struct_name.contains("MixedLindbladNoiseOperator") {
+            (
+                quote::format_ident!("MixedDecoherenceProductWrapper"),
+                quote::format_ident!("mixed_systems"),
+                quote::format_ident!("MixedLindbladNoiseSystem"),
+            )
+        } else if struct_name.contains("MixedLindbladOpenSystem") {
+            (
+                quote::format_ident!("MixedDecoherenceProductWrapper"),
+                quote::format_ident!("mixed_systems"),
+                quote::format_ident!("MixedLindbladOpenSystem"),
+            )
+        } else if struct_name.contains("BosonLindbladNoiseOperator") {
+            (
+                quote::format_ident!("BosonProductWrapper"),
+                quote::format_ident!("bosons"),
+                quote::format_ident!("BosonLindbladNoiseSystem"),
+            )
+        } else if struct_name.contains("BosonLindbladOpenSystem") {
+            (
+                quote::format_ident!("BosonProductWrapper"),
+                quote::format_ident!("bosons"),
+                quote::format_ident!("BosonLindbladOpenSystem"),
+            )
+        } else if struct_name.contains("FermionLindbladNoiseOperator") {
+            (
+                quote::format_ident!("FermionProductWrapper"),
+                quote::format_ident!("fermions"),
+                quote::format_ident!("FermionLindbladNoiseSystem"),
+            )
+        } else {
+            (
+                quote::format_ident!("FermionProductWrapper"),
+                quote::format_ident!("fermions"),
+                quote::format_ident!("FermionLindbladOpenSystem"),
+            )
+        };
     // ------------
     // Start the generating part of the macro
     let operate_on_density_matrix_quote = if attribute_arguments.contains("OperateOnDensityMatrix")
     {
         quote! {
-                /// Return a list of the unsorted keys in self.
-                ///
-                /// Returns:
-                ///     list[OperatorProduct]: The sequence of keys of the self.
-                pub fn keys(&self) -> Vec<#index_type> {
-                    let mut system_keys: Vec<#index_type> = Vec::new();
-                    for key in self.internal.keys() {
-                        system_keys.push(
-                            #index_type { internal: key.clone() },
-                        );
-                    }
-                    system_keys
-                }
-
-                /// Return number of entries in self.
-                ///
-                /// Returns:
-                ///     int: The length of the content of self.
-                pub fn __len__(&self) -> usize {
-                    self.internal.len()
-                }
-
-                /// Return an instance of self that has no entries but clones all other properties, with the given capacity.
-                ///
-                /// Args:
-                ///     capacity (Optional[int]): The capacity of the new instance to create.
-                ///
-                /// Returns:
-                ///     self: An empty clone with the same properties as self, with the given capacity.
-                #[pyo3(signature = (capacity = None))]
-                pub fn empty_clone(&self, capacity: Option<usize>) -> #ident {
-                    #ident {
-                        internal: self.internal.empty_clone(capacity)
-                    }
-                }
-
-                /// Return true if self contains no values.
-                ///
-                /// Returns:
-                ///     bool: Whether self is empty or not.
-                pub fn is_empty(&self) -> bool {
-                    self.internal.is_empty()
-                }
-
-                /// Truncate self by returning a copy without entries under a threshold.
-                ///
-                /// Args:
-                ///     threshold: The threshold for inclusion.
-                ///
-                /// Returns:
-                ///     self: The truncated version of self.
-                pub fn truncate(&self, threshold: f64) -> #ident {
-                    #ident { internal: self.internal.truncate(threshold) }
-                }
-
                 /// Get the coefficient corresponding to the key.
                 ///
                 /// Args:
                 ///     key: Product to get the value of.
                 ///
                 /// Returns:
                 ///     CalculatorComplex: Value at key (or 0.0).
                 ///
                 /// Raises:
-                ///     ValueError: Product could not be constructed from key.
-                pub fn get(&self, key: Py<PyAny>) -> PyResult<#value_type> {
-                    let converted_key = #index_type::from_pyany(key).map_err(|err| {
-                        PyValueError::new_err(format!(
-                            "Product could not be constructed: {:?}",
-                            err
-                        ))
-                    })?;
-                    Ok(#value_type {
-                        internal: self.clone().internal.get(&converted_key).clone(),
+                ///     ValueError: Left-hand product could not be constructed from key.
+                ///     ValueError: Right-hand product could not be constructed from key.
+                pub fn get(&self, key: (Py<PyAny>, Py<PyAny>)) -> PyResult<CalculatorComplexWrapper> {
+                    let (converted_left, converted_right) = (
+                        #index_type::from_pyany(key.0).map_err(|err| {
+                            PyValueError::new_err(format!(
+                                "Product could not be constructed: {:?}",
+                                err
+                            ))
+                        })?,
+                        #index_type::from_pyany(key.1).map_err(|err| {
+                            PyValueError::new_err(format!(
+                                "Product could not be constructed: {:?}",
+                                err
+                            ))
+                        })?,
+                    );
+                    Ok(CalculatorComplexWrapper {
+                        internal: self
+                            .clone()
+                            .internal
+                            .get(&(converted_left, converted_right))
+                            .clone(),
                     })
                 }
 
-                /// Remove the value of the input key.
+                /// Remove the value of the input object key.
                 ///
                 /// Returns:
-                ///     Optional[Union[CalculatorComplex, CalculatorFloat]]: Key existed if this is not None, and this is the value it had before it was removed.
+                ///     Optional[CalculatorComplex]: Key existed if this is not None, and this is the value it had before it was removed.
                 ///
                 /// Raises:
-                ///     ValueError: Product could not be constructed.
-                pub fn remove(&mut self, key: Py<PyAny>) -> PyResult<Option<#value_type>> {
-                    let converted_key = #index_type::from_pyany(key).map_err(|err| {
-                        PyValueError::new_err(format!(
-                            "Product could not be constructed: {:?}",
-                            err
-                        ))
-                    })?;
-                    match self.internal.remove(&converted_key) {
-                        Some(x) => Ok(Some(#value_type { internal: x })),
+                ///     ValueError: Left-hand Product could not be constructed.
+                ///     ValueError: Right-hand Product could not be constructed.
+                pub fn remove(
+                    &mut self,
+                    key: (Py<PyAny>, Py<PyAny>),
+                ) -> PyResult<Option<CalculatorComplexWrapper>> {
+                    let (converted_left, converted_right) = (
+                        #index_type::from_pyany(key.0).map_err(|err| {
+                            PyValueError::new_err(format!(
+                                "Product could not be constructed: {:?}",
+                                err
+                            ))
+                        })?,
+                        #index_type::from_pyany(key.1).map_err(|err| {
+                            PyValueError::new_err(format!(
+                                "Product could not be constructed: {:?}",
+                                err
+                            ))
+                        })?,
+                    );
+                    match self.internal.remove(&(converted_left, converted_right)) {
+                        Some(x) => Ok(Some(CalculatorComplexWrapper { internal: x })),
                         None => Ok(None),
                     }
                 }
 
                 /// Overwrite an existing entry or set a new entry in self.
                 ///
                 /// Returns:
-                ///     Optional[Union[CalculatorComplex, CalculatorFloat]]: Key existed if this is not None, and this is the value it had before it was overwritten.
+                ///     Optional[CalculatorComplex]: Key existed if this is not None, and this is the value it had before it was overwritten.
                 ///
                 /// Raises:
-                ///     ValueError: Product could not be constructed.
+                ///     ValueError: Left-hand Product could not be constructed.
+                ///     ValueError: Right-hand Product could not be constructed.
                 pub fn set(
                     &mut self,
-                    key: Py<PyAny>,
-                    value: Py<PyAny>,
-                ) -> PyResult<Option<#value_type>> {
-                    let value = #value_type::from_pyany(value)
-                        .map_err(|_| PyTypeError::new_err("Value is not CalculatorComplex or CalculatorFloat"))?;
-                    let converted_key = #index_type::from_pyany(key).map_err(|err| {
-                        PyValueError::new_err(format!(
-                            "Product could not be constructed: {:?}",
-                            err
-                        ))
-                    })?;
-                    match self.internal.set(converted_key, value).map_err(|err| {
-                        PyValueError::new_err(format!(
-                            "Error in set function of System: {:?}",
-                            err
-                        ))
-                    })? {
-                        Some(x) => Ok(Some(#value_type { internal: x })),
+                    key: (Py<PyAny>, Py<PyAny>),
+                    value: &PyAny,
+                ) -> PyResult<Option<CalculatorComplexWrapper>> {
+                    let value = qoqo_calculator_pyo3::convert_into_calculator_complex(value)
+                        .map_err(|_| PyTypeError::new_err("Value is not CalculatorComplex"))?;
+                    let (converted_left, converted_right) = (
+                        #index_type::from_pyany(key.0).map_err(|err| {
+                            PyValueError::new_err(format!(
+                                "Product could not be constructed: {:?}",
+                                err
+                            ))
+                        })?,
+                        #index_type::from_pyany(key.1).map_err(|err| {
+                            PyValueError::new_err(format!(
+                                "Product could not be constructed: {:?}",
+                                err
+                            ))
+                        })?,
+                    );
+                    match self
+                        .internal
+                        .set((converted_left, converted_right), value)
+                        .map_err(|err| {
+                            PyValueError::new_err(format!("Error in set function of FermionOperator: {:?}", err))
+                        })? {
+                        Some(x) => Ok(Some(CalculatorComplexWrapper { internal: x })),
                         None => Ok(None),
                     }
                 }
 
-                /// Add a new (key object, value Union[CalculatorComplex, CalculatorFloat]) pair to existing entries.
+                /// Adds a new (key object, CalculatorComplex) pair to existing entries.
                 ///
                 /// Raises:
                 ///     TypeError: Value is not CalculatorComplex or CalculatorFloat.
-                ///     ValueError: Product could not be constructed.
+                ///     ValueError: Left-hand product could not be constructed.
+                ///     ValueError: Right-hand product could not be constructed.
                 ///     ValueError: Error in add_operator_product function of self.
-                pub fn add_operator_product(&mut self, key: Py<PyAny>, value: Py<PyAny>) -> PyResult<()> {
-                    let value = #value_type::from_pyany(value)
-                        .map_err(|_| PyTypeError::new_err("Value is not CalculatorComplex or CalculatorFloat"))?;
-                    let converted_key = #index_type::from_pyany(key).map_err(|err| {
-                        PyValueError::new_err(format!(
-                            "Product could not be constructed: {:?}",
-                            err
-                        ))
-                    })?;
+                pub fn add_operator_product(
+                    &mut self,
+                    key: (Py<PyAny>, Py<PyAny>),
+                    value: &PyAny,
+                ) -> PyResult<()> {
+                    let value = qoqo_calculator_pyo3::convert_into_calculator_complex(value)
+                        .map_err(|_| PyTypeError::new_err("Value is not CalculatorComplex"))?;
+                    let (converted_left, converted_right) = (
+                        #index_type::from_pyany(key.0).map_err(|err| {
+                            PyValueError::new_err(format!(
+                                "Product could not be constructed: {:?}",
+                                err
+                            ))
+                        })?,
+                        #index_type::from_pyany(key.1).map_err(|err| {
+                            PyValueError::new_err(format!(
+                                "Product could not be constructed: {:?}",
+                                err
+                            ))
+                        })?,
+                    );
                     self.internal
-                        .add_operator_product(converted_key, value)
+                        .add_operator_product((converted_left, converted_right), value)
                         .map_err(|err| {
                             PyValueError::new_err(format!(
-                                "Error in add_operator_product function of System: {:?}",
+                                "Error in add_operator_product function of Operator: {:?}",
                                 err
                             ))
                         })
                 }
 
+                /// Return unsorted keys in self.
+                ///
+                /// Returns:
+                ///     list[(OperatorProduct, OperatorProduct)]: The sequence of keys of self.
+                pub fn keys(&self) -> Vec<(#index_type, #index_type)> {
+                    let mut system_keys: Vec<(#index_type, #index_type)> = Vec::new();
+                    for (key_l, key_r) in self.internal.keys() {
+                        system_keys.push(
+                            (#index_type { internal: key_l.clone() }, #index_type { internal: key_r.clone() })
+                        );
+                }
+                    system_keys
+                }
+
                 /// Return unsorted values in self.
                 ///
                 /// Returns:
-                ///     list[Union[CalculatorComplex, CalculatorFloat]]: The sequence of values of self.
-                pub fn values(&self) -> Vec<#value_type> {
-                    let mut system_values: Vec<#value_type> = Vec::new();
+                ///     list[CalculatorComplex]: The sequence of values of self.
+                pub fn values(&self) -> Vec<CalculatorComplexWrapper> {
+                    let mut system_values: Vec<CalculatorComplexWrapper> = Vec::new();
                     for val in self.internal.values() {
                         system_values.push(
-                            #value_type { internal: val.clone() },
+                            CalculatorComplexWrapper { internal: val.clone() },
                         );
                     }
                     system_values
                 }
-        }
-    } else {
-        TokenStream::new()
-    };
-    let operate_on_state_quote = if attribute_arguments.contains("OperateOnState") {
-        quote! {
-                /// Return the hermitian conjugate of self.
+
+                /// Return number of entries in object.
+                ///
+                /// Returns:
+                ///     int: The length of the content of self.
+                pub fn __len__(&self) -> usize {
+                    self.internal.len()
+                }
+
+                /// Return an instance of self that has no entries but clones all other properties, with the given capacity.
+                ///
+                /// Args:
+                ///     capacity: The capacity of the object to create.
                 ///
                 /// Returns:
-                ///     self: The hermitian conjugate of self.
-                pub fn hermitian_conjugate(&self) -> #ident {
+                ///     self: An empty clone with the same properties as self, with the given capacity.
+                #[pyo3(signature = (capacity = None))]
+                pub fn empty_clone(&self, capacity: Option<usize>) -> #ident {
                     #ident {
-                        internal: self.internal.hermitian_conjugate()
+                        internal: self.internal.empty_clone(capacity)
                     }
                 }
-        }
-    } else {
-        TokenStream::new()
-    };
-    let operate_on_modes_quote = if attribute_arguments.contains("OperateOnModes") {
-        quote! {
-            /// Return maximum index in self.
-            ///
-            /// Returns:
-            ///     int: Maximum index.
-            pub fn current_number_modes(&self) -> usize {
-                self.internal.current_number_modes()
-            }
 
-            /// Return the number_modes input of self.
-            ///
-            /// Returns:
-            ///     int: The number of modes in self.
-            pub fn number_modes(&self) -> usize {
-                self.internal.number_modes()
-            }
-
-            /// Separate self into an operator with the terms of given number of creation and annihilation operators and an operator with the remaining operations.
-            ///
-            /// Args:
-            ///     number_creators_annihilators (Tuple[int, int]): Number of modes to filter for in the keys.
-            ///
-            /// Returns:
-            ///     Tuple[Self, Self]: Operator with the noise terms where the number of creation and annihilation operators matches the number of spins the operator product acts on and Operator with all other contributions.
-            ///
-            /// Raises:
-            ///     ValueError: Error in adding terms to return values.
-            pub fn separate_into_n_terms(&self, number_creators_annihilators: (usize, usize)) -> PyResult<(#ident, #ident)> {
-                let (separated, remainder) = self.internal.separate_into_n_terms(number_creators_annihilators).map_err(|err| PyValueError::new_err(format!("{:?}", err)))?;
-                Ok((
-                    #ident { internal: separated },
-                    #ident { internal: remainder }
-                ))
-            }
-        }
-    } else {
-        TokenStream::new()
-    };
-    let operate_on_spins_quote = if attribute_arguments.contains("OperateOnSpins") {
-        quote! {
-                /// Return maximum spin index in self.
+                /// Return true if object contains no values.
                 ///
                 /// Returns:
-                ///     int: Maximum index.
-                pub fn current_number_spins(&self) -> usize {
-                    self.internal.current_number_spins()
+                ///     bool: Whether self is empty or not.
+                pub fn is_empty(&self) -> bool {
+                    self.internal.is_empty()
                 }
 
-                /// Return the number_spins input of self.
+                /// Truncate self by returning a copy without entries under a threshold.
+                ///
+                /// Args:
+                ///     threshold: The threshold for inclusion.
                 ///
                 /// Returns:
-                ///     int: The number of spins in self.
-                pub fn number_spins(&self) -> usize {
-                    self.internal.number_spins()
+                ///     self: The truncated version of self.
+                pub fn truncate(&self, threshold: f64) -> #ident {
+                    #ident { internal: self.internal.truncate(threshold) }
                 }
 
-                /// Separate self into an operator with the terms of given number of spins and an operator with the remaining operations.
+                /// Implement `*` for self and Union[CalculatorComplex, CalculatorFloat].
                 ///
                 /// Args:
-                ///     number_spins (int): Number of spins to filter for in the keys.
+                ///     value (Union[CalculatorComplex, CalculatorFloat]): value by which to multiply self by.
                 ///
                 /// Returns:
-                ///     Tuple[Self, Self]: Operator with the noise terms where the number of spins matches the number of spins the operator product acts on and Operator with all other contributions.
+                ///     self: The object multiplied by the value.
                 ///
                 /// Raises:
-                ///     ValueError: Error in adding terms to return values.
-        pub fn separate_into_n_terms(&self, number_spins: usize) -> PyResult<(#ident, #ident)> {
-                    let (separated, remainder) = self.internal.separate_into_n_terms(number_spins).map_err(|err| PyValueError::new_err(format!("{:?}", err)))?;
-                    Ok((
-                        #ident { internal: separated },
-                        #ident { internal: remainder }
-                    ))
+                ///     ValueError: The rhs of the multiplication is neither CalculatorFloat nor CalculatorComplex.
+                pub fn __mul__(&self, value: &PyAny) -> PyResult<#ident> {
+                    let cf_value = qoqo_calculator_pyo3::convert_into_calculator_float(value);
+                    match cf_value {
+                        Ok(x) => Ok(#ident {
+                            internal: self.clone().internal * x,
+                        }),
+                        Err(_) => {
+                            let cc_value = qoqo_calculator_pyo3::convert_into_calculator_complex(value);
+                            match cc_value {
+                                Ok(x) => Ok(#ident { internal: self.clone().internal * x }),
+                                Err(err) => Err(PyValueError::new_err(format!(
+                                    "The rhs of the multiplication is neither CalculatorFloat nor CalculatorComplex: {:?}",
+                                    err)))
+                            }
+                        }
+                    }
                 }
+        }
+    } else {
+        TokenStream::new()
+    };
+    let operate_on_modes_quote = if attribute_arguments.contains("OperateOnModes") {
+        quote! {
+            /// Return the current_number_modes input of self.
+            ///
+            /// Returns:
+            ///     int: The number of modes in self.
+            pub fn current_number_modes(&self) -> usize {
+                self.internal.current_number_modes()
             }
+        }
     } else {
         TokenStream::new()
     };
-    let to_sparse_matrix_operator_quote = if attribute_arguments.contains("ToSparseMatrixOperator")
-    {
+    let operate_on_spins_quote = if attribute_arguments.contains("OperateOnSpins") {
         quote! {
-                /// Constructs the sparse matrix representation of self as a scipy COO matrix with a given number of spins.
-                ///
-                /// Args:
-                ///     number_spins: The number of spins in self.
-                ///
-                /// Returns:
-                ///     Tuple[np.ndarray, Tuple[np.ndarray, np.ndarray]]: The matrix representation of self.
-                ///
-                /// Raises:
-                ///     ValueError: CalculatorError.
-                ///     RuntimeError: Could not convert to complex superoperator matrix.
-                #[pyo3(signature = (number_spins = None))]
-                pub fn sparse_matrix_coo(&self, number_spins: Option<usize>) -> PyResult<PyCooMatrix> {
-                    let coo = self
-                        .internal
-                        .sparse_matrix_coo(number_spins)
-                        .map_err(|err| match err {
-                            StruqtureError::CalculatorError(c_err) => {
-                                PyValueError::new_err(format!("{}", c_err))
-                            }
-                            _ => PyRuntimeError::new_err(
-                                "Could not convert to complex superoperator matrix".to_string(),
-                            ),
-                        })?;
-                    to_py_coo(coo)
-                }
+            /// Return the current_number_spins input of self.
+            ///
+            /// Returns:
+            ///     int: The number of spins in self.
+            pub fn current_number_spins(&self) -> usize {
+                self.internal.current_number_spins()
+            }
         }
     } else {
         TokenStream::new()
     };
     let to_sparse_matrix_superoperator_quote = if attribute_arguments
         .contains("ToSparseMatrixSuperOperator")
     {
@@ -359,15 +367,15 @@
                 /// Construct the sparse matrix representation of the superoperator in COO representation.
                 ///
                 /// The superoperator for the operator O is defined as the Matrix S so that
                 /// `flatten(-i [O, p]) = S flatten(p)` wher `[,]` is the commutator, `p` is a matrix
                 /// and `flatten` flattens a matrix into a vector in row-major form.
                 ///
                 /// Args:
-                ///     number_spins: The number of spins to construct the matrix for.
+                ///     number_spins: The number of spins in self.
                 ///
                 /// Returns:
                 ///     Tuple[np.ndarray, Tuple[np.ndarray, np.ndarray]]: The matrix representation of self.
                 ///
                 /// Raises:
                 ///     ValueError: CalculatorError.
                 ///     RuntimeError: Could not convert to complex superoperator matrix.
@@ -448,78 +456,340 @@
                 }
         }
     } else {
         TokenStream::new()
     };
     let operate_on_mixedsystems_quote = if attribute_arguments.contains("OperateOnMixedSystems") {
         quote! {
-                /// Return the number_spins input of each spin subsystem of self.
+                /// Return the current_number_spins input of each spin subsystem of self.
                 ///
                 /// Returns:
                 ///     int: The number of spins in each spin subsystem of self.
-                pub fn number_spins(&self) -> Vec<usize> {
-                    self.internal.number_spins()
-                }
-
-                /// Return maximum spin index in each spin subsystem of self.
-                ///
-                /// Returns:
-                ///     int: Maximum index in each spin subsystem of self.
                 pub fn current_number_spins(&self) -> Vec<usize> {
                     self.internal.current_number_spins()
                 }
+
                 /// Return the number of bosonic modes in each bosonic subsystem of self.
                 ///
                 /// Returns:
                 ///     list[int]: The number of bosonic modes in each bosonic subsystem of self.
-                pub fn number_bosonic_modes(&self) -> Vec<usize> {
-                    self.internal.number_bosonic_modes()
-                }
-
-                /// Return the number of bosonic modes each bosonic subsystem of self acts on.
-                ///
-                /// Returns:
-                ///     list[int]: Maximum bosonic mode index currently used in each bosonic subsystem of self.
                 pub fn current_number_bosonic_modes(&self) -> Vec<usize> {
                     self.internal.current_number_bosonic_modes()
                 }
 
                 /// Return the number of fermionic modes in each fermionic subsystem of self.
                 ///
                 /// Returns:
                 ///     list[int]: The number of fermionic modes in each fermionic subsystem of self.
-                pub fn number_fermionic_modes(&self) -> Vec<usize> {
-                    self.internal.number_fermionic_modes()
+                pub fn current_number_fermionic_modes(&self) -> Vec<usize> {
+                    self.internal.current_number_fermionic_modes()
+                }
+        }
+    } else {
+        TokenStream::new()
+    };
+    let open_system_quote = if attribute_arguments.contains("OpenSystem") {
+        let (system_type, system_index_type, value_type, noise_type) =
+            if struct_name.contains("Qubit") {
+                (
+                    quote::format_ident!("QubitHamiltonianWrapper"),
+                    quote::format_ident!("PauliProductWrapper"),
+                    quote::format_ident!("CalculatorFloatWrapper"),
+                    quote::format_ident!("QubitLindbladNoiseOperatorWrapper"),
+                )
+            } else if struct_name.contains("Boson") {
+                (
+                    quote::format_ident!("BosonHamiltonianWrapper"),
+                    quote::format_ident!("HermitianBosonProductWrapper"),
+                    quote::format_ident!("CalculatorComplexWrapper"),
+                    quote::format_ident!("BosonLindbladNoiseOperatorWrapper"),
+                )
+            } else if struct_name.contains("Fermion") {
+                (
+                    quote::format_ident!("FermionHamiltonianWrapper"),
+                    quote::format_ident!("HermitianFermionProductWrapper"),
+                    quote::format_ident!("CalculatorComplexWrapper"),
+                    quote::format_ident!("FermionLindbladNoiseOperatorWrapper"),
+                )
+            } else {
+                (
+                    quote::format_ident!("MixedHamiltonianWrapper"),
+                    quote::format_ident!("HermitianMixedProductWrapper"),
+                    quote::format_ident!("CalculatorComplexWrapper"),
+                    quote::format_ident!("MixedLindbladNoiseOperatorWrapper"),
+                )
+            };
+        quote! {
+            /// Return the system part of self.
+            ///
+            /// Returns:
+            ///     System type: The system of self.
+            pub fn system(&self) -> #system_type {
+                #system_type {
+                    internal: self.internal.system().clone(),
                 }
+            }
+
+            /// Return the noise part of self.
+            ///
+            /// Returns:
+            ///     Noise type: The noise of self.
+            pub fn noise(&self) -> #noise_type {
+                #noise_type {
+                    internal: self.internal.noise().clone(),
+                }
+            }
+
+            /// Return a tuple of the system and the noise of self.
+            ///
+            /// Returns:
+            ///     (System, Noise): The system and noise of self.
+            pub fn ungroup(
+                &self,
+            ) -> (
+                #system_type,
+                #noise_type,
+            ) {
+                (self.system(), self.noise())
+            }
+
+            /// Take a tuple of a system term and a noise term and combines them to be a OpenSystem.
+            ///
+            /// Args:
+            ///     system: The system to have in the new instance.
+            ///     noise: The noise to have in the new instance.
+            ///
+            /// Returns:
+            ///     self: The OpenSystem with input system and noise terms.
+            ///
+            /// Raises:
+            ///     ValueError: System could not be constructed.
+            ///     ValueError: Noise could not be constructed.
+            ///     ValueError: Grouping could not be constructed.
+            #[staticmethod]
+            pub fn group(system: Py<PyAny>, noise: Py<PyAny>) -> PyResult<Self> {
+                let system = #system_type::from_pyany(system).map_err(|err| {
+                    PyValueError::new_err(format!("System could not be constructed: {:?}", err))
+                })?;
+                let noise = #noise_type::from_pyany(noise).map_err(|err| {
+                    PyValueError::new_err(format!("Noise could not be constructed: {:?}", err))
+                })?;
+                let new_self = #struct_ident::group(system, noise).map_err(|err| {
+                    PyValueError::new_err(format!("Grouping could not be constructed: {:?}", err))
+                })?;
+                Ok(Self { internal: new_self })
+            }
+
+            /// Return an instance of self that has no entries but clones all other properties, with the given capacity.
+            ///
+            /// Returns:
+            ///     self: An empty clone with the same properties as self, with the given capacity.
+            pub fn empty_clone(&self) -> #ident {
+                #ident {
+                    internal: self.internal.empty_clone()
+                }
+            }
+
+            /// Truncate self by returning a copy without entries under a threshold.
+            ///
+            /// Args:
+            ///     threshold: The threshold for inclusion.
+            ///
+            /// Returns:
+            ///     self: The truncated version of self.
+            pub fn truncate(&self, threshold: f64) -> #ident {
+                #ident {
+                    internal: self.internal.truncate(threshold)
+                }
+            }
+
+            /// Set a new entry in the system of the open system.
+            ///
+            /// Args:
+            ///     key (Product type): Product key of set object.
+            ///     value (Union[CalculatorComplex, CalculatorFloat]): Value of set object.
+            ///
+            /// Returns:
+            ///     OpenSystem: The OpenSystem with the new entry.
+            ///
+            /// Raises:
+            ///     ValueError: key element cannot be converted to product.
+            ///     TypeError: Value cannot be converted to Union[CalculatorComplex, CalculatorFloat].
+            pub fn system_set(
+                &mut self,
+                key: Py<PyAny>,
+                value: Py<PyAny>,
+            ) -> PyResult<#ident> {
+                let pp = #system_index_type::from_pyany(key)?;
+                let value = #value_type::from_pyany(value)
+                    .map_err(|_| PyTypeError::new_err("Value cannot be converted to Union[CalculatorComplex, CalculatorFloat]"))?;
+
+                self.internal.system_mut().set(pp, value).map_err(|_| PyTypeError::new_err("Couldn't set key and value combination"))?;
+
+                Ok(#ident {
+                    internal: self.internal.clone(),
+                })
+            }
+
+            /// Set a new entry in the noise of the open system.
+            ///
+            /// Args:
+            ///     key (Tuple(Product type, Product type)): Tuple of Products of set object.
+            ///     value (CalculatorComplex): CalculatorComplex value of set object.
+            ///
+            /// Returns:
+            ///     OpenSystem: The OpenSystem with the new entry.
+            ///
+            /// Raises:
+            ///     ValueError: Left key element cannot be converted to product.
+            ///     ValueError: Right key element cannot be converted to product.
+            ///     TypeError: Value cannot be converted to Union[CalculatorComplex, CalculatorFloat].
+            pub fn noise_set(
+                &mut self,
+                key: (Py<PyAny>, Py<PyAny>),
+                value: Py<PyAny>,
+            ) -> PyResult<#ident> {
+                let dp_left = #index_type::from_pyany(key.0)?;
+                let dp_right = #index_type::from_pyany(key.1)?;
+                let value = CalculatorComplexWrapper::from_pyany(value)
+                    .map_err(|_| PyTypeError::new_err("Value is not CalculatorComplex"))?;
+
+                self.internal.noise_mut().set((dp_left, dp_right), value).map_err(|_| PyTypeError::new_err("Couldn't set key and value combination"))?;
+
+                Ok(#ident {
+                    internal: self.internal.clone(),
+                })
+            }
+
+            /// Get the CalculatorComplex or CalculatorFloat coefficient corresponding to the key.
+            ///
+            /// Args:
+            ///     key (Product type): Product key of set object.
+            ///
+            /// Returns:
+            ///     CalculatorComplex or CalculatorFloat: Value at key (or 0.0).
+            ///
+            /// Raises:
+            ///     ValueError: key element cannot be converted to product.
+            pub fn system_get(
+                &mut self,
+                key: Py<PyAny>,
+            ) -> PyResult<#value_type> {
+                let pp = #system_index_type::from_pyany(key)?;
+                let get_value = self.internal.system().get(&pp);
+
+                Ok(#value_type {
+                    internal: get_value.into(),
+                })
+            }
+
+            /// Get the CalculatorComplex coefficient corresponding to the key.
+            ///
+            /// Args:
+            ///     key (Tuple(Product type, Product type)): Tuple of Products of set object.
+            ///
+            /// Returns:
+            ///     CalculatorComplex: Value at key (or 0.0).
+            ///
+            /// Raises:
+            ///     ValueError: Left key element cannot be converted to product.
+            ///     ValueError: Right key element cannot be converted to product.
+            pub fn noise_get(
+                &mut self,
+                key: (Py<PyAny>, Py<PyAny>),
+            ) -> PyResult<CalculatorComplexWrapper> {
+                let dp_left = #index_type::from_pyany(key.0)?;
+                let dp_right = #index_type::from_pyany(key.1)?;
+                let get_value = self.internal.noise().get(&(dp_left, dp_right));
+
+                Ok(CalculatorComplexWrapper {
+                    internal: get_value.into(),
+                })
+            }
+
+            /// Add a new entry to the system of the open system.
+            ///
+            /// Args:
+            ///     key (Product type): Product key of set object.
+            ///     value (Union[CalculatorComplex, CalculatorFloat]): Value of set object.
+            ///
+            /// Returns:
+            ///     OpenSystem: The OpenSystem with the new entry.
+            ///
+            /// Raises:
+            ///     ValueError: key element cannot be converted to product.
+            ///     TypeError: Value cannot be converted to Union[CalculatorComplex, CalculatorFloat].
+            pub fn system_add_operator_product(
+                &mut self,
+                key: Py<PyAny>,
+                value: Py<PyAny>,
+            ) -> PyResult<#ident> {
+                let pp = #system_index_type::from_pyany(key)?;
+                let value = #value_type::from_pyany(value)
+                    .map_err(|_| PyTypeError::new_err("Value cannot be converted to CalculatorComplex"))?;
+
+                self.internal.system_mut().add_operator_product(pp, value).map_err(|_| PyTypeError::new_err("Couldn't add in key and value combination"))?;
+
+                Ok(#ident {
+                    internal: self.internal.clone(),
+                })
+            }
+
+            /// Add a new entry to the system of the open system.
+            ///
+            /// Args:
+            ///     key (Tuple(Product type, Product type)): Tuple of Products of set object.
+            ///     value (CalculatorComplex): Value of set object.
+            ///
+            /// Returns:
+            ///     OpenSystem: The OpenSystem with the new entry.
+            ///
+            /// Raises:
+            ///     ValueError: Left key element cannot be converted to product.
+            ///     ValueError: Right key element cannot be converted to product.
+            ///     TypeError: Value cannot be converted to CalculatorComplex.
+            pub fn noise_add_operator_product(
+                &mut self,
+                key: (Py<PyAny>, Py<PyAny>),
+                value: Py<PyAny>,
+            ) -> PyResult<#ident> {
+                let dp_left = #index_type::from_pyany(key.0)?;
+                let dp_right = #index_type::from_pyany(key.1)?;
+                let value = CalculatorComplexWrapper::from_pyany(value)
+                    .map_err(|_| PyTypeError::new_err("Value is not CalculatorComplex"))?;
+
+                self.internal.noise_mut().add_operator_product((dp_left, dp_right), value).map_err(|_| PyTypeError::new_err("Number of spins exceeded"))?;
+
+                Ok(#ident {
+                    internal: self.internal.clone(),
+                })
+            }
 
-                /// Return the number of fermionic modes each fermionic subsystem of self acts on.
+                /// Implement `*` for self and CalculatorFloat.
+                ///
+                /// Args:
+                ///     value (CalculatorFloat): value by which to multiply self by.
                 ///
                 /// Returns:
-                ///     list[int]: Maximum fermionic mode index currently used in each fermionic subsystem of self.
-                pub fn current_number_fermionic_modes(&self) -> Vec<usize> {
-                    self.internal.current_number_fermionic_modes()
+                ///     self: The object multiplied by the value.
+                ///
+                /// Raises:
+                ///     ValueError: The rhs of the multiplication cannot be converted to CalculatorFloat.
+                pub fn __mul__(&self, value: &PyAny) -> PyResult<#ident> {
+                let cf_value = qoqo_calculator_pyo3::convert_into_calculator_float(value);
+                match cf_value {
+                    Ok(x) => Ok(#ident {
+                        internal: self.clone().internal * x,
+                    }),
+                    Err(err) => Err(PyValueError::new_err(format!(
+                        "The rhs of the multiplication is not a CalculatorFloat: {:?}",
+                        err
+                    ))),
                 }
-
-                // /// Separate self into an operator with the terms of given number of qubits and an operator with the remaining operations.
-                // ///
-                // /// Args:
-                // ///     number_particles (Tuple[int, int, int]): Number of particles to filter for in the keys.
-                // ///
-                // /// Returns:
-                // ///     int: The number of modes in self.
-                // ///
-                // /// Raises:
-                // ///     ValueError: Operator with the noise terms where number_particles matches the number of spins the operator product acts on and Operator with all other contributions.
-                // pub fn separate_into_n_terms(&self, number_particles: (usize, usize, usize)) -> PyResult<(#ident, #ident)> {
-                //     let (separated, remainder) = self.internal.separate_into_n_terms(number_particles).map_err(|err| PyValueError::new_err(format!("{:?}", err)))?;
-                //     Ok((
-                //         #ident { internal: separated },
-                //         #ident { internal: remainder }
-                //     ))
-                // }
+            }
         }
     } else {
         TokenStream::new()
     };
     let calculus_quote = if attribute_arguments.contains("Calculus") {
         quote! {
             /// Implement `-1` for self.
@@ -539,14 +809,63 @@
             ///
             /// Returns:
             ///     self: The two objects added.
             ///
             /// Raises:
             ///     ValueError: Objects could not be added.
             pub fn __add__(&self, other: #ident) -> PyResult<#ident> {
+                let new_self = (self.clone().internal + other.internal);
+                Ok(#ident {
+                    internal: new_self
+                })
+            }
+
+            /// Implement `-` for self with self-type.
+            ///
+            /// Args:
+            ///     other (self): value by which to subtract from self.
+            ///
+            /// Returns:
+            ///     self: The two objects subtracted.
+            ///
+            /// Raises:
+            ///     ValueError: Objects could not be subtracted.
+            pub fn __sub__(&self, other: #ident) -> PyResult<#ident> {
+                let new_self = (self.clone().internal - other.internal);
+                Ok(#ident {
+                    internal: new_self
+                })
+            }
+        }
+    } else {
+        TokenStream::new()
+    };
+    let hermitian_calculus_quote = if attribute_arguments.contains("HermitianCalculus") {
+        quote! {
+            /// Implement `-1` for self.
+            ///
+            /// Returns:
+            ///     self: The object * -1.
+            pub fn __neg__(&self) -> #ident {
+                #ident {
+                    internal: -self.clone().internal
+                }
+            }
+
+            /// Implement `+` for self with self-type.
+            ///
+            /// Args:
+            ///     other (self): value by which to add to self.
+            ///
+            /// Returns:
+            ///     self: The two objects added.
+            ///
+            /// Raises:
+            ///     ValueError: Objects could not be added.
+            pub fn __add__(&self, other: #ident) -> PyResult<#ident> {
                 let new_self = (self.clone().internal + other.internal).map_err(|err| PyValueError::new_err(format!("Objects could not be added: {:?}", err)))?;
                 Ok(#ident {
                     internal: new_self
                 })
             }
 
             /// Implement `-` for self with self-type.
@@ -568,75 +887,153 @@
         }
     } else {
         TokenStream::new()
     };
     let q = quote! {
 
         impl #ident {
-            /// Fallible conversion of generic python object.
-            pub fn from_pyany(input: Py<PyAny>
-            ) -> PyResult<#struct_ident> {
+            /// Fallible conversion of generic python object..
+            pub fn from_pyany(input: Py<PyAny>) -> PyResult<#struct_ident> {
                 Python::with_gil(|py| -> PyResult<#struct_ident> {
+                    let source_serialisation_meta = input.call_method0(py, "_get_serialisation_meta").map_err(|_| {
+                        PyTypeError::new_err("Trying to use Python object as a struqture-py object that does not behave as struqture-py object. Are you sure you have the right type to all functions?".to_string())
+                    })?;
+                    let source_serialisation_meta: String = source_serialisation_meta.extract(py).map_err(|_| {
+                        PyTypeError::new_err("Trying to use Python object as a struqture-py object that does not behave as struqture-py object. Are you sure you have the right type to all functions?".to_string())
+                    })?;
+
+                    let source_serialisation_meta: struqture::StruqtureSerialisationMeta = serde_json::from_str(&source_serialisation_meta).map_err(|_| {
+                        PyTypeError::new_err("Trying to use Python object as a struqture-py object that does not behave as struqture-py object. Are you sure you have the right type to all functions?".to_string())
+                    })?;
+
+                    let target_serialisation_meta = <#struct_ident as struqture::SerializationSupport>::target_serialisation_meta();
+
+                    struqture::check_can_be_deserialised(&target_serialisation_meta, &source_serialisation_meta).map_err(|err| {
+                        PyTypeError::new_err(err.to_string())
+                    })?;
+
                     let input = input.as_ref(py);
                     if let Ok(try_downcast) = input.extract::<#ident>() {
                         return Ok(try_downcast.internal);
                     } else {
-                    let get_bytes = input.call_method0("to_bincode").map_err(|_| {
-                        PyTypeError::new_err("Serialisation failed".to_string())
-                    })?;
-                    let bytes = get_bytes.extract::<Vec<u8>>().map_err(|_| {
-                        PyTypeError::new_err("Deserialisation failed".to_string())
-                    })?;
-                    deserialize(&bytes[..]).map_err(|err| {
-                        PyTypeError::new_err(format!(
-                            "Type conversion failed: {}",
-                            err
-                        ))}
-                    )
-
+                        let get_bytes = input.call_method0("to_bincode").map_err(|_| {
+                            PyTypeError::new_err("Serialisation failed".to_string())
+                        })?;
+                        let bytes = get_bytes.extract::<Vec<u8>>().map_err(|_| {
+                            PyTypeError::new_err("Deserialisation failed".to_string())
+                        })?;
+                        deserialize(&bytes[..]).map_err(|err| {
+                            PyTypeError::new_err(format!(
+                                "Type conversion failed: {}",
+                                err
+                            ))}
+                        )
                     }
-                }
+                })
+            }
 
-                )
+            /// Fallible conversion of generic python object that is implemented in struqture 1.x.
+            #[cfg(feature = "struqture_1_import")]
+            pub fn from_pyany_struqture_one(input: Py<PyAny>) -> PyResult<#struct_ident> {
+                Python::with_gil(|py| -> PyResult<#struct_ident> {
+                    let input = input.as_ref(py);
+                    let get_bytes = input
+                        .call_method0("to_bincode")
+                        .map_err(|_| PyTypeError::new_err("Serialisation failed".to_string()))?;
+                    let bytes = get_bytes
+                        .extract::<Vec<u8>>()
+                        .map_err(|_| PyTypeError::new_err("Deserialisation failed".to_string()))?;
+                    let one_import = deserialize(&bytes[..])
+                        .map_err(|err| PyTypeError::new_err(format!("Type conversion failed: {}", err)))?;
+                    let qubit_operator: #struct_ident = #struct_ident::from_struqture_1(&one_import).map_err(
+                        |err| PyValueError::new_err(format!("Trying to obtain struqture 2.x object from struqture 1.x object. Conversion failed. Was the right type passed to all functions? {:?}", err)
+                    ))?;
+                    Ok(qubit_operator)
+                })
+            }
+
+            /// Fallible conversion of generic python object that is implemented in struqture 1.x.
+            #[cfg(feature = "struqture_1_export")]
+            pub fn from_pyany_to_struqture_one(
+                input: Py<PyAny>,
+            ) -> PyResult<struqture_one::#struqture_one_module::#struqture_one_ident> {
+                let res = #ident::from_pyany(input)?;
+                let one_export = #struct_ident::to_struqture_1(&res).map_err(
+                    |err| PyValueError::new_err(format!("Trying to obtain struqture 2.x object from struqture 1.x object. Conversion failed. Was the right type passed to all functions? {:?}", err)
+                ))?;
+                Ok(one_export)
+            }
         }
-    }
         #[pymethods]
         impl #ident {
 
             #(#items)*
 
             #operate_on_density_matrix_quote
-            #operate_on_state_quote
             #operate_on_modes_quote
             #operate_on_spins_quote
-            #to_sparse_matrix_operator_quote
+            #open_system_quote
             #to_sparse_matrix_superoperator_quote
             #operate_on_mixedsystems_quote
             #calculus_quote
+            #hermitian_calculus_quote
 
             // ----------------------------------
             // Default pyo3 implementations
 
-            /// Return a copy of self (copy here produces a deepcopy).
+            // add in a function converting struqture_one (not py) to struqture 2
+            // take a pyany, implement from_pyany by hand (or use from_pyany_struqture_one internally) and wrap the result in a struqture 2 spin operator wrapper
+            #[cfg(feature = "struqture_1_import")]
+            #[staticmethod]
+            pub fn from_struqture_one(input: Py<PyAny>) -> PyResult<#ident> {
+                let qubit_operator: #struct_ident =
+                    #ident::from_pyany_struqture_one(input)?;
+                Ok(#ident {
+                    internal: qubit_operator,
+                })
+            }
+
+            // add in a function converting struqture_one (not py) to struqture 2
+            // take a pyany, implement from_pyany by hand (or use from_pyany_struqture_one internally) and wrap the result in a struqture 2 spin operator wrapper
+            #[cfg(feature = "struqture_1_import")]
+            #[staticmethod]
+            pub fn from_json_struqture_one(input: String) -> PyResult<#ident> {
+                let qubit_operator: struqture_one::#struqture_one_module::#struqture_one_ident =
+                    serde_json::from_str(&input).map_err(|err| {
+                        PyValueError::new_err(format!(
+                            "Input cannot be deserialized from json to struqture 1.x: {}",
+                            err
+                        ))
+                    })?;
+                Ok(#ident {
+                    internal: #struct_ident::from_struqture_1(&qubit_operator).map_err(|err| {
+                        PyValueError::new_err(format!(
+                            "Trying to obtain struqture 2.x object from struqture 1.x object. Conversion failed. Was the right type passed to all functions? {:?}", err
+                        ))
+                    })?,
+                })
+            }
+
+            /// Return a copy (copy here produces a deepcopy).
             ///
             /// Returns:
-            ///     self: A deep copy of self.
+            ///     Operator: A deep copy of self.
             pub fn __copy__(&self) -> #ident {
                 self.clone()
             }
 
-            /// Return a deep copy of self.
+            /// Return a deep copy .
             ///
             /// Returns:
-            ///     self: A deep copy of self.
+            ///     Operator: A deep copy of self.
             pub fn __deepcopy__(&self, _memodict: Py<PyAny>) -> #ident {
                 self.clone()
             }
 
-            /// Convert the bincode representation of self to an instance using the [bincode] crate.
+            /// Convert the bincode representation of the object to an instance using the [bincode] crate.
             ///
             /// Args:
             ///     input (ByteArray): The serialized object (in [bincode] form).
             ///
             /// Returns:
             ///    The deserialized object.
             ///
@@ -655,15 +1052,15 @@
                             "Input cannot be deserialized from bytes. {}",
                             err
                         ))
                     })?,
                 })
             }
 
-            /// Return the bincode representation of self using the [bincode] crate.
+            /// Return the bincode representation of the object using the [bincode] crate.
             ///
             /// Returns:
             ///     ByteArray: The serialized object (in [bincode] form).
             ///
             /// Raises:
             ///     ValueError: Cannot serialize object to bytes.
             pub fn to_bincode(&self) -> PyResult<Py<PyByteArray>> {
@@ -672,28 +1069,28 @@
                 })?;
                 let b: Py<PyByteArray> = Python::with_gil(|py| -> Py<PyByteArray> {
                     PyByteArray::new(py, &serialized[..]).into()
                 });
                 Ok(b)
             }
 
-            /// Return the json representation of self.
+            /// Return the json representation of the object.
             ///
             /// Returns:
-            ///     str: The serialized form of self.
+            ///     str: The serialized form of the object.
             ///
             /// Raises:
             ///     ValueError: Cannot serialize object to json.
             pub fn to_json(&self) -> PyResult<String> {
                 let serialized = serde_json::to_string(&self.internal)
                     .map_err(|_| PyValueError::new_err("Cannot serialize object to json".to_string()))?;
                 Ok(serialized)
             }
 
-            /// Convert the json representation of self to an instance.
+            /// Convert the json representation of the object to an instance.
             ///
             /// Args:
             ///     input (str): The serialized object in json form.
             ///
             /// Returns:
             ///     The deserialized object.
             ///
@@ -737,27 +1134,27 @@
             /// Returns:
             ///     Whether the two operations compared evaluated to True or False
             ///
             /// Raises:
             ///     NotImplementedError: Other comparison not implemented.
             pub fn __richcmp__(&self, other: Py<PyAny>, op: pyo3::class::basic::CompareOp) -> PyResult<bool> {
                 let other = Self::from_pyany(other);
-                match op {
-                    pyo3::class::basic::CompareOp::Eq => match other {
-                        Ok(pauli) => Ok(self.internal == pauli),
-                        _ => Ok(false),
-                    },
-                    pyo3::class::basic::CompareOp::Ne => match other {
-                        Ok(pauli) => Ok(self.internal != pauli),
-                        _ => Ok(true),
-                    },
-                    _ => Err(pyo3::exceptions::PyNotImplementedError::new_err(
-                        "Other comparison not implemented",
-                    )),
-                }
+                    match op {
+                        pyo3::class::basic::CompareOp::Eq => match other {
+                            Ok(pauli) => Ok(self.internal == pauli),
+                            _ => Ok(false),
+                        },
+                        pyo3::class::basic::CompareOp::Ne => match other {
+                            Ok(pauli) => Ok(self.internal != pauli),
+                            _ => Ok(true),
+                        },
+                        _ => Err(pyo3::exceptions::PyNotImplementedError::new_err(
+                            "Other comparison not implemented",
+                        )),
+                    }
             }
 
             #[cfg(feature = "json_schema")]
             /// Returns the current version of the struqture library .
             ///
             /// Returns:
             ///     str: The current version of the library.
@@ -768,18 +1165,25 @@
 
             #[cfg(feature = "json_schema")]
             /// Return the minimum version of struqture that supports this object.
             ///
             /// Returns:
             ///     str: The minimum version of the struqture library to deserialize this object.
             pub fn min_supported_version(&self) -> String {
-                let min_version: (usize, usize, usize) = #struct_ident::min_supported_version();
+                let min_version: (usize, usize, usize) = struqture::SerializationSupport::min_supported_version(&self.internal);
                 return format!("{}.{}.{}", min_version.0, min_version.1, min_version.2);
             }
 
+            /// Returns the StruqtureSerialisationMeta of the object.
+            fn _get_serialisation_meta(&self) -> PyResult<String>{
+                let meta = struqture::SerializationSupport::struqture_serialisation_meta(&self.internal);
+                let string = serde_json::to_string(&meta).map_err(|err| PyValueError::new_err(err.to_string()))?;
+                Ok(string)
+            }
+
             #[cfg(feature = "json_schema")]
             /// Return the JsonSchema for the json serialisation of the class.
             ///
             /// Returns:
             ///     str: The json schema serialized to json
             #[staticmethod]
             pub fn json_schema() -> String {
```

### Comparing `struqture_py-1.6.1/struqture-py/Cargo.toml` & `struqture_py-2.0.0a0/struqture-py/Cargo.toml`

 * *Files 17% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 [package]
 name = "struqture-py"
-version = "1.6.1"
+version = "2.0.0-alpha.0"
 authors = ["HQS Quantum Simulations <info@quantumsimulations.de>"]
 edition = "2021"
 rust-version = "1.57"
 categories = ["science", "simulation"]
 description = "Python interface of struqture, the HQS tool for representing operators, Hamiltonians and open systems."
 license = "Apache-2.0"
 include=["src*", "struqture_py", "Cargo.toml", "build.rs", "pyproject.toml"]
@@ -17,24 +17,26 @@
 crate-type = ["cdylib", "rlib"]
 
 [dependencies.pyo3]
 version = "0.20"
 features = ["num-complex", "multiple-pymethods"]
 
 [dependencies]
-struqture = {version="1.6", path="../struqture", default-features=false}
+struqture = {version="2.0.0-alpha.0", path="../struqture", default-features=false}
+struqture_one = {package = "struqture", version="=1.6", optional=true, default-features=false}
+
 serde = { version = "1.0", features = ["derive"] }
 numpy = "0.20"
 qoqo_calculator = {version="1.1.2", default-features=false}
 qoqo_calculator_pyo3 = {version="1.1.2", default-features=false}
 bincode = "1.3"
 serde_json = "1.0"
 thiserror = "1.0"
 num-complex = "0.4"
-struqture-py-macros = {version="1.6", path="../struqture-py-macros"}
+struqture-py-macros = {version="2.0.0-alpha.0", path="../struqture-py-macros"}
 schemars = {version = "0.8"}
 
 [dev-dependencies]
 test-case = "3.1"
 nalgebra = "0.32"
 ndarray = {version="0.15"}
 
@@ -45,11 +47,12 @@
 proc-macro2 = "1.0"
 pyo3-build-config="0.20"
 
 [package.metadata.docs.rs]
 no-default-features = true
 
 [features]
-extension-module = ["pyo3/extension-module"]#, "qoqo_calculator_pyo3/extension-module"]
-default = ["extension-module", "json_schema", "indexed_map_iterators"]
+extension-module = ["pyo3/extension-module"]
+default = ["extension-module", "json_schema"]
 json_schema = ["struqture/json_schema"]
-indexed_map_iterators = ["struqture/indexed_map_iterators"]
+struqture_1_export = ["struqture_one", "struqture/struqture_1_export", "struqture/struqture_1_import"]
+struqture_1_import = ["struqture_one", "struqture/struqture_1_import", "struqture/struqture_1_export"]
```

### Comparing `struqture_py-1.6.1/struqture-py/build.rs` & `struqture_py-2.0.0a0/struqture-py/build.rs`

 * *Files identical despite different names*

### Comparing `struqture_py-1.6.1/struqture-py/src/bosons/boson_product.rs` & `struqture_py-2.0.0a0/struqture-py/src/bosons/boson_product.rs`

 * *Files 2% similar despite different names*

```diff
@@ -16,16 +16,17 @@
 use pyo3::types::PyType;
 use std::collections::hash_map::DefaultHasher;
 use std::collections::HashMap;
 use std::hash::{Hash, Hasher};
 use std::str::FromStr;
 use struqture::bosons::*;
 use struqture::prelude::*;
+use struqture::SerializationSupport;
 #[cfg(feature = "json_schema")]
-use struqture::{MinSupportedVersion, STRUQTURE_VERSION};
+use struqture::STRUQTURE_VERSION;
 use struqture_py_macros::product_wrapper;
 
 /// A product of bosonic creation and annihilation operators.
 ///
 /// The BosonProduct is used as an index for non-hermitian, normal ordered bosonic operators.
 /// A bosonic operator can be written as a sum over normal ordered products of creation and annihilation operators.
 /// The BosonProduct is used as an index when setting or adding new summands to a bosonic operator and when querrying the
```

### Comparing `struqture_py-1.6.1/struqture-py/src/bosons/bosonic_hamiltonian_system.rs` & `struqture_py-2.0.0a0/struqture-py/src/bosons/bosonic_hamiltonian.rs`

 * *Files 13% similar despite different names*

```diff
@@ -6,116 +6,113 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::bosons::{BosonSystemWrapper, HermitianBosonProductWrapper};
+use crate::bosons::{BosonOperatorWrapper, HermitianBosonProductWrapper};
 use bincode::deserialize;
 use pyo3::exceptions::{PyTypeError, PyValueError};
 use pyo3::prelude::*;
 use pyo3::types::PyByteArray;
 use qoqo_calculator::CalculatorComplex;
 use qoqo_calculator_pyo3::CalculatorComplexWrapper;
-use struqture::bosons::BosonHamiltonianSystem;
+use struqture::bosons::BosonHamiltonian;
 #[cfg(feature = "json_schema")]
-use struqture::{MinSupportedVersion, STRUQTURE_VERSION};
+use struqture::STRUQTURE_VERSION;
 use struqture::{OperateOnDensityMatrix, OperateOnModes, OperateOnState};
 use struqture_py_macros::noiseless_system_wrapper;
 
 /// These are representations of systems of bosons.
 ///
-/// BosonHamiltonianSystems are characterized by a BosonOperator to represent the hamiltonian of the spin system
+/// BosonHamiltonians are characterized by a BosonOperator to represent the hamiltonian of the spin system
 /// and an optional number of bosons.
 ///
 /// Examples
 /// --------
 ///
 /// .. code-block:: python
 ///
 ///     import numpy.testing as npt
 ///     import scipy.sparse as sp
 ///     from qoqo_calculator_pyo3 import CalculatorComplex
-///     from struqture_py.bosons import BosonHamiltonianSystem, HermitianBosonProduct
+///     from struqture_py.bosons import BosonHamiltonian, HermitianBosonProduct
 ///     
-///     ssystem = BosonHamiltonianSystem(2)
+///     ssystem = BosonHamiltonian(2)
 ///     pp = HermitianBosonProduct([0], [0])
 ///     ssystem.add_operator_product(pp, 5.0)
-///     npt.assert_equal(ssystem.number_modes(), 2)
+///     npt.assert_equal(ssystem.current_number_modes(), 2)
 ///     npt.assert_equal(ssystem.get(pp), CalculatorComplex(5))
 ///     npt.assert_equal(ssystem.keys(), [pp])
 ///
-#[pyclass(name = "BosonHamiltonianSystem", module = "struqture_py.bosons")]
+#[pyclass(name = "BosonHamiltonian", module = "struqture_py.bosons")]
 #[derive(Clone, Debug, PartialEq)]
-pub struct BosonHamiltonianSystemWrapper {
-    /// Internal storage of [struqture::bosons::BosonHamiltonianSystem]
-    pub internal: BosonHamiltonianSystem,
+pub struct BosonHamiltonianWrapper {
+    /// Internal storage of [struqture::bosons::BosonHamiltonian]
+    pub internal: BosonHamiltonian,
 }
 
 #[noiseless_system_wrapper(
     OperateOnBosons,
     OperateOnState,
     OperateOnModes,
     OperateOnDensityMatrix,
-    Calculus
+    HermitianCalculus
 )]
-impl BosonHamiltonianSystemWrapper {
-    /// Create an empty BosonHamiltonianSystem.
-    ///
-    /// Args:
-    ///     number_bosons (Optional[int]): The number of bosons in the BosonHamiltonianSystem.
+impl BosonHamiltonianWrapper {
+    /// Create an empty BosonHamiltonian.
     ///
     /// Returns:
-    ///     self: The new BosonHamiltonianSystem with the input number of bosons.
+    ///     self: The new BosonHamiltonian with the input number of bosons.
     #[new]
-    #[pyo3(signature = (number_bosons = None))]
-    pub fn new(number_bosons: Option<usize>) -> Self {
+    pub fn new() -> Self {
         Self {
-            internal: BosonHamiltonianSystem::new(number_bosons),
+            internal: BosonHamiltonian::new(),
         }
     }
 
-    /// Implement `*` for BosonHamiltonianSystem and BosonHamiltonianSystem/CalculatorComplex/CalculatorFloat.
+    /// Implement `*` for BosonHamiltonian and BosonHamiltonian/CalculatorComplex/CalculatorFloat.
     ///
     /// Args:
-    ///     value (Union[BosonHamiltonianSystem, CalculatorComplex, CalculatorFloat]): value by which to multiply the self BosonHamiltonianSystem
+    ///     value (Union[BosonHamiltonian, CalculatorComplex, CalculatorFloat]): value by which to multiply the self BosonHamiltonian
     ///
     /// Returns:
-    ///     BosonSystem: The BosonHamiltonianSystem multiplied by the value.
+    ///     BosonOperator: The BosonHamiltonian multiplied by the value.
     ///
     /// Raises:
-    ///     ValueError: The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor BosonHamiltonianSystem.
-    pub fn __mul__(&self, value: &PyAny) -> PyResult<BosonSystemWrapper> {
+    ///     ValueError: The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor BosonHamiltonian.
+    pub fn __mul__(&self, value: &PyAny) -> PyResult<BosonOperatorWrapper> {
         let cf_value = qoqo_calculator_pyo3::convert_into_calculator_float(value);
         match cf_value {
-            Ok(x) => Ok(BosonSystemWrapper {
+            Ok(x) => Ok(BosonOperatorWrapper {
                 internal: (self.clone().internal * CalculatorComplex::from(x)),
             }),
             Err(_) => {
                 let cc_value = qoqo_calculator_pyo3::convert_into_calculator_complex(value);
                 match cc_value {
-                    Ok(x) => Ok(BosonSystemWrapper {
+                    Ok(x) => Ok(BosonOperatorWrapper {
                         internal: (self.clone().internal * x),
                     }),
                     Err(_) => {
                         let bhs_value = Self::from_pyany(value.into());
                         match bhs_value {
                             Ok(x) => {
-                                let new_self = (self.clone().internal * x).map_err(|err| {
-                                    PyValueError::new_err(format!(
-                                        "BosonHamiltonianSystems could not be multiplied: {:?}",
-                                        err
-                                    ))
-                                })?;
-                                Ok(BosonSystemWrapper { internal: new_self })
+                                let new_self = self.clone().internal * x;
+                                Ok(BosonOperatorWrapper { internal: new_self })
                             },
                             Err(err) => Err(PyValueError::new_err(format!(
-                                "The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor BosonHamiltonianSystem: {:?}",
+                                "The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor BosonHamiltonian: {:?}",
                                 err))),
                         }
                     }
                 }
             }
         }
     }
 }
+
+impl Default for BosonHamiltonianWrapper {
+    fn default() -> Self {
+        Self::new()
+    }
+}
```

### Comparing `struqture_py-1.6.1/struqture-py/src/bosons/bosonic_noise_system.rs` & `struqture_py-2.0.0a0/struqture-py/src/spins/qubit_noise_operator.rs`

 * *Files 24% similar despite different names*

```diff
@@ -6,92 +6,98 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::bosons::BosonProductWrapper;
+use crate::fermions::FermionLindbladNoiseOperatorWrapper;
+use crate::spins::DecoherenceProductWrapper;
+use crate::{to_py_coo, PyCooMatrix};
 use bincode::deserialize;
-use pyo3::exceptions::{PyTypeError, PyValueError};
+use num_complex::Complex64;
+use pyo3::exceptions::{PyRuntimeError, PyTypeError, PyValueError};
 use pyo3::prelude::*;
 use pyo3::types::PyByteArray;
 use qoqo_calculator_pyo3::CalculatorComplexWrapper;
-use struqture::bosons::BosonLindbladNoiseSystem;
+use struqture::mappings::JordanWignerSpinToFermion;
+use struqture::spins::{OperateOnSpins, QubitLindbladNoiseOperator, ToSparseMatrixSuperOperator};
 #[cfg(feature = "json_schema")]
-use struqture::{MinSupportedVersion, STRUQTURE_VERSION};
-use struqture::{OperateOnDensityMatrix, OperateOnModes};
-use struqture_py_macros::noisy_system_wrapper;
+use struqture::STRUQTURE_VERSION;
+use struqture::{OperateOnDensityMatrix, StruqtureError};
+use struqture_py_macros::{mappings, noisy_system_wrapper};
 
-/// These are representations of noisy systems of bosons.
+/// These are representations of noisy systems of spins.
 ///
-/// In a BosonLindbladNoiseSystem is characterized by a BosonLindbladNoiseOperator to represent the hamiltonian of the system, and an optional number of bosons.
+/// In a QubitLindbladNoiseOperator is characterized by a QubitLindbladNoiseOperator to represent the hamiltonian of the spin system, and an optional number of spins.
 ///
 /// Examples
 /// --------
 ///
 /// .. code-block:: python
 ///
 ///     import numpy.testing as npt
 ///     import scipy.sparse as sp
 ///     from qoqo_calculator_pyo3 import CalculatorComplex
-///     from struqture_py.bosons import BosonLindbladNoiseSystem, BosonProduct
+///     from struqture_py.spins import QubitLindbladNoiseOperator, DecoherenceProduct
 ///
-///     slns = BosonLindbladNoiseSystem()
-///     dp = BosonProduct([0], [1])
+///     slns = QubitLindbladNoiseOperator()
+///     dp = DecoherenceProduct().z(0).x(1)
 ///     slns.add_operator_product((dp, dp), 2.0)
-///     npt.assert_equal(slns.current_number_modes(), 2)
+///     npt.assert_equal(slns.current_number_spins(), 2)
 ///     npt.assert_equal(slns.get((dp, dp)), CalculatorComplex(2))
+///     npt.assert_equal(slns.keys(), [(dp, dp)])
+///     dimension = 4**slns.current_number_spins()
+///     matrix = sp.coo_matrix(slns.sparse_matrix_superoperator_coo(), shape=(dimension, dimension))
 ///
-#[pyclass(name = "BosonLindbladNoiseSystem", module = "struqture_py.bosons")]
+#[pyclass(name = "QubitLindbladNoiseOperator", module = "struqture_py.spins")]
 #[derive(Clone, Debug, PartialEq, Default)]
-pub struct BosonLindbladNoiseSystemWrapper {
-    /// Internal storage of [struqture::bosons::BosonLindbladNoiseSystem]
-    pub internal: BosonLindbladNoiseSystem,
+pub struct QubitLindbladNoiseOperatorWrapper {
+    /// Internal storage of [struqture::spins::QubitLindbladNoiseOperator]
+    pub internal: QubitLindbladNoiseOperator,
 }
 
-#[noisy_system_wrapper(OperateOnModes, OperateOnBosons, OperateOnDensityMatrix, Calculus)]
-impl BosonLindbladNoiseSystemWrapper {
-    /// Create a new BosonLindbladNoiseSystem.
-    ///
-    /// Args:
-    ///     number_bosons (Optional(int)): The number of bosons in the BosonLindbladNoiseSystem.
+#[mappings(JordanWignerSpinToFermion)]
+#[noisy_system_wrapper(
+    OperateOnSpins,
+    OperateOnDensityMatrix,
+    ToSparseMatrixSuperOperator,
+    Calculus
+)]
+impl QubitLindbladNoiseOperatorWrapper {
+    /// Create a new QubitLindbladNoiseOperator.
     ///
     /// Returns:
-    ///     self: The new BosonLindbladNoiseSystem with the input number of bosons.
+    ///     self: The new QubitLindbladNoiseOperator with the input number of spins.
     #[new]
-    #[pyo3(signature = (number_bosons = None))]
-    pub fn new(number_bosons: Option<usize>) -> Self {
+    pub fn new() -> Self {
         Self {
-            internal: BosonLindbladNoiseSystem::new(number_bosons),
+            internal: QubitLindbladNoiseOperator::new(),
         }
     }
 
-    /// Separate self into an operator with the terms of given number of creation and annihilation operators and an operator with the remaining operations.
+    /// Separate self into an operator with the terms of given number of spins and an operator with the remaining operations.
     ///
     /// Args:
-    ///     number_creators_annihilators_left (Tuple[int, int]): Number of creators and number of annihilators to filter for in the left term of the keys.
-    ///     number_creators_annihilators_right (Tuple[int, int]): Number of creators and number of annihilators to filter for in the right term of the keys.
+    ///     number_spins_left (int): Number of spins to filter for in the left term of the keys.
+    ///     number_spins_right (int): Number of spins to filter for in the right term of the keys.
     ///
     /// Returns:
-    ///     Tuple[BosonLindbladNoiseSystem, BosonLindbladNoiseSystem]: Operator with the noise terms where the number of creation and annihilation operators matches the number of spins the operator product acts on and Operator with all other contributions.
+    ///     Tuple[QubitLindbladNoiseOperator, QubitLindbladNoiseOperator]: Operator with the noise terms where the number of spins matches the number of spins the operator product acts on and Operator with all other contributions.
     ///
     /// Raises:
     ///     ValueError: Error in adding terms to return values.
     pub fn separate_into_n_terms(
         &self,
-        number_creators_annihilators_left: (usize, usize),
-        number_creators_annihilators_right: (usize, usize),
+        number_spins_left: usize,
+        number_spins_right: usize,
     ) -> PyResult<(Self, Self)> {
         let (separated, remainder) = self
             .internal
-            .separate_into_n_terms(
-                number_creators_annihilators_left,
-                number_creators_annihilators_right,
-            )
+            .separate_into_n_terms(number_spins_left, number_spins_right)
             .map_err(|err| PyValueError::new_err(format!("{:?}", err)))?;
         Ok((
             Self {
                 internal: separated,
             },
             Self {
                 internal: remainder,
```

### Comparing `struqture_py-1.6.1/struqture-py/src/bosons/bosonic_open_system.rs` & `struqture_py-2.0.0a0/struqture-py/src/bosons/bosonic_open_system.rs`

 * *Files 14% similar despite different names*

```diff
@@ -7,25 +7,25 @@
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
 use super::{
-    BosonHamiltonianSystemWrapper, BosonLindbladNoiseSystemWrapper, BosonProductWrapper,
+    BosonHamiltonianWrapper, BosonLindbladNoiseOperatorWrapper, BosonProductWrapper,
     HermitianBosonProductWrapper,
 };
 use bincode::deserialize;
 use pyo3::exceptions::{PyTypeError, PyValueError};
 use pyo3::prelude::*;
 use pyo3::types::PyByteArray;
 use qoqo_calculator_pyo3::CalculatorComplexWrapper;
 use struqture::bosons::BosonLindbladOpenSystem;
 #[cfg(feature = "json_schema")]
-use struqture::{MinSupportedVersion, STRUQTURE_VERSION};
+use struqture::STRUQTURE_VERSION;
 use struqture::{OpenSystem, OperateOnDensityMatrix, OperateOnModes};
 use struqture_py_macros::noisy_system_wrapper;
 
 /// These are representations of noisy systems of bosons.
 ///
 /// In a BosonLindbladOpenSystem is characterized by a BosonLindbladOpenOperator to represent the hamiltonian of the system, and an optional number of bosons.
 ///
@@ -48,24 +48,20 @@
 #[pyclass(name = "BosonLindbladOpenSystem", module = "struqture_py.bosons")]
 #[derive(Clone, Debug, PartialEq, Default)]
 pub struct BosonLindbladOpenSystemWrapper {
     /// Internal storage of [struqture::bosons::BosonLindbladOpenSystem]
     pub internal: BosonLindbladOpenSystem,
 }
 
-#[noisy_system_wrapper(OpenSystem, OperateOnModes, Calculus)]
+#[noisy_system_wrapper(OpenSystem, OperateOnModes, HermitianCalculus)]
 impl BosonLindbladOpenSystemWrapper {
     /// Create a new BosonLindbladOpenSystem.
     ///
-    /// Args:
-    ///     number_bosons (Optional(int)): The number of bosons in the BosonLindbladOpenSystem.
-    ///
     /// Returns:
     ///     self: The new BosonLindbladOpenSystem with the input number of bosons.
     #[new]
-    #[pyo3(signature = (number_bosons = None))]
-    pub fn new(number_bosons: Option<usize>) -> Self {
+    pub fn new() -> Self {
         Self {
-            internal: BosonLindbladOpenSystem::new(number_bosons),
+            internal: BosonLindbladOpenSystem::new(),
         }
     }
 }
```

### Comparing `struqture_py-1.6.1/struqture-py/src/bosons/bosonic_system.rs` & `struqture_py-2.0.0a0/struqture-py/src/fermions/fermionic_operator.rs`

 * *Files 16% similar despite different names*

```diff
@@ -6,93 +6,92 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::bosons::BosonProductWrapper;
+use crate::fermions::FermionProductWrapper;
+use crate::spins::QubitOperatorWrapper;
 use bincode::deserialize;
 use pyo3::exceptions::{PyTypeError, PyValueError};
 use pyo3::prelude::*;
 use pyo3::types::PyByteArray;
 use qoqo_calculator::CalculatorComplex;
 use qoqo_calculator_pyo3::CalculatorComplexWrapper;
-use struqture::bosons::BosonSystem;
+use struqture::fermions::FermionOperator;
+use struqture::mappings::JordanWignerFermionToSpin;
 #[cfg(feature = "json_schema")]
-use struqture::{MinSupportedVersion, STRUQTURE_VERSION};
+use struqture::STRUQTURE_VERSION;
 use struqture::{OperateOnDensityMatrix, OperateOnModes, OperateOnState};
-use struqture_py_macros::noiseless_system_wrapper;
+use struqture_py_macros::{mappings, noiseless_system_wrapper};
 
-/// These are representations of systems of bosons.
+/// These are representations of systems of fermions.
 ///
-/// BosonSystems are characterized by a BosonOperator to represent the hamiltonian of the spin system
-/// and an optional number of bosons.
+/// FermionOperators are characterized by a FermionOperator to represent the hamiltonian of the spin system
+/// and an optional number of fermions.
 ///
 /// Examples
 /// --------
 ///
 /// .. code-block:: python
 ///
 ///     import numpy.testing as npt
 ///     import scipy.sparse as sp
 ///     from qoqo_calculator_pyo3 import CalculatorComplex
-///     from struqture_py.bosons import BosonSystem, BosonProduct
+///     from struqture_py.fermions import FermionOperator, FermionProduct
 ///
-///     ssystem = BosonSystem(2)
-///     pp = BosonProduct([0], [1])
+///     ssystem = FermionOperator(2)
+///     pp = FermionProduct([0], [0])
 ///     ssystem.add_operator_product(pp, 5.0)
-///     npt.assert_equal(ssystem.number_modes(), 2)
+///     npt.assert_equal(ssystem.current_number_modes(), 2)
 ///     npt.assert_equal(ssystem.get(pp), CalculatorComplex(5))
 ///     npt.assert_equal(ssystem.keys(), [pp])
 ///
-#[pyclass(name = "BosonSystem", module = "struqture_py.bosons")]
+#[pyclass(name = "FermionOperator", module = "struqture_py.fermions")]
 #[derive(Clone, Debug, PartialEq)]
-pub struct BosonSystemWrapper {
-    /// Internal storage of [struqture::bosons::BosonSystem]
-    pub internal: BosonSystem,
+pub struct FermionOperatorWrapper {
+    /// Internal storage of [struqture::fermions::FermionOperator]
+    pub internal: FermionOperator,
 }
 
+#[mappings(JordanWignerFermionToSpin)]
 #[noiseless_system_wrapper(
-    OperateOnBosons,
+    OperateOnFermions,
     OperateOnState,
     OperateOnModes,
     OperateOnDensityMatrix,
     Calculus
 )]
-impl BosonSystemWrapper {
-    /// Create an empty BosonSystem.
-    ///
-    /// Args:
-    ///     number_bosons (Optional[int]): The number of bosons in the BosonSystem.
+impl FermionOperatorWrapper {
+    /// Create an empty FermionOperator.
     ///
     /// Returns:
-    ///     self: The new BosonSystem with the input number of bosons.
+    ///     self: The new FermionOperator with the input number of fermions.
     #[new]
-    #[pyo3(signature = (number_bosons = None))]
-    pub fn new(number_bosons: Option<usize>) -> Self {
+    pub fn new() -> Self {
         Self {
-            internal: BosonSystem::new(number_bosons),
+            internal: FermionOperator::new(),
         }
     }
 
-    /// Implement `*` for BosonSystem and BosonSystem/CalculatorComplex/CalculatorFloat.
+    /// Implement `*` for FermionOperator and FermionOperator/CalculatorComplex/CalculatorFloat.
     ///
     /// Args:
-    ///     value (Union[BosonSystem, CalculatorComplex, CalculatorFloat]): value by which to multiply the self BosonSystem
+    ///     value (Union[FermionOperator, CalculatorComplex, CalculatorFloat]): value by which to multiply the self FermionOperator
     ///
     /// Returns:
-    ///     BosonSystem: The BosonSystem multiplied by the value.
+    ///     FermionOperator: The FermionOperator multiplied by the value.
     ///
     /// Raises:
-    ///     ValueError: The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor BosonSystem.
+    ///     ValueError: The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor FermionOperator.
     pub fn __mul__(&self, value: &PyAny) -> PyResult<Self> {
         let cf_value = qoqo_calculator_pyo3::convert_into_calculator_float(value);
         match cf_value {
-            Ok(x) => Ok(BosonSystemWrapper {
+            Ok(x) => Ok(FermionOperatorWrapper {
                 internal: self.clone().internal * CalculatorComplex::from(x),
             }),
             Err(_) => {
                 let cc_value = qoqo_calculator_pyo3::convert_into_calculator_complex(value);
                 match cc_value {
                     Ok(x) => Ok(Self {
                         internal: self.clone().internal * x,
@@ -101,16 +100,22 @@
                         let bhs_value = Self::from_pyany(value.into());
                         match bhs_value {
                             Ok(x) => {
                                 let new_self = self.clone().internal * x;
                                 Ok(Self { internal: new_self })
                             },
                             Err(err) => Err(PyValueError::new_err(format!(
-                                "The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor BosonSystem: {:?}",
+                                "The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor FermionOperator: {:?}",
                                 err)))
                         }
                     }
                 }
             }
         }
     }
 }
+
+impl Default for FermionOperatorWrapper {
+    fn default() -> Self {
+        Self::new()
+    }
+}
```

### Comparing `struqture_py-1.6.1/struqture-py/src/bosons/hermitian_boson_product.rs` & `struqture_py-2.0.0a0/struqture-py/src/bosons/hermitian_boson_product.rs`

 * *Files 6% similar despite different names*

```diff
@@ -17,16 +17,17 @@
 use pyo3::types::PyType;
 use std::collections::hash_map::DefaultHasher;
 use std::collections::HashMap;
 use std::hash::{Hash, Hasher};
 use std::str::FromStr;
 use struqture::bosons::*;
 use struqture::prelude::*;
+use struqture::SerializationSupport;
 #[cfg(feature = "json_schema")]
-use struqture::{MinSupportedVersion, STRUQTURE_VERSION};
+use struqture::STRUQTURE_VERSION;
 use struqture_py_macros::product_wrapper;
 
 /// A product of bosonic creation and annihilation operators.
 ///
 /// The HermitianBosonProduct is used as an index for non-hermitian, normal ordered bosonic operators.
 /// A bosonic operator can be written as a sum over normal ordered products of creation and annihilation operators.
 /// The HermitianBosonProduct is used as an index when setting or adding new summands to a bosonic operator and when querrying the
```

### Comparing `struqture_py-1.6.1/struqture-py/src/bosons/mod.rs` & `struqture_py-2.0.0a0/struqture-py/src/bosons/mod.rs`

 * *Files 11% similar despite different names*

```diff
@@ -13,61 +13,61 @@
 //! Module for representing bosonic physical systems
 //!
 //! A boson system can contain any combination of none, one or several subsystems of spin, bosonic or fermionic types.
 //! For example a mixed system with two spin-subsystems or a mixed system with a spin-subsystem and a bosonic-subsystem would both be valid.
 //!
 //! This module can be used to represent mixed quantum operators, mixed quantum Hamiltonians and mixed open quantum systems.
 //!
-//! In general the enduser should use the high-level modules [struqture::mixed_systems::MixedSystem] and [struqture::mixed_systems::MixedHamiltonianSystem]
+//! In general the enduser should use the high-level modules [struqture::mixed_systems::MixedOperator] and [struqture::mixed_systems::MixedHamiltonian]
 //! to represent mixed quantum Operators and mixed Hamiltonians respectively.
 //!
 //! Open Quantum Systems should be represented using [struqture::mixed_systems::MixedLindbladOpenSystem].
 //!
 //!
 
 use pyo3::prelude::*;
 
 mod boson_product;
 pub use boson_product::BosonProductWrapper;
 
 mod hermitian_boson_product;
 pub use hermitian_boson_product::HermitianBosonProductWrapper;
 
-mod bosonic_system;
-pub use bosonic_system::BosonSystemWrapper;
+mod bosonic_operator;
+pub use bosonic_operator::BosonOperatorWrapper;
 
-mod bosonic_hamiltonian_system;
-pub use bosonic_hamiltonian_system::BosonHamiltonianSystemWrapper;
+mod bosonic_hamiltonian;
+pub use bosonic_hamiltonian::BosonHamiltonianWrapper;
 
-mod bosonic_noise_system;
-pub use bosonic_noise_system::BosonLindbladNoiseSystemWrapper;
+mod bosonic_noise_operator;
+pub use bosonic_noise_operator::BosonLindbladNoiseOperatorWrapper;
 
 mod bosonic_open_system;
 pub use bosonic_open_system::BosonLindbladOpenSystemWrapper;
 
 /// Bosons module of struqture Python interface
 ///
-/// Module for representing bosonic indices (BosonProduct and HermitianBosonProduct), bosonic systems (BosonSystem and BosonHamiltonianSystem),
-/// and Lindblad type bosonic open systems (BosonLindbladNoiseSystem, BosonLindbladOpenSystem).
+/// Module for representing bosonic indices (BosonProduct and HermitianBosonProduct), bosonic systems (BosonOperator and BosonHamiltonian),
+/// and Lindblad type bosonic open systems (BosonLindbladNoiseOperator, BosonLindbladOpenSystem).
 ///
 /// .. autosummary::
 ///     :toctree: generated/
 ///
 ///     BosonProduct
 ///     HermitianBosonProduct
-///     BosonSystem
-///     BosonHamiltonianSystem
-///     BosonLindbladNoiseSystem
+///     BosonOperator
+///     BosonHamiltonian
+///     BosonLindbladNoiseOperator
 ///     BosonLindbladOpenSystem
 ///
 #[pymodule]
 pub fn bosons(_py: Python, m: &PyModule) -> PyResult<()> {
     // pyo3_log::init();
     m.add_class::<BosonProductWrapper>()?;
     m.add_class::<HermitianBosonProductWrapper>()?;
-    m.add_class::<BosonSystemWrapper>()?;
-    m.add_class::<BosonHamiltonianSystemWrapper>()?;
-    m.add_class::<BosonLindbladNoiseSystemWrapper>()?;
+    m.add_class::<BosonOperatorWrapper>()?;
+    m.add_class::<BosonHamiltonianWrapper>()?;
+    m.add_class::<BosonLindbladNoiseOperatorWrapper>()?;
     m.add_class::<BosonLindbladOpenSystemWrapper>()?;
 
     Ok(())
 }
```

### Comparing `struqture_py-1.6.1/struqture-py/src/fermions/fermion_product.rs` & `struqture_py-2.0.0a0/struqture-py/src/fermions/fermion_product.rs`

 * *Files 2% similar despite different names*

```diff
@@ -6,29 +6,29 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::spins::SpinSystemWrapper;
+use crate::spins::QubitOperatorWrapper;
 use pyo3::exceptions::{PyTypeError, PyValueError};
 use pyo3::prelude::*;
 use pyo3::types::PyByteArray;
 use pyo3::types::PyType;
 use std::collections::hash_map::DefaultHasher;
 use std::collections::HashMap;
 use std::hash::{Hash, Hasher};
 use std::str::FromStr;
 use struqture::fermions::*;
 use struqture::mappings::JordanWignerFermionToSpin;
 use struqture::prelude::*;
-use struqture::spins::*;
+use struqture::SerializationSupport;
 #[cfg(feature = "json_schema")]
-use struqture::{MinSupportedVersion, STRUQTURE_VERSION};
+use struqture::STRUQTURE_VERSION;
 use struqture_py_macros::{mappings, product_wrapper};
 
 /// A product of fermionic creation and annihilation operators.
 ///
 /// The FermionProduct is used as an index for non-hermitian, normal ordered fermionic operators.
 /// A fermionic operator can be written as a sum over normal ordered products of creation and annihilation operators.
 /// The FermionProduct is used as an index when setting or adding new summands to a fermionic operator and when querrying the
```

### Comparing `struqture_py-1.6.1/struqture-py/src/fermions/fermionic_hamiltonian_system.rs` & `struqture_py-2.0.0a0/struqture-py/src/fermions/fermionic_hamiltonian.rs`

 * *Files 15% similar despite different names*

```diff
@@ -6,122 +6,124 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
-use super::FermionSystemWrapper;
+use super::FermionOperatorWrapper;
 use crate::fermions::HermitianFermionProductWrapper;
-use crate::spins::SpinHamiltonianSystemWrapper;
+use crate::spins::QubitHamiltonianWrapper;
 use bincode::deserialize;
 use pyo3::exceptions::{PyTypeError, PyValueError};
 use pyo3::prelude::*;
 use pyo3::types::PyByteArray;
 use qoqo_calculator::CalculatorComplex;
 use qoqo_calculator_pyo3::CalculatorComplexWrapper;
-use struqture::fermions::FermionHamiltonianSystem;
+use struqture::fermions::FermionHamiltonian;
 use struqture::mappings::JordanWignerFermionToSpin;
 #[cfg(feature = "json_schema")]
-use struqture::{MinSupportedVersion, STRUQTURE_VERSION};
+use struqture::STRUQTURE_VERSION;
 use struqture::{OperateOnDensityMatrix, OperateOnModes, OperateOnState};
 use struqture_py_macros::{mappings, noiseless_system_wrapper};
 
 /// These are representations of systems of fermions.
 ///
-/// FermionHamiltonianSystems are characterized by a FermionOperator to represent the hamiltonian of the spin system
+/// FermionHamiltonians are characterized by a FermionOperator to represent the hamiltonian of the spin system
 /// and an optional number of fermions.
 ///
 /// Examples
 /// --------
 ///
 /// .. code-block:: python
 ///
 ///     import numpy.testing as npt
 ///     import scipy.sparse as sp
 ///     from qoqo_calculator_pyo3 import CalculatorComplex
-///     from struqture_py.fermions import FermionHamiltonianSystem, HermitianFermionProduct
+///     from struqture_py.fermions import FermionHamiltonian, HermitianFermionProduct
 ///
-///     ssystem = FermionHamiltonianSystem(2)
+///     ssystem = FermionHamiltonian()
 ///     pp = HermitianFermionProduct([0], [0])
 ///     ssystem.add_operator_product(pp, 5.0)
-///     npt.assert_equal(ssystem.number_modes(), 2)
+///     npt.assert_equal(ssystem.current_number_modes(), 2)
 ///     npt.assert_equal(ssystem.get(pp), CalculatorComplex(5))
 ///     npt.assert_equal(ssystem.keys(), [pp])
 ///
-#[pyclass(name = "FermionHamiltonianSystem", module = "struqture_py.fermions")]
+#[pyclass(name = "FermionHamiltonian", module = "struqture_py.fermions")]
 #[derive(Clone, Debug, PartialEq)]
-pub struct FermionHamiltonianSystemWrapper {
-    /// Internal storage of [struqture::fermions::FermionHamiltonianSystem]
-    pub internal: FermionHamiltonianSystem,
+pub struct FermionHamiltonianWrapper {
+    /// Internal storage of [struqture::fermions::FermionHamiltonian]
+    pub internal: FermionHamiltonian,
 }
 
 #[mappings(JordanWignerFermionToSpin)]
 #[noiseless_system_wrapper(
     OperateOnFermions,
     OperateOnState,
     OperateOnModes,
     OperateOnDensityMatrix,
-    Calculus
+    HermitianCalculus
 )]
-impl FermionHamiltonianSystemWrapper {
-    /// Create an empty FermionHamiltonianSystem.
-    ///
-    /// Args:
-    ///     number_fermions (Optional[int]): The number of fermions in the FermionHamiltonianSystem.
+impl FermionHamiltonianWrapper {
+    /// Create an empty FermionHamiltonian.
     ///
     /// Returns:
-    ///     self: The new FermionHamiltonianSystem with the input number of fermions.
+    ///     self: The new FermionHamiltonian with the input number of fermions.
     #[new]
-    #[pyo3(signature = (number_fermions = None))]
-    pub fn new(number_fermions: Option<usize>) -> Self {
+    pub fn new() -> Self {
         Self {
-            internal: FermionHamiltonianSystem::new(number_fermions),
+            internal: FermionHamiltonian::new(),
         }
     }
 
-    /// Implement `*` for FermionHamiltonianSystem and FermionHamiltonianSystem/CalculatorComplex/CalculatorFloat.
+    /// Implement `*` for FermionHamiltonian and FermionHamiltonian/CalculatorComplex/CalculatorFloat.
     ///
     /// Args:
-    ///     value (Union[FermionHamiltonianSystem, CalculatorComplex, CalculatorFloat]): value by which to multiply the self FermionHamiltonianSystem
+    ///     value (Union[FermionHamiltonian, CalculatorComplex, CalculatorFloat]): value by which to multiply the self FermionHamiltonian
     ///
     /// Returns:
-    ///     FermionSystem: The FermionHamiltonianSystem multiplied by the value.
+    ///     FermionOperator: The FermionHamiltonian multiplied by the value.
     ///
     /// Raises:
-    ///     ValueError: The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor FermionHamiltonianSystem.
-    pub fn __mul__(&self, value: &PyAny) -> PyResult<FermionSystemWrapper> {
+    ///     ValueError: The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor FermionHamiltonian.
+    pub fn __mul__(&self, value: &PyAny) -> PyResult<FermionOperatorWrapper> {
         let cf_value = qoqo_calculator_pyo3::convert_into_calculator_float(value);
         match cf_value {
-            Ok(x) => Ok(FermionSystemWrapper {
+            Ok(x) => Ok(FermionOperatorWrapper {
                 internal: (self.clone().internal * CalculatorComplex::from(x))
-                    .map_err(|_| PyTypeError::new_err("System cannot be multiplied"))?,
+                    .map_err(|_| PyTypeError::new_err("Operator cannot be multiplied"))?,
             }),
             Err(_) => {
                 let cc_value = qoqo_calculator_pyo3::convert_into_calculator_complex(value);
                 match cc_value {
-                    Ok(x) => Ok(FermionSystemWrapper {
+                    Ok(x) => Ok(FermionOperatorWrapper {
                         internal: (self.clone().internal * x)
-                            .map_err(|_| PyTypeError::new_err("System cannot be multiplied"))?,
+                            .map_err(|_| PyTypeError::new_err("Operator cannot be multiplied"))?,
                     }),
                     Err(_) => {
                         let bhs_value = Self::from_pyany(value.into());
                         match bhs_value {
                             Ok(x) => {
                                 let new_self = (self.clone().internal * x).map_err(|err| {
                                     PyValueError::new_err(format!(
-                                        "FermionHamiltonianSystems could not be multiplied: {:?}",
+                                        "FermionHamiltonians could not be multiplied: {:?}",
                                         err
                                     ))
                                 })?;
-                                Ok(FermionSystemWrapper { internal: new_self })
+                                Ok(FermionOperatorWrapper { internal: new_self })
                             },
                             Err(err) => Err(PyValueError::new_err(format!(
-                                "The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor FermionHamiltonianSystem: {:?}",
+                                "The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor FermionHamiltonian: {:?}",
                                 err)))
                         }
                     }
                 }
             }
         }
     }
 }
+
+impl Default for FermionHamiltonianWrapper {
+    fn default() -> Self {
+        Self::new()
+    }
+}
```

### Comparing `struqture_py-1.6.1/struqture-py/src/fermions/fermionic_open_system.rs` & `struqture_py-2.0.0a0/struqture-py/src/fermions/fermionic_open_system.rs`

 * *Files 4% similar despite different names*

```diff
@@ -7,27 +7,27 @@
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
 use super::{
-    FermionHamiltonianSystemWrapper, FermionLindbladNoiseSystemWrapper, FermionProductWrapper,
+    FermionHamiltonianWrapper, FermionLindbladNoiseOperatorWrapper, FermionProductWrapper,
     HermitianFermionProductWrapper,
 };
-use crate::spins::SpinLindbladOpenSystemWrapper;
+use crate::spins::QubitLindbladOpenSystemWrapper;
 use bincode::deserialize;
 use pyo3::exceptions::{PyTypeError, PyValueError};
 use pyo3::prelude::*;
 use pyo3::types::PyByteArray;
 use qoqo_calculator_pyo3::CalculatorComplexWrapper;
 use struqture::fermions::FermionLindbladOpenSystem;
 use struqture::mappings::JordanWignerFermionToSpin;
 #[cfg(feature = "json_schema")]
-use struqture::{MinSupportedVersion, STRUQTURE_VERSION};
+use struqture::STRUQTURE_VERSION;
 use struqture::{OpenSystem, OperateOnDensityMatrix, OperateOnModes};
 use struqture_py_macros::{mappings, noisy_system_wrapper};
 
 /// These are representations of noisy systems of fermions.
 ///
 /// In a FermionLindbladOpenSystem is characterized by a FermionLindbladOpenOperator to represent the hamiltonian of the system, and an optional number of fermions.
 ///
@@ -51,24 +51,20 @@
 #[derive(Clone, Debug, PartialEq, Default)]
 pub struct FermionLindbladOpenSystemWrapper {
     /// Internal storage of [struqture::fermions::FermionLindbladOpenSystem]
     pub internal: FermionLindbladOpenSystem,
 }
 
 #[mappings(JordanWignerFermionToSpin)]
-#[noisy_system_wrapper(OpenSystem, OperateOnModes, Calculus)]
+#[noisy_system_wrapper(OpenSystem, OperateOnModes, HermitianCalculus)]
 impl FermionLindbladOpenSystemWrapper {
     /// Create a new FermionLindbladOpenSystem.
     ///
-    /// Args:
-    ///     number_fermions (Optional(int)): The number of fermions in the FermionLindbladOpenSystem.
-    ///
     /// Returns:
     ///     self: The new FermionLindbladOpenSystem with the input number of fermions.
     #[new]
-    #[pyo3(signature = (number_fermions = None))]
-    pub fn new(number_fermions: Option<usize>) -> Self {
+    pub fn new() -> Self {
         Self {
-            internal: FermionLindbladOpenSystem::new(number_fermions),
+            internal: FermionLindbladOpenSystem::new(),
         }
     }
 }
```

### Comparing `struqture_py-1.6.1/struqture-py/src/fermions/fermionic_system.rs` & `struqture_py-2.0.0a0/struqture-py/src/mixed_systems/mixed_operator.rs`

 * *Files 22% similar despite different names*

```diff
@@ -6,113 +6,123 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::fermions::FermionProductWrapper;
-use crate::spins::SpinSystemWrapper;
+use crate::mixed_systems::MixedProductWrapper;
 use bincode::deserialize;
 use pyo3::exceptions::{PyTypeError, PyValueError};
 use pyo3::prelude::*;
 use pyo3::types::PyByteArray;
 use qoqo_calculator::CalculatorComplex;
 use qoqo_calculator_pyo3::CalculatorComplexWrapper;
-use struqture::fermions::FermionSystem;
-use struqture::mappings::JordanWignerFermionToSpin;
+use struqture::mixed_systems::{MixedOperator, OperateOnMixedSystems};
 #[cfg(feature = "json_schema")]
-use struqture::{MinSupportedVersion, STRUQTURE_VERSION};
-use struqture::{OperateOnDensityMatrix, OperateOnModes, OperateOnState};
-use struqture_py_macros::{mappings, noiseless_system_wrapper};
+use struqture::STRUQTURE_VERSION;
+use struqture::{OperateOnDensityMatrix, OperateOnState};
+use struqture_py_macros::noiseless_system_wrapper;
 
-/// These are representations of systems of fermions.
+/// These are representations of systems of mixed_systems.
 ///
-/// FermionSystems are characterized by a FermionOperator to represent the hamiltonian of the spin system
-/// and an optional number of fermions.
+/// MixedOperators are characterized by a MixedOperator to represent the hamiltonian of the spin system
+/// and an optional number of mixed_systems.
 ///
 /// Examples
 /// --------
 ///
 /// .. code-block:: python
 ///
 ///     import numpy.testing as npt
 ///     import scipy.sparse as sp
 ///     from qoqo_calculator_pyo3 import CalculatorComplex
-///     from struqture_py.fermions import FermionSystem, FermionProduct
+///     from struqture_py.mixed_systems import MixedOperator, MixedProduct
+///     from struqture_py.spins import PauliProduct
+///     from struqture_py.bosons import BosonProduct
+///     from struqture_py.fermions import FermionProduct
 ///
-///     ssystem = FermionSystem(2)
-///     pp = FermionProduct([0], [0])
+///     ssystem = MixedOperator([2], [2], [2])
+///     pp = MixedProduct([PauliProduct().z(0)], [BosonProduct([0], [1])], [FermionProduct([0], [0])])
 ///     ssystem.add_operator_product(pp, 5.0)
-///     npt.assert_equal(ssystem.number_modes(), 2)
+///     npt.assert_equal(ssystem.current_number_spins(), [2])
 ///     npt.assert_equal(ssystem.get(pp), CalculatorComplex(5))
-///     npt.assert_equal(ssystem.keys(), [pp])
 ///
-#[pyclass(name = "FermionSystem", module = "struqture_py.fermions")]
+#[pyclass(name = "MixedOperator", module = "struqture_py.mixed_systems")]
 #[derive(Clone, Debug, PartialEq)]
-pub struct FermionSystemWrapper {
-    /// Internal storage of [struqture::fermions::FermionSystem]
-    pub internal: FermionSystem,
+pub struct MixedOperatorWrapper {
+    /// Internal storage of [struqture::mixed_systems::MixedOperator]
+    pub internal: MixedOperator,
 }
 
-#[mappings(JordanWignerFermionToSpin)]
 #[noiseless_system_wrapper(
-    OperateOnFermions,
+    OperateOnMixedSystems,
+    HermitianOperateOnMixedSystems,
     OperateOnState,
-    OperateOnModes,
     OperateOnDensityMatrix,
-    Calculus
+    HermitianCalculus
 )]
-impl FermionSystemWrapper {
-    /// Create an empty FermionSystem.
+impl MixedOperatorWrapper {
+    /// Create an empty MixedOperator.
     ///
     /// Args:
-    ///     number_fermions (Optional[int]): The number of fermions in the FermionSystem.
+    ///     number_spins (int): The number of spin subsystems in the MixedOperator.
+    ///     number_bosons (int): The number of boson subsystems in the MixedOperator.
+    ///     number_fermions (int): The number of fermion subsystems in the MixedOperator.
     ///
     /// Returns:
-    ///     self: The new FermionSystem with the input number of fermions.
+    ///     self: The new (empty) MixedOperator.
     #[new]
-    #[pyo3(signature = (number_fermions = None))]
-    pub fn new(number_fermions: Option<usize>) -> Self {
+    #[pyo3(signature = (
+        number_spins,
+        number_bosons,
+        number_fermions,
+    ))]
+    pub fn new(number_spins: usize, number_bosons: usize, number_fermions: usize) -> Self {
         Self {
-            internal: FermionSystem::new(number_fermions),
+            internal: MixedOperator::new(number_spins, number_bosons, number_fermions),
         }
     }
 
-    /// Implement `*` for FermionSystem and FermionSystem/CalculatorComplex/CalculatorFloat.
+    /// Implement `*` for MixedOperator and MixedOperator/CalculatorComplex/CalculatorFloat.
     ///
     /// Args:
-    ///     value (Union[FermionSystem, CalculatorComplex, CalculatorFloat]): value by which to multiply the self FermionSystem
+    ///     value (Union[MixedOperator, CalculatorComplex, CalculatorFloat]): value by which to multiply the self MixedOperator
     ///
     /// Returns:
-    ///     FermionSystem: The FermionSystem multiplied by the value.
+    ///     MixedOperator: The MixedOperator multiplied by the value.
     ///
     /// Raises:
-    ///     ValueError: The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor FermionSystem.
+    ///     ValueError: The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor MixedOperator.
     pub fn __mul__(&self, value: &PyAny) -> PyResult<Self> {
         let cf_value = qoqo_calculator_pyo3::convert_into_calculator_float(value);
         match cf_value {
-            Ok(x) => Ok(FermionSystemWrapper {
+            Ok(x) => Ok(Self {
                 internal: self.clone().internal * CalculatorComplex::from(x),
             }),
             Err(_) => {
                 let cc_value = qoqo_calculator_pyo3::convert_into_calculator_complex(value);
                 match cc_value {
                     Ok(x) => Ok(Self {
                         internal: self.clone().internal * x,
                     }),
                     Err(_) => {
                         let bhs_value = Self::from_pyany(value.into());
                         match bhs_value {
                             Ok(x) => {
-                                let new_self = self.clone().internal * x;
+                                let new_self = (self.clone().internal * x).map_err(|err| {
+                                    PyValueError::new_err(format!(
+                                        "MixedOperators could not be multiplied: {:?}",
+                                        err
+                                    ))
+                                })?;
                                 Ok(Self { internal: new_self })
                             },
                             Err(err) => Err(PyValueError::new_err(format!(
-                                "The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor FermionSystem: {:?}",
+                                "The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor MixedOperator: {:?}",
                                 err)))
                         }
                     }
                 }
             }
         }
     }
```

### Comparing `struqture_py-1.6.1/struqture-py/src/fermions/hermitian_fermion_product.rs` & `struqture_py-2.0.0a0/struqture-py/src/fermions/hermitian_fermion_product.rs`

 * *Files 2% similar despite different names*

```diff
@@ -7,29 +7,29 @@
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
 use super::FermionProductWrapper;
-use crate::spins::SpinHamiltonianSystemWrapper;
+use crate::spins::QubitHamiltonianWrapper;
 use pyo3::exceptions::{PyTypeError, PyValueError};
 use pyo3::prelude::*;
 use pyo3::types::PyByteArray;
 use pyo3::types::PyType;
 use std::collections::hash_map::DefaultHasher;
 use std::collections::HashMap;
 use std::hash::{Hash, Hasher};
 use std::str::FromStr;
 use struqture::fermions::*;
 use struqture::mappings::JordanWignerFermionToSpin;
 use struqture::prelude::*;
-use struqture::spins::*;
+use struqture::SerializationSupport;
 #[cfg(feature = "json_schema")]
-use struqture::{MinSupportedVersion, STRUQTURE_VERSION};
+use struqture::STRUQTURE_VERSION;
 use struqture_py_macros::{mappings, product_wrapper};
 
 /// A product of fermionic creation and annihilation operators.
 ///
 /// The HermitianFermionProduct is used as an index for non-hermitian, normal ordered fermionic operators.
 /// A fermionic operator can be written as a sum over normal ordered products of creation and annihilation operators.
 /// The HermitianFermionProduct is used as an index when setting or adding new summands to a fermionic operator and when querrying the
```

### Comparing `struqture_py-1.6.1/struqture-py/src/fermions/mod.rs` & `struqture_py-2.0.0a0/struqture-py/src/fermions/mod.rs`

 * *Files 16% similar despite different names*

```diff
@@ -13,61 +13,61 @@
 //! Module for representing fermionic physical systems
 //!
 //! A fermion system can contain any combination of none, one or several subsystems of spin, fermionic or fermionic types.
 //! For example a mixed system with two spin-subsystems or a mixed system with a spin-subsystem and a fermionic-subsystem would both be valid.
 //!
 //! This module can be used to represent mixed quantum operators, mixed quantum Hamiltonians and mixed open quantum systems.
 //!
-//! In general the enduser should use the high-level modules [struqture::mixed_systems::MixedSystem] and [struqture::mixed_systems::MixedHamiltonianSystem]
+//! In general the enduser should use the high-level modules [struqture::mixed_systems::MixedOperator] and [struqture::mixed_systems::MixedHamiltonian]
 //! to represent mixed quantum Operators and mixed Hamiltonians respectively.
 //!
 //! Open Quantum Systems should be represented using [struqture::mixed_systems::MixedLindbladOpenSystem].
 //!
 //!
 
 use pyo3::prelude::*;
 
 mod fermion_product;
 pub use fermion_product::FermionProductWrapper;
 
 mod hermitian_fermion_product;
 pub use hermitian_fermion_product::HermitianFermionProductWrapper;
 
-mod fermionic_system;
-pub use fermionic_system::FermionSystemWrapper;
+mod fermionic_operator;
+pub use fermionic_operator::FermionOperatorWrapper;
 
-mod fermionic_hamiltonian_system;
-pub use fermionic_hamiltonian_system::FermionHamiltonianSystemWrapper;
+mod fermionic_hamiltonian;
+pub use fermionic_hamiltonian::FermionHamiltonianWrapper;
 
-mod fermionic_noise_system;
-pub use fermionic_noise_system::FermionLindbladNoiseSystemWrapper;
+mod fermionic_noise_operator;
+pub use fermionic_noise_operator::FermionLindbladNoiseOperatorWrapper;
 
 mod fermionic_open_system;
 pub use fermionic_open_system::FermionLindbladOpenSystemWrapper;
 
 /// Fermions module of struqture Python interface
 ///
-/// Module for representing fermionic indices (FermionProduct and HermitianFermionProduct), fermionic systems (FermionSystem and FermionHamiltonianSystem),
-/// and Lindblad type fermionic open systems (FermionLindbladNoiseSystem, FermionLindbladOpenSystem).
+/// Module for representing fermionic indices (FermionProduct and HermitianFermionProduct), fermionic systems (FermionOperator and FermionHamiltonian),
+/// and Lindblad type fermionic open systems (FermionLindbladNoiseOperator, FermionLindbladOpenSystem).
 ///
 /// .. autosummary::
 ///     :toctree: generated/
 ///
 ///     FermionProduct
 ///     HermitianFermionProduct
-///     FermionSystem
-///     FermionHamiltonianSystem
-///     FermionLindbladNoiseSystem
+///     FermionOperator
+///     FermionHamiltonian
+///     FermionLindbladNoiseOperator
 ///     FermionLindbladOpenSystem
 ///
 #[pymodule]
 pub fn fermions(_py: Python, m: &PyModule) -> PyResult<()> {
     // pyo3_log::init();
     m.add_class::<FermionProductWrapper>()?;
     m.add_class::<HermitianFermionProductWrapper>()?;
-    m.add_class::<FermionSystemWrapper>()?;
-    m.add_class::<FermionHamiltonianSystemWrapper>()?;
-    m.add_class::<FermionLindbladNoiseSystemWrapper>()?;
+    m.add_class::<FermionOperatorWrapper>()?;
+    m.add_class::<FermionHamiltonianWrapper>()?;
+    m.add_class::<FermionLindbladNoiseOperatorWrapper>()?;
     m.add_class::<FermionLindbladOpenSystemWrapper>()?;
 
     Ok(())
 }
```

### Comparing `struqture_py-1.6.1/struqture-py/src/lib.rs` & `struqture_py-2.0.0a0/struqture-py/src/lib.rs`

 * *Files identical despite different names*

### Comparing `struqture_py-1.6.1/struqture-py/src/mixed_systems/mixed_decoherence_product.rs` & `struqture_py-2.0.0a0/struqture-py/src/mixed_systems/mixed_decoherence_product.rs`

 * *Files 1% similar despite different names*

```diff
@@ -21,17 +21,18 @@
 use std::collections::hash_map::DefaultHasher;
 use std::hash::{Hash, Hasher};
 use std::str::FromStr;
 use struqture::bosons::BosonProduct;
 use struqture::fermions::FermionProduct;
 use struqture::mixed_systems::*;
 use struqture::spins::DecoherenceProduct;
+use struqture::SerializationSupport;
 use struqture::SymmetricIndex;
 #[cfg(feature = "json_schema")]
-use struqture::{MinSupportedVersion, STRUQTURE_VERSION};
+use struqture::STRUQTURE_VERSION;
 use struqture_py_macros::product_wrapper;
 
 /// A mixed product of pauli products and boson products.
 ///
 /// A `DecoherenceProduct <struqture_py.spins.DecoherenceProduct>` is a representation of products of pauli matrices acting on qubits. It is used in order to build the corresponding spin terms of a hamiltonian.
 ///
 /// A `BosonProduct <struqture_py.bosons.BosonProduct>` is a product of bosonic creation and annihilation operators.
```

### Comparing `struqture_py-1.6.1/struqture-py/src/mixed_systems/mixed_hamiltonian_system.rs` & `struqture_py-2.0.0a0/struqture-py/src/mixed_systems/mixed_plus_minus_operator.rs`

 * *Files 27% similar despite different names*

```diff
@@ -6,147 +6,138 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
-use super::MixedSystemWrapper;
-use crate::mixed_systems::HermitianMixedProductWrapper;
+use super::MixedOperatorWrapper;
+use crate::mixed_systems::MixedPlusMinusProductWrapper;
 use bincode::deserialize;
 use pyo3::exceptions::{PyTypeError, PyValueError};
 use pyo3::prelude::*;
 use pyo3::types::PyByteArray;
+use qoqo_calculator::CalculatorComplex;
 use qoqo_calculator_pyo3::CalculatorComplexWrapper;
-use struqture::mixed_systems::{
-    GetValueMixed, MixedHamiltonianSystem, MixedProduct, MixedSystem, OperateOnMixedSystems,
-};
+use struqture::mixed_systems::{MixedOperator, MixedPlusMinusOperator, OperateOnMixedSystems};
 #[cfg(feature = "json_schema")]
-use struqture::{MinSupportedVersion, STRUQTURE_VERSION};
-use struqture::{OperateOnDensityMatrix, OperateOnState, SymmetricIndex};
+use struqture::STRUQTURE_VERSION;
+use struqture::{OperateOnDensityMatrix, OperateOnState};
 use struqture_py_macros::noiseless_system_wrapper;
 
 /// These are representations of systems of mixed_systems.
 ///
-/// MixedHamiltonianSystems are characterized by a MixedOperator to represent the hamiltonian of the spin system
+/// MixedPlusMinusOperators are characterized by a MixedOperator to represent the hamiltonian of the spin system
 /// and an optional number of mixed_systems.
 ///
 /// Examples
 /// --------
 ///
 /// .. code-block:: python
 ///
 ///     import numpy.testing as npt
 ///     import scipy.sparse as sp
 ///     from qoqo_calculator_pyo3 import CalculatorComplex
-///     from struqture_py.mixed_systems import MixedHamiltonianSystem, HermitianMixedProduct
+///     from struqture_py.mixed_systems import MixedPlusMinusOperator, MixedPlusMinusProduct
 ///     from struqture_py.spins import PauliProduct
 ///     from struqture_py.bosons import BosonProduct
 ///     from struqture_py.fermions import FermionProduct
 ///
-///     ssystem = MixedHamiltonianSystem([2], [2], [2])
-///     pp = HermitianMixedProduct([PauliProduct().z(0)], [BosonProduct([0], [1])], [FermionProduct([0], [0])])
+///     ssystem = MixedPlusMinusOperator(1, 1, 1)
+///     pp = MixedPlusMinusProduct([PauliProduct().z(0)], [BosonProduct([0], [1])], [FermionProduct([0], [0])])
 ///     ssystem.add_operator_product(pp, 5.0)
-///     npt.assert_equal(ssystem.number_spins(), [2])
+///     npt.assert_equal(ssystem.current_number_spins(), [2])
 ///     npt.assert_equal(ssystem.get(pp), CalculatorComplex(5))
 ///
-#[pyclass(name = "MixedHamiltonianSystem", module = "struqture_py.mixed_systems")]
+#[pyclass(name = "MixedPlusMinusOperator", module = "struqture_py.mixed_systems")]
 #[derive(Clone, Debug, PartialEq)]
-pub struct MixedHamiltonianSystemWrapper {
-    /// Internal storage of [struqture::mixed_systems::MixedHamiltonianSystem]
-    pub internal: MixedHamiltonianSystem,
+pub struct MixedPlusMinusOperatorWrapper {
+    /// Internal storage of [struqture::mixed_systems::MixedPlusMinusOperator]
+    pub internal: MixedPlusMinusOperator,
 }
 
 #[noiseless_system_wrapper(
     OperateOnMixedSystems,
-    HermitianOperateOnMixedSystems,
     OperateOnState,
     OperateOnDensityMatrix,
-    Calculus
+    HermitianCalculus
 )]
-impl MixedHamiltonianSystemWrapper {
-    /// Create an empty MixedHamiltonianSystem.
+impl MixedPlusMinusOperatorWrapper {
+    /// Create an empty MixedPlusMinusOperator.
     ///
     /// Args:
-    ///     number_spins (List[Optional[int]]): The number of spin subsystems in the MixedHamiltonianSystem.
-    ///     number_bosons (List[Optional[int]]): The number of boson subsystems in the MixedHamiltonianSystem.
-    ///     number_fermions (List[Optional[int]]): The number of fermion subsystems in the MixedHamiltonianSystem.
+    ///     number_spins (List[Optional[int]]): The number of spin subsystems in the MixedPlusMinusOperator.
+    ///     number_bosons (List[Optional[int]]): The number of boson subsystems in the MixedPlusMinusOperator.
+    ///     number_fermions (List[Optional[int]]): The number of fermion subsystems in the MixedPlusMinusOperator.
     ///
     /// Returns:
-    ///     self: The new (empty) MixedHamiltonianSystem.
+    ///     self: The new (empty) MixedPlusMinusOperator.
     #[new]
-    #[pyo3(signature = (
-        number_spins = vec![None],
-        number_bosons = vec![None],
-        number_fermions = vec![None],
-    ))]
-    pub fn new(
-        number_spins: Vec<Option<usize>>,
-        number_bosons: Vec<Option<usize>>,
-        number_fermions: Vec<Option<usize>>,
-    ) -> Self {
+    pub fn new(number_spins: usize, number_bosons: usize, number_fermions: usize) -> Self {
         Self {
-            internal: MixedHamiltonianSystem::new(number_spins, number_bosons, number_fermions),
+            internal: MixedPlusMinusOperator::new(number_spins, number_bosons, number_fermions),
         }
     }
 
-    /// Implement `*` for MixedHamiltonianSystem and MixedHamiltonianSystem/CalculatorComplex/CalculatorFloat.
+    /// Implement `*` for MixedPlusMinusOperator and MixedPlusMinusOperator/CalculatorComplex/CalculatorFloat.
     ///
     /// Args:
-    ///     value (Union[MixedHamiltonianSystem, CalculatorComplex, CalculatorFloat]): value by which to multiply the self MixedHamiltonianSystem
+    ///     value (Union[MixedPlusMinusOperator, CalculatorComplex, CalculatorFloat]): value by which to multiply the self MixedPlusMinusOperator
     ///
     /// Returns:
-    ///     MixedSystem: The MixedHamiltonianSystem multiplied by the value.
+    ///     MixedPlusMinusOperator: The MixedPlusMinusOperator multiplied by the value.
     ///
     /// Raises:
-    ///     ValueError: The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor MixedHamiltonianSystem.
-    pub fn __mul__(&self, value: &PyAny) -> PyResult<MixedSystemWrapper> {
-        let mut new_spins: Vec<Option<usize>> = Vec::new();
-        for spin in self.internal.number_spins() {
-            new_spins.push(Some(spin))
-        }
-        let mut new_bosons: Vec<Option<usize>> = Vec::new();
-        for boson in self.internal.number_bosonic_modes() {
-            new_bosons.push(Some(boson))
-        }
-        let mut new_fermions: Vec<Option<usize>> = Vec::new();
-        for fermion in self.internal.number_fermionic_modes() {
-            new_fermions.push(Some(fermion))
-        }
-        let mut mixed_system = MixedSystem::new(new_spins, new_bosons, new_fermions);
-        for (key, val) in self.internal.clone().into_iter() {
-            let bp = MixedProduct::get_key(&key);
-            mixed_system
-                .add_operator_product(bp.clone(), val.clone())
-                .expect("Internal bug in add_operator_product");
-            if !key.is_natural_hermitian() {
-                let bp_conj = bp.hermitian_conjugate();
-                mixed_system
-                    .add_operator_product(MixedProduct::get_key(&bp_conj.0), val * bp_conj.1)
-                    .expect("Internal error in add_operator_product");
-            }
-        }
-        let cc_value = qoqo_calculator_pyo3::convert_into_calculator_complex(value);
-        match cc_value {
-            Ok(x) => Ok(MixedSystemWrapper {
-                internal: mixed_system * x,
+    ///     ValueError: The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor MixedPlusMinusOperator.
+    pub fn __mul__(&self, value: &PyAny) -> PyResult<Self> {
+        let cf_value = qoqo_calculator_pyo3::convert_into_calculator_float(value);
+        match cf_value {
+            Ok(x) => Ok(Self {
+                internal: self.clone().internal * CalculatorComplex::from(x),
             }),
             Err(_) => {
-                let bhs_value = Self::from_pyany(value.into());
-                match bhs_value {
-                    Ok(x) => {
-                        let new_self = (self.clone().internal * x).map_err(|err| {
-                            PyValueError::new_err(format!(
-                                "MixedHamiltonianSystems could not be multiplied: {:?}",
-                                err
-                            ))
-                        })?;
-                        Ok(MixedSystemWrapper { internal: new_self })
-                    },
+                let cc_value = qoqo_calculator_pyo3::convert_into_calculator_complex(value);
+                match cc_value {
+                    Ok(x) => Ok(Self {
+                        internal: self.clone().internal * x,
+                    }),
                     Err(err) => Err(PyValueError::new_err(format!(
-                        "The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor MixedHamiltonianSystem: {:?}",
-                        err)))
-                }
+                                "The rhs of the multiplication is neither CalculatorFloat nor CalculatorComplex: {:?}",
+                                err)))
+                        }
             }
         }
     }
+
+    /// Convert a MixedOperator into a MixedPlusMinusOperator.
+    ///
+    /// Args:
+    ///     value (MixedOperator): The MixedOperator to create the MixedPlusMinusOperator from.
+    ///
+    /// Returns:
+    ///     MixedPlusMinusOperator: The operator created from the input MixedOperator.
+    ///
+    /// Raises:
+    ///     ValueError: Could not create MixedOperator from input.
+    #[staticmethod]
+    pub fn from_mixed_system(value: Py<PyAny>) -> PyResult<MixedPlusMinusOperatorWrapper> {
+        let system = MixedOperatorWrapper::from_pyany(value)
+            .map_err(|err| PyValueError::new_err(format!("{:?}", err)))?;
+        Ok(MixedPlusMinusOperatorWrapper {
+            internal: MixedPlusMinusOperator::from(system.clone()),
+        })
+    }
+
+    /// Convert a MixedPlusMinusOperator into a MixedOperator.
+    ///
+    /// Returns:
+    ///     MixedOperator: The operator created from the input MixedPlusMinusOperator and optional number of spins.
+    ///
+    /// Raises:
+    ///     ValueError: Could not create MixedOperator from MixedPlusMinusOperator.
+    ///     ValueError: Could not create MixedOperator from MixedOperator.
+    pub fn to_mixed_system(&self) -> PyResult<MixedOperatorWrapper> {
+        let result: MixedOperator = MixedOperator::try_from(self.internal.clone())
+            .map_err(|err| PyValueError::new_err(format!("{:?}", err)))?;
+        Ok(MixedOperatorWrapper { internal: result })
+    }
 }
```

### Comparing `struqture_py-1.6.1/struqture-py/src/mixed_systems/mixed_hermitian_product.rs` & `struqture_py-2.0.0a0/struqture-py/src/mixed_systems/mixed_hermitian_product.rs`

 * *Files 1% similar despite different names*

```diff
@@ -22,17 +22,18 @@
 use std::collections::hash_map::DefaultHasher;
 use std::hash::{Hash, Hasher};
 use std::str::FromStr;
 use struqture::bosons::BosonProduct;
 use struqture::fermions::FermionProduct;
 use struqture::mixed_systems::*;
 use struqture::spins::PauliProduct;
+use struqture::SerializationSupport;
 use struqture::SymmetricIndex;
 #[cfg(feature = "json_schema")]
-use struqture::{MinSupportedVersion, STRUQTURE_VERSION};
+use struqture::STRUQTURE_VERSION;
 use struqture_py_macros::product_wrapper;
 
 /// A mixed product of pauli products and boson products.
 ///
 /// A `PauliProduct <struqture_py.spins.PauliProduct>` is a representation of products of pauli matrices acting on qubits. It is used in order to build the corresponding spin terms of a hamiltonian.
 ///
 /// A `BosonProduct <struqture_py.bosons.BosonProduct>` is a product of bosonic creation and annihilation operators.
```

### Comparing `struqture_py-1.6.1/struqture-py/src/mixed_systems/mixed_open_system.rs` & `struqture_py-2.0.0a0/struqture-py/src/mixed_systems/mixed_open_system.rs`

 * *Files 10% similar despite different names*

```diff
@@ -7,25 +7,25 @@
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
 use super::{
-    HermitianMixedProductWrapper, MixedDecoherenceProductWrapper, MixedHamiltonianSystemWrapper,
-    MixedLindbladNoiseSystemWrapper,
+    HermitianMixedProductWrapper, MixedDecoherenceProductWrapper, MixedHamiltonianWrapper,
+    MixedLindbladNoiseOperatorWrapper,
 };
 use bincode::deserialize;
 use pyo3::exceptions::{PyTypeError, PyValueError};
 use pyo3::prelude::*;
 use pyo3::types::PyByteArray;
 use qoqo_calculator_pyo3::CalculatorComplexWrapper;
 use struqture::mixed_systems::{MixedLindbladOpenSystem, OperateOnMixedSystems};
 #[cfg(feature = "json_schema")]
-use struqture::{MinSupportedVersion, STRUQTURE_VERSION};
+use struqture::STRUQTURE_VERSION;
 use struqture::{OpenSystem, OperateOnDensityMatrix};
 use struqture_py_macros::noisy_system_wrapper;
 
 /// These are representations of noisy systems of mixed_systems.
 ///
 /// In a MixedLindbladOpenSystem is characterized by a MixedLindbladOpenOperator to represent the hamiltonian of the system, and an optional number of mixed_systems.
 ///
@@ -53,34 +53,30 @@
 )]
 #[derive(Clone, Debug, PartialEq)]
 pub struct MixedLindbladOpenSystemWrapper {
     /// Internal storage of [struqture::mixed_systems::MixedLindbladOpenSystem]
     pub internal: MixedLindbladOpenSystem,
 }
 
-#[noisy_system_wrapper(OpenSystem, OperateOnMixedSystems, Calculus)]
+#[noisy_system_wrapper(OpenSystem, OperateOnMixedSystems, HermitianCalculus)]
 impl MixedLindbladOpenSystemWrapper {
     /// Create a new MixedLindbladOpenSystem.
     ///
     /// Args:
-    ///     number_spins (List[Optional[int]]): The number of spin subsystems in the MixedLindbladOpenSystem.
-    ///     number_bosons (List[Optional[int]]): The number of boson subsystems in the MixedLindbladOpenSystem.
-    ///     number_fermions (List[Optional[int]]): The number of fermion subsystems in the MixedLindbladOpenSystem.
+    ///     number_spins (int): The number of spin subsystems in the MixedLindbladOpenSystem.
+    ///     number_bosons (int): The number of boson subsystems in the MixedLindbladOpenSystem.
+    ///     number_fermions (int): The number of fermion subsystems in the MixedLindbladOpenSystem.
     ///
     /// Returns:
     ///     self: The new MixedLindbladOpenSystem.
     #[new]
     #[pyo3(signature = (
-        number_spins = vec![None],
-        number_bosons = vec![None],
-        number_fermions = vec![None],
+        number_spins,
+        number_bosons,
+        number_fermions,
     ))]
-    pub fn new(
-        number_spins: Vec<Option<usize>>,
-        number_bosons: Vec<Option<usize>>,
-        number_fermions: Vec<Option<usize>>,
-    ) -> Self {
+    pub fn new(number_spins: usize, number_bosons: usize, number_fermions: usize) -> Self {
         Self {
             internal: MixedLindbladOpenSystem::new(number_spins, number_bosons, number_fermions),
         }
     }
 }
```

### Comparing `struqture_py-1.6.1/struqture-py/src/mixed_systems/mixed_plus_minus_operator.rs` & `struqture_py-2.0.0a0/struqture-py/src/mixed_systems/mixed_plus_minus_product.rs`

 * *Files 25% similar despite different names*

```diff
@@ -6,159 +6,178 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::mixed_systems::MixedPlusMinusProductWrapper;
-use bincode::deserialize;
+use crate::bosons::*;
+use crate::fermions::*;
+use crate::spins::*;
+use num_complex::Complex64;
 use pyo3::exceptions::{PyTypeError, PyValueError};
 use pyo3::prelude::*;
 use pyo3::types::PyByteArray;
 use qoqo_calculator::CalculatorComplex;
 use qoqo_calculator_pyo3::CalculatorComplexWrapper;
-use struqture::mixed_systems::{
-    MixedOperator, MixedPlusMinusOperator, MixedSystem, OperateOnMixedSystems,
-};
-use struqture::{OperateOnDensityMatrix, OperateOnState};
-use struqture_py_macros::noiseless_system_wrapper;
+use std::collections::hash_map::DefaultHasher;
+use std::hash::{Hash, Hasher};
+use std::str::FromStr;
+use struqture::bosons::BosonProduct;
+use struqture::fermions::FermionProduct;
+use struqture::mixed_systems::*;
+use struqture::spins::PlusMinusProduct;
+use struqture::SymmetricIndex;
+use struqture_py_macros::product_wrapper;
 
-use super::MixedSystemWrapper;
+use super::MixedProductWrapper;
+use struqture::SerializationSupport;
 #[cfg(feature = "json_schema")]
-use struqture::{MinSupportedVersion, STRUQTURE_VERSION};
+use struqture::STRUQTURE_VERSION;
 
-/// These are representations of systems of mixed_systems.
+/// A mixed product of pauli products and boson products.
 ///
-/// MixedPlusMinusOperators are characterized by a MixedOperator to represent the hamiltonian of the spin system
-/// and an optional number of mixed_systems.
+/// A `PlusMinusProduct <struqture_py.spins.PlusMinusProduct>` is a representation of products of pauli matrices acting on qubits. It is used in order to build the corresponding spin terms of a hamiltonian.
+///
+/// A `BosonProduct <struqture_py.bosons.BosonProduct>` is a product of bosonic creation and annihilation operators.
+/// It is used as an index for non-hermitian, normal ordered bosonic operators.
+///
+/// A `FermionProduct <struqture_py.fermions.FermionProduct>` is a product of bosonic creation and annihilation operators.
+/// It is used as an index for non-hermitian, normal ordered bosonic operators.
+///
+/// Note: For a physical system, the `bosons` (BosonProduct) are usually considered
+/// in presence of a `system-spin` part (PlusMinusProduct) and a `bath-spin` part (PlusMinusProduct),
+/// as shown in the example below.
 ///
 /// Examples
 /// --------
 ///
 /// .. code-block:: python
 ///
-///     import numpy.testing as npt
-///     import scipy.sparse as sp
-///     from qoqo_calculator_pyo3 import CalculatorComplex
-///     from struqture_py.mixed_systems import MixedPlusMinusOperator, MixedPlusMinusProduct
-///     from struqture_py.spins import PauliProduct
+///     from struqture_py.mixed_systems import MixedPlusMinusProduct
+///     from struqture_py.spins import PlusMinusProduct
 ///     from struqture_py.bosons import BosonProduct
-///     from struqture_py.fermions import FermionProduct
-///
-///     ssystem = MixedPlusMinusOperator(1, 1, 1)
-///     pp = MixedPlusMinusProduct([PauliProduct().z(0)], [BosonProduct([0], [1])], [FermionProduct([0], [0])])
-///     ssystem.add_operator_product(pp, 5.0)
-///     npt.assert_equal(ssystem.number_spins(), [2])
-///     npt.assert_equal(ssystem.get(pp), CalculatorComplex(5))
-///
-#[pyclass(name = "MixedPlusMinusOperator", module = "struqture_py.mixed_systems")]
-#[derive(Clone, Debug, PartialEq)]
-pub struct MixedPlusMinusOperatorWrapper {
-    /// Internal storage of [struqture::mixed_systems::MixedPlusMinusOperator]
-    pub internal: MixedPlusMinusOperator,
+///     
+///     # For instance, to represent the terms $\sigma_0^{x} \sigma_2^{x}$
+///     # and $\sigma_1^{x} \sigma_2^{x}$
+///     mp_spins_system = PlusMinusProduct().x(0).x(2)
+///     mp_spins_bath = PlusMinusProduct().x(1).x(2)
+///
+///     # For instance, to represent $a_1*a_1$
+///     mp_bosons = BosonProduct([1], [1])
+///     
+///     mp = MixedPlusMinusProduct([mp_spins_system, mp_spins_bath], [mp_bosons], [])
+///     npt.assert_equal(mp.spins(), [mp_spins_system, mp_spins_bath])
+///     npt.assert_equal(mp.bosons(), [mp_bosons])
+///     
+#[pyclass(name = "MixedPlusMinusProduct", module = "struqture_py.mixed_systems")]
+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Default)]
+pub struct MixedPlusMinusProductWrapper {
+    // Internal storage of [struqture::mixed_systems::MixedPlusMinusProduct]
+    pub internal: MixedPlusMinusProduct,
 }
 
-#[noiseless_system_wrapper(
-    OperateOnMixedSystems,
-    OperateOnState,
-    OperateOnDensityMatrix,
-    Calculus
-)]
-impl MixedPlusMinusOperatorWrapper {
-    /// Create an empty MixedPlusMinusOperator.
-    ///
-    /// Args:
-    ///     number_spins (List[Optional[int]]): The number of spin subsystems in the MixedPlusMinusOperator.
-    ///     number_bosons (List[Optional[int]]): The number of boson subsystems in the MixedPlusMinusOperator.
-    ///     number_fermions (List[Optional[int]]): The number of fermion subsystems in the MixedPlusMinusOperator.
-    ///
-    /// Returns:
-    ///     self: The new (empty) MixedPlusMinusOperator.
-    #[new]
-    pub fn new(number_spins: usize, number_bosons: usize, number_fermions: usize) -> Self {
-        Self {
-            internal: MixedPlusMinusOperator::new(number_spins, number_bosons, number_fermions),
-        }
-    }
-
-    /// Implement `*` for MixedPlusMinusOperator and MixedPlusMinusOperator/CalculatorComplex/CalculatorFloat.
+#[product_wrapper(SymmetricIndex, MixedIndex)]
+impl MixedPlusMinusProductWrapper {
+    /// Create a new MixedPlusMinusProduct.
     ///
     /// Args:
-    ///     value (Union[MixedPlusMinusOperator, CalculatorComplex, CalculatorFloat]): value by which to multiply the self MixedPlusMinusOperator
+    ///     spins (List[PlusMinusProduct]): Products of pauli operators acting on qubits.
+    ///     bosons (List[BosonProduct]): Products of bosonic creation and annihilation operators.
+    ///     fermions (List[FermionProduct]): Products of fermionic creation and annihilation operators.
     ///
     /// Returns:
-    ///     MixedPlusMinusOperator: The MixedPlusMinusOperator multiplied by the value.
+    ///     MixedPlusMinusProduct: a new MixedPlusMinusProduct with the input of spins, bosons and fermions.
     ///
     /// Raises:
-    ///     ValueError: The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor MixedPlusMinusOperator.
-    pub fn __mul__(&self, value: &PyAny) -> PyResult<Self> {
-        let cf_value = qoqo_calculator_pyo3::convert_into_calculator_float(value);
-        match cf_value {
-            Ok(x) => Ok(Self {
-                internal: self.clone().internal * CalculatorComplex::from(x),
-            }),
-            Err(_) => {
-                let cc_value = qoqo_calculator_pyo3::convert_into_calculator_complex(value);
-                match cc_value {
-                    Ok(x) => Ok(Self {
-                        internal: self.clone().internal * x,
-                    }),
-                    Err(err) => Err(PyValueError::new_err(format!(
-                                "The rhs of the multiplication is neither CalculatorFloat nor CalculatorComplex: {:?}",
-                                err)))
-                        }
-            }
+    ///     ValueError: MixedPlusMinusProduct can not be constructed from the input.
+    #[new]
+    pub fn new(
+        spins: Vec<Py<PyAny>>,
+        bosons: Vec<Py<PyAny>>,
+        fermions: Vec<Py<PyAny>>,
+    ) -> PyResult<Self> {
+        let mut spinsv: Vec<PlusMinusProduct> = Vec::new();
+        for s in spins {
+            spinsv.push(PlusMinusProductWrapper::from_pyany(s)?);
+        }
+        let mut bosonsv: Vec<BosonProduct> = Vec::new();
+        for b in bosons {
+            bosonsv.push(BosonProductWrapper::from_pyany(b)?);
         }
+        let mut fermionsv: Vec<FermionProduct> = Vec::new();
+        for f in fermions {
+            fermionsv.push(FermionProductWrapper::from_pyany(f)?);
+        }
+        Ok(Self {
+            internal: MixedPlusMinusProduct::new(spinsv, bosonsv, fermionsv),
+        })
     }
 
-    /// Convert a MixedSystem into a MixedPlusMinusOperator.
+    /// Creates a list of corresponding (MixedPlusMinusProduct, CalculatorComplex) tuples from the input MixedProduct.
     ///
     /// Args:
-    ///     value (MixedSystem): The MixedSystem to create the MixedPlusMinusOperator from.
+    ///     value (MixedProduct): The MixedProduct object to convert.
     ///
     /// Returns:
-    ///     MixedPlusMinusOperator: The operator created from the input MixedSystem.
+    ///     list[tuple[(MixedPlusMinusProduct, CalculatorComplex)]]: The converted input.
     ///
     /// Raises:
-    ///     ValueError: Could not create MixedSystem from input.
+    ///     ValueError: Input is not a MixedProduct.
     #[staticmethod]
-    pub fn from_mixed_system(value: Py<PyAny>) -> PyResult<MixedPlusMinusOperatorWrapper> {
-        let system = MixedSystemWrapper::from_pyany(value)
-            .map_err(|err| PyValueError::new_err(format!("{:?}", err)))?;
-        Ok(MixedPlusMinusOperatorWrapper {
-            internal: MixedPlusMinusOperator::from(system.operator().clone()),
-        })
+    pub fn from_mixed_product(
+        value: Py<PyAny>,
+    ) -> PyResult<Vec<(MixedPlusMinusProductWrapper, CalculatorComplexWrapper)>> {
+        match MixedProductWrapper::from_pyany(value) {
+            Ok(x) => {
+                let result: Vec<(MixedPlusMinusProduct, Complex64)> =
+                    Vec::<(MixedPlusMinusProduct, Complex64)>::from(x);
+                let result_pyo3: Vec<(MixedPlusMinusProductWrapper, CalculatorComplexWrapper)> =
+                    result
+                        .iter()
+                        .map(|(key, val)| {
+                            (
+                                MixedPlusMinusProductWrapper {
+                                    internal: key.clone(),
+                                },
+                                CalculatorComplexWrapper {
+                                    internal: CalculatorComplex::new(val.re, val.im),
+                                },
+                            )
+                        })
+                        .collect();
+                Ok(result_pyo3)
+            }
+            Err(_) => Err(PyValueError::new_err("Input is not a MixedProduct")),
+        }
     }
 
-    /// Convert a MixedPlusMinusOperator into a MixedSystem.
-    ///
-    /// Args:
-    ///     number_spins (list[Optional[int]]): The number of spins to initialize the MixedSystem with.
-    ///     number_bosons (list[Optional[int]]): The number of bosons to initialize the MixedSystem with.
-    ///     number_fermions (list[Optional[int]]): The number of fermions to initialize the MixedSystem with.
+    /// Convert the `self` instance to the corresponding list of (MixedProduct, CalculatorComplex) instances.
     ///
     /// Returns:
-    ///     MixedSystem: The operator created from the input MixedPlusMinusOperator and optional number of spins.
+    ///     list[tuple[(MixedProduct, CalculatorComplex)]]: The converted MixedPlusMinusProduct.
     ///
     /// Raises:
-    ///     ValueError: Could not create MixedOperator from MixedPlusMinusOperator.
-    ///     ValueError: Could not create MixedSystem from MixedOperator.
-    pub fn to_mixed_system(
+    ///     ValueError: The conversion was not successful.
+    pub fn to_mixed_product_list(
         &self,
-        number_spins: Vec<Option<usize>>,
-        number_bosons: Vec<Option<usize>>,
-        number_fermions: Vec<Option<usize>>,
-    ) -> PyResult<MixedSystemWrapper> {
-        let result: MixedOperator = MixedOperator::try_from(self.internal.clone())
-            .map_err(|err| PyValueError::new_err(format!("{:?}", err)))?;
-        Ok(MixedSystemWrapper {
-            internal: MixedSystem::from_operator(
-                result,
-                number_spins,
-                number_bosons,
-                number_fermions,
-            )
-            .map_err(|err| PyValueError::new_err(format!("{:?}", err)))?,
-        })
+    ) -> PyResult<Vec<(MixedProductWrapper, CalculatorComplexWrapper)>> {
+        let result: Vec<(MixedProduct, Complex64)> =
+            Vec::<(MixedProduct, Complex64)>::try_from(self.internal.clone()).map_err(|err| {
+                PyValueError::new_err(format!("The conversion was not successful: {:?}", err))
+            })?;
+        let result_pyo3: Vec<(MixedProductWrapper, CalculatorComplexWrapper)> = result
+            .iter()
+            .map(|(key, val)| {
+                (
+                    MixedProductWrapper {
+                        internal: key.clone(),
+                    },
+                    CalculatorComplexWrapper {
+                        internal: CalculatorComplex::new(val.re, val.im),
+                    },
+                )
+            })
+            .collect();
+        Ok(result_pyo3)
     }
 }
```

### Comparing `struqture_py-1.6.1/struqture-py/src/mixed_systems/mixed_plus_minus_product.rs` & `struqture_py-2.0.0a0/struqture-py/src/mixed_systems/mixed_product.rs`

 * *Files 24% similar despite different names*

```diff
@@ -13,170 +13,192 @@
 use crate::bosons::*;
 use crate::fermions::*;
 use crate::spins::*;
 use num_complex::Complex64;
 use pyo3::exceptions::{PyTypeError, PyValueError};
 use pyo3::prelude::*;
 use pyo3::types::PyByteArray;
-use qoqo_calculator::CalculatorComplex;
-use qoqo_calculator_pyo3::CalculatorComplexWrapper;
+use pyo3::types::PyType;
 use std::collections::hash_map::DefaultHasher;
 use std::hash::{Hash, Hasher};
 use std::str::FromStr;
 use struqture::bosons::BosonProduct;
 use struqture::fermions::FermionProduct;
 use struqture::mixed_systems::*;
-use struqture::spins::PlusMinusProduct;
+use struqture::spins::PauliProduct;
+use struqture::SerializationSupport;
 use struqture::SymmetricIndex;
-use struqture_py_macros::product_wrapper;
-
-use super::MixedProductWrapper;
 #[cfg(feature = "json_schema")]
-use struqture::{MinSupportedVersion, STRUQTURE_VERSION};
+use struqture::STRUQTURE_VERSION;
+use struqture_py_macros::product_wrapper;
 
 /// A mixed product of pauli products and boson products.
 ///
-/// A `PlusMinusProduct <struqture_py.spins.PlusMinusProduct>` is a representation of products of pauli matrices acting on qubits. It is used in order to build the corresponding spin terms of a hamiltonian.
+/// A `PauliProduct <struqture_py.spins.PauliProduct>` is a representation of products of pauli matrices acting on qubits. It is used in order to build the corresponding spin terms of a hamiltonian.
 ///
 /// A `BosonProduct <struqture_py.bosons.BosonProduct>` is a product of bosonic creation and annihilation operators.
 /// It is used as an index for non-hermitian, normal ordered bosonic operators.
 ///
 /// A `FermionProduct <struqture_py.fermions.FermionProduct>` is a product of bosonic creation and annihilation operators.
 /// It is used as an index for non-hermitian, normal ordered bosonic operators.
 ///
 /// Note: For a physical system, the `bosons` (BosonProduct) are usually considered
-/// in presence of a `system-spin` part (PlusMinusProduct) and a `bath-spin` part (PlusMinusProduct),
+/// in presence of a `system-spin` part (PauliProduct) and a `bath-spin` part (PauliProduct),
 /// as shown in the example below.
 ///
 /// Examples
 /// --------
 ///
 /// .. code-block:: python
 ///
-///     from struqture_py.mixed_systems import MixedPlusMinusProduct
-///     from struqture_py.spins import PlusMinusProduct
+///     from struqture_py.mixed_systems import MixedProduct
+///     from struqture_py.spins import PauliProduct
 ///     from struqture_py.bosons import BosonProduct
 ///     
 ///     # For instance, to represent the terms $\sigma_0^{x} \sigma_2^{x}$
 ///     # and $\sigma_1^{x} \sigma_2^{x}$
-///     mp_spins_system = PlusMinusProduct().x(0).x(2)
-///     mp_spins_bath = PlusMinusProduct().x(1).x(2)
+///     mp_spins_system = PauliProduct().x(0).x(2)
+///     mp_spins_bath = PauliProduct().x(1).x(2)
 ///
 ///     # For instance, to represent $a_1*a_1$
 ///     mp_bosons = BosonProduct([1], [1])
 ///     
-///     mp = MixedPlusMinusProduct([mp_spins_system, mp_spins_bath], [mp_bosons], [])
+///     mp = MixedProduct([mp_spins_system, mp_spins_bath], [mp_bosons], [])
 ///     npt.assert_equal(mp.spins(), [mp_spins_system, mp_spins_bath])
 ///     npt.assert_equal(mp.bosons(), [mp_bosons])
 ///     
-#[pyclass(name = "MixedPlusMinusProduct", module = "struqture_py.mixed_systems")]
+#[pyclass(name = "MixedProduct", module = "struqture_py.mixed_systems")]
 #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Default)]
-pub struct MixedPlusMinusProductWrapper {
-    // Internal storage of [struqture::mixed_systems::MixedPlusMinusProduct]
-    pub internal: MixedPlusMinusProduct,
+pub struct MixedProductWrapper {
+    // Internal storage of [struqture::mixed_systems::MixedProduct]
+    pub internal: MixedProduct,
 }
 
 #[product_wrapper(SymmetricIndex, MixedIndex)]
-impl MixedPlusMinusProductWrapper {
-    /// Create a new MixedPlusMinusProduct.
+impl MixedProductWrapper {
+    /// Create a new MixedProduct.
     ///
     /// Args:
-    ///     spins (List[PlusMinusProduct]): Products of pauli operators acting on qubits.
+    ///     spins (List[PauliProduct]): Products of pauli operators acting on qubits.
     ///     bosons (List[BosonProduct]): Products of bosonic creation and annihilation operators.
     ///     fermions (List[FermionProduct]): Products of fermionic creation and annihilation operators.
     ///
     /// Returns:
-    ///     MixedPlusMinusProduct: a new MixedPlusMinusProduct with the input of spins, bosons and fermions.
+    ///     MixedProduct: a new MixedProduct with the input of spins, bosons and fermions.
     ///
     /// Raises:
-    ///     ValueError: MixedPlusMinusProduct can not be constructed from the input.
+    ///     ValueError: MixedProduct can not be constructed from the input.
     #[new]
     pub fn new(
         spins: Vec<Py<PyAny>>,
         bosons: Vec<Py<PyAny>>,
         fermions: Vec<Py<PyAny>>,
     ) -> PyResult<Self> {
-        let mut spinsv: Vec<PlusMinusProduct> = Vec::new();
+        let mut spinsv: Vec<PauliProduct> = Vec::new();
         for s in spins {
-            spinsv.push(PlusMinusProductWrapper::from_pyany(s)?);
+            spinsv.push(PauliProductWrapper::from_pyany(s)?);
         }
         let mut bosonsv: Vec<BosonProduct> = Vec::new();
         for b in bosons {
             bosonsv.push(BosonProductWrapper::from_pyany(b)?);
         }
         let mut fermionsv: Vec<FermionProduct> = Vec::new();
         for f in fermions {
             fermionsv.push(FermionProductWrapper::from_pyany(f)?);
         }
         Ok(Self {
-            internal: MixedPlusMinusProduct::new(spinsv, bosonsv, fermionsv),
+            internal: MixedProduct::new(spinsv, bosonsv, fermionsv).map_err(|err| {
+                PyValueError::new_err(format!("Could not construct MixedProduct: {:?}", err))
+            })?,
         })
     }
 
-    /// Creates a list of corresponding (MixedPlusMinusProduct, CalculatorComplex) tuples from the input MixedProduct.
+    /// Create a pair (MixedProduct, CalculatorComplex).
+    ///
+    /// The first item is the valid MixedProduct created from the input creators and annihilators.
+    /// The second term is the input CalculatorComplex transformed according to the valid order of creators and annihilators.
     ///
     /// Args:
-    ///     value (MixedProduct): The MixedProduct object to convert.
+    ///     creators: The creator indices to have in the MixedProduct.
+    ///     annihilators: The annihilators indices to have in the MixedProduct.
+    ///     value: The CalculatorComplex to transform.
     ///
     /// Returns:
-    ///     list[tuple[(MixedPlusMinusProduct, CalculatorComplex)]]: The converted input.
+    ///     Tuple[MixedProduct, CalculatorComplex] - The valid MixedProduct and the corresponding transformed CalculatorComplex.
     ///
     /// Raises:
-    ///     ValueError: Input is not a MixedProduct.
-    #[staticmethod]
-    pub fn from_mixed_product(
-        value: Py<PyAny>,
-    ) -> PyResult<Vec<(MixedPlusMinusProductWrapper, CalculatorComplexWrapper)>> {
-        match MixedProductWrapper::from_pyany(value) {
-            Ok(x) => {
-                let result: Vec<(MixedPlusMinusProduct, Complex64)> =
-                    Vec::<(MixedPlusMinusProduct, Complex64)>::from(x);
-                let result_pyo3: Vec<(MixedPlusMinusProductWrapper, CalculatorComplexWrapper)> =
-                    result
-                        .iter()
-                        .map(|(key, val)| {
-                            (
-                                MixedPlusMinusProductWrapper {
-                                    internal: key.clone(),
-                                },
-                                CalculatorComplexWrapper {
-                                    internal: CalculatorComplex::new(val.re, val.im),
-                                },
-                            )
-                        })
-                        .collect();
-                Ok(result_pyo3)
+    ///     ValueError: Valid pair could not be constructed, pauli spins couldn't be converted from string.
+    ///     ValueError: Valid pair could not be constructed, bosons couldn't be converted from string.
+    ///     ValueError: Valid pair could not be constructed, fermions couldn't be converted from string.
+    ///     TypeError: Value cannot be converted to CalculatorComplex.
+    ///     ValueError: Valid pair could not be constructed.
+    #[classmethod]
+    pub fn create_valid_pair(
+        _cls: &PyType,
+        spins: Vec<String>,
+        bosons: Vec<String>,
+        fermions: Vec<String>,
+        value: &PyAny,
+    ) -> PyResult<(Self, qoqo_calculator_pyo3::CalculatorComplexWrapper)> {
+        let mut converted_spins: Vec<PauliProduct> = Vec::new();
+        for s in spins {
+            match PauliProduct::from_str(s.as_str()) {
+                Ok(x) => converted_spins.push(x),
+                Err(err) => return Err(PyValueError::new_err(format!("Valid pair could not be constructed, pauli spins couldn't be converted from string: {:?}", err)))
+            }
+        }
+        let mut converted_bosons: Vec<BosonProduct> = Vec::new();
+        for b in bosons {
+            match BosonProduct::from_str(b.as_str()) {
+                Ok(x) => converted_bosons.push(x),
+                Err(err) => return Err(PyValueError::new_err(format!("Valid pair could not be constructed, bosons couldn't be converted from string: {:?}", err)))
             }
-            Err(_) => Err(PyValueError::new_err("Input is not a MixedProduct")),
         }
+        let mut converted_fermions: Vec<FermionProduct> = Vec::new();
+        for f in fermions {
+            match FermionProduct::from_str(f.as_str()) {
+                Ok(x) => converted_fermions.push(x),
+                Err(err) => return Err(PyValueError::new_err(format!("Valid pair could not be constructed, fermions couldn't be converted from string: {:?}", err)))
+            }
+        }
+
+        let value = qoqo_calculator_pyo3::convert_into_calculator_complex(value)
+            .map_err(|_| PyTypeError::new_err("Value cannot be converted to CalculatorComplex"))?;
+        let (index, value) = MixedProduct::create_valid_pair(
+            converted_spins,
+            converted_bosons,
+            converted_fermions,
+            value,
+        )
+        .map_err(|err| {
+            PyValueError::new_err(format!("Valid pair could not be constructed: {:?}", err))
+        })?;
+        Ok((
+            Self { internal: index },
+            qoqo_calculator_pyo3::CalculatorComplexWrapper { internal: value },
+        ))
     }
 
-    /// Convert the `self` instance to the corresponding list of (MixedProduct, CalculatorComplex) instances.
+    /// Implement `*` for MixedProduct and MixedProduct.
+    ///
+    /// Args:
+    ///     other (MixedProduct): value by which to multiply the self MixedProduct
     ///
     /// Returns:
-    ///     list[tuple[(MixedProduct, CalculatorComplex)]]: The converted MixedPlusMinusProduct.
+    ///     MixedProduct: The MixedProduct multiplied by the value.
     ///
     /// Raises:
-    ///     ValueError: The conversion was not successful.
-    pub fn to_mixed_product_list(
-        &self,
-    ) -> PyResult<Vec<(MixedProductWrapper, CalculatorComplexWrapper)>> {
-        let result: Vec<(MixedProduct, Complex64)> =
-            Vec::<(MixedProduct, Complex64)>::try_from(self.internal.clone()).map_err(|err| {
-                PyValueError::new_err(format!("The conversion was not successful: {:?}", err))
-            })?;
-        let result_pyo3: Vec<(MixedProductWrapper, CalculatorComplexWrapper)> = result
-            .iter()
-            .map(|(key, val)| {
-                (
-                    MixedProductWrapper {
-                        internal: key.clone(),
-                    },
-                    CalculatorComplexWrapper {
-                        internal: CalculatorComplex::new(val.re, val.im),
-                    },
-                )
-            })
-            .collect();
-        Ok(result_pyo3)
+    ///     ValueError: The rhs of the multiplication not MixedProduct.
+    pub fn __mul__(&self, other: Self) -> PyResult<Vec<(Self, Complex64)>> {
+        let vec_object = (self.internal.clone() * other.internal).map_err(|err| {
+            PyValueError::new_err(format!(
+                "Could not multiply the two MixedProducts: {:?}",
+                err
+            ))
+        })?;
+        let mut return_vector: Vec<(Self, Complex64)> = Vec::new();
+        for obj in vec_object {
+            return_vector.push((Self { internal: obj.0 }, obj.1));
+        }
+        Ok(return_vector)
     }
 }
```

### Comparing `struqture_py-1.6.1/struqture-py/src/mixed_systems/mixed_system.rs` & `struqture_py-2.0.0a0/struqture-py/src/spins/qubit_operator.rs`

 * *Files 18% similar despite different names*

```diff
@@ -6,101 +6,96 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::mixed_systems::MixedProductWrapper;
+use crate::fermions::FermionOperatorWrapper;
+use crate::spins::PauliProductWrapper;
+use crate::{to_py_coo, PyCooMatrix};
 use bincode::deserialize;
-use pyo3::exceptions::{PyTypeError, PyValueError};
+use num_complex::Complex64;
+use pyo3::exceptions::{PyRuntimeError, PyTypeError, PyValueError};
 use pyo3::prelude::*;
 use pyo3::types::PyByteArray;
 use qoqo_calculator::CalculatorComplex;
 use qoqo_calculator_pyo3::CalculatorComplexWrapper;
-use struqture::mixed_systems::{MixedSystem, OperateOnMixedSystems};
+use struqture::mappings::JordanWignerSpinToFermion;
+use struqture::spins::{
+    OperateOnSpins, QubitOperator, ToSparseMatrixOperator, ToSparseMatrixSuperOperator,
+};
+use struqture::StruqtureError;
 #[cfg(feature = "json_schema")]
-use struqture::{MinSupportedVersion, STRUQTURE_VERSION};
+use struqture::STRUQTURE_VERSION;
 use struqture::{OperateOnDensityMatrix, OperateOnState};
-use struqture_py_macros::noiseless_system_wrapper;
+use struqture_py_macros::{mappings, noiseless_system_wrapper};
 
-/// These are representations of systems of mixed_systems.
+/// These are representations of systems of spins.
 ///
-/// MixedSystems are characterized by a MixedOperator to represent the hamiltonian of the spin system
-/// and an optional number of mixed_systems.
+/// QubitOperators are characterized by a QubitOperator to represent the hamiltonian of the spin system
+/// and an optional number of spins.
 ///
 /// Examples
 /// --------
 ///
 /// .. code-block:: python
 ///
 ///     import numpy.testing as npt
 ///     import scipy.sparse as sp
 ///     from qoqo_calculator_pyo3 import CalculatorComplex
-///     from struqture_py.mixed_systems import MixedSystem, MixedProduct
-///     from struqture_py.spins import PauliProduct
-///     from struqture_py.bosons import BosonProduct
-///     from struqture_py.fermions import FermionProduct
+///     from struqture_py.spins import QubitOperator, PauliProduct
 ///
-///     ssystem = MixedSystem([2], [2], [2])
-///     pp = MixedProduct([PauliProduct().z(0)], [BosonProduct([0], [1])], [FermionProduct([0], [0])])
+///     ssystem = QubitOperator(2)
+///     pp = PauliProduct().z(0)
 ///     ssystem.add_operator_product(pp, 5.0)
-///     npt.assert_equal(ssystem.number_spins(), [2])
+///     npt.assert_equal(ssystem.current_number_spins(), 2)
 ///     npt.assert_equal(ssystem.get(pp), CalculatorComplex(5))
+///     npt.assert_equal(ssystem.keys(), [pp])
+///     dimension = 4**ssystem.current_number_spins()
+///     matrix = sp.coo_matrix(ssystem.sparse_matrix_superoperator_coo(), shape=(dimension, dimension))
 ///
-#[pyclass(name = "MixedSystem", module = "struqture_py.mixed_systems")]
+#[pyclass(name = "QubitOperator", module = "struqture_py.spins")]
 #[derive(Clone, Debug, PartialEq)]
-pub struct MixedSystemWrapper {
-    /// Internal storage of [struqture::mixed_systems::MixedSystem]
-    pub internal: MixedSystem,
+pub struct QubitOperatorWrapper {
+    /// Internal storage of [struqture::spins::QubitOperator]
+    pub internal: QubitOperator,
 }
 
+#[mappings(JordanWignerSpinToFermion)]
 #[noiseless_system_wrapper(
-    OperateOnMixedSystems,
-    HermitianOperateOnMixedSystems,
+    OperateOnSpins,
     OperateOnState,
+    ToSparseMatrixOperator,
+    ToSparseMatrixSuperOperator,
     OperateOnDensityMatrix,
     Calculus
 )]
-impl MixedSystemWrapper {
-    /// Create an empty MixedSystem.
-    ///
-    /// Args:
-    ///     number_spins (List[Optional[int]]): The number of spin subsystems in the MixedSystem.
-    ///     number_bosons (List[Optional[int]]): The number of boson subsystems in the MixedSystem.
-    ///     number_fermions (List[Optional[int]]): The number of fermion subsystems in the MixedSystem.
+impl QubitOperatorWrapper {
+    /// Create an empty QubitOperator.
     ///
     /// Returns:
-    ///     self: The new (empty) MixedSystem.
+    ///     self: The new QubitOperator with the input number of spins.
     #[new]
-    #[pyo3(signature = (
-        number_spins = vec![None],
-        number_bosons = vec![None],
-        number_fermions = vec![None],
-    ))]
-    pub fn new(
-        number_spins: Vec<Option<usize>>,
-        number_bosons: Vec<Option<usize>>,
-        number_fermions: Vec<Option<usize>>,
-    ) -> Self {
+    pub fn new() -> Self {
         Self {
-            internal: MixedSystem::new(number_spins, number_bosons, number_fermions),
+            internal: QubitOperator::new(),
         }
     }
 
-    /// Implement `*` for MixedSystem and MixedSystem/CalculatorComplex/CalculatorFloat.
+    /// Implement `*` for QubitOperator and QubitOperator/CalculatorComplex/CalculatorFloat.
     ///
     /// Args:
-    ///     value (Union[MixedSystem, CalculatorComplex, CalculatorFloat]): value by which to multiply the self MixedSystem
+    ///     value (Union[QubitOperator, CalculatorComplex, CalculatorFloat]): value by which to multiply the self QubitOperator
     ///
     /// Returns:
-    ///     MixedSystem: The MixedSystem multiplied by the value.
+    ///     QubitOperator: The QubitOperator multiplied by the value.
     ///
     /// Raises:
-    ///     ValueError: The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor MixedSystem.
+    ///     ValueError: The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor QubitOperator.
     pub fn __mul__(&self, value: &PyAny) -> PyResult<Self> {
         let cf_value = qoqo_calculator_pyo3::convert_into_calculator_float(value);
         match cf_value {
             Ok(x) => Ok(Self {
                 internal: self.clone().internal * CalculatorComplex::from(x),
             }),
             Err(_) => {
@@ -109,25 +104,26 @@
                     Ok(x) => Ok(Self {
                         internal: self.clone().internal * x,
                     }),
                     Err(_) => {
                         let bhs_value = Self::from_pyany(value.into());
                         match bhs_value {
                             Ok(x) => {
-                                let new_self = (self.clone().internal * x).map_err(|err| {
-                                    PyValueError::new_err(format!(
-                                        "MixedSystems could not be multiplied: {:?}",
-                                        err
-                                    ))
-                                })?;
+                                let new_self = self.clone().internal * x;
                                 Ok(Self { internal: new_self })
                             },
                             Err(err) => Err(PyValueError::new_err(format!(
-                                "The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor MixedSystem: {:?}",
+                                "The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor QubitOperator: {:?}",
                                 err)))
                         }
                     }
                 }
             }
         }
     }
 }
+
+impl Default for QubitOperatorWrapper {
+    fn default() -> Self {
+        Self::new()
+    }
+}
```

### Comparing `struqture_py-1.6.1/struqture-py/src/mixed_systems/mod.rs` & `struqture_py-2.0.0a0/struqture-py/src/mixed_systems/mod.rs`

 * *Files 20% similar despite different names*

```diff
@@ -20,61 +20,61 @@
 
 mod mixed_hermitian_product;
 pub use mixed_hermitian_product::HermitianMixedProductWrapper;
 
 mod mixed_decoherence_product;
 pub use mixed_decoherence_product::MixedDecoherenceProductWrapper;
 
-mod mixed_system;
-pub use mixed_system::MixedSystemWrapper;
+mod mixed_operator;
+pub use mixed_operator::MixedOperatorWrapper;
 
 mod mixed_plus_minus_operator;
 pub use mixed_plus_minus_operator::MixedPlusMinusOperatorWrapper;
 
-mod mixed_hamiltonian_system;
-pub use mixed_hamiltonian_system::MixedHamiltonianSystemWrapper;
+mod mixed_hamiltonian;
+pub use mixed_hamiltonian::MixedHamiltonianWrapper;
 
-mod mixed_noise_system;
-pub use mixed_noise_system::MixedLindbladNoiseSystemWrapper;
+mod mixed_noise_operator;
+pub use mixed_noise_operator::MixedLindbladNoiseOperatorWrapper;
 
 mod mixed_open_system;
 pub use mixed_open_system::MixedLindbladOpenSystemWrapper;
 
 /// Module for representing mixed physical systems.
 ///
 /// A mixed physical system can contain any combination of none, one, or several subsystems
 /// of spin, bosonic, or fermionic types.
 /// For example a mixed system with two spin-subsystems or a mixed system with a bosonic-subsystem and a bosonic-subsystem would both be valid.
 ///
 /// This module, here the python inferface for struqture, can be used to represent
 /// mixed quantum indices (MixedProduct, HermitianMixedProduct and MixedDecoherenceProduct),
-/// mixed systems (MixedSystem and MixedHamiltonianSystem) and Lindblad type mixed open systems
-/// (MixedLindbladNoiseSystem and MixedLindbladOpenSystem).
+/// mixed systems (MixedOperator and MixedHamiltonian) and Lindblad type mixed open systems
+/// (MixedLindbladNoiseOperator and MixedLindbladOpenSystem).
 ///
 /// .. autosummary::
 ///     :toctree: generated/
 ///
 ///     MixedProduct
 ///     HermitianMixedProduct
 ///     MixedDecoherenceProduct
-///     MixedSystem
-///     MixedHamiltonianSystem
-///     MixedLindbladNoiseSystem
+///     MixedOperator
+///     MixedHamiltonian
+///     MixedLindbladNoiseOperator
 ///     MixedLindbladOpenSystem
 ///     MixedPlusMinusProduct
 ///     MixedPlusMinusOperator
 ///
 #[pymodule]
 pub fn mixed_systems(_py: Python, m: &PyModule) -> PyResult<()> {
     // pyo3_log::init();
     m.add_class::<MixedProductWrapper>()?;
     m.add_class::<HermitianMixedProductWrapper>()?;
     m.add_class::<MixedDecoherenceProductWrapper>()?;
-    m.add_class::<MixedSystemWrapper>()?;
-    m.add_class::<MixedHamiltonianSystemWrapper>()?;
-    m.add_class::<MixedLindbladNoiseSystemWrapper>()?;
+    m.add_class::<MixedOperatorWrapper>()?;
+    m.add_class::<MixedHamiltonianWrapper>()?;
+    m.add_class::<MixedLindbladNoiseOperatorWrapper>()?;
     m.add_class::<MixedLindbladOpenSystemWrapper>()?;
     m.add_class::<MixedPlusMinusProductWrapper>()?;
     m.add_class::<MixedPlusMinusOperatorWrapper>()?;
 
     Ok(())
 }
```

### Comparing `struqture_py-1.6.1/struqture-py/src/spins/decoherence_product.rs` & `struqture_py-2.0.0a0/struqture-py/src/spins/decoherence_product.rs`

 * *Files 2% similar despite different names*

```diff
@@ -6,41 +6,41 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::fermions::FermionSystemWrapper;
+use crate::fermions::FermionOperatorWrapper;
 use num_complex::Complex64;
 use pyo3::exceptions::{PyTypeError, PyValueError};
 use pyo3::prelude::*;
 use pyo3::types::PyByteArray;
 use std::collections::hash_map::DefaultHasher;
 use std::collections::HashMap;
 use std::hash::{Hash, Hasher};
 use std::str::FromStr;
-use struqture::fermions::FermionSystem;
 use struqture::mappings::JordanWignerSpinToFermion;
 use struqture::spins::{DecoherenceProduct, SingleDecoherenceOperator};
+use struqture::SerializationSupport;
 #[cfg(feature = "json_schema")]
-use struqture::{MinSupportedVersion, STRUQTURE_VERSION};
+use struqture::STRUQTURE_VERSION;
 use struqture::{SpinIndex, SymmetricIndex};
 use struqture_py_macros::{mappings, product_wrapper};
 
 /// These are combinations of SingleDecoherenceOperators on specific qubits.
 ///
 /// DecoherenceProducts act in a noisy system. They are representation of products of decoherence
 /// matrices acting on qubits in order to build the terms of a hamiltonian.
 /// For instance, to represent the term :math:`\sigma_0^{x}` :math:`\sigma_2^{z}`:
 ///
 /// `DecoherenceProduct().x(0).z(2)`.
 ///
 /// DecoherenceProduct is  supposed to be used as input for the function `add_noise`,
-/// for instance in the spin system classes SpinLindbladOpenSystem, SpinLindbladNoiseSystem or SpinLindbladNoiseOperator,
+/// for instance in the spin system classes QubitLindbladOpenSystem, SpinLindbladNoiseSystem or QubitLindbladNoiseOperator,
 /// or in the mixed systems as part of `MixedDecoherenceProduct <mixed_systems.MixedDecoherenceProduct>`.
 ///
 /// Examples
 /// --------
 ///
 /// .. code-block:: python
 ///
@@ -55,15 +55,15 @@
 #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Default)]
 pub struct DecoherenceProductWrapper {
     /// Internal storage of [struqture::spins::DecoherenceProduct]
     pub internal: DecoherenceProduct,
 }
 
 #[mappings(JordanWignerSpinToFermion)]
-#[product_wrapper(SpinIndex, SymmetricIndex)]
+#[product_wrapper(SpinIndex, SymmetricIndex, Calculus)]
 impl DecoherenceProductWrapper {
     /// Create an empty DecoherenceProduct.
     ///
     /// Returns:
     ///     self: The new, empty DecoherenceProduct.
     #[new]
     pub fn new() -> Self {
```

### Comparing `struqture_py-1.6.1/struqture-py/src/spins/mod.rs` & `struqture_py-2.0.0a0/struqture-py/src/spins/mod.rs`

 * *Files 16% similar despite different names*

```diff
@@ -22,48 +22,48 @@
 
 mod plus_minus_operator;
 pub use plus_minus_operator::PlusMinusOperatorWrapper;
 
 mod plus_minus_noise_operator;
 pub use plus_minus_noise_operator::PlusMinusLindbladNoiseOperatorWrapper;
 
-mod spin_system;
-pub use spin_system::SpinSystemWrapper;
+mod qubit_operator;
+pub use qubit_operator::QubitOperatorWrapper;
 
-mod spin_hamiltonian_system;
-pub use spin_hamiltonian_system::SpinHamiltonianSystemWrapper;
+mod qubit_hamiltonian;
+pub use qubit_hamiltonian::QubitHamiltonianWrapper;
 
-mod spin_noise_system;
-pub use spin_noise_system::SpinLindbladNoiseSystemWrapper;
+mod qubit_noise_operator;
+pub use qubit_noise_operator::QubitLindbladNoiseOperatorWrapper;
 
-mod spin_open_system;
-pub use spin_open_system::SpinLindbladOpenSystemWrapper;
+mod qubit_open_system;
+pub use qubit_open_system::QubitLindbladOpenSystemWrapper;
 
 /// Spin module of struqture Python interface
 ///
-/// Module for representing spin indices (PauliProduct and DecoherenceProduct), spin systems (SpinSystem and SpinHamiltonianSystem)
-/// and Lindblad type spin open systems (SpinLindbladNoiseSystem and SpinLindbladOpenSystem).
+/// Module for representing spin indices (PauliProduct and DecoherenceProduct), spin systems (QubitOperator and QubitHamiltonian)
+/// and Lindblad type spin open systems (QubitLindbladNoiseOperator and QubitLindbladOpenSystem).
 ///
 /// .. autosummary::
 ///     :toctree: generated/
 ///
 ///     PauliProduct
 ///     DecoherenceProduct
-///     SpinSystem
-///     SpinHamiltonianSystem
-///     SpinLindbladNoiseSystem
-///     SpinLindbladOpenSystem
+///     QubitOperator
+///     QubitHamiltonian
+///     QubitLindbladNoiseOperator
+///     QubitLindbladOpenSystem
 ///
 #[pymodule]
 pub fn spins(_py: Python, m: &PyModule) -> PyResult<()> {
     // pyo3_log::init();
     m.add_class::<PauliProductWrapper>()?;
     m.add_class::<DecoherenceProductWrapper>()?;
-    m.add_class::<SpinSystemWrapper>()?;
-    m.add_class::<SpinHamiltonianSystemWrapper>()?;
-    m.add_class::<SpinLindbladNoiseSystemWrapper>()?;
-    m.add_class::<SpinLindbladOpenSystemWrapper>()?;
+    m.add_class::<QubitOperatorWrapper>()?;
+    m.add_class::<QubitHamiltonianWrapper>()?;
+    m.add_class::<QubitLindbladNoiseOperatorWrapper>()?;
+    m.add_class::<QubitLindbladOpenSystemWrapper>()?;
     m.add_class::<PlusMinusProductWrapper>()?;
     m.add_class::<PlusMinusOperatorWrapper>()?;
     m.add_class::<PlusMinusLindbladNoiseOperatorWrapper>()?;
     Ok(())
 }
```

### Comparing `struqture_py-1.6.1/struqture-py/src/spins/pauli_product.rs` & `struqture_py-2.0.0a0/struqture-py/src/spins/pauli_product.rs`

 * *Files 14% similar despite different names*

```diff
@@ -6,42 +6,42 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::fermions::FermionSystemWrapper;
+use crate::fermions::FermionOperatorWrapper;
 use num_complex::Complex64;
 use pyo3::exceptions::{PyTypeError, PyValueError};
 use pyo3::prelude::*;
 use pyo3::types::PyByteArray;
 use std::collections::hash_map::DefaultHasher;
 use std::collections::HashMap;
 use std::hash::{Hash, Hasher};
 use std::str::FromStr;
-use struqture::fermions::FermionSystem;
 use struqture::mappings::JordanWignerSpinToFermion;
-use struqture::spins::{PauliProduct, SingleSpinOperator};
+use struqture::spins::{PauliProduct, SingleQubitOperator};
+use struqture::SerializationSupport;
 #[cfg(feature = "json_schema")]
-use struqture::{MinSupportedVersion, STRUQTURE_VERSION};
+use struqture::STRUQTURE_VERSION;
 use struqture::{SpinIndex, SymmetricIndex};
 use struqture_py_macros::{mappings, product_wrapper};
 
-/// PauliProducts are combinations of SingleSpinOperators on specific qubits.
+/// PauliProducts are combinations of SingleQubitOperators on specific qubits.
 ///
 /// PauliProducts can be used in either noise-free or a noisy system.
 /// They are representations of products of pauli matrices acting on qubits,
 /// in order to build the terms of a hamiltonian.
 /// For instance, to represent the term :math:`\sigma_0^{x}` :math:`\sigma_2^{x}` :
 ///
 /// `PauliProduct().x(0).x(2)`.
 ///
 /// PauliProduct is  supposed to be used as input for the function `set_pauli_product`,
-/// for instance in the spin system classes SpinLindbladOpenSystem, SpinHamiltonianSystem or SpinSystem,
+/// for instance in the spin system classes QubitLindbladOpenSystem, QubitHamiltonian or QubitOperator,
 /// or in the mixed systems as part of `MixedProduct <mixed_systems.MixedProduct>`
 /// or as part of `HermitianMixedProduct <mixed_systems.HermitianMixedProduct>`.
 ///
 /// Examples
 /// --------
 ///
 /// .. code-block:: python
@@ -50,61 +50,62 @@
 ///     from struqture_py.spins import PauliProduct
 ///     pp = PauliProduct().x(0).y(1).z(2)
 ///     pp = pp.set_pauli(3, "X")
 ///     npt.assert_equal(pp.get(0), "X")
 ///     npt.assert_equal(pp.keys(), [0, 1, 2, 3])
 ///
 #[pyclass(name = "PauliProduct", module = "struqture_py.spins")]
+// #[pyo3(crate = "pyo3")]
 #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
 pub struct PauliProductWrapper {
     /// Internal storage of [struqture::spins::PauliProduct]
     pub internal: PauliProduct,
 }
 
 #[mappings(JordanWignerSpinToFermion)]
-#[product_wrapper(SpinIndex, SymmetricIndex)]
+#[product_wrapper(SpinIndex, SymmetricIndex, Calculus)]
 impl PauliProductWrapper {
     /// Create an empty PauliProduct.
     ///
     /// Returns:
     ///     self: The new, empty PauliProduct.
     #[new]
     pub fn new() -> Self {
         Self {
             internal: PauliProduct::new(),
         }
     }
 
-    /// Set a new entry for SingleSpinOperator X in the internal dictionary.
+    /// Set a new entry for SingleQubitOperator X in the internal dictionary.
     ///
     /// Args:
     ///     index (int): Index of set object.
     ///
     /// Returns:
     ///     PauliProduct: The PauliProduct with the new entry.
     pub fn x(&self, index: usize) -> PauliProductWrapper {
         Self {
             internal: self.clone().internal.x(index),
         }
     }
 
-    /// Set a new entry for SingleSpinOperator Y in the internal dictionary.
+    /// Set a new entry for SingleQubitOperator Y in the internal dictionary.
     ///
     /// Args:
     ///     index (int): Index of set object.
     ///
     /// Returns:
     ///     PauliProduct: The PauliProduct with the new entry.
     pub fn y(&self, index: usize) -> PauliProductWrapper {
         Self {
             internal: self.clone().internal.y(index),
         }
     }
 
-    /// Set a new entry for SingleSpinOperator Z in the internal dictionary.
+    /// Set a new entry for SingleQubitOperator Z in the internal dictionary.
     ///
     /// Args:
     ///     index (int): Index of set object.
     ///
     /// Returns:
     ///     PauliProduct: The PauliProduct with the new entry.
     pub fn z(&self, index: usize) -> PauliProductWrapper {
@@ -118,15 +119,15 @@
     /// Args:
     ///     index (int): Index of set object.
     ///     pauli (str): Value of set object.
     ///
     /// Returns:
     ///     self: The entry was correctly set and the PauliProduct is returned.
     pub fn set_pauli(&self, index: usize, pauli: String) -> PyResult<Self> {
-        let converted_pauli = SingleSpinOperator::from_str(pauli.as_str()).map_err(|err| {
+        let converted_pauli = SingleQubitOperator::from_str(pauli.as_str()).map_err(|err| {
             PyValueError::new_err(format!(
                 "pauli could not be converted to X, Y, Z: {:?}",
                 err
             ))
         })?;
         Ok(Self {
             internal: self.internal.clone().set_pauli(index, converted_pauli),
```

### Comparing `struqture_py-1.6.1/struqture-py/src/spins/plus_minus_product.rs` & `struqture_py-2.0.0a0/struqture-py/src/spins/plus_minus_product.rs`

 * *Files 16% similar despite different names*

```diff
@@ -6,36 +6,35 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crate::fermions::FermionSystemWrapper;
+use super::{DecoherenceProductWrapper, PauliProductWrapper};
+use crate::fermions::FermionOperatorWrapper;
 use num_complex::Complex64;
 use pyo3::exceptions::{PyTypeError, PyValueError};
 use pyo3::prelude::*;
 use pyo3::types::{PyAny, PyByteArray};
 use qoqo_calculator::CalculatorComplex;
 use qoqo_calculator_pyo3::CalculatorComplexWrapper;
 use std::collections::hash_map::DefaultHasher;
 use std::collections::HashMap;
 use std::hash::{Hash, Hasher};
 use std::str::FromStr;
-use struqture::fermions::FermionSystem;
 use struqture::mappings::JordanWignerSpinToFermion;
 use struqture::spins::{
     DecoherenceProduct, PauliProduct, PlusMinusProduct, SinglePlusMinusOperator,
 };
+use struqture::SerializationSupport;
 use struqture::SymmetricIndex;
-use struqture_py_macros::{mappings, product_wrapper};
-
-use super::{DecoherenceProductWrapper, PauliProductWrapper};
 #[cfg(feature = "json_schema")]
-use struqture::{MinSupportedVersion, STRUQTURE_VERSION};
+use struqture::STRUQTURE_VERSION;
+use struqture_py_macros::{mappings, product_wrapper};
 
 /// PlusMinusProducts are combinations of SinglePlusMinusOperators on specific qubits.
 ///
 /// PlusMinusProducts can be used in either noise-free or a noisy system.
 /// They are representations of products of pauli matrices acting on qubits,
 /// in order to build the terms of a hamiltonian.
 /// For instance, to represent the term :math:`\sigma_0^{+}` :math:`\sigma_2^{+}` :
@@ -59,15 +58,15 @@
 #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
 pub struct PlusMinusProductWrapper {
     /// Internal storage of [struqture::spins::PlusMinusProduct]
     pub internal: PlusMinusProduct,
 }
 
 #[mappings(JordanWignerSpinToFermion)]
-#[product_wrapper(SymmetricIndex)]
+#[product_wrapper(SymmetricIndex, SpinIndex)]
 impl PlusMinusProductWrapper {
     /// Create an empty PlusMinusProduct.
     ///
     /// Returns:
     ///     self: The new, empty PlusMinusProduct.
     #[new]
     pub fn new() -> Self {
@@ -131,85 +130,14 @@
             ))
         })?;
         Ok(Self {
             internal: self.internal.clone().set_pauli(index, converted_pauli),
         })
     }
 
-    /// Get the pauli matrix corresponding to the index.
-    ///
-    /// Args:
-    ///     index (int): Index of get object.
-    ///
-    /// Returns:
-    ///     Optional[str]: The key's corresponding value (if it exists).
-    pub fn get(&self, index: usize) -> Option<String> {
-        self.internal.get(&index).map(|x| format!("{}", x))
-    }
-
-    /// Return a list of the unsorted keys in self.
-    ///
-    /// Returns:
-    ///     list[int]: The sequence of qubit index keys of self.
-    pub fn keys(&self) -> Vec<usize> {
-        let keys: Vec<usize> = self.internal.iter().map(|(k, _)| k).copied().collect();
-        keys
-    }
-
-    /// Return maximum index in self.
-    ///
-    /// Returns:
-    ///     int: Maximum index.
-    pub fn current_number_spins(&self) -> usize {
-        self.internal.current_number_spins()
-    }
-
-    /// Return number of entries in object.
-    ///
-    /// Returns:
-    ///     int: The length of the content of the object.
-    pub fn __len__(&self) -> usize {
-        self.internal.iter().len()
-    }
-
-    /// Remap the qubits in a new instance of self (returned).
-    ///
-    /// Args:
-    ///     mapping (dict[int, int]): The map containing the {qubit: qubit} mapping to use.
-    ///
-    /// Returns:
-    ///     self: The new instance of self with the qubits remapped.
-    pub fn remap_qubits(&self, mapping: HashMap<usize, usize>) -> PlusMinusProductWrapper {
-        PlusMinusProductWrapper {
-            internal: self.internal.remap_qubits(&mapping),
-        }
-    }
-
-    /// Return the concatenation of two objects of type `self` with no overlapping qubits.
-    ///
-    /// Args:
-    ///     other (self): The object to concatenate self with.
-    ///
-    /// Returns:
-    ///     list[int]: A list of the corresponding creator indices.
-    ///
-    /// Raises:
-    ///     ValueError: The two objects could not be concatenated.
-    pub fn concatenate(&self, other: PlusMinusProductWrapper) -> PyResult<PlusMinusProductWrapper> {
-        let concatenated = self.internal.concatenate(other.internal).map_err(|err| {
-            PyValueError::new_err(format!(
-                "The two objects could not be concatenated: {:?}",
-                err
-            ))
-        })?;
-        Ok(PlusMinusProductWrapper {
-            internal: concatenated,
-        })
-    }
-
     /// Creates a list of corresponding (PlusMinusProduct, CalculatorComplex) tuples from the input PauliProduct or DecoherenceProduct.
     ///
     /// Args:
     ///     value (PauliProduct or DecoherenceProduct): The input object to convert.
     ///
     /// Returns:
     ///     list[tuple[(PlusMinusProduct, CalculatorComplex)]]: The converted input.
@@ -262,24 +190,14 @@
                 Err(_) => Err(PyValueError::new_err(
                     "Input is neither PauliProduct nor DecoherenceProduct",
                 )),
             },
         }
     }
 
-    /// DEPRECATED: Convert `self` into a list of (PauliProduct, CalculatorComplex) tuples.
-    ///
-    /// This function is deprecated, please use `to_pauli_product_list`
-    ///
-    /// Returns:
-    ///     list[tuple[(PauliProduct, CalculatorComplex)]]: A list of the terms `self` corresponds to.
-    pub fn to_pauli_product(&self) -> Vec<(PauliProductWrapper, CalculatorComplexWrapper)> {
-        self.to_pauli_product_list()
-    }
-
     /// Convert `self` into a list of (PauliProduct, CalculatorComplex) tuples.
     ///
     /// Returns:
     ///     list[tuple[(PauliProduct, CalculatorComplex)]]: A list of the terms `self` corresponds to.
     pub fn to_pauli_product_list(&self) -> Vec<(PauliProductWrapper, CalculatorComplexWrapper)> {
         let result: Vec<(PauliProduct, Complex64)> =
             Vec::<(PauliProduct, Complex64)>::from(self.internal.clone());
@@ -295,26 +213,14 @@
                     },
                 )
             })
             .collect();
         result_pyo3
     }
 
-    /// DEPRECATED: Convert `self` into a list of (DecoherenceProduct, CalculatorComplex) tuples.
-    ///
-    /// This function is deprecated, please use `to_decoherence_product_list`
-    ///
-    /// Returns:
-    ///     list[tuple[(DecoherenceProduct, CalculatorComplex)]]: A list of the terms `self` corresponds to.
-    pub fn to_decoherence_product(
-        &self,
-    ) -> Vec<(DecoherenceProductWrapper, CalculatorComplexWrapper)> {
-        self.to_decoherence_product_list()
-    }
-
     /// Convert `self` into a list of (DecoherenceProduct, CalculatorComplex) tuples.
     ///
     /// Returns:
     ///     list[tuple[(DecoherenceProduct, CalculatorComplex)]]: A list of the terms `self` corresponds to.
     pub fn to_decoherence_product_list(
         &self,
     ) -> Vec<(DecoherenceProductWrapper, CalculatorComplexWrapper)> {
```

### Comparing `struqture_py-1.6.1/struqture-py/src/spins/spin_hamiltonian_system.rs` & `struqture_py-2.0.0a0/struqture-py/src/spins/qubit_hamiltonian.rs`

 * *Files 22% similar despite different names*

```diff
@@ -6,127 +6,125 @@
 //     http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
-use super::SpinSystemWrapper;
-use crate::fermions::FermionHamiltonianSystemWrapper;
+use super::QubitOperatorWrapper;
+use crate::fermions::FermionHamiltonianWrapper;
 use crate::spins::PauliProductWrapper;
 use crate::{to_py_coo, PyCooMatrix};
 use bincode::deserialize;
 use num_complex::Complex64;
 use pyo3::exceptions::{PyRuntimeError, PyTypeError, PyValueError};
 use pyo3::prelude::*;
 use pyo3::types::PyByteArray;
 use qoqo_calculator::CalculatorComplex;
 use qoqo_calculator_pyo3::CalculatorFloatWrapper;
 use struqture::mappings::JordanWignerSpinToFermion;
 use struqture::spins::{
-    OperateOnSpins, SpinHamiltonianSystem, ToSparseMatrixOperator, ToSparseMatrixSuperOperator,
+    OperateOnSpins, QubitHamiltonian, ToSparseMatrixOperator, ToSparseMatrixSuperOperator,
 };
 use struqture::StruqtureError;
 #[cfg(feature = "json_schema")]
-use struqture::{MinSupportedVersion, STRUQTURE_VERSION};
+use struqture::STRUQTURE_VERSION;
 use struqture::{OperateOnDensityMatrix, OperateOnState};
 use struqture_py_macros::{mappings, noiseless_system_wrapper};
+
 /// These are representations of systems of spins.
 ///
-/// SpinHamiltonianSystems are characterized by a SpinOperator to represent the hamiltonian of the spin system
+/// QubitHamiltonians are characterized by a QubitOperator to represent the hamiltonian of the spin system
 /// and an optional number of spins.
 ///
 /// Examples
 /// --------
 ///
 /// .. code-block:: python
 ///
 ///     import numpy.testing as npt
 ///     import scipy.sparse as sp
 ///     from qoqo_calculator_pyo3 import CalculatorComplex
-///     from struqture_py.spins import SpinHamiltonianSystem, PauliProduct
+///     from struqture_py.spins import QubitHamiltonian, PauliProduct
 ///
-///     ssystem = SpinHamiltonianSystem(2)
+///     ssystem = QubitHamiltonian(2)
 ///     pp = PauliProduct().z(0)
 ///     ssystem.add_operator_product(pp, 5.0)
-///     npt.assert_equal(ssystem.number_spins(), 2)
+///     npt.assert_equal(ssystem.current_number_spins(), 2)
 ///     npt.assert_equal(ssystem.get(pp), CalculatorComplex(5))
 ///     npt.assert_equal(ssystem.keys(), [pp])
-///     dimension = 4**ssystem.number_spins()
+///     dimension = 4**ssystem.current_number_spins()
 ///     matrix = sp.coo_matrix(ssystem.sparse_matrix_superoperator_coo(), shape=(dimension, dimension))
 ///
-#[pyclass(name = "SpinHamiltonianSystem", module = "struqture_py.spins")]
+#[pyclass(name = "QubitHamiltonian", module = "struqture_py.spins")]
 #[derive(Clone, Debug, PartialEq)]
-pub struct SpinHamiltonianSystemWrapper {
-    /// Internal storage of [struqture::spins::SpinHamiltonianSystem]
-    pub internal: SpinHamiltonianSystem,
+pub struct QubitHamiltonianWrapper {
+    /// Internal storage of [struqture::spins::QubitHamiltonian]
+    pub internal: QubitHamiltonian,
 }
 
 #[mappings(JordanWignerSpinToFermion)]
 #[noiseless_system_wrapper(
     OperateOnSpins,
     OperateOnState,
     ToSparseMatrixOperator,
     ToSparseMatrixSuperOperator,
     OperateOnDensityMatrix,
     Calculus
 )]
-impl SpinHamiltonianSystemWrapper {
-    /// Create an empty SpinHamiltonianSystem.
-    ///
-    /// Args:
-    ///     number_spins (Optional[int]): The number of spins in the SpinHamiltonianSystem.
+impl QubitHamiltonianWrapper {
+    /// Create an empty QubitHamiltonian.
     ///
     /// Returns:
-    ///     self: The new SpinHamiltonianSystem with the input number of spins.
+    ///     self: The new QubitHamiltonian with the input number of spins.
     #[new]
-    #[pyo3(signature = (number_spins = None))]
-    pub fn new(number_spins: Option<usize>) -> Self {
+    pub fn new() -> Self {
         Self {
-            internal: SpinHamiltonianSystem::new(number_spins),
+            internal: QubitHamiltonian::new(),
         }
     }
 
-    /// Implement `*` for SpinHamiltonianSystem and SpinHamiltonianSystem/CalculatorComplex/CalculatorFloat.
+    /// Implement `*` for QubitHamiltonian and QubitHamiltonian/CalculatorComplex/CalculatorFloat.
     ///
     /// Args:
-    ///     value (Union[SpinHamiltonianSystem, CalculatorComplex, CalculatorFloat]): value by which to multiply the self SpinHamiltonianSystem
+    ///     value (Union[QubitHamiltonian, CalculatorComplex, CalculatorFloat]): value by which to multiply the self QubitHamiltonian
     ///
     /// Returns:
-    ///     SpinSystem: The SpinHamiltonianSystem multiplied by the value.
+    ///     QubitOperator: The QubitHamiltonian multiplied by the value.
     ///
     /// Raises:
-    ///     ValueError: The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor SpinHamiltonianSystem.
-    pub fn __mul__(&self, value: &PyAny) -> PyResult<SpinSystemWrapper> {
+    ///     ValueError: The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor QubitHamiltonian.
+    pub fn __mul__(&self, value: &PyAny) -> PyResult<QubitOperatorWrapper> {
         let cf_value = qoqo_calculator_pyo3::convert_into_calculator_float(value);
         match cf_value {
-            Ok(x) => Ok(SpinSystemWrapper {
+            Ok(x) => Ok(QubitOperatorWrapper {
                 internal: self.clone().internal * CalculatorComplex::from(x),
             }),
             Err(_) => {
                 let cc_value = qoqo_calculator_pyo3::convert_into_calculator_complex(value);
                 match cc_value {
-                    Ok(x) => Ok(SpinSystemWrapper {
+                    Ok(x) => Ok(QubitOperatorWrapper {
                         internal: self.clone().internal * x,
                     }),
                     Err(_) => {
                         let bhs_value = Self::from_pyany(value.into());
                         match bhs_value {
                             Ok(x) => {
-                                let new_self = (self.clone().internal * x).map_err(|err| {
-                                    PyValueError::new_err(format!(
-                                        "SpinHamiltonianSystems could not be multiplied: {:?}",
-                                        err
-                                    ))
-                                })?;
-                                Ok(SpinSystemWrapper { internal: new_self })
+                                let new_self = self.clone().internal * x;
+                                Ok(QubitOperatorWrapper { internal: new_self })
                             },
                             Err(err) => Err(PyValueError::new_err(format!(
-                                "The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor SpinHamiltonianSystem: {:?}",
+                                "The rhs of the multiplication is neither CalculatorFloat, CalculatorComplex, nor QubitHamiltonian: {:?}",
                                 err)))
                         }
                     }
                 }
             }
         }
     }
 }
+
+impl Default for QubitHamiltonianWrapper {
+    fn default() -> Self {
+        Self::new()
+    }
+}
```

### Comparing `struqture_py-1.6.1/struqture-py/src/spins/spin_open_system.rs` & `struqture_py-2.0.0a0/struqture-py/src/spins/qubit_open_system.rs`

 * *Files 14% similar despite different names*

```diff
@@ -7,70 +7,71 @@
 //
 // Unless required by applicable law or agreed to in writing, software distributed under the
 // License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 // express or implied. See the License for the specific language governing permissions and
 // limitations under the License.
 
 use super::{DecoherenceProductWrapper, PauliProductWrapper};
-use super::{SpinHamiltonianSystemWrapper, SpinLindbladNoiseSystemWrapper};
+use super::{QubitHamiltonianWrapper, QubitLindbladNoiseOperatorWrapper};
 use crate::fermions::FermionLindbladOpenSystemWrapper;
 use crate::{to_py_coo, PyCooMatrix};
 use bincode::deserialize;
 use num_complex::Complex64;
 use pyo3::exceptions::{PyRuntimeError, PyTypeError, PyValueError};
 use pyo3::prelude::*;
 use pyo3::types::PyByteArray;
 use qoqo_calculator_pyo3::{CalculatorComplexWrapper, CalculatorFloatWrapper};
 use struqture::mappings::JordanWignerSpinToFermion;
-use struqture::spins::{OperateOnSpins, SpinLindbladOpenSystem, ToSparseMatrixSuperOperator};
+use struqture::spins::{OperateOnSpins, QubitLindbladOpenSystem, ToSparseMatrixSuperOperator};
 #[cfg(feature = "json_schema")]
-use struqture::{MinSupportedVersion, STRUQTURE_VERSION};
+use struqture::STRUQTURE_VERSION;
 use struqture::{OpenSystem, OperateOnDensityMatrix, StruqtureError};
 use struqture_py_macros::{mappings, noisy_system_wrapper};
 
 /// These are representations of noisy systems of spins.
 ///
-/// In a SpinLindbladOpenSystem is characterized by a SpinLindbladOpenOperator to represent the hamiltonian of the system, and an optional number of spins.
+/// In a QubitLindbladOpenSystem is characterized by a SpinLindbladOpenOperator to represent the hamiltonian of the system, and an optional number of spins.
 ///
 /// Examples
 /// --------
 ///
 /// .. code-block:: python
 ///
 ///     import numpy.testing as npt
 ///     import scipy.sparse as sp
 ///     from qoqo_calculator_pyo3 import CalculatorComplex, CalculatorFloat
-///     from struqture_py.spins import SpinLindbladOpenSystem, DecoherenceProduct
+///     from struqture_py.spins import QubitLindbladOpenSystem, DecoherenceProduct
 ///
-///     slns = SpinLindbladOpenSystem()
+///     slns = QubitLindbladOpenSystem()
 ///     dp = DecoherenceProduct().z(0).x(1)
 ///     slns.system_add_operator_product(dp, 2.0)
 ///     npt.assert_equal(slns.current_number_spins(), 2)
 ///     npt.assert_equal(slns.system().get(dp), CalculatorFloat(2))
-///     dimension = 4**slns.number_spins()
+///     dimension = 4**slns.current_number_spins()
 ///     matrix = sp.coo_matrix(slns.sparse_matrix_superoperator_coo(), shape=(dimension, dimension))
 ///
-#[pyclass(name = "SpinLindbladOpenSystem", module = "struqture_py.spins")]
+#[pyclass(name = "QubitLindbladOpenSystem", module = "struqture_py.spins")]
 #[derive(Clone, Debug, PartialEq, Default)]
-pub struct SpinLindbladOpenSystemWrapper {
-    /// Internal storage of [struqture::spins::SpinLindbladOpenSystem]
-    pub internal: SpinLindbladOpenSystem,
+pub struct QubitLindbladOpenSystemWrapper {
+    /// Internal storage of [struqture::spins::QubitLindbladOpenSystem]
+    pub internal: QubitLindbladOpenSystem,
 }
 
 #[mappings(JordanWignerSpinToFermion)]
-#[noisy_system_wrapper(OpenSystem, OperateOnSpins, ToSparseMatrixSuperOperator, Calculus)]
-impl SpinLindbladOpenSystemWrapper {
-    /// Create a new SpinLindbladOpenSystem.
-    ///
-    /// Args:
-    ///     number_spins (Optional[int]): The number of spins in the SpinLindbladOpenSystem.
+#[noisy_system_wrapper(
+    OpenSystem,
+    OperateOnSpins,
+    ToSparseMatrixSuperOperator,
+    HermitianCalculus
+)]
+impl QubitLindbladOpenSystemWrapper {
+    /// Create a new QubitLindbladOpenSystem.
     ///
     /// Returns:
-    ///     SpinLindbladOpenSystem: The new SpinLindbladOpenSystem with the input number of spins.
+    ///     QubitLindbladOpenSystem: The new QubitLindbladOpenSystem with the input number of spins.
     #[new]
-    #[pyo3(signature = (number_spins = None))]
-    pub fn new(number_spins: Option<usize>) -> Self {
+    pub fn new() -> Self {
         Self {
-            internal: SpinLindbladOpenSystem::new(number_spins),
+            internal: QubitLindbladOpenSystem::new(),
         }
     }
 }
```

### Comparing `struqture_py-1.6.1/struqture-py/struqture_py/DEPENDENCIES` & `struqture_py-2.0.0a0/struqture-py/struqture_py/DEPENDENCIES`

 * *Files identical despite different names*

### Comparing `struqture_py-1.6.1/struqture-py/struqture_py/PYTHON_LICENSE` & `struqture_py-2.0.0a0/struqture-py/struqture_py/PYTHON_LICENSE`

 * *Files identical despite different names*

### Comparing `struqture_py-1.6.1/Cargo.lock` & `struqture_py-2.0.0a0/Cargo.lock`

 * *Files 1% similar despite different names*

```diff
@@ -1501,14 +1501,31 @@
 version = "0.11.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5ee073c9e4cd00e28217186dbe12796d692868f432bf2e97ee73bed0c56dfa01"
 
 [[package]]
 name = "struqture"
 version = "1.6.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b5e6a6fae203fb8098042ab51364cf5ff79020312e68b63038371d627029ab08"
+dependencies = [
+ "itertools 0.12.1",
+ "ndarray",
+ "num-complex",
+ "qoqo_calculator",
+ "schemars",
+ "serde",
+ "test-case",
+ "thiserror",
+ "tinyvec",
+]
+
+[[package]]
+name = "struqture"
+version = "2.0.0-alpha.0"
 dependencies = [
  "bincode",
  "criterion",
  "indexmap",
  "itertools 0.12.1",
  "jsonschema",
  "nalgebra",
@@ -1516,22 +1533,23 @@
  "num-complex",
  "qoqo_calculator",
  "rand",
  "schemars",
  "serde",
  "serde_json",
  "serde_test",
+ "struqture 1.6.1",
  "test-case",
  "thiserror",
  "tinyvec",
 ]
 
 [[package]]
 name = "struqture-py"
-version = "1.6.1"
+version = "2.0.0-alpha.0"
 dependencies = [
  "bincode",
  "nalgebra",
  "ndarray",
  "num-complex",
  "numpy",
  "proc-macro2",
@@ -1539,24 +1557,25 @@
  "pyo3-build-config",
  "qoqo_calculator",
  "qoqo_calculator_pyo3",
  "quote",
  "schemars",
  "serde",
  "serde_json",
- "struqture",
+ "struqture 1.6.1",
+ "struqture 2.0.0-alpha.0",
  "struqture-py-macros",
  "syn 2.0.52",
  "test-case",
  "thiserror",
 ]
 
 [[package]]
 name = "struqture-py-macros"
-version = "1.6.1"
+version = "2.0.0-alpha.0"
 dependencies = [
  "num-complex",
  "proc-macro2",
  "quote",
  "syn 2.0.52",
 ]
```

### Comparing `struqture_py-1.6.1/pyproject.toml` & `struqture_py-2.0.0a0/pyproject.toml`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 [project]
 name = "struqture-py"
-version = "1.6.1"
+version = "2.0.0-alpha.0"
 dependencies = [
   'numpy',
   'qoqo_calculator_pyo3>=1.1.2',
 ]
 license = {text="Apache-2.0 AND Apache-2.0 with LLVM-exception AND MIT AND Unicode-DFS-2016 AND BSD-2-Clause AND BSD-3-CLause"}
 maintainers = [{name = "HQS Quantum Simulations GmbH", email = "info@quantumsimulations.de"}]
 requires-python = ">=3.8"
```

### Comparing `struqture_py-1.6.1/struqture_py/DEPENDENCIES` & `struqture_py-2.0.0a0/struqture_py/DEPENDENCIES`

 * *Files identical despite different names*

### Comparing `struqture_py-1.6.1/struqture_py/PYTHON_LICENSE` & `struqture_py-2.0.0a0/struqture_py/PYTHON_LICENSE`

 * *Files identical despite different names*

### Comparing `struqture_py-1.6.1/PKG-INFO` & `struqture_py-2.0.0a0/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.3
 Name: struqture-py
-Version: 1.6.1
+Version: 2.0.0a0
 Requires-Dist: numpy
 Requires-Dist: qoqo-calculator-pyo3 >=1.1.2
 License-File: LICENSE
 Summary: Python interface of struqture, the HQS tool for representing operators, Hamiltonians and open systems.
 Author: HQS Quantum Simulations <info@quantumsimulations.de>
 Author-email: HQS Quantum Simulations <info@quantumsimulations.de>
 Maintainer-email: HQS Quantum Simulations GmbH <info@quantumsimulations.de>
@@ -25,15 +25,15 @@
 * Support for arbitrary spin, bosonic, fermionic and mixed systems
 * Full serialisation support to json and other formats
 * Preventing construction of unphysical objects by using well defined types for all objects in struqture
 * Support of symbolic values in operators, Hamiltonians and open systems
 
 Following these design goals, we prioritize using distinctive types to construct objects over a less verbose syntax.
 Similarly the support of symbolic expression leads to a trade-off in speed compared to an implementation using only floating point values.
-Struqture is designed to also support the construction and (de)serialisation of large systems but for the use in numeric algorithms we recommend transforming Operators and Hamiltonians into a sparse matrix form.
+Struqture is designed to also support the construction and (de)serialisation of large operators but for the use in numeric algorithms we recommend transforming Operators and Hamiltonians into a sparse matrix form.
 
 ## Documentation
 
 We recommend users to start with the [user documentation](https://hqsquantumsimulations.github.io/struqture/) for stuqture and struqture-py.
 The user documentation is intended to give a high level overview of the design and usage of struqture. For a full list of the available data types and functions see the API-Documentation of [struqture](https://docs.rs/struqture/) and [struqture-py](https://hqsquantumsimulations.github.io/struqture/pyapi/index.html).
 
 ## Installation
```

