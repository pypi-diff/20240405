# Comparing `tmp/seidart-0.0.19-cp311-cp311-manylinux_2_17_i686.manylinux2014_i686.whl.zip` & `tmp/seidart-0.0.9-cp311-cp311-manylinux_2_24_x86_64.whl.zip`

## zipinfo {}

```diff
@@ -1,37 +1,37 @@
-Zip file size: 1251360 bytes, number of entries: 35
-drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-04 21:28 seidart-0.0.19.dist-info/
-drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-04 21:28 seidart/
-drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-04 21:28 seidart.libs/
--rw-rw-r--  2.0 unx     2503 b- defN 24-Apr-04 21:28 seidart-0.0.19.dist-info/RECORD
--rw-r--r--  2.0 unx    44777 b- defN 24-Apr-04 21:28 seidart-0.0.19.dist-info/METADATA
--rw-r--r--  2.0 unx      148 b- defN 24-Apr-04 21:28 seidart-0.0.19.dist-info/WHEEL
--rw-r--r--  2.0 unx        8 b- defN 24-Apr-04 21:28 seidart-0.0.19.dist-info/top_level.txt
--rw-r--r--  2.0 unx    35149 b- defN 24-Apr-04 21:28 seidart-0.0.19.dist-info/LICENSE.txt
-drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-04 21:28 seidart/visualization/
-drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-04 21:28 seidart/fortran/
-drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-04 21:28 seidart/routines/
-drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-04 21:28 seidart/simulations/
--rw-r--r--  2.0 unx      100 b- defN 24-Apr-04 21:28 seidart/__init__.py
--rw-r--r--  2.0 unx     3959 b- defN 24-Apr-04 21:28 seidart/visualization/vtkbuild.py
--rw-r--r--  2.0 unx     5082 b- defN 24-Apr-04 21:28 seidart/visualization/im2anim.py
--rw-r--r--  2.0 unx     3764 b- defN 24-Apr-04 21:28 seidart/visualization/rcxdisplay.py
--rw-r--r--  2.0 unx    10931 b- defN 24-Apr-04 21:28 seidart/visualization/imgen.py
--rw-r--r--  2.0 unx     5014 b- defN 24-Apr-04 21:28 seidart/visualization/slice25d.py
--rw-r--r--  2.0 unx     1244 b- defN 24-Apr-04 21:28 seidart/visualization/implot.py
--rw-r--r--  2.0 unx     6094 b- defN 24-Apr-04 21:28 seidart/visualization/wiggleplot.py
--rw-r--r--  2.0 unx       16 b- defN 24-Apr-04 21:28 seidart/fortran/__init__.py
--rwxr-xr-x  2.0 unx   584781 b- defN 24-Apr-04 21:28 seidart/fortran/cpmlfdtd.cpython-311-i386-linux-gnu.so
--rw-r--r--  2.0 unx    33977 b- defN 24-Apr-04 21:28 seidart/routines/materials.py
--rw-r--r--  2.0 unx     9535 b- defN 24-Apr-04 21:28 seidart/routines/sourcefunction.py
--rw-r--r--  2.0 unx    21025 b- defN 24-Apr-04 21:28 seidart/routines/prjrun.py
--rw-r--r--  2.0 unx      224 b- defN 24-Apr-04 21:28 seidart/routines/__init__.py
--rw-r--r--  2.0 unx    16910 b- defN 24-Apr-04 21:28 seidart/routines/arraybuild.py
--rw-r--r--  2.0 unx     2816 b- defN 24-Apr-04 21:28 seidart/routines/orientation_tensor.py
--rw-r--r--  2.0 unx     9459 b- defN 24-Apr-04 21:28 seidart/routines/prjbuild.py
--rw-r--r--  2.0 unx    50433 b- defN 24-Apr-04 21:28 seidart/routines/definitions.py
--rw-r--r--  2.0 unx     2145 b- defN 24-Apr-04 21:28 seidart/routines/test_adaptive_mesh.py
--rw-r--r--  2.0 unx     1357 b- defN 24-Apr-04 21:28 seidart/simulations/common_offset.py
--rw-r--r--  2.0 unx        0 b- defN 24-Apr-04 21:28 seidart/simulations/__init__.py
--rwxr-xr-x  2.0 unx   362301 b- defN 24-Apr-04 21:28 seidart.libs/libquadmath-e2ac3af2.so.0.0.0
--rwxr-xr-x  2.0 unx  2491809 b- defN 24-Apr-04 21:28 seidart.libs/libgfortran-a8535147.so.5.0.0
-35 files, 3705561 bytes uncompressed, 1246576 bytes compressed:  66.4%
+Zip file size: 2473495 bytes, number of entries: 35
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-02 15:20 seidart/
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-02 15:20 seidart-0.0.9.dist-info/
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-02 15:20 seidart.libs/
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-02 15:20 seidart/fortran/
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-02 15:20 seidart/routines/
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-02 15:20 seidart/simulations/
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-02 15:20 seidart/visualization/
+-rw-r--r--  2.0 unx      100 b- defN 24-Apr-02 15:20 seidart/__init__.py
+-rw-r--r--  2.0 unx       16 b- defN 24-Apr-02 15:20 seidart/fortran/__init__.py
+-rwxr-xr-x  2.0 unx   527737 b- defN 24-Apr-02 15:20 seidart/fortran/cpmlfdtd.cpython-311-x86_64-linux-gnu.so
+-rw-r--r--  2.0 unx      224 b- defN 24-Apr-02 15:20 seidart/routines/__init__.py
+-rw-r--r--  2.0 unx    15149 b- defN 24-Apr-02 15:20 seidart/routines/arraybuild.py
+-rw-r--r--  2.0 unx    28906 b- defN 24-Apr-02 15:20 seidart/routines/definitions.py
+-rw-r--r--  2.0 unx    28134 b- defN 24-Apr-02 15:20 seidart/routines/materials.py
+-rw-r--r--  2.0 unx     2816 b- defN 24-Apr-02 15:20 seidart/routines/orientation_tensor.py
+-rw-r--r--  2.0 unx    10278 b- defN 24-Apr-02 15:20 seidart/routines/prjbuild.py
+-rw-r--r--  2.0 unx    15800 b- defN 24-Apr-02 15:20 seidart/routines/prjrun.py
+-rw-r--r--  2.0 unx     6527 b- defN 24-Apr-02 15:20 seidart/routines/sourcefunction.py
+-rw-r--r--  2.0 unx     2145 b- defN 24-Apr-02 15:20 seidart/routines/test_adaptive_mesh.py
+-rw-r--r--  2.0 unx        0 b- defN 24-Apr-02 15:20 seidart/simulations/__init__.py
+-rw-r--r--  2.0 unx     1357 b- defN 24-Apr-02 15:20 seidart/simulations/common_offset.py
+-rw-r--r--  2.0 unx     4062 b- defN 24-Apr-02 15:20 seidart/visualization/im2anim.py
+-rw-r--r--  2.0 unx    11224 b- defN 24-Apr-02 15:20 seidart/visualization/imgen.py
+-rw-r--r--  2.0 unx     1244 b- defN 24-Apr-02 15:20 seidart/visualization/implot.py
+-rw-r--r--  2.0 unx     3606 b- defN 24-Apr-02 15:20 seidart/visualization/rcxdisplay.py
+-rw-r--r--  2.0 unx     5014 b- defN 24-Apr-02 15:20 seidart/visualization/slice25d.py
+-rw-r--r--  2.0 unx     3959 b- defN 24-Apr-02 15:20 seidart/visualization/vtkbuild.py
+-rw-r--r--  2.0 unx     6094 b- defN 24-Apr-02 15:20 seidart/visualization/wiggleplot.py
+-rw-r--r--  2.0 unx    35149 b- defN 24-Apr-02 15:20 seidart-0.0.9.dist-info/LICENSE.txt
+-rw-r--r--  2.0 unx    49360 b- defN 24-Apr-02 15:20 seidart-0.0.9.dist-info/METADATA
+-rw-r--r--  2.0 unx      114 b- defN 24-Apr-02 15:20 seidart-0.0.9.dist-info/WHEEL
+-rw-r--r--  2.0 unx        8 b- defN 24-Apr-02 15:20 seidart-0.0.9.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2501 b- defN 24-Apr-02 15:20 seidart-0.0.9.dist-info/RECORD
+-rwxrwxr-x  2.0 unx  6986481 b- defN 24-Apr-02 15:20 seidart.libs/libgfortran-0a5141d4.so.5.0.0
+-rwxrwxr-x  2.0 unx   788369 b- defN 24-Apr-02 15:20 seidart.libs/libquadmath-7463de5d.so.0.0.0
+35 files, 8536374 bytes uncompressed, 2468719 bytes compressed:  71.1%
```

## zipnote {}

```diff
@@ -1,106 +1,106 @@
-Filename: seidart-0.0.19.dist-info/
+Filename: seidart/
 Comment: 
 
-Filename: seidart/
+Filename: seidart-0.0.9.dist-info/
 Comment: 
 
 Filename: seidart.libs/
 Comment: 
 
-Filename: seidart-0.0.19.dist-info/RECORD
+Filename: seidart/fortran/
 Comment: 
 
-Filename: seidart-0.0.19.dist-info/METADATA
+Filename: seidart/routines/
 Comment: 
 
-Filename: seidart-0.0.19.dist-info/WHEEL
+Filename: seidart/simulations/
 Comment: 
 
-Filename: seidart-0.0.19.dist-info/top_level.txt
+Filename: seidart/visualization/
 Comment: 
 
-Filename: seidart-0.0.19.dist-info/LICENSE.txt
+Filename: seidart/__init__.py
 Comment: 
 
-Filename: seidart/visualization/
+Filename: seidart/fortran/__init__.py
 Comment: 
 
-Filename: seidart/fortran/
+Filename: seidart/fortran/cpmlfdtd.cpython-311-x86_64-linux-gnu.so
 Comment: 
 
-Filename: seidart/routines/
+Filename: seidart/routines/__init__.py
 Comment: 
 
-Filename: seidart/simulations/
+Filename: seidart/routines/arraybuild.py
 Comment: 
 
-Filename: seidart/__init__.py
+Filename: seidart/routines/definitions.py
 Comment: 
 
-Filename: seidart/visualization/vtkbuild.py
+Filename: seidart/routines/materials.py
 Comment: 
 
-Filename: seidart/visualization/im2anim.py
+Filename: seidart/routines/orientation_tensor.py
 Comment: 
 
-Filename: seidart/visualization/rcxdisplay.py
+Filename: seidart/routines/prjbuild.py
 Comment: 
 
-Filename: seidart/visualization/imgen.py
+Filename: seidart/routines/prjrun.py
 Comment: 
 
-Filename: seidart/visualization/slice25d.py
+Filename: seidart/routines/sourcefunction.py
 Comment: 
 
-Filename: seidart/visualization/implot.py
+Filename: seidart/routines/test_adaptive_mesh.py
 Comment: 
 
-Filename: seidart/visualization/wiggleplot.py
+Filename: seidart/simulations/__init__.py
 Comment: 
 
-Filename: seidart/fortran/__init__.py
+Filename: seidart/simulations/common_offset.py
 Comment: 
 
-Filename: seidart/fortran/cpmlfdtd.cpython-311-i386-linux-gnu.so
+Filename: seidart/visualization/im2anim.py
 Comment: 
 
-Filename: seidart/routines/materials.py
+Filename: seidart/visualization/imgen.py
 Comment: 
 
-Filename: seidart/routines/sourcefunction.py
+Filename: seidart/visualization/implot.py
 Comment: 
 
-Filename: seidart/routines/prjrun.py
+Filename: seidart/visualization/rcxdisplay.py
 Comment: 
 
-Filename: seidart/routines/__init__.py
+Filename: seidart/visualization/slice25d.py
 Comment: 
 
-Filename: seidart/routines/arraybuild.py
+Filename: seidart/visualization/vtkbuild.py
 Comment: 
 
-Filename: seidart/routines/orientation_tensor.py
+Filename: seidart/visualization/wiggleplot.py
 Comment: 
 
-Filename: seidart/routines/prjbuild.py
+Filename: seidart-0.0.9.dist-info/LICENSE.txt
 Comment: 
 
-Filename: seidart/routines/definitions.py
+Filename: seidart-0.0.9.dist-info/METADATA
 Comment: 
 
-Filename: seidart/routines/test_adaptive_mesh.py
+Filename: seidart-0.0.9.dist-info/WHEEL
 Comment: 
 
-Filename: seidart/simulations/common_offset.py
+Filename: seidart-0.0.9.dist-info/top_level.txt
 Comment: 
 
-Filename: seidart/simulations/__init__.py
+Filename: seidart-0.0.9.dist-info/RECORD
 Comment: 
 
-Filename: seidart.libs/libquadmath-e2ac3af2.so.0.0.0
+Filename: seidart.libs/libgfortran-0a5141d4.so.5.0.0
 Comment: 
 
-Filename: seidart.libs/libgfortran-a8535147.so.5.0.0
+Filename: seidart.libs/libquadmath-7463de5d.so.0.0.0
 Comment: 
 
 Zip file comment:
```

## seidart/visualization/im2anim.py

```diff
@@ -8,26 +8,24 @@
 from glob2 import glob
 import argparse
 import matplotlib.pyplot as plt
 import matplotlib.image as mpimg
 from scipy.io import FortranFile
 from seidart.visualization.imgen import *
 import os
-import subprocess
 
 # =============================================================================
 def build_animation(
         prjfile, 
         channel, 
         delay, 
         numsteps, 
         alpha, 
         is_complex: bool = False,
-        is_single_precision: bool = True,
-        plottype: str = 'magnitude'
+        is_single_precision: bool = True
     ):
     '''
     '''
     # Check if the .dat files are still around
     files = glob(channel + '*.dat')
     files.sort()
 
@@ -35,16 +33,15 @@
     n=numsteps
 
     for fn in files:
         if n == numsteps:
             mag = FDTDImage(
                 prjfile, fn, 
                 is_complex = is_complex, 
-                is_single_precision = is_single_precision,
-                plottype = plottype
+                is_single_precision = is_single_precision
             )
             mag.magnitudeplot(alpha = alpha)
             mag.addlabels()
             mag.plotfile = 'magnitude.' + fn[:-3] + '.png'
             plt.savefig(mag.plotfile)
             plt.close()
             n = 1
@@ -53,15 +50,15 @@
 
 
     print('Creating the GIF')
     # Use imagemagick via shell command to create the gif
     shellcommand = 'convert -delay ' + \
         str(delay) + ' -loop 0 magnitude.' + channel + '*.png ' + \
             channel + '.gif'
-    subprocess.call(shellcommand, shell = True)
+    call(shellcommand, shell = True)
 
     # Remove the png files 
     for filepath in glob('magnitude.' + channel + '*.png'):
         os.remove(filepath)
         
 
 # -------------------------- Command Line Arguments ---------------------------
@@ -112,52 +109,17 @@
     )
     
     parser.add_argument(
         '-z', '--is_complex', action = 'store_true', required = False,
         help = """Flag whether the data will be complex valued. If the data is
         not flagged but is complex, only the real data will be returned. """
     )
-    
-    parser.add_argument(
-        '-D', '--is_double_precision', action = 'store_false', required = False,
-        help = """Flag whether the data is in double precision."""
-    )
-    
-    parser.add_argument(
-        '-P', '--plot_type', required = False, default = ['magnitude'], 
-        nargs = 1, type = str, 
-        help = """
-        Plot types are different for EM and seismic. Valid inputs are: 
-        
-        EM
-        --    
-            'magnitude', 
-            'phase' (complex only), 
-            'energy_density (complex only)'
-        Seismic
-        -------
-            'magnitude',
-            'quiver'
-        """
-    )
 
     # Get the arguments
     args = parser.parse_args()
     prjfile = ''.join(args.prjfile)
     channel = ''.join(args.channel)
     delay = str(args.delay[0])
     num_steps = args.num_steps[0]
     alpha = min([1, args.alpha[0]] )
     is_complex = args.is_complex
-    is_single_precision = args.is_single_precision
-    plot_type = args.plot_type[0]
-    
-    build_animation(
-        prjfile, 
-        channel, 
-        delay, 
-        numsteps, 
-        alpha, 
-        is_complex,
-        is_single_precision,
-        plot_type
-    )
+
```

## seidart/visualization/rcxdisplay.py

```diff
@@ -13,124 +13,126 @@
 import argparse
 import matplotlib
 matplotlib.use('TkAgg')
 import matplotlib.pyplot as plt
 import matplotlib.image as mpimg
 from seidart.routines.definitions import *
 
-def main(
-        prjfile: str, 
-        cofile: str, 
-        gain: int, 
-        exaggeration: float, 
-        is_seismic: bool
-    ) -> None:
-    # -----------------------------------------------------------------------------
-    # Load the values from the project file
-    domain, material, seismic, electromag = loadproject(
-        prjfile,
-        Domain(),
-        Material(),
-        Model(),
-        Model()
-    )
-
-    # Open the csv containing time series values
-    dat = np.genfromtxt(cofile, delimiter = ',')
-    m,n = dat.shape
-
-    if is_seismic:
-        mult = 1e2
-    else:
-        mult = 1e6
-
-    timelocs = np.arange(0, m, int(m/10) ) # 10 tick marks along y-axis
-    rcxlocs = np.arange(0, n, int(n/5) ) # 5 tick marks along x-axis
-
-
-    if is_seismic:
-        timevals = np.round(timelocs*float(seismic.dt) * mult, 2)
-    else:
-        timevals = np.round(timelocs*float(electromag.dt) * mult, 2)
-
-    if gain == 0:
-        gain = 1
-    elif gain < m:
-        for j in range(0, n):
-            # Subtract the mean value
-            # dat[:,j] = dat[:,j] - np.mean(dat[:,j])
-            dat[:,j] = agc(dat[:,j], gain, "mean")
-    else:
-        gain = m
-
-
-    fig = plt.figure()#figsize =(n/2,m/2) )
-    ax1 = plt.gca()
-    # ax2 = ax1.twinx()
-
-    ax1.imshow(dat, cmap = 'Greys', aspect = 'auto')
-    ax1.set_xlabel(r'Receiver #')
-    ax1.xaxis.tick_top()
-    ax1.xaxis.set_label_position('top')
-    ax1.set_xticks(rcxlocs)
-    ax1.set_xticklabels(rcxlocs)
-    ax1.set_ylabel(r'Two-way Travel Time (s)')
-    ax1.set_yticks(timelocs)
-    ax1.set_yticklabels(timevals)
-
-    # Other figure handle operations
-    ax1.set_aspect(aspect = exaggeration)
-
-    if is_seismic:
-        ax1.text(0, m + 0.03*m, 'x $10^{-2}$')
-    else:
-        ax1.text(0, m + 0.03*m, 'x $10^{-6}$')
-
-    ax1.update_datalim( ((0,0),(m, n)))
-    plt.show()
-
-
-if __name__ == "__main__":
-    # -------------------------- Command Line Arguments ---------------------------
-    parser = argparse.ArgumentParser(
-        description="""Plots a csv file of timeseries data (columns) for targeted receivers """ )
-
-    parser.add_argument(
-        '-p', '--prjfile',
-        nargs = 1, type = str, required = True,
-        help = """Path to the project file."""
-    )
-
-    parser.add_argument(
-        '-f', '--file',
-        nargs=1, type=str, required=True,
-        help="""Path to the csv file with receiver timeseries data"""
-    )
-
-    parser.add_argument(
-        '-g', '--gain',
-        nargs = 1, type = float, required = False, default = [100],
-        help = "The smoothing length"
-    )
-
-    parser.add_argument(
-        '-e', '--exaggeration',
-        nargs=1, type = float, required = False, default = [0.5],
-        help = """Set the aspect ratio between the x and y axes for
-        plotting. Default is 0.5"""
-    )
-
-    parser.add_argument(
-        '-s', '--seismic',
-        action = 'store_true', required = False,
-        help = """Flag whether this is a seismic or electromagnetic model"""
-    )
-
-    # -----------------------
-    args = parser.parse_args()
-    prjfile = ''.join(args.prjfile)
-    cofile = ''.join(args.file)
-    gain = args.gain[0]
-    exaggeration = args.exaggeration[0]
-    is_seismic = args.seismic
-    
-    main(prjfile, cofile, gain, exaggeration, is_seismic)
+# -------------------------- Command Line Arguments ---------------------------
+parser = argparse.ArgumentParser(
+    description="""Plots a csv file of timeseries data (columns) for targeted receivers """ )
+
+parser.add_argument(
+    '-p', '--prjfile',
+    nargs = 1, type = str, required = True,
+    help = """Path to the project file."""
+)
+
+parser.add_argument(
+    '-f', '--file',
+    nargs=1, type=str, required=True,
+    help="""Path to the csv file with receiver timeseries data"""
+)
+
+parser.add_argument(
+    '-g', '--gain',
+    nargs = 1, type = float, required = False, default = [100],
+    help = "The smoothing length"
+)
+
+parser.add_argument(
+    '-e', '--exaggeration',
+    nargs=1, type = float, required = False, default = [0.5],
+	  help = """Set the aspect ratio between the x and y axes for
+    plotting. Default is 0.5"""
+)
+
+#parser.add_argument(
+#    '-r', '--receiver',
+#    nargs = 1, type = str, required = True,
+#    help = """The csv file path that contains the receiver locations"""
+#)
+parser.add_argument(
+    '-s', '--seismic',
+    action = 'store_true', required = False,
+    help = """Flag whether this is a seismic or electromagnetic model"""
+)
+
+#parser.add_argument(
+#    '-t', '--surveytype',
+#    nargs = 1, type = str, required = True,
+#    help = """The type of survey that you are plotting. The available options
+#    are: war, co, cmp. The correspond to wide angle, common offset, and common
+#    midpoint, respectively."""
+#)
+
+
+args = parser.parse_args()
+prjfile = ''.join(args.prjfile)
+cofile = ''.join(args.file)
+gain = args.gain[0]
+exaggeration = args.exaggeration[0]
+is_seismic = args.seismic
+
+# -----------------------------------------------------------------------------
+# Load the values from the project file
+domain, material, seismic, electromag = loadproject(
+    prjfile,
+    Domain(),
+    Material(),
+    Model(),
+    Model()
+)
+
+# Open the csv containing time series values
+dat = np.genfromtxt(cofile, delimiter = ',')
+m,n = dat.shape
+
+if is_seismic:
+    mult = 1e2
+else:
+    mult = 1e6
+
+timelocs = np.arange(0, m, int(m/10) ) # 10 tick marks along y-axis
+rcxlocs = np.arange(0, n, int(n/5) ) # 5 tick marks along x-axis
+
+
+if is_seismic:
+    timevals = np.round(timelocs*float(seismic.dt) * mult, 2)
+else:
+    timevals = np.round(timelocs*float(electromag.dt) * mult, 2)
+
+if gain == 0:
+    gain = 1
+elif gain < m:
+    for j in range(0, n):
+        # Subtract the mean value
+        # dat[:,j] = dat[:,j] - np.mean(dat[:,j])
+        dat[:,j] = agc(dat[:,j], gain, "mean")
+else:
+    gain = m
+
+
+fig = plt.figure()#figsize =(n/2,m/2) )
+ax1 = plt.gca()
+# ax2 = ax1.twinx()
+
+ax1.imshow(dat, cmap = 'Greys', aspect = 'auto')
+ax1.set_xlabel(r'Receiver #')
+ax1.xaxis.tick_top()
+ax1.xaxis.set_label_position('top')
+ax1.set_xticks(rcxlocs)
+ax1.set_xticklabels(rcxlocs)
+ax1.set_ylabel(r'Two-way Travel Time (s)')
+ax1.set_yticks(timelocs)
+ax1.set_yticklabels(timevals)
+
+# Other figure handle operations
+ax1.set_aspect(aspect = exaggeration)
+
+if is_seismic:
+	ax1.text(0, m + 0.03*m, 'x $10^{-2}$')
+else:
+	ax1.text(0, m + 0.03*m, 'x $10^{-6}$')
+
+ax1.update_datalim( ((0,0),(m, n)))
+plt.show()
```

## seidart/visualization/imgen.py

```diff
@@ -345,7 +345,16 @@
             linewidths = 1,
             edgecolor = (0.2, 0.2, 0.2, 1 ) 
         )
 
     def addrcx(self):
         pass 
     
+    
+# =============================================================================
+# def datinput(fn, nx, nz):
+#     # Get the U,V components; the velocity values
+#     f = FortranFile(fn, 'r')
+#     dat = f.read_reals(dtype = 'float32')
+#     dat = dat.reshape(nz, nx)
+#     return(dat)
+
```

## seidart/routines/materials.py

```diff
@@ -1,33 +1,35 @@
+#!/usr/bin/env python3
+# -*- coding: utf-8 -*-
+"""
+Created by Steven Bernsen
+We are given a range of velocities of different materials found empirically. 
+For isotropic materials we can determine the Lame constants from the equations:
+    Vp = sqrt( lambda + 2 mu  / rho ),
+    Vs = sqrt( mu / rho ),
+    c11 = c22 = c33 = lambda + 2 mu,
+    c12 = c13 = c23 = lambda,
+    c44 = c55 = c66 = mu
+"""
+
 import numpy as np
 from typing import Union, Tuple
 from scipy.interpolate import interp1d
 
-__all__ = [
-    'pressure_array',
-    'anisotropic_boolean',
-    'get_seismic',
-    'get_perm',
-    'rho_water_correction',
-    'isotropic_stiffness_tensor',
-    'isotropic_permittivity_tensor',
-    'porewater_correction',
-    'ice_stiffness',
-    'ice_permittivity',
-    'snow_permittivity',
-    'snow_conductivity',
-    'read_ang',
-    'rotator_zxz',
-    'bond',
-    'fujita_complex_permittivity'
-]
-
-# Global constants
 eps0 = 8.85418782e-12 # used for em only
 mu0 = 4.0*np.pi*1.0e-7 # used for em only
+# =============================================================================
+#                               Class Variables
+# =============================================================================
+
+
+
+# =============================================================================
+#                       Define material dictionaries
+# =============================================================================
 
 """
 Seismic values can be found in: 
       Acoustics of Porous Media (1992), Bourbie, Coussy, and Zinszner
       
 Permittivity values can be found in:
         Electrical Properties of Rocks and Minerals
@@ -41,29 +43,16 @@
     Values are: 
         Vp_min, Vp_max, Vs_min, Vs_max, Rel_Perm_min, Rel_Perm_max, Conductivity_min, Conductivity_max
     
     Permittivity is given as the relative permittivity and for most cases we 
     will assume that relative permeability is unity; however, if we include
     materials that are high in magnetite, hematite, etc. then we will need to
     accomodate for better permeability estimates.
-    
-    We are given a range of velocities of different materials found empirically. 
-    For isotropic materials we can determine the Lame constants from the equations:
-        Vp = sqrt( lambda + 2 mu  / rho ),
-        Vs = sqrt( mu / rho ),
-        c11 = c22 = c33 = lambda + 2 mu,
-        c12 = c13 = c23 = lambda,
-        c44 = c55 = c66 = mu
-        
-    Created by Steven Bernsen
 """
 
-# =============================================================================
-#                       Define material dictionaries
-# =============================================================================
 
 isotropic_materials = {
     "air":np.array([343, 343, 0.0, 0.0, 1.0, 1.0, 1.0e-16, 1.0e-15]),
     "ice1h":np.array([3400, 3800, 1700, 1900, 3.1, 3.22, 1.0e-7, 1.0e-6]),
     "snow":np.array([100, 2000, 50, 500, 1.0, 70, 1.0e-9, 1.0e-4]),
     "soil":np.array([300, 700, 100, 300, 3.9, 29.4, 1.0e-2, 1.0e-1]), # Permittivity estimates are best constructed with the snow_permittivity() function
     "water":np.array([1450, 1500, 0, 0, 80.36, 80.36, 5.5e-6, 5.0e-2]), # This can change drastically depending on the ions in solution
@@ -74,50 +63,52 @@
     "gneiss":np.array([4400, 5200, 2700, 3200, 8.5, 8.5, 2.5e-4, 2.5e-3]),
     "basalt":np.array([5000, 6000, 2800, 3400, 12, 12, 1.0e-6, 1.0e-4]),
     "limestone":np.array([3500, 6000, 2000, 3300, 7.8, 8.5, 2.5e-4, 1.0e-3]),
     "anhydrite":np.array([4000, 5500, 2200, 3100, 5, 11.5, 1.0e-6, 1.0e-5]), # permittivity value from Gypsum
     "coal":np.array([2200, 2700, 1000, 1400, 5.6, 6.3, 1.0e-8, 1.0e-3]), # This has a water dependency
     "salt":np.array([4500, 5500, 2500, 3100, 5.6, 5.6, 1.0e-7, 1.0e2]) # This is dependent on ions and water content
 }
-# =============================================================================
-#                                  Functions
-# =============================================================================
+
 
 # -----------------------------------------------------------------------------
 def pressure_array(
         im: Union[list, np.ndarray], 
         temp: Union[list, np.ndarray], 
         rho: Union[list, np.ndarray], 
         dz: Union[list, np.ndarray], 
         porosity: Union[list, np.ndarray] = [0], 
         lwc: Union[list, np.ndarray] = [0]
-    ) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
-    """
-    Computes the hydrostatic pressure, temperature, and density at each grid 
-    point based on material ID, accounting for porosity and water content.
-
-    :param im: An m-by-n array of integer values representing material IDs.
-    :param temp: Temperatures at each grid point.
-    :param rho: Densities at each grid point.
-    :param dz: Vertical spacing between grid points.
-    :param porosity: Porosities at each grid point, default is a list of zeros.
-    :param lwc: Liquid water contents at each grid point, default is a list 
-        of zeros.
-    :type im: Union[list, np.ndarray]
-    :type temp: Union[list, np.ndarray]
-    :type rho: Union[list, np.ndarray]
-    :type dz: Union[list, np.ndarray]
-    :type porosity: Union[list, np.ndarray], optional
-    :type lwc: Union[list, np.ndarray], optional
-    :return: A tuple containing arrays for temperature, density, and hydrostatic 
-        pressure at each grid point.
-    :rtype: Tuple[np.ndarray, np.ndarray, np.ndarray]
-    """
+    ) -> Tuple[np.ndarray, np.ndarray, np.ndarray]: 
+    '''
+    Compute the hydrostatic pressure for each grid point and correct the 
+    stiffness matrix to reflect this. The hydrostatic pressure is computed
+    using the overburden P = rho * g * h, but rho is not assumed to be
+    constant. This is a lower order approximation and doesn't include external
+    stress and dynamics. 
+
+    temp and rho are k-by-1 indices
 
+    :param im: an m-by-n array of integer values corresponding to the material
+        ID. 
+    :type im: list or np.ndarray 
 
+    :param temp:  
+    :type : 
+
+    :return temperature:
+    :rtype temperature: np.ndarray
+
+    :return density: 
+    :rtype density: np.ndarray
+
+    :return pressure:
+    :rtype pressure: np.ndarray
+
+    '''
+    
     # First match the size of 
     k = np.unique(im)
 
     m, n = im.shape
     # allocate the pressure, temperature and density
     pressure = np.zeros([m, n])
     density = np.zeros([m, n])
@@ -129,35 +120,32 @@
             temperature[i,j] = temp[ im[i,j] ]
             density[i,j],_,_ = porewater_correction(temperature[i,j], rho[ im[i,j] ], 
                 porosity[ im[i,j]], lwc[ im[i,j]])
             pressure[i,j] = np.mean(density[0:i,j]) * 9.80665 * i * dz
     
     return(temperature, density, pressure)
 
-# -----------------------------------------------------------------------------
-def anisotropic_boolean(
-        im: Union[np.ndarray, list], 
-        matbool: Union[np.ndarray, list], 
-        angvect: Union[np.ndarray, list]
-    ) -> Tuple[np.ndarray, np.ndarray]:
-    """
-    Determines if materials identified in an image are anisotropic and provides
-    corresponding angular file names if applicable.
-
-    :param im: An array representing material IDs in an image.
-    :param matbool: Array indicating whether a material is anisotropic.
-    :param angvect: Array of angular file names for anisotropic materials.
-    :type im: Union[np.ndarray, list]
-    :type matbool: Union[np.ndarray, list]
-    :type angvect: Union[np.ndarray, list]
-    :return: A tuple of two arrays; the first indicates anisotropy (boolean), 
-        the second contains angular file names.
-    :rtype: Tuple[np.ndarray, np.ndarray]
-    """
 
+def anisotropic_boolean(im, matbool, angvect):
+    '''
+    :param :  Union[list, np.ndarray]
+    :type : 
+
+    :param :  
+    :type : 
+
+    :param :  
+    :type : 
+
+    :return :
+    :rtype :
+
+    :return :
+    :rtype :
+    '''
     m,n = im.shape
     anisotropic = np.zeros([m,n], dtype = bool)
     afile = np.zeros([m,n], dtype = str)
 
     for i in range(0, m):
         for j in range(0,n):
 
@@ -169,69 +157,75 @@
             )
             
             if anisotropic[i,j]:
                 afile[i,j] = angvect[ im[i,j] ]
 
     return(anisotropic, afile)
 
+# =============================================================================
 # -----------------------------------------------------------------------------
 def get_seismic(
         material_name: Union[list, np.ndarray] = [None], 
         temp: Union[list, np.ndarray] = [None], 
         rho: Union[list, np.ndarray] = [None], 
         porosity: Union[list, np.ndarray] = [0], 
         lwc: Union[list, np.ndarray] = [0], 
         anisotropic: Union[list, np.ndarray] = [False], 
         angfile: Union[list, np.ndarray] = [None]
-    ) -> np.ndarray:
-    """
-    Calculates seismic stiffness coefficients based on material properties,
-    accounting for anisotropic conditions where applicable.
-
-    :param material_name: Names of materials.
-    :param temp: Temperatures associated with each material.
-    :param rho: Densities of materials.
-    :param porosity: Porosities of materials.
-    :param lwc: Liquid water contents of materials.
-    :param anisotropic: Indicates if materials are anisotropic.
-    :param angfile: Angular files associated with anisotropic materials.
-    :type material_name: Union[list, np.ndarray], optional
-    :type temp: Union[list, np.ndarray], optional
-    :type rho: Union[list, np.ndarray], optional
-    :type porosity: Union[list, np.ndarray], optional
-    :type lwc: Union[list, np.ndarray], optional
-    :type anisotropic: Union[list, np.ndarray], optional
-    :type angfile: Union[list, np.ndarray], optional
-    :return: A tensor containing seismic stiffness coefficients.
-    :rtype: np.ndarray
-    """
+    ):
+    '''
+    Compute the seismic stiffness coefficients given the temperature, percent
+    pore space, and water content. Anisotropic files will be flagged by the 
+    boolean, and an angular file needs to be included. A single material can be
+    computed or an array of materials. If an array is input, the length of each 
+    parameter must match. For an anisotropic material, the tensor values are 
+    calculated from the Hill estimate.
+    
+    Parameters
+    ----------
+    :param material_name: the string identifier of the material
+    :type material_name: list or np.ndarray
+
+    :param temp: The temperature of the material. 
+    :type temp: list or np.array
+
+    :param rho: The density of the material.
+    :type rho: list or np.array
+
+    :param porosity: the percent value for the porosity of the material
+    :type porosity: list or np.array
+
+    :param lwc: the percent value for liquid water content
+    :type lwc: list or np.array
+
+    :param anisotropic: A list or array of boolean values. If False, the 
+        isotropic stiffness tensor is computed
+    :type anisotropic: list or np.array
+
+    :return tensor: An m-by-23 array of the material ID, the 21 tensor
+        components of the upper triangular of the Voigt notation 
+    :rtype tensor: np.ndarray
 
+    '''
     m = len(temp)
     tensor = np.zeros([m, 23])
 
-    # Adjust the stiffness tensor according to the pressure and temperature 
-    # conditions for ice
+    # Adjust the stiffness tensor according to the pressure and temperature conditions for ice
     for ind in range(0, m):
-        density,_,_ = porewater_correction(
-            temp[ind], 
-            rho[ind], 
-            porosity[ind], 
-            lwc[ind] 
-        )
+        density,_,_ = porewater_correction(temp[ind], rho[ind], porosity[ind], lwc[ind] )
 
         if anisotropic[ind] and material_name[ind] == 'ice1h':
             euler = read_ang(angfile[ind])
             p = len(euler[:,0])
 
             cvoigt = np.zeros([6,6])
             creuss = np.zeros([6,6])
             C = np.zeros([6,6])
             
-            # Assume a constant pressure of 0.1 MPa (Why? because this is 
-            # approximately 1 ATM)
+            # Assume a constant pressure of 0.1 MPa (Why? because this is approximately 1 ATM)
             C = ice_stiffness(temp[ind], 0.1)
             S = np.linalg.inv(C)
 
             for k in range(0, p):
                 R = rotator_zxz(euler[k,:] )
                 M = bond(R)
                 N = np.linalg.inv(M)
@@ -259,79 +253,75 @@
             C[4,4], C[4,5],
             C[5,5], 
             density
         )
 
     return(tensor)
 
+
 # -----------------------------------------------------------------------------
 def get_perm(
-        material,
+        matclass,
         modelclass
-    ) -> np.ndarray:
-    """
-    Computes the permittivity and conductivity tensors for materials based on attributes
-    contained within material and model class instances.
-
-    :param material: An instance of a class containing attributes for materials, including
-                     temperature, density, porosity, water content, and anisotropic properties.
-    :type material: Material
-    :param modelclass: An instance of a class containing modeling parameters, such as the
-                       frequency of interest for electromagnetic modeling.
-    :type modelclass: Model
-    :return: A tensor array containing permittivity and conductivity values for each material.
-    :rtype: np.ndarray
-    """
-
+    ):
+    '''
+    Compute the permittivity and conductivity tensors for a material and its
+    attributes
+    :param :  
+    :type : 
+
+    :return :
+    :rtype :
+    '''
     #!!!!! Use the material class as an input since it will have all of the values that you need instead of inputting all of them 
-    material.temp
+    matclass.temp
     
-    m = len(material.temp)
+    m = len(matclass.temp)
     # We will always compute the complex tensor. 
     tensor = np.zeros([m, 13], dtype = complex)
     
     # Adjust the stiffness tensor according to the pressure and temperature 
     # conditions for ice
     for ind in range(0, m):
         
-        if material.material[ind] == 'ice1h':
+        if matclass.material[ind] == 'ice1h':
             permittivity = ice_permittivity(
-                material.temp[ind],
-                material.density[ind],
+                matclass.temp[ind],
+                matclass.density[ind],
                 center_frequency = modelclass.f0
             )
             conductivity = snow_conductivity(
                 permittivity = permittivity, frequency = modelclass.f0
             )
             
-        elif material.material[ind] == 'snow':
+        elif matclass.material[ind] == 'snow':
             permittivity = snow_permittivity(
-                temperature = material.temp[ind],
-                lwc = material.lwc[ind], 
-                porosity = material.porosity[ind]
+                temperature = matclass.temp[ind],
+                lwc = matclass.lwc[ind], 
+                porosity = matclass.porosity[ind]
             )
             conductivity = snow_conductivity(
                 permittivity = permittivity, frequency = modelclass.f0
             )
         else:
             permittivity = np.round(
                 isotropic_permittivity_tensor(
-                    material.temp[ind], 
-                    material.porosity[ind], 
-                    material.lwc[ind], 
-                    material.material[ind])[0], 
+                    matclass.temp[ind], 
+                    matclass.porosity[ind], 
+                    matclass.lwc[ind], 
+                    matclass.material[ind])[0], 
                     3
                 )
             conductivity = isotropic_permittivity_tensor(
-                material.temp[ind], 
-                material.porosity[ind], 
-                material.lwc[ind], material.material[ind]
+                matclass.temp[ind], 
+                matclass.porosity[ind], 
+                matclass.lwc[ind], matclass.material[ind]
             )[1]
         
-        if material.is_anisotropic[ind]:
+        if matclass.is_anisotropic[ind]:
             euler = read_ang(angfile[ind])
             p = len(euler[:,0])
             
             pvoigt = np.zeros([3,3])
             preuss = np.zeros([3,3])
             permittivity = np.zeros([3,3])
             
@@ -364,58 +354,43 @@
                 conductivity[1,1], conductivity[1,2],
                 conductivity[2,2]
             ] 
         )
     
     return(tensor)
 
+
 # -----------------------------------------------------------------------------
-def rho_water_correction(temperature: float = 0.0) -> float:
-    """
-    Corrects the density of water based on temperature using the empirical 
-    formula derived from the Kell equation.
-
-    :param temperature: The temperature at which to compute the water density 
-        correction.
-    :type temperature: float
-    :return: The corrected water density.
-    :rtype: float
-    """
+# =============================================================================
+def rho_water_correction(temperature = 0):
     rho_water = (
         999.83952 + \
             16.945176 * temperature - \
                 7.9870401e-3 * temperature**2 - \
                     46.170461e-6 * temperature**3 + \
                         105.56302e-9 * temperature**4 - \
                             280.54253e-12 * temperature**5
         )/(1 + 16.897850e-3 * temperature)
     return(rho_water)
 
-# -----------------------------------------------------------------------------
-def isotropic_stiffness_tensor(
-        pressure: float, 
-        density: float, 
-        material_limits: np.ndarray
-        ) -> np.ndarray:
-    """
-    Computes the isotropic stiffness tensor for a given material based on 
-    pressure, density, and predefined material properties.
-
-    :param pressure: The hydrostatic pressure to which the material is 
-        subjected.
-    :param density: The density of the material.
-    :param material_limits: An array containing the material's velocity limits 
-        and other relevant properties.
-    :type pressure: float
-    :type density: float
-    :type material_limits: np.ndarray
-    :return: The isotropic stiffness tensor for the material.
-    :rtype: np.ndarray
-    """
-
+def isotropic_stiffness_tensor(pressure, density, material_limits):
+    '''
+    Compute the isotropic stiffness tensor using values from the 
+    'isotropic_materials' dictionary. The dictionary of values provides general
+    set of p and s wave values which are then used to compute the stiffness 
+    tensor. See the header for more details on the source of those values. 
+
+    Parameters
+    ----------
+    :param :  
+    :type : 
+
+    :return :
+    :rtype :
+    '''
     Vp = material_limits[0:2]
     Vs = material_limits[2:4]
     cp = 2*(Vp[1] - Vp[0])/np.pi 
     cs = 2*(Vs[1] - Vs[0])/np.pi
     
     # Correct for pressure
     pvelocity = cp*np.arctan(pressure ) + Vp[0]
@@ -433,35 +408,42 @@
     C[1,1]= C[1,1] + mu
     C[2,2] = C[2,2] + mu
 
     return(C)
 
 # -----------------------------------------------------------------------------
 def isotropic_permittivity_tensor(
-        temperature: float, 
-        porosity: float, 
-        water_content: float, 
-        material_name: str
-    ) -> Tuple[np.ndarray, np.ndarray]:
-    """
-    Computes the isotropic permittivity tensor for a material based on 
-    temperature, porosity, water content, and the material's inherent properties.
-
-    :param temperature: The temperature of the material.
-    :param porosity: The porosity of the material.
-    :param water_content: The water content in the material.
-    :param material_name: The name of the material.
-    :type temperature: float
-    :type porosity: float
-    :type water_content: float
-    :type material_name: str
-    :return: A tuple containing the permittivity and conductivity tensors.
-    :rtype: Tuple[np.ndarray, np.ndarray]
-    """
-
+        temperature, 
+        porosity, 
+        water_content, 
+        material_name
+    ):
+    '''
+    Compute the isotropic permittivity tensor using values from the 
+    'isotropic_materials' dictionary. The dictionary of values provides general
+    relative permittivity values which are then used to compute the 
+    permittivity tensor.
+    
+    Parameters
+    ----------
+    :param temperature:  
+    :type temperature: 
+
+    :param porosity:  
+    :type porosity:
+
+    :param liquid_water_content:  
+    :type liquid_water_content:
+
+    :param material_name:  
+    :type material_name:
+
+    :return :
+    :rtype :
+    '''
     material_limits = isotropic_materials[ material_name ]
     perm0 = material_limits[4]
     perm1 = material_limits[5]
 
     cond0 = material_limits[6]
     cond1 = material_limits[7]
 
@@ -499,79 +481,74 @@
         cond_coef = (cond1 - cond0)/3
         permittivity = np.eye(3,3) * (perm_coef*(porosity) + perm0)
         conductivity = np.eye(3,3) * (cond_coef*(porosity) + cond0)
     
     return(permittivity, conductivity)
 
 # -----------------------------------------------------------------------------
-def porewater_correction(
-        temperature: float, 
-        density: float, 
-        porosity: float, 
-        liquid_water_content: float
-    ) -> Tuple[float, float, float]:
-    """
-    Applies corrections to the bulk density of a material based on its porosity 
-    and water content, considering temperature adjustments to the densities of 
-    air and water.
-
-    :param temperature: The temperature of the material.
-    :param density: The initial density of the material.
-    :param porosity: The porosity percentage of the material.
-    :param liquid_water_content: The percentage of the pore space filled with 
-        water.
-    :type temperature: float
-    :type density: float
-    :type porosity: float
-    :type liquid_water_content: float
-    :return: A tuple containing the corrected density, the density contribution 
-        from air, and the density contribution from water.
-    :rtype: Tuple[float, float, float]
-    """
-
+def porewater_correction(temperature, density, porosity, liquid_water_content ):
+    '''
+    Correct the bulk density given the amount of pore water content. The 
+    water and air density are corrected given the temperature. The porosity 
+    should already be incorporated in the material density, but we are 
+    calculating the volumetric fractions of pore density and rock density
+    
+    Parameters
+    ----------
+    :param temperature:  
+    :type temperature:
+
+    :param density:  
+    :type density:
+
+    :param porosity:  
+    :type porosity: 
+
+    :param liquid_water_content:  
+    :type liquid_water_content:
+
+    :return :
+    :rtype :
+    '''
     rho_air = 0.02897/(8.2057338e-5 * (273 + temperature) )
     # Kell Equation; This doesn't incorporate pressure. That would be a nice
     # addition so that we can mimic super cooled water at depth. 
     rho_water = rho_water_correction(temperature)
     
     # rho_water = -4.6074e-7*temperature**4 + \
     #   1.0326e-4*temperature**3 - 1.0833e-2*temperature**2 + \
     #       9.4207e-2*temperature**1 + 999.998
 
-    # There are certain limits such as phase changes so let's put practical 
-    # limits on this
+    # There are certain limits such as phase changes so let's put practical limits on this
     rho_water = np.max( (rho_water, 950) ) # We can't quite accomodate supercooled water density
     rho_water = np.min( (rho_water, rho_water_correction() )) # beyond the freezing and vaporization temperatures, things get wonky
     
     # the water content is the percent of pores that contain water
     grams_air = (1-liquid_water_content/100)*rho_air
     grams_water = (liquid_water_content/100)*rho_water
     rho_wc = grams_air + grams_water
         
     density = (1-porosity/100)*density + (porosity/100)*rho_wc
 
     return(density, grams_air, grams_water)
 
 # -----------------------------------------------------------------------------
-def ice_stiffness(
-        temperature: float = None, 
-        pressure: float = 0.0
-    ) -> np.ndarray:
-    """
-    Computes the stiffness tensor for ice under specified temperature and 
-    pressure conditions based on empirical relationships.
-
-    :param temperature: The temperature at which to compute the stiffness tensor.
-    :param pressure: The pressure at which to compute the stiffness tensor.
-    :type temperature: float, optional
-    :type pressure: float
-    :return: The stiffness tensor for ice.
-    :rtype: np.ndarray
-    """
+def ice_stiffness(temperature = None, pressure = 0) :
+    '''
+    This equation is from G
 
+    
+    Parameters
+    ----------
+    :param :  
+    :type : 
+
+    :return :
+    :rtype :
+    '''
     # Allocate space for the stiffness tensor
     C = np.zeros([6,6])
     
     C[0,0] = 136.813 - 0.28940*temperature - 0.00178270*(temperature**2) \
       + 4.6648*pressure - 0.13501*(pressure**2) 
     C[0,1] = 69.4200 - 0.14673*temperature - 0.00090362*(temperature**2) \
       + 5.0743*pressure + .085917*(pressure**2)
@@ -592,36 +569,30 @@
     C[5,5] = (C[0,0] - C[0,1] )/2
     
     stiffness = C*1e8
 
     return(stiffness)
 
 # -----------------------------------------------------------------------------
+
 def ice_permittivity(
-        temperature: float, 
-        density: float, 
-        center_frequency: float = None,
-        method: str = "fujita"
-    ) -> np.ndarray:
-    """
-    Computes the complex permittivity of ice given its temperature, density, and
-    the frequency of interest. Supports different methods of calculation.
-
-    :param temperature: Temperature of the ice in degrees Celsius.
-    :param density: Density of the ice in kg/m^3.
-    :param center_frequency: Frequency at which to compute permittivity, in Hz.
-    :param method: The method used for calculating permittivity. Supports 
-        "kovacs" and "fujita".
-    :type temperature: float
-    :type density: float
-    :type center_frequency: float, optional
-    :type method: str
-    :return: The complex permittivity tensor for ice.
-    :rtype: np.ndarray
-    """
+        temperature, 
+        density, 
+        center_frequency = None,
+        method = "fujita"
+    ):
+    '''
+    Parameters
+    ----------
+    :param :  
+    :type : 
+
+    :return :
+    :rtype :
+    '''
     #Allocate
     P = np.zeros([3,3], dtype = complex)
 
     # The following is for 2-10 GHz. The details can be found in 
     if method == "kovacs":
         perm = (1 + 0.845 * density)**2
     else: # Fujita et al. (2000)
@@ -641,33 +612,26 @@
 # -----------------------------------------------------------------------------
 def snow_permittivity(
         density: float = 917., 
         temperature: float = 0., 
         lwc: float = 0., 
         porosity: float = 50.,
         method: str = "shivola-tiuri"
-    ) -> np.ndarray:
-    """
-    Calculates the complex permittivity of snow based on its density, temperature, liquid water content (LWC), 
-    porosity, and the chosen calculation method.
-
-    :param density: Density of the snow in kg/m^3.
-    :param temperature: Temperature of the snow in degrees Celsius.
-    :param lwc: Liquid water content of the snow in percentage.
-    :param porosity: Porosity of the snow in percentage.
-    :param method: The method to be used for calculating permittivity. Defaults to "shivola-tiuri".
-    :type density: float
-    :type temperature: float
-    :type lwc: float
-    :type porosity: float
-    :type method: str
-    :return: The complex permittivity tensor for snow.
-    :rtype: np.ndarray
-    """
+    ):
+    '''
 
+    
+    Parameters
+    ----------
+    :param :  
+    :type : 
+
+    :return :
+    :rtype :
+    '''
     # Temperature equations
     # jones (2005), liebe et al. (1991)
     # Density equations 
     # shivola and tiuri (1986), wise
     
     rho_d,grams_air,grams_water = porewater_correction(
         temperature, density, porosity, lwc
@@ -696,38 +660,39 @@
     complex_permittivity = 0.8*lwc + 0.72*(lwc**2)
     permittivity = np.eye(3,3) * complex(perm, complex_permittivity)
 
     return(permittivity)
 
 # -----------------------------------------------------------------------------
 def water_permittivity(temperature):
+    '''
+
+    
+    Parameters
+    ----------
+    :param :  
+    :type : 
+
+    :return :
+    :rtype :
+    '''
     pass
+    # return( snow_permativity() )
 
 # -----------------------------------------------------------------------------
-def snow_conductivity(
-        lwc: float = None, 
-        permittivity: np.ndarray = None, 
-        frequency: float = None
-    ) -> np.ndarray:
-    """
-    Computes the electrical conductivity of snow given its liquid water content 
-    (LWC), permittivity, and frequency of interest.
-
-    :param lwc: Liquid water content of the snow, optionally used if 
-        permittivity is not provided.
-    :param permittivity: The complex permittivity of snow, if available.
-    :param frequency: Frequency at which conductivity is to be calculated, 
-        in Hz.
-    :type lwc: float, optional
-    :type permittivity: np.ndarray, optional
-    :type frequency: float, optional
-    :return: The conductivity tensor for snow.
-    :rtype: np.ndarray
-    """
-
+def snow_conductivity(lwc = None, permittivity = None, frequency = None):
+    '''
+    Parameters
+    ----------
+    :param :  
+    :type : 
+
+    :return :
+    :rtype :
+    '''
     if np.iscomplexobj(permittivity):
         sigma = permittivity.imag * frequency * eps0
     else:
         # granlund et al. (2010)
         _,_,grams_water = porewater_correction(
             temperature, density, porosity, lwc
         )
@@ -738,30 +703,38 @@
         # put it in terms of S/m
         sigma = (20 + 3e3 * lwc) * 1e-4 
     
     conductivity = np.eye(3,3) * sigma 
     return(conductivity)
 
 # -----------------------------------------------------------------------------
-def read_ang(filepath: str) -> np.ndarray:
-    """
-    Reads Euler angles from a .ang file, typically associated with 
-    EBSD (Electron Backscatter Diffraction) data.
-
-    :param filepath: The path to the .ang file.
-    :type filepath: str
-    :return: An array of Euler angles extracted from the file.
-    :rtype: np.ndarray
-
-    Note:
-        The .ang file is expected to contain columns for Euler angles in 
-        radians, following Bunge's notation (z-x-z rotation), among other data 
-        related to EBSD measurements.
-    """
 
+def read_ang(filepath):
+    '''
+
+    
+    Parameters
+    ----------
+    :param :  
+    :type : 
+
+    :return :
+    :rtype :
+
+    The input .ang file will have the columns as 
+        c1-3    Euler angles (radians; Bunge's notation - z-x-z rotation )
+        c4,5    horizontal, vertical respectively
+        c6      image quality
+        c7      confidence index
+        c8      phase ID
+        c9      detector intensity
+        c10     fit
+    Refer to this thread for more description of the aforementioned
+        https://www.researchgate.net/post/How_can_I_get_X_Y_position_data_of_a_single_grain_from_EBSD_scan
+    '''
     
     # Load the file in as a data frame
     euler = np.genfromtxt(filepath, delimiter = " ")
 
     # take only the euler angles...for now
     if euler.shape[0] > 3 :
         euler = euler[:,0:3]
@@ -778,26 +751,28 @@
 
     # reshape back to array
     euler = euler.reshape(m, int( len(euler)/m ) )
 
     # save ferris
     return(euler)
 
+
 # -----------------------------------------------------------------------------
-def rotator_zxz(eul: np.ndarray) -> np.ndarray:
-    """
-    Generates a rotation matrix from Euler angles using the z-x-z rotation 
-    convention.
-
-    :param eul: An array containing the three Euler angles.
-    :type eul: np.ndarray
-    :return: The 3x3 rotation matrix derived from the Euler angles.
-    :rtype: np.ndarray
-    """
+def rotator_zxz(eul):
+    '''
 
+    
+    Parameters
+    ----------
+    :param :  
+    :type : 
+
+    :return :
+    :rtype :
+    '''
     # From the 3 euler angles for the zxz rotation, compute the rotation matrix
     R = np.zeros([3,3])
     D = np.zeros([3,3])
     C = np.zeros([3,3])
     B = np.zeros([3,3])
 
     D[0,:] = [ np.cos( eul[0] ), -np.sin( eul[0] ), 0.0 ]
@@ -814,62 +789,40 @@
 
     R = np.matmul(D, C)
     R = np.matmul(R, B)
 
     return(R)
 
 # -----------------------------------------------------------------------------
-def bond(R: np.ndarray) -> np.ndarray:
-    """
-    Calculates the 6x6 Bond transformation matrix from a 3x3 rotation matrix, 
-    useful for transforming stiffness or compliance matrices in crystallography 
-    and materials science.
-
-    :param R: The 3x3 rotation matrix.
-    :type R: np.ndarray
-    :return: The 6x6 Bond transformation matrix.
-    :rtype: np.ndarray
-    """
 
+def bond(R):
+    '''
+    
+    
+    Parameters
+    ----------
+    :param :  
+    :type : 
+
+    :return :
+    :rtype :
+    '''
     # From the euler rotation matrix, compute the 6-by-6 bond matrix
     M = np.zeros([6,6])
-    M[0,:] = [ 
-        R[0,0]**2, R[0,1]**2, R[0,2]**2, 
-        2*R[0,1]*R[0,2], 2*R[0,2]*R[0,0], 2*R[0,0]*R[0,1] 
-    ]
-    M[1,:] = [ 
-        R[1,0]**2, R[1,1]**2, R[1,2]**2, 
-        2*R[1,1]*R[1,2], 2*R[1,2]*R[1,0], 2*R[1,0] * R[1,1] 
-    ]
-    M[2,:] = [ 
-        R[2,0]**2, R[2,1]**2, R[2,2]**2, 
-        2*R[2,1]*R[2,2], 2*R[2,2]*R[2,0], 2*R[2,0] * R[2,1] 
-    ]
-    M[3,:] = [ 
-        R[1,0]* R[2,0], R[1,1] * R[2,1], 
-        R[1,2] * R[2,2], R[1,1] * R[2,2] + R[1,2]*R[2,1], 
-        R[1,0]*R[2,2] + R[1,2]*R[2,0], R[1,1]*R[2,0] + R[1,0]*R[2,1] 
-    ]
-    M[4,:] = [ 
-        R[2,0]* R[0,0], R[2,1] * R[0,1], 
-        R[2,2] * R[0,2], R[0,1] * R[2,2] + R[0,2]*R[2,1], 
-        R[0,2]*R[2,0] + R[0,0]*R[2,2], R[0,0]*R[2,1] + R[0,1]*R[2,0] 
-    ]
-    M[5,:] = [ 
-        R[0,0]* R[1,0], R[0,1] * R[1,1], 
-        R[0,2] * R[1,2], R[0,1] * R[1,2] + R[0,2]*R[1,1], 
-        R[0,2]*R[1,0] + R[0,0]*R[1,2], R[0,0]*R[1,1] + R[0,1]*R[1,0] 
-    ]
+    M[0,:] = [ R[0,0]**2, R[0,1]**2, R[0,2]**2, 2*R[0,1]*R[0,2], 2*R[0,2]*R[0,0], 2*R[0,0]*R[0,1] ]
+    M[1,:] = [ R[1,0]**2, R[1,1]**2, R[1,2]**2, 2*R[1,1]*R[1,2], 2*R[1,2]*R[1,0], 2*R[1,0] * R[1,1] ]
+    M[2,:] = [ R[2,0]**2, R[2,1]**2, R[2,2]**2, 2*R[2,1]*R[2,2], 2*R[2,2]*R[2,0], 2*R[2,0] * R[2,1] ]
+    M[3,:] = [ R[1,0]* R[2,0], R[1,1] * R[2,1], R[1,2] * R[2,2], R[1,1] * R[2,2] + R[1,2]*R[2,1], R[1,0]*R[2,2] + R[1,2]*R[2,0], R[1,1]*R[2,0] + R[1,0]*R[2,1] ]
+    M[4,:] = [ R[2,0]* R[0,0], R[2,1] * R[0,1], R[2,2] * R[0,2], R[0,1] * R[2,2] + R[0,2]*R[2,1], R[0,2]*R[2,0] + R[0,0]*R[2,2], R[0,0]*R[2,1] + R[0,1]*R[2,0] ]
+    M[5,:] = [ R[0,0]* R[1,0], R[0,1] * R[1,1], R[0,2] * R[1,2], R[0,1] * R[1,2] + R[0,2]*R[1,1], R[0,2]*R[1,0] + R[0,0]*R[1,2], R[0,0]*R[1,1] + R[0,1]*R[1,0] ]
 
     return(M)
     
+
 # -----------------------------------------------------------------------------
-# -----------------------------------------------------------------------------
-# The following is for the complex permittivity calculations that were defined
-# by Fujita et al. 
 T = np.array(
     [190, 200, 220, 240, 248, 253, 258, 263, 265]
 )
 A = np.array(
     [0.005, 0.010, 0.031, .268, .635, 1.059, 1.728, 2.769, 3.326]
 )*10.e-4
 B = np.array(
@@ -879,26 +832,16 @@
     [1.175, 1.168, 1.129, 1.088, 1.073, 1.062, 1.056, 1.038, 1.024]
 )
 # Interpolation functions for A, B, and C
 A_interp = interp1d(T, A, kind='cubic', fill_value='extrapolate')
 B_interp = interp1d(T, B, kind='cubic', fill_value='extrapolate')
 C_interp = interp1d(T, C, kind='cubic', fill_value='extrapolate')
 
-def fujita_complex_permittivity(temperature: float, frequency: float) -> float:
-    """
-    Calculates the complex permittivity of ice using Fujita's method, based on 
-    the provided temperature and frequency.
-
-    :param temperature: The temperature of ice in degrees Celsius.
-    :param frequency: The frequency at which to calculate permittivity, in Hz.
-    :type temperature: float
-    :type frequency: float
-    :return: The complex permittivity value.
-    :rtype: float
-    """
+def fujita_complex_permittivity(temperature, frequency):
+    # 
     # frequency = 1 is equivalent to 1 GHz or 1e9 Hz. The input is in Hz.
     frequency = frequency / 1e9
     A_val = A_interp(T_given)
     B_val = B_interp(T_given)
     C_val = C_interp(T_given)
     epsilon_val = A_val/f + B_val*(f**C_val)
     return epsilon_val
```

## seidart/routines/sourcefunction.py

```diff
@@ -1,33 +1,39 @@
+#!/usr/bin/env python3
+
+"""Build the source function. The default is an impulse function with center 
+frequency f0, but we can also generate other wavelets and chirplets."""
 
 import argparse
 import numpy as np 
 from seidart.routines.definitions import *
 from scipy import signal
 import matplotlib.pyplot as plt 
 from scipy.io import FortranFile 
 import scipy.signal
-from typing import Tuple 
 
 # ================================ Definitions ================================
-def wavelet(timevec: np.ndarray, f: float, stype: str) -> np.ndarray:
-    """
-    Generates a wavelet based on the specified type and parameters.
-
-    :param timevec: The time vector for the wavelet.
-    :param f: The center frequency of the wavelet.
-    :param stype: The type of wavelet to generate. Options include 'gaus0', 
-                  'gaus1', 'gaus2', 'chirp', and 'chirplet'.
-    :type timevec: np.ndarray
-    :type f: float
-    :type stype: str
-    :return: The generated wavelet.
-    :rtype: np.ndarray
-    """
+def wavelet(timevec, f, stype):
+    '''
+
+    
+    Parameters
+    ----------
+    :param :  
+    :type : 
+
+    :param :  
+    :type : 
+    
+    :param :  
+    :type : 
 
+    :return :
+    :rtype :
+    '''
     # Create the wavelet given the parameters
     a = np.pi**2 * f**2
     to = 1/f
     if stype == 'gaus0':
         x = np.exp(-a*(timevec - to)**2)
     if stype == "gaus1":
         x = - 2.0 * a * (timevec - to) * np.exp(-a * ((timevec - to)**2))    
@@ -39,105 +45,89 @@
     if stype == "chirplet":
         x = signal.chirp(timevec, f, to, 20*f, phi = -90)
         g = np.exp(-(a/4)*(timevec - to)**2)
         x = x * g        
     x = x/x.max()
     return(x)
 
-def multimodesrc(timevec: np.ndarray, f: float, stype: str) -> np.ndarray:
-    """
-    Creates a multi-mode source by linearly combining wavelets at different 
-    frequencies.
-
-    :param timevec: The time vector for the source.
-    :param f: The center frequency around which the modes are generated.
-    :param stype: The type of wavelet to use for each mode.
-    :type timevec: np.ndarray
-    :type f: float
-    :type stype: str
-    :return: The combined multi-mode source.
-    :rtype: np.ndarray
-    """
+def multimodesrc(timevec, f, stype):
+    '''
 
+    
+    Parameters
+    ----------
+    :param :  
+    :type : 
+
+    :return :
+    :rtype :
+    '''
     # Create a double octave sweep centered at f0 from the addition of multiple
     # sources. 
     # The change will be linear in 1/8 octave steps
     fmin = f0/4 
     fmax = f0
     df = (f0 - f0/2)/8
     f = np.arange(fmin, fmax, df)
     stf = np.zeros([len(timevec)])
     for freq in f:
         stf = stf + wavelet(timevec, freq, stype)
     return(stf)
 
-def plotsource(t: np.ndarray, x: np.ndarray) -> Tuple[plt.Figure, np.ndarray]:
-    """
-    Plots the source function and its power spectrum.
-
-    :param t: The time vector corresponding to the source function.
-    :param x: The source function.
-    :type t: np.ndarray
-    :type x: np.ndarray
-    :return: A tuple containing the matplotlib figure and axes array.
-    :rtype: Tuple[plt.Figure, np.ndarray]
-    """
+def plotsource(t, x):
+    '''
 
+    
+    Parameters
+    ----------
+    :param :  
+    :type : 
+
+    :return :
+    :rtype :
+    '''
     fs = 1/np.mean(np.diff(t) )
     f, pxx = signal.welch(x, fs = fs)
     db = 10*np.log10(pxx)
     fig, ax = plt.subplots(2)
     ax[0].plot(t, x, '-b')
     ax[0].set( xlabel = 'Time (s)', ylabel= 'Amplitude')
     ax[1].plot(f, db, '-b')
     ax[1].set(xlabel = 'Frequency (Hz)', ylabel = 'Power (dB)')
     ax[1].set_xlim([f.min(), np.min([20*f0, f.max()])] )
     return(fig,ax)
 
-def writesrc(fn: str, srcarray: np.ndarray) -> None:
-    """
-    Writes a source array to a Fortran-formatted binary file.
-
-    :param fn: The filename for the output file.
-    :param srcarray: The source array to write.
-    :type fn: str
-    :type srcarray: np.ndarray
-    """
+def writesrc(fn, srcarray):
+    '''
 
+    
+    Parameters
+    ----------
+    :param :  
+    :type : 
+
+    :return :
+    :rtype :
+    '''
     f = FortranFile(fn, 'w')
     f.write_record(srcarray)
     f.close()
 
-def sourcefunction(
-        modelclass: Model, 
-        factor: float, 
-        source_type: str, 
-        model_type: str, 
-        multimodal: bool = False
-    ) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
-    """
-    Generates a source function based on the provided model class and parameters.
-
-    :param modelclass: The model class containing time steps, frequency, and 
-        orientation.
-    :param factor: Amplitude scaling factor for the source.
-    :param source_type: The type of source to generate.
-    :param model_type: Specifies whether the source is for a seismic ('s') or 
-        electromagnetic ('e') model.
-    :param multimodal: Whether to generate a multimodal source. Defaults to False.
-    :type modelclass: Model
-    :type factor: float
-    :type source_type: str
-    :type model_type: str
-    :type multimodal: bool
-    :return: A tuple containing the time vector and the x, y, z components of 
-        the force, along with the source function.
-    :rtype: Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]
-    """
+def sourcefunction(modelclass, factor, source_type, model_type, multimodal = False):
+    '''
 
+    
+    Parameters
+    ----------
+    :param :  
+    :type : 
+
+    :return :
+    :rtype :
+    '''
     # Create the source 
     N = int(modelclass.time_steps)
     timevec = np.linspace(1, N, num = N ) * \
         float(modelclass.dt)
     f0 = float(modelclass.f0)
 
     # Create the source function
@@ -157,85 +147,24 @@
         writesrc("seismicsourcez.dat", forcez)
     if model_type == 'e' or model_type == 'electromag':
         writesrc("electromagneticsourcex.dat", forcex)
         writesrc("electromagneticsourcey.dat", forcey)
         writesrc("electromagneticsourcez.dat", forcez)
     return(timevec, forcex, forcey, forcez, srcfn)
 
-
-def main(
-        prjfile: str, 
-        source_type: str, 
-        factor: float, 
-        model_type: str,
-        multimodal: bool, 
-        make_plot: bool
-    ) -> None:
-    """
-    Main function to generate and optionally plot a source function based on 
-    input parameters.
-
-    :param prjfile: Path to the project file.
-    :param source_type: Type of the source function to generate.
-    :param factor: Amplitude scaling factor for the source.
-    :param model_type: Specifies the model type ('s' for seismic, 'e' for 
-        electromagnetic).
-    :param multimodal: Indicates if a multimodal source should be generated. 
-        Defaults to False.
-    :param make_plot: Whether to plot the generated source function. Defaults 
-        to False.
-    :type prjfile: str
-    :type source_type: str
-    :type factor: float
-    :type model_type: str
-    :type multimodal: bool
-    :type make_plot: bool
-    """
-
-    # Load the project file 
-    # Let's initiate the domain
-    domain, material, seismic, electromag = loadproject(
-        prjfile, 
-        Domain(), 
-        Material(), 
-        Model(), 
-        Model()
-    )
-    if model_type == 's' or model_type == 'seismic':
-        timevec, fx, fy, fz, srcfn = sourcefunction(
-            seismic, 
-            factor, 
-            source_type, 
-            model_type, 
-            multimodal = multimodal
-        )
-    if model_type == 'e' or model_type == 'electromagnetic':
-        timevec, fx, fy, fz, srcfn = sourcefunction(
-            electromag, 
-            factor, 
-            source_type, 
-            model_type, 
-            multimodal = multimodal
-        )
-    if make_plot:
-        plotsource(timevec, srcfn)
-        plt.show()
-
 # --------------------------- Command Line Arguments --------------------------
 if __name__ == "__main__":
     parser = argparse.ArgumentParser(
         description = """We support building a few different source time 
         functions and writing them to a text file. From a specified project 
         file we can create the time series for a source function and save it 
-        in a Fortran formatted .dat file. The default is an impulse function 
-        with center frequency f0, but we can also generate other wavelets and 
-        chirplets.
+        in a Fortran formatted .dat file. 
         """
     )
-    
+
     parser.add_argument(
         '-p', '--projectfile', nargs = 1, type = str, required = True,
         help = """The path to the project file"""
     )
 
     parser.add_argument(
         '-S', '--sourcetype', nargs = 1, type = str, required = False, 
@@ -266,25 +195,51 @@
     )
 
     parser.add_argument(
         '-P', '--plot', action='store_true',
         help = """Plot the source and spectrum"""
     )
 
+
     args = parser.parse_args()
     prjfile = ''.join(args.projectfile)
     source_type = ''.join(args.sourcetype)
     factor = args.amplitude[0]
     model_type = ''.join(args.modeltype)
     multimodal = args.multimodal 
-    make_plot = args.plot
+    plotbool = args.plot
     #
-    
-    main(prjfile, source_type, factor, model_type, multimodal, make_plot)
-    
+    # Load the project file 
+    # Let's initiate the domain
+    domain, material, seismic, electromag = loadproject(
+        prjfile, 
+        Domain(), 
+        Material(), 
+        Model(), 
+        Model()
+    )
+    if model_type == 's' or model_type == 'seismic':
+        timevec, fx, fy, fz, srcfn = sourcefunction(
+            seismic, 
+            factor, 
+            source_type, 
+            model_type, 
+            multimodal = multimodal
+        )
+    if model_type == 'e' or model_type == 'electromagnetic':
+        timevec, fx, fy, fz, srcfn = sourcefunction(
+            electromag, 
+            factor, 
+            source_type, 
+            model_type, 
+            multimodal = multimodal
+        )
+    if plotbool:
+        plotsource(timevec, srcfn)
+        plt.show()
```

## seidart/routines/prjrun.py

```diff
@@ -1,189 +1,151 @@
+#!/usr/bin/env python3
+
+# This script will read the parameters given from a project file and run the 
+# specified models. 
+
+# -----------------------------------------------------------------------------
+
 import argparse
 import os.path
 import os
 import numpy as np
 import matplotlib.image as mpimg
 from subprocess import call
-from typing import Tuple
 # import seidart.routines.materials as mf
 from seidart.routines.definitions import *
 
 # Modeling modules
 from seidart.fortran.cpmlfdtd import cpmlfdtd
 
-# Global Constants
-clight = 2.99792458e8  # Speed of light in vacuum (m/s)
-NP = 2  # Numerical parameter for CPML
-NPA = 2  # Additional numerical parameter for CPML
-k_max = 1.1e1  # Max value for CPML parameter
-eps0 = 8.85418782e-12  # Permittivity of free space
-mu0 = 4.0 * np.pi * 1.0e-7  # Permeability of free space
-Rcoef = 0.0010  # Reflection coefficient, used for seismic only
+# ------------- Globals ----------------
+clight = 2.99792458e8 # In general
+# Define constants
+NP = 2 
+NPA = 2 
+k_max = 1.1e1 # 1.25e1 #This is the value determined from the litterature. 
+eps0 = 8.85418782e-12 # used for em only
+mu0 = 4.0*np.pi*1.0e-7 # used for em only
+Rcoef = 0.0010 # used for seismic only
 
 # ============================ Create the objects =============================
 # Let's initiate the domain and check to make sure everything is good to go
-def domain_initialization(
-        prjfile: str
-    ) -> Tuple[Domain, Material, Model, Model]:
+def domain_initialization(prjfile: str):
     """
-    Initializes the simulation domain and materials, and prepares seismic and 
-    electromagnetic models based on a project file.
 
-    This function reads simulation parameters from a specified project file and 
-    uses them to initialize the domain, material properties, and two models 
-    (seismic and electromagnetic). It performs checks to ensure all necessary 
-    parameters are specified and modifies the material list by removing RGB 
-    values. 
-
-    :param prjfile: The path to the project file containing initialization 
-        parameters for the domain, materials, and models.
-    :type prjfile: str
-    :return: A tuple containing initialized Domain, Material, and two Model 
-        instances (seismic and electromagnetic).
-    :rtype: Tuple[Domain, Material, Model, Model]
-
-    Each Model instance is checked to ensure required parameters are provided, 
-    and the material list is pruned to exclude RGB values before final checks 
-    are performed.
+    :param prjfile:
+    :type prjfile: str 
     """
 
     domain, material, seismic, electromag = loadproject(
         prjfile,
         Domain(), 
         Material(),
         Model(),
         Model()
     )
 
-    # Model initialization and checks
+    # =================================== Model ===================================
+    # Check to make sure all the domain values were given
     domain.para_check()
+
+    # Check the model inputs
     seismic.para_check()
     electromag.para_check()
+
+    # Check to make sure all the model inputs are satisfied
     seismic.tensor_check()
     electromag.tensor_check()
 
-    # Modify material list and perform final checks
-    material.material_list = np.delete(material.material_list, 2, axis=1)
-    material.para_check()
+    # Drop the rgb values 
+    material.material_list = np.delete(material.material_list, 2, axis = 1)
+    # print(material.material_list)
 
+    # Check the material list
+    material.para_check()
     return(domain, material, seismic, electromag)
 
 # -----------------------------------------------------------------------------
 def status_check(
-    modelclass: Model, 
-    material: Material, 
-    domain: Domain, 
+    modelclass, 
+    material,
+    domain,
     prjfile: str, 
     seismic: bool = True, 
-    append_to_prjfile: bool = True
-    ) -> None:
-    """
-    Checks the status of the modeling classes and appends coefficients to the
-    project file if necessary.
-
-    :param modelclass: The model class to check.
-    :param material: The material class instance.
-    :param domain: The domain class instance.
-    :param prjfile: Path to the project file.
-    :param seismic: Flag indicating if the model is seismic. Defaults to True.
-    :param append_to_prjfile: Flag to append coefficients to the project file. 
-                              Defaults to True.
-    :type modelclass: Union[Model, None]
-    :type material: Material
-    :type domain: Domain
-    :type prjfile: str
-    :type seismic: bool
-    :type append_to_prjfile: bool
-    """
+    appendbool: bool = True,
+    ):
     if modelclass.exit_status == 0 and \
         material.material_flag and \
-            append_to_prjfile:
+            appendbool:
         # The coefficients aren't provided but the materials are so we can 
         # compute them
         # Assign the materials to their respective corners
         material.sort_material_list()
+    if seismic:
+        print('Computing the stiffness coefficients.')
+        tensor = material.functions.get_seismic(
+            temp = material.temp, 
+            rho = material.rho,
+            porosity = material.porosity,
+            lwc = material.lwc, 
+            anisotropic = material.is_anisotropic,
+            angfile = material.angfiles, 
+            material_name = material.material
+        )
+        modelclass.tensor_coefficients = tensor
+    else:
+        print('Computing the permittivity and conductivity coefficients.')
         
-        if seismic:
-            print('Computing the stiffness coefficients.')
-            tensor = material.functions.get_seismic(
-                temp = material.temp, 
-                rho = material.rho,
-                porosity = material.porosity,
-                lwc = material.lwc, 
-                anisotropic = material.is_anisotropic,
-                angfile = material.angfiles, 
-                material_name = material.material
-            )
-            modelclass.tensor_coefficients = tensor
-        else:
-            print('Computing the permittivity and conductivity coefficients.')
-            
-            tensor = material.functions.get_perm(
-                material, modelclass
-            )
-            modelclass.tensor_coefficients = tensor
-        
-        # Before we append the coefficients to the text file let's round to the second decimal
-        tensor = np.round(tensor, 2)
-        if seismic:
-            ind = np.where(tensor.max() == tensor)
-            max_rho = tensor[ ind[0][0], -1]
-        
-        # We're going to find the lines marked 'C' or 'P' and input the values there
+        tensor = material.functions.get_perm(
+            material, modelclass
+        )
+        modelclass.tensor_coefficients = tensor
+    
+    # Before we append the coefficients to the text file let's round to the second decimal
+    tensor = np.round(tensor, 2)
+    if seismic:
+        ind = np.where(tensor.max() == tensor)
+        max_rho = tensor[ ind[0][0], -1]
+    
+    # We're going to find the lines marked 'C' or 'P' and input the values there
 
-        if seismic:
-            modelclass.dt = np.min([domain.dx, domain.dz]) / np.sqrt(3.0 * tensor.max()/max_rho )
-            append_coefficients(prjfile, tensor, CP = 'C', dt = modelclass.dt)
-        else:
-            modelclass.dt = np.min([domain.dx, domain.dz]) / \
-                (2.0 * clight/ \
-                    np.sqrt(np.min(
-                        [
-                            tensor[:,1].astype(float).min(), 
-                            tensor[:,4].astype(float).min()
-                        ]
-                    )) 
-                )
-            append_coefficients(prjfile, tensor, CP = 'P', dt = modelclass.dt)
-        
-        # The time step needs to satisfy the Courant number and also have a nyquist
-        # that will resolve the source frequency
-        src_nyquist = 1/(2*modelclass.f0)
-        if src_nyquist < modelclass.dt:
-            print(
-                '''Nyquist is not small enough for the source frequency. Change
-                the source frequency or decrease the spatial step size'''
+    if seismic:
+        modelclass.dt = np.min([domain.dx, domain.dz]) / np.sqrt(3.0 * tensor.max()/max_rho )
+        append_coefficients(prjfile, tensor, CP = 'C', dt = modelclass.dt)
+    else:
+        modelclass.dt = np.min([domain.dx, domain.dz]) / \
+            (2.0 * clight/ \
+                np.sqrt(np.min(
+                    [
+                        tensor[:,1].astype(float).min(), 
+                        tensor[:,4].astype(float).min()
+                    ]
+                )) 
             )
+        append_coefficients(prjfile, tensor, CP = 'P', dt = modelclass.dt)
+    
+    # The time step needs to satisfy the Courant number and also have a nyquist
+    # that will resolve the source frequency
+    src_nyquist = 1/(2*modelclass.f0)
+    if src_nyquist < modelclass.dt:
+        print(
+            '''Nyquist is not small enough for the source frequency. Change
+            the source frequency or decrease the spatial step size'''
+        )
 
-        print("Finished. Appending to project file.\n")
+    print("Finished. Appending to project file.\n")
 
 # -----------------------------------------------------------------------------
 def cpmlcompute(
-        modelclass: Model, 
-        domain: Domain, 
-        direction: str, 
-        half: bool = False, 
-        seismic: bool = True
-    ) -> None:
-    """
-    Computes CPML parameters for a given direction and updates model/domain.
-
-    :param modelclass: The model class instance to update.
-    :param domain: The domain class instance to update.
-    :param direction: Direction to compute CPML ('x', 'y', or 'z').
-    :param half: Flag to compute half CPML parameters. Defaults to False.
-    :param seismic: Flag indicating if the model is seismic. Defaults to True.
-    :type modelclass: Model
-    :type domain: Domain
-    :type direction: str
-    :type half: bool
-    :type seismic: bool
-    """
-
+    modelclass, 
+    domain, 
+    direction: str, 
+    half: bool = False, 
+    seismic: bool = True
+    ):
     # For 2D models, we don't need to compute the cpml in the y-direction
     if domain.dim == 2 and direction == 'y':
         return 
     
     nx = domain.nx + 2*domain.cpml
     nz = domain.nz + 2*domain.cpml
     if domain.dim == 2.5:
@@ -191,22 +153,21 @@
         deltamin = np.min([domain.dx, domain.dy, domain.dz]) 
     else:
         deltamin = np.min([domain.dx, domain.dz]) 
 
     # Allocate space
     if direction == 'x':
         N = int(nx)
-        dx = float(domain.dx)
+        dx = int(domain.dx)
     elif direction == 'y':
         N = int(ny)
-        dx = float(domain.dy) 
+        dx = int(domain.dy) 
     else:
         N = int(nz)
-        dx = float(domain.dz)
-    
+        dx = int(domain.dz)
     # -----------------------------------------------------------------------------
     # Compute the distance along the absorbing boundary relative to the end of the 
     # original model space. 
     dist = dx * np.arange(0, domain.cpml)
     if half:
         dist = dist + dx/2 
 
@@ -256,32 +217,19 @@
         kappa.tofile('kappa' + direction + '_cpml.dat')
         alpha.tofile('alpha' + direction + '_cpml.dat')
         acoeff.tofile('acoef' + direction + '_cpml.dat')
         bcoeff.tofile('bcoef' + direction + '_cpml.dat')
 
 # ================================== SEISMIC ==================================
 def runseismic(
-        modelclass: Model, 
-        material: Material, 
-        domain: Domain, 
-        single_precision: bool
-    ) -> None:
-    """
-    Runs the seismic model using the initialized modelclass, material, and domain.
-
-    :param modelclass: The seismic model class instance.
-    :param material: The material class instance.
-    :param domain: The domain class instance.
-    :param single_precision: Flag for single precision data processing.
-    :type modelclass: Model
-    :type material: Material
-    :type domain: Domain
-    :type single_precision: bool
-    """
-
+        modelclass,
+        material, 
+        domain,
+        single_precision: bool,
+    ):
     modelclass, domain = prepme(modelclass, domain, complex_tensor = False)
     direction = ['x', 'y', 'z']
     # Compute CPML
     print(direction)
     print('computing cpml')
     for d in direction:
         cpmlcompute(modelclass, domain, d, seismic = seismic)
@@ -338,35 +286,20 @@
                 modelclass.src,
                 modelclass.time_steps,
                 single_precision
             )     
 
 # =============================================================================
 def runelectromag(
-        modelclass: Model, 
-        material: Material, 
-        domain: Domain, 
+        modelclass,
+        material, 
+        domain,
         use_complex_equations: bool = False,
-        single_precision: bool = True
-    ) -> None:
-    """
-    Runs the electromagnetic model with options for complex equations and precision.
-
-    :param modelclass: The electromagnetic model class instance.
-    :param material: The material class instance.
-    :param domain: The domain class instance.
-    :param use_complex_equations: Flag to use complex equations in modeling.
-    :param single_precision: Flag for single precision data processing.
-    :type modelclass: Model
-    :type material: Material
-    :type domain: Domain
-    :type use_complex_equations: bool
-    :type single_precision: bool
-    """
-
+        single_precision: bool = True,
+    ):
     modelclass, domain = prepme(
         modelclass, domain, complex_tensor = use_complex_equations
     )
     direction = ['x', 'y', 'z']
     # Compute CPML
     print(direction)
     print('computing cpml')
@@ -434,88 +367,20 @@
                 domain.dx, domain.dz,
                 domain.cpml,
                 modelclass.src,
                 modelclass.time_steps,
                 single_precision
             )
         
-def main(
-        prjfile: str, 
-        model_type: str, 
-        append_to_prjfile: bool, 
-        pwd: str, 
-        double_precision: bool, 
-        use_complex_equations: bool
-    ) -> None:
-    """
-    Main function orchestrating domain initialization, status checking, and 
-    model execution based on provided command line arguments.
-
-    Initializes the simulation domain and material properties from a project file,
-    checks the status of seismic and electromagnetic models, and runs the specified
-    model(s) with configured settings. The function allows for re-computation and 
-    appending of material coefficients to the project file and supports both
-    seismic and electromagnetic model types with options for precision and complex
-    equations.
-
-    :param prjfile: The path to the project file containing simulation settings.
-    :param model_type: Specifies the type of model to run ('s' for seismic, 'e' 
-                       for electromagnetic).
-    :param append_to_prjfile: Flag indicating whether to append computed coefficients 
-                              to the project file.
-    :param pwd: The working directory where the project file is located.
-    :param double_precision: Flag indicating whether to use double precision for 
-                             simulation outputs.
-    :param use_complex_equations: Flag indicating whether to use complex equations 
-                                  for electromagnetic simulations.
-    :type prjfile: str
-    :type model_type: str
-    :type append_to_prjfile: bool
-    :type pwd: str
-    :type double_precision: bool
-    :type use_complex_equations: bool
-    """
-    domain, material, seismic, electromag = domain_initialization(prjfile)
-    status_check(
-        seismic, 
-        material,
-        domain,
-        prjfile, 
-        seismic=True, 
-        append_to_prjfile = append_to_prjfile
-    )
-    status_check(
-        electromag, 
-        material, 
-        domain,
-        prjfile, 
-        seismic=False, 
-        append_to_prjfile = append_to_prjfile,
-        use_complex_equations = use_complex_equations
-    )
-    
-    
-    if model_type == 's':
-        runseismic(
-            seismic, material, domain, 
-            double_precision
-        )
-    if model_type == 'e':
-        runelectromag(
-            electromag, material, domain, 
-            use_complex_equations = use_complex_equations, 
-            double_precision = double_precision
-        )
 
 # -------------------------- Command Line Arguments ---------------------------
 if __name__ == "__main__":
     parser = argparse.ArgumentParser(
-        description="""
-        This script will read the parameters given from a project file and run 
-        the specified models. The SeidarT software requires a .PNG image that is used to construct the model domain for seismic and
+        description="""The SeidarT software requires a
+        .PNG image that is used to construct the model domain for seismic and
         electromagnetic wave propagation. Given the image file, a project file
         will be constructed which contains all the necessary parameters to be
         read in to the finite differences time domain modeling schemes."""
     )
 
     parser.add_argument(
         '-p', '--prjfile', nargs=1, type=str, required = True,
@@ -563,22 +428,45 @@
     #     default is False."""
     # )
 
     # Get the arguments
     args = parser.parse_args()
     prjfile = ''.join(args.prjfile)
     model_type = ''.join(args.model)
-    append_to_prjfile = args.append[0] == 1
+    appendbool = args.append[0] == 1
     pwd = os.path.dirname(prjfile)
     double_precision = args.double_precision
     use_complex_equations = args.use_complex_equations
      
     # attenuation = args.attenuation
     #
-    main(
+    domain, material, seismic, electromag = domain_initialization(prjfile)
+    status_check(
+        seismic, 
+        material,
+        domain,
         prjfile, 
-        model_type, 
-        append_to_prjfile, 
-        pwd, 
-        double_precision, 
-        use_complex_equations
-    )
+        seismic=True, 
+        appendbool = appendbool
+    )
+    status_check(
+        electromag, 
+        material, 
+        domain,
+        prjfile, 
+        seismic=False, 
+        appendbool = appendbool,
+        use_complex_equations = use_complex_equations
+    )
+    
+    
+    if model_type == 's':
+        runseismic(
+            seismic, material, domain, 
+            double_precision
+        )
+    if model_type == 'e':
+        runelectromag(
+            electromag, material, domain, 
+            use_complex_equations = use_complex_equations, 
+            double_precision = double_precision
+        )
```

## seidart/routines/arraybuild.py

```diff
@@ -1,61 +1,48 @@
+#!/usr/bin/env python3
+
+# Create a receiver array and plot the timeseries
+
 import numpy as np
 import pandas as pd
 from glob2 import glob
 import argparse
 import matplotlib.pyplot as plt
 import matplotlib.image as mpimg
 from seidart.routines.definitions import *
 
+# from obspy import Trace, Stream, UTCDateTime
+
 # =============================================================================
 class Array:
     def __init__(
         self, 
         channel: str,
         prjfile: str, 
         receiver_file: str,
         receiver_indices: bool = False, 
         single_precision: bool = True,
         is_complex: bool = False
     ):
         """
-        Initializes the Array object with project settings and receiver details.
-
-        :param channel: The data channel to be analyzed.
-        :type channel: str
-        :param prjfile: Path to the project file.
-        :type prjfile: str
-        :param receiver_file: Path to the receiver locations file.
-        :type receiver_file: str
-        :param receiver_indices: Flag if receiver file contains indices (True) 
-                                 or Cartesian coordinates (False).
-        :type receiver_indices: bool
-        :param single_precision: Use single precision for numerical data 
-            if True.
-        :type single_precision: bool
-        :param is_complex: Treat the data as complex if True.
-        :type is_complex: bool
+        :param dt: Time step between measurements.
+        :param receivers_xyz: Coordinates of the receivers in a numpy array of shape (n, 3).
+        :param source_xyz: Location of the source as a tuple or list (x, y, z).
         """
         self.prjfile = prjfile 
         self.channel = channel
         self.receiver_file = receiver_file
         self.receiver_indices = receiver_indices
         self.single_precision = single_precision
         self.is_complex = is_complex
         self.stream = None
-        self.gain = 100
-        self.exaggeration = 0.5
         self.build()
     
     # -------------------------------------------------------------------------
     def build(self):
-        """
-        Constructs domain and models based on project file and sets up source 
-        and receiver configurations.
-        """
         self.domain, self.material, self.seismic, self.electromag = loadproject(
             self.prjfile,
             Domain(), 
             Material(),
             Model(),
             Model()
         )
@@ -94,21 +81,53 @@
                         int(self.electromag.y), 
                         int(self.electromag.z)
                     ]
                 )
         
         # Load the time series for all receivers
         self.getrcx()
-    
+        # self.streams = self._create_streams()
+        
+    # -------------------------------------------------------------------------
+    # def _create_streams(self):
+    #     streams = {}
+    #     start_time = UTCDateTime()  # Using current time as a reference, adjust as necessary
+
+    #     m, n = self.timeseries.shape 
+    #     stream = Stream()
+        
+    #     for ind in range(n):
+    #         dat = self.timeseries[:,ind]
+    #         datc = self.timeseries_complex[:,ind]
+    #         for loc in np.array(['00', '10']):
+    #             header = {
+    #                 'station': f"R{ind}", 'location': loc, 'network': 'SDRT',
+    #                 'channel': self.channel,
+    #                 'starttime': start_time,
+    #                 'delta': self.dt,
+    #                 'npts': m,
+    #                 'coordinates': {
+    #                     'latitude': self.receiver_xyz[ind][1],
+    #                     'longitude': self.receiver_xyz[ind][0],
+    #                     'elevation': self.receiver_xyz[ind][2],
+    #                 },
+    #             }
+    #             if loc == '00':
+    #                 trace = Trace(data=dat, header=header)
+    #             if loc == '10' and 'E' in self.channel:
+    #                 trace = Trace(data=datc, header=header)
+                
+    #             stream.append(trace)
+        
+    #     self.stream = stream
+        # return stream
+
     # -------------------------------------------------------------------------
     def loadxyz(self):
-        """
-        Loads and sorts receiver locations from a file and adjusts them 
-        according to the domain and CPML layer.
-        """
+        '''Load and sort the receiver locations'''
         xyz = pd.read_csv(self.receiver_file)
 
         # We need to make sure the recievers are ordered correctly and the 
         # absorbing boundary is corrected for
         # First check to see if the inputs are indices or
         cpml = int(self.domain.cpml)
         # Adjust the object fields relative to the cpml. The y-direction will be
@@ -127,49 +146,37 @@
         # the correct shape. We won't be able to differentiate if the array is 
         # in correct shape if it is 3x3
         if self.receiver_xyz.shape[0] == 3 and np.prod(self.receiver_xyz.shape) > 9:
             self.receiver_xyz = self.receiver_xyz.T
         if self.receiver_xyz.shape[0] == 3 and np.prod(self.receiver_xyz.shape) == 6:
             self.receiver_xyz = self.receiver_xyz.T
         
-        # If the receiver file contains values that are relative to the 
-        # cartesian space of the domain, we want to change them to the indices
-        # of the 
         if not self.receiver_indices:
             self.receiver_xyz = self.receiver_xyz / \
                 np.array(
                     [
                         float(self.domain.dx), 
                         float(self.domain.dy), 
                         float(self.domain.dz) 
                     ]
                 )
-            self.receiver_xyz.astype(int)
 
         self.receiver_xyz = self.receiver_xyz + cpml
         # return(self.domain, self.receiver_xyz)
     
     # -------------------------------------------------------------------------
     def getrcx(self):
-        """
-        Loads the time series data for all receivers and handles complex data
-        conditions.
-        """
         # input rcx as an n-by-2 array integer values for their indices.
-        src_ind = (
-            self.source / \
-            np.array([self.domain.dx, self.domain.dy, self.domain.dz])
-        ).astype(int)
         if self.domain.dim == 2.5:
             all_files = glob(
-                self.channel + '*.' + '.'.join(src_ind.astype(str)) + '.dat'
+                self.channel + '*.' + '.'.join(self.source.astype(str)) + '.dat'
             )
         else: 
             all_files = glob(
-                self.channel + '*.' + '.'.join(src_ind[np.array([0,2])].astype(str)) + '..dat'
+                self.channel + '*.' + '.'.join(self.source[0:2].astype(str)) + '..dat'
             )
         
         all_files.sort()
         m = len(all_files)
         if len(self.receiver_xyz.shape) == 1:
             n = 1
             timeseries = np.zeros([m]) 
@@ -247,51 +254,50 @@
         # Store both of the time series in the array object
         self.timeseries_complex = timeseries_complex
         self.timeseries = timeseries
     
     # -------------------------------------------------------------------------
     def sectionplot(
             self, 
+            gain: int = 100, 
+            exaggeration: float = 0.5, 
             plot_complex: bool = False
         ):
-        """
-        Creates a grayscale section plot of the time series data.
-
-        :param plot_complex: Plot the complex part of the solution if True.
-        :type plot_complex: bool
-        """
+        '''
+        Create a gray scale section plot
+        '''
         if plot_complex:
             # Use complex values 
             dat = self.timeseries_complex 
         else:
             dat = self.timeseries
         
         m,n = dat.shape
-        
+
         if self.is_seismic:
             mult = 1e2
         else:
             mult = 1e6
 
         timelocs = np.arange(0, m, int(m/10) ) # 10 tick marks along y-axis
         rcxlocs = np.arange(0, np.max([n, 5]), int(np.max([n, 5])/5) ) # 5 tick marks along x-axis
 
         if self.is_seismic:
             timevals = np.round(timelocs*float(self.dt) * mult, 2)
         else:
             timevals = np.round(timelocs*float(self.dt) * mult, 2)
 
-        if self.gain == 0:
-            self.gain = 1
+        if gain == 0:
+            gain = 1
             
-        if self.gain < m:
+        if gain < m:
             for j in range(0, n):
                 # Subtract the mean value
                 # dat[:,j] = dat[:,j] - np.mean(dat[:,j])
-                dat[:,j] = agc(dat[:,j], self.gain, "mean")
+                dat[:,j] = agc(dat[:,j], gain, "mean")
 
 
         self.fig = plt.figure()#figsize =(n/2,m/2) )
         self.ax = plt.gca()
 
         self.ax.imshow(dat, cmap = 'Greys', aspect = 'auto')
         self.ax.set_xlabel(r'Receiver #')
@@ -300,15 +306,15 @@
         self.ax.set_xticks(rcxlocs)
         self.ax.set_xticklabels(rcxlocs)
         self.ax.set_ylabel(r'Two-way Travel Time (s)')
         self.ax.set_yticks(timelocs)
         self.ax.set_yticklabels(timevals)
 
         # Other figure handle operations
-        self.ax.set_aspect(aspect = self.exaggeration)
+        self.ax.set_aspect(aspect = exaggeration)
 
         if self.is_seismic:
             self.ax.text(0, m + 0.03*m, 'x $10^{-2}$')
         else:
             self.ax.text(0, m + 0.03*m, 'x $10^{-6}$')
         
         self.ax.update_datalim( ((0,0),(m, n)))
@@ -325,69 +331,20 @@
             ]
         )
         # Pickle the object and save to file
         with open(filename, 'wb') as file:
             pickle.dump(self, filename)
 
 
-def main(
-        prjfile: str, 
-        receiver_file: str, 
-        channel: str, 
-        rind: bool, 
-        is_complex: bool, 
-        single_precision: bool, 
-        exaggeration: float, 
-        gain: int,
-        plot_complex: bool = False,
-        plot: bool = False
-    ) -> None:
-    """
-    The main function creating an Array object and triggering plotting or 
-    saving actions based on user inputs.
-
-    :param prjfile: Path to the project file.
-    :param receiver_file: Path to the receiver file.
-    :param channel: Data channel to be analyzed.
-    :param rind: Flag for coordinate indices.
-    :param is_complex: Flag for complex data handling.
-    :param single_precision: Flag for single precision data.
-    :param exaggeration: Aspect ratio between the x and y axes for plotting.
-    :param gain: Smoothing length for the data.
-    :param plot_complex: Flag to plot complex part of the solution.
-    :param plot: Flag to enable plotting.
-    """
-    array = Array(
-        channel,
-        prjfile, 
-        receiver_file,
-        rind, 
-        single_precision = single_precision,
-        is_complex = is_complex
-    )
-    
-    if gain:
-        array.gain = gain
-    if exaggeration:
-        array.exaggeration = exaggeration
-    if save:
-        array.save()
-    if plot:
-        array.section_plot(plot_complex = plot_complex)
-
 # =============================================================================
 # ========================== Command Line Arguments ===========================
 # =============================================================================
 if __name__ == "__main__":
-    parser = argparse.ArgumentParser(
-        description="""This program creates an Array class that can be saved in 
-        pickle format. Receiver locations listed in the the specified receiver 
-        file are extracted to create the time series. The minimum number of 
-        plots is 1 which will return a wiggle plot.""" 
-    )
+    parser = argparse.ArgumentParser(description="""This program creates a csv file of time series for each receiver location
+        listed in the the specified receiver file.""" )
     
     parser.add_argument(
         '-p', '--prjfile',
         nargs = 1, type = str, required = True,
         help = 'The project file path'
     )
     
@@ -396,16 +353,16 @@
         nargs=1, type=str, required = True,
         help='the file path for the text file of receiver locations'
     )
     
     parser.add_argument(
         '-i', '--index',
         action = 'store_true', required = False,
-        help = """Indicate whether the receiver file contains coordinate indices 
-        or if these are the locations in meters. Default (0 - meters)"""
+        help = """Indicate whether the receiver file contains coordinate indices or
+        if these are the locations in meters. Default (0 - meters)"""
     )
     
     parser.add_argument(
         '-c', '--channel',
         nargs = 1, type = str, required = True,
         help = """The channel to query. """
     )
@@ -436,47 +393,35 @@
     )
     
     parser.add_argument(
         '-s', '--save', action = 'store_true', required = False, 
         help = """Flag to save the array object as a .pkl file."""
     )
     
-    parser.add_argument(
-        '-P', '--plot', action = 'store_true', required = False,
-        help = """Flag whether you want to return a plot to the console."""
-    )
-    
-    parser.add_argument(
-        '-C', '--plot_complex', action = 'store_true', required = False,
-        help = """
-        If flagged, plot the complex part of the solution otherwise default to 
-        the real valued solution. 
-        """
-    )
-    
     # Get the arguments
     args = parser.parse_args()
     prjfile = ''.join(args.prjfile)
     receiver_file = ''.join(args.rcxfile)
     channel = ''.join(args.channel)
     rind = args.index
     is_complex = args.is_complex
     single_precision = args.double_precision 
     exaggeration = args.exaggeration[0] 
     gain = args.gain[0]
-    plot_complex = args.plot_complex
-    plot = args.plot 
     
     # ==================== Create the object and assign inputs ====================    
-    main(
+    array = Array(
+        channel,
         prjfile, 
-        receiver_file, 
-        channel, 
+        receiver_file,
         rind, 
-        is_complex, 
-        single_precision, 
-        exaggeration, 
-        gain, 
-        plot_complex = plot_complex,
-        plot = plot
+        single_precision = single_precision,
+        is_complex = is_complex
     )
+    
+    if gain and exaggeration:
+        array.gain = gain
+        array.exaggeration = exaggeration
+        
+    if save:
+        array.save()
```

## seidart/routines/prjbuild.py

```diff
@@ -4,30 +4,19 @@
 # to be used in the seisarT program
 #
 # -----------------------------------------------------------------------------
 
 import argparse
 import numpy as np
 import matplotlib.image as mpimg
-from typing import Tuple
 
-__all__ = ['prjbuild']
 
 # ------------------------ Some Necessary Definitions -------------------------
 
-def image2int(imfilename: str) -> Tuple[np.ndarray, np.ndarray]:
-    """
-    Converts an image file to a 2D array of integer values representing unique
-    RGB combinations and returns the unique RGB values.
-
-    :param imfilename: The path to the image file.
-    :type imfilename: str
-    :return: A tuple containing the 2D array of integer values and the array of unique RGB values.
-    :rtype: Tuple[np.ndarray, np.ndarray]
-    """
+def image2int(imfilename):
 	# read the image
 	img = mpimg.imread(imfilename)
 	# Convert RGB to a single value
 	rgb_int = np.array(65536*img[:,:,0] +  255*img[:,:,1] + img[:,:,2])
 	# Get the unique values of the image
 	rgb_uni = np.unique(rgb_int)
 	# We want the unique rgb values too
@@ -45,25 +34,15 @@
 
 	if np.max(rgb) <= 1.0:
 		rgb = rgb * 255
 		rgb = rgb.astype(int)
 
 	return( rgb_int.astype(int), rgb)
 
-def prjbuild(image_file: str, prjfile: str) -> None:
-    """
-    Generates a project file (.prj) based on an input image file. This file
-    contains domain parameters, material parameters, attenuation parameters,
-    seismic parameters, and electromagnetic parameters derived from the image.
-
-    :param image_file: The path to the input image file.
-    :param prjfile: The path where the project file is to be saved.
-    :type image_file: str
-    :type prjfile: str
-    """
+def prjbuild(image_file, prjfile):
 	# ----- Read the image file
 	im, rgb = image2int(image_file)
 	im = im.transpose()
 	mat_id = np.unique(im)
 	# Start writing the project file. To allow for headers we will start all
 	# pertinant information after
 	with open(prjfile, 'w') as prj:
@@ -110,20 +89,20 @@
 				str(rgb[x,1]) + '/' + str(rgb[x,2]) +
 				',,,,,,,')
 			prj.write( ln + new_line)
 		prj.write(new_line)
 	
 	# -------------------------------------------------------------------------
 	# ----- Write the attenuation parameters
-	header = ("# number, Alpha1, Alpha2, Alpha3, fref")
+	header = ("# number, Alpha1, Alpha2, Alpha3, Q1, Q2, Q3, fref_em, fref_s")
 	with open(prjfile, 'a') as prj:
 		i = 0
 		prj.write(header + new_line)
 		for x in mat_id:
-			ln = ('A,' + str(x) + ',,,,')
+			ln = ('A,' + str(x) + ',,,,,,,,')
 			prj.write(ln + new_line)
 		prj.write(new_line)
 	
 	# -------------------------------------------------------------------------
 	# ----- Write seismic parameters
 	dt = 'dt,'
 	steps = 'time_steps,'
@@ -239,16 +218,15 @@
 #	angle from x-axis in the x-y plane (+ counterclockwise when viewed from above)
 #
 # Written by Steven Bernsen
 # University of Maine
 # -----------------------------------------------------------------------------
 
 """
-def main(image_file, prjfile):
-	prjbuild(image_file, prjfile)
+
 
 # -------------------------- Command Line Arguments ---------------------------
 if __name__ == "__main__":
 	parser = argparse.ArgumentParser(description="""The SeidarT software requires a
 		.PNG image that is used to construct the model domain for seismic and
 		electromagnetic wave propagation. Given the image file, a project file
 		will be constructed which contains all the necessary parameters to be
@@ -267,10 +245,53 @@
 		the full path directory"""
 	)
 
 	# Get the arguments
 	args = parser.parse_args()
 	image_file = ''.join(args.imagefile)
 	prjfile = ''.join(args.prjfile)
-	main(image_file, prjfile)
+	prjbuild(image_file, prjfile)
+
+
 
 
+# ------------------- Write Additional Survey File Tempates -------------------
+# meta_header = """
+# # Options for the following fields
+# # project_file - (STRING) the file path to the project file
+# # survey_type - (STRING) the type of survey you would like to model. Available
+# #				options are 'co' = common offset, 'cmp' = common midpoint,
+# #				'wa' = wide angle.
+# #
+# # The following inputs change given the survey type. There are additional
+# # values that need to be passed in the wrapper
+# #
+# # delta (FLOAT)
+# #					'wa' the spacing between each reciever
+# #					'cmp' the change in the source and the reciever distance from
+# #						the common midpoint (given below)
+# #					'co' the shift in the same direction of the source and
+# #						reciever. The spacing between the source and reciever
+# #						remains constant so they are moved in the same direction
+# #
+# # initial_position (FLOAT)
+# #					'wa' the initial reciever location along the array in meters
+# #					'cmp' the reciever location
+# #					'co'  the reciever location
+# #
+# # final_position (FLOAT)
+# #					'wa' the final reciever location along the array in meters
+# #					'cmp' this is the same value as initial position; moot
+# #					'co' 			'' ''			''	''
+# #
+# """
+
+# if args.meta_file is not None:
+# 	with open(meta_file, 'w') as meta:
+# 		meta.write(meta_header + new_line)
+# 		meta.write('project_file: ' + project_file + new_line)
+# 		meta.write('survey_type: wa' + new_line)
+# 		meta.write('delta: 1' + new_line)
+# 		meta.write('initial_position: 0  0  0' + new_line)
+# 		meta.write('final_position: ' + str(np.shape(im)[0]) + '0 ' + str(np.shape(im)[0]) + new_line )
+# 		meta.write('reciever_file: None' + new_line)
+# 		meta.write('source_file: None' )
```

## seidart/routines/definitions.py

```diff
@@ -1,44 +1,18 @@
 import numpy as np
 import pandas as pd
 import seidart.routines.materials as mf
 import matplotlib.pyplot as plt
 import matplotlib.image as mpimg
 import matplotlib.animation as anim
 import os.path
-from typing import Optional
 from subprocess import call
 from scipy.io import FortranFile
 import glob2
 
-
-__all__ = [
-    'read_dat',
-    'image2int',
-    'complex2str',
-    'str2complex',
-    'append_coefficients',
-    'loadproject',
-    'prepme',
-    'coefs2prj',
-    'airsurf',
-    'rcxgen',
-    'coherdt',
-    'coherstf',
-    'stfvec2mat',
-    'movingsrc',
-    'indvar',
-    'agc',
-    'Domain',
-    'Material',
-    'Model',
-    'AnimatedGif'
-    # Add any other public names here
-]
-
 # =============================================================================
 # =========================== Define Class Variables ==========================
 # =============================================================================
 
 # We need to define some class variables
 class Domain:
     def __init__(self):
@@ -100,54 +74,23 @@
         else:
             print('\n Domain inputs are not satisfied. I can"t go on anymore. \n')
             # quit()
 
 # -----------------------------------------------------------------------------
 
 class Material:
-    """
-    A class to manage materials for simulation purposes.
-
-    Attributes
-    ----------
-    material_list : numpy.ndarray
-        An array to store the list of materials.
-    material_flag : bool
-        A flag indicating whether the materials were read in successfully.
-    material : numpy.ndarray or None
-        Stores material information.
-    rgb : numpy.ndarray or None
-        Stores RGB values for materials (not used currently).
-    temp : numpy.ndarray or None
-        Stores temperature values for materials.
-    rho : numpy.ndarray or None
-        Stores density values for materials.
-    porosity : numpy.ndarray or None
-        Stores porosity values for materials.
-    lwc : numpy.ndarray or None
-        Stores liquid water content values for materials.
-    is_anisotropic : numpy.ndarray or None
-        Indicates if the material is anisotropic.
-    angfiles : numpy.ndarray or None
-        Stores ANG file paths for anisotropic materials.
-    functions : Any
-        Stores material processing functions.
-    """
+    '''
+    
+    '''
     # initialize the class
-    def __init__(self) -> None:
-        """
-        Initializes the Material class by building the initial structure.
-        """
+    def __init__(self):
         super().__init__()
         self.build()
 
-    def build(self) -> None:
-        """
-        Initializes the material attributes with default values.
-        """
+    def build(self):
         self.material_list = np.array([]) # initialize
         self.material_flag = False # Whether the materials were read in
 
         # We will assign each of the list variables
         self.material = None
         self.rgb = None
         self.temp = None
@@ -157,33 +100,25 @@
         self.lwc = None
         self.is_anisotropic = None
         self.angfiles = None
 
         # The processing functions
         self.functions = mf
 
-    def sort_material_list(self) -> None:
-        """
-        Sorts the material list based on the material properties.
-        """
+    def sort_material_list(self):
         self.material = self.material_list[:,1]
         self.temp = self.material_list[:,2].astype(float)
         # self.attenuation = self.material_list[:,3].astype(float)
         self.rho = self.material_list[:,3].astype(float)
         self.porosity = self.material_list[:,4].astype(float)
         self.lwc = self.material_list[:,5].astype(float)
         self.is_anisotropic = self.material_list[:,6] == 'True'
         self.angfiles = self.material_list[:,7]
 
-    def para_check(self) -> None:
-        """
-        Checks the parameters of the material list for completeness.
-
-        It ensures that necessary fields are provided and checks for the presence of .ANG files for anisotropic materials.
-        """
+    def para_check(self):
         # The fields for the materials in the input are defined as:
         # 'id, R/G/B, Temp., Dens., Por., WC, Anis, ANG_File'
         # but the R/G/B column is deleted
 
         if len(self.material_list) > 0:
             # Check to make sure the necessary fields are provided
             check = 0
@@ -205,61 +140,19 @@
             if file_check == 0:
                 self.material_flag = True
             else:
                 print('No .ANG file specified for anisotropic material')
 
 # -----------------------------------------------------------------------------
 class Model:
-    """
-    A class to manage the simulation model configuration.
-
-    Attributes
-    ----------
-    dt : float or None
-        The time step size.
-    time_steps : int or None
-        The total number of time steps in the simulation.
-    x : float or None
-        The x-coordinate of the source location.
-    y : float or None
-        The y-coordinate of the source location. Optional, defaults to None.
-    z : float or None
-        The z-coordinate of the source location.
-    f0 : float or None
-        The source frequency.
-    theta : float or None
-        The angle of incidence in the xz-plane. Optional, defaults to 0 if unspecified.
-    phi : float or None
-        The angle of incidence in the xy-plane. Optional, defaults to 0 if `y` is specified and `phi` is unspecified.
-    src : Any
-        The source information. Type is unspecified.
-    tensor_coefficients : numpy.ndarray or None
-        The tensor coefficients for the simulation. Optional, but required for tensor-based simulations.
-    compute_coefficients : bool
-        A flag indicating whether to compute coefficients. Defaults to True.
-    attenuation_coefficients : numpy.ndarray or None
-        The attenuation coefficients for the simulation. Optional.
-    fref : float or None
-        The reference frequency for attenuation. Optional.
-    attenuation_fadjust : bool or None
-        Flag to adjust frequency for attenuation. Optional.
-    exit_status : int
-        Status code to indicate the success or failure of parameter checks.
-    """
-    def __init__(self) -> None:
-        """
-        Initializes the Model class by building the initial configuration.
-        """
+    def __init__(self):
         super().__init__()
         self.build()
     
-    def build(self) -> None:
-        """
-        Initializes the simulation model attributes with default values.
-        """
+    def build(self):
         self.dt = None
         self.time_steps = None
         self.x = None
         self.y = None
         self.z = None
         self.f0 = None
         self.theta = None
@@ -269,34 +162,30 @@
         self.compute_coefficients = True
         self.attenuation_coefficients = None
         self.fref = None
         self.attenuation_fadjust = None
         self.exit_status = 0
 
     
-    def tensor_check(self) -> None:
-        """
-        Checks if tensor coefficients are specified and valid. Disables coefficient computation if valid.
-        """
+    def tensor_check(self):
+        
         # If the tensors are there
         check = 0
         # if not self.tensor_coefficients:
         # 	print('ldkjf')
         for row in self.tensor_coefficients:
             for val in row:
                 if not val:
                     check = check + 1
         
         if check == 0:
             self.compute_coefficients = False
     
-    def para_check(self) -> None:
-        """
-        Performs parameter checks for essential simulation settings and updates the exit status accordingly.
-        """
+    def para_check(self):
+        
         if not self.time_steps:
             self.exit_status = 1
             print('Number of time steps aren"t satisfied.')
         
         if not self.x or not self.z:
             self.exit_status = 1
             print('No source location is specified.')
@@ -311,59 +200,28 @@
         
         # if y is specified but not phi
         if self.y and not self.phi:
             self.phi = 0
 
 # -----------------------------------------------------------------------------
 class AnimatedGif:
-    """
-    A class to create an animated GIF from a series of images.
-
-    :param size: The size of the animated GIF in pixels (width, height), 
-        defaults to (640, 480)
-    :type size: Tuple[int, int], optional
-
-    Attributes:
-        fig (matplotlib.figure.Figure): The figure object for the animation.
-        images (List): A list of image frames to be included in the GIF.
-        background (List): Background image data.
-        source_location (List[int, int]): The location of the source point in 
-        the plot.
-        nx (int): Width of the plot.
-        nz (int): Height of the plot.
-        output_format (int): Format of the output file. 0 for GIF, 1 for other 
-        formats.
-    """
     def __init__(self, size=(640,480) ):
-        """
-        Initialize the AnimatedGif class with a figure size.
-        """
         self.fig = plt.figure()
         self.fig.set_size_inches(size[0]/100, size[1]/100)
         ax = self.fig.add_axes([0, 0, 1, 1], frameon=False, aspect=1)
         ax.set_xticks([])
         ax.set_yticks([])
         self.images = []
         self.background = []
         self.source_location = []
         self.nx = size[0]
         self.nz = size[1]
         self.output_format = 0
 
     def add(self, image, label='', extent=None ):
-        """
-        Adds an image to the animation sequence.
-
-        :param image: The image data to add.
-        :type image: np.ndarray
-        :param label: The label to add to the image, defaults to ''.
-        :type label: str, optional
-        :param extent: The extent of the image, defaults to None.
-        :type extent: Tuple[int, int, int, int], optional
-        """
         bound = np.max([abs(np.min(image)),abs(np.max(image))])
         plt_im = plt.imshow(
             image,cmap='seismic',
             animated=True,
             extent=(0, (self.nx), (self.nz), 0),
             vmin=-bound,vmax=bound
         )
@@ -386,66 +244,28 @@
             extent[2] + 20,
             label,
             color='red'
         ) # Lower left corner
         self.images.append([plt_im, plt_bg, plt_txt])
 
     def save(self, filename, frame_rate = 50):
-        """
-        Save the animated GIF.
-
-        :param filename: The name of the output file.
-        :type filename: str
-        :param frame_rate: The frame rate of the animation, defaults to 50.
-        :type frame_rate: int, optional
-        """
         animation = anim.ArtistAnimation(self.fig,
                                         self.images,
                                         interval = frame_rate,
                                         blit = True
                                         )
         if self.output_format == 1:
             animation.save(filename, dpi = 300)
         else:
             animation.save(filename, dpi = 300, writer = 'imagemagick')
 
-# -------------------------- Function Definitions -----------------------------
+    # -------------------------- Function Definitions -------------------------
 def read_dat(
-        fn: str, 
-        channel: str, 
-        domain: Domain, 
-        is_complex: bool, 
-        single: bool =False
-    ) -> np.ndarray:
-    """
-    Read data from an unformatted Fortran binary file and return it as a numpy 
-    array. This function supports reading data in single or double precision, 
-    and can handle complex data.
-
-    :param fn: The filename of the data file to read.
-    :type fn: str
-    :param channel: Specifies the data channel ('Ex', 'Ey', 'Ez', etc.) 
-        to read.
-    :type channel: str
-    :param domain: The domain object that contains dimensions (dim, nx, ny, nz) 
-        of the data.
-    :type domain: Domain
-    :param is_complex: A flag indicating if the data is complex.
-    :type is_complex: bool
-    :param single: A flag indicating if the data should be read in 
-        single precision. Defaults to False (double precision).
-    :type single: bool
-    :return: The data read from the file, reshaped according to the 
-        domain dimensions.
-    :rtype: np.ndarray
-
-    The domain parameter is expected to be an object with attributes 
-        `dim`, `nx`, `ny`, and `nz`.
-    These are used to determine the shape of the returned numpy array.
-    """
+        fn: str, channel: str, domain, is_complex: bool, single: bool =False
+    ):
     if single:
         dtype = np.float32 
     else:
         dtype = np.float64 
     
     if domain.dim == 2.5:
         if channel == 'Ex':
@@ -498,37 +318,17 @@
     f.close()
     return(dat)
 
 # =============================================================================
 # ============================== Useful Functions =============================
 # =============================================================================
 
-def image2int(image_filename: str) -> np.ndarray:
-    """
-    Convert an image file into an integer array where each unique RGB color 
-    is mapped to a unique integer.
-
-    This function reads an image from a file, converts RGB colors to a single 
-    integer value by combining the RGB channels, then maps each unique color in
-    the image to a unique integer. This can be useful for image analysis tasks 
-    where colors represent different categories or labels.
-
-    :param image_filename: The path to the image file.
-    :type image_filename: str
-    :return: A 2D array where each element represents a unique integer mapping 
-        of the original RGB colors.
-    :rtype: np.ndarray
-
-    The conversion of RGB to a single value is performed using the formula: 
-    65536*red + 255*green + blue. Note that this function assumes the input 
-    image is in a format readable by matplotlib.image.imread (e.g., PNG, JPG), 
-    and that it has three color channels (RGB).
-    """
+def image2int(imfilename):
     # read the image
-    img = mpimg.imread(image_filename)
+    img = mpimg.imread(imfilename)
 
     # Convert RGB to a single value
     rgb_int = np.array(65536*img[:,:,0] +  255*img[:,:,1] + img[:,:,2])
 
     # Get the unique values of the image
     rgb_uni = np.unique(rgb_int)
 
@@ -539,168 +339,85 @@
     return rgb_int.astype(int)
 
 # -----------------------------------------------------------------------------
 # After computing tensor coefficients we want to append them to the given text
 # file. In order to do this, we need to create a new file then move it to the
 # original file
 
-def complex2str(complex_vector: np.ndarray) -> str:
-    """
-    Convert a numpy array of complex numbers into a string representation, 
-    with the first element representing an identifier and the subsequent 
-    elements representing complex numbers.
-
-    This function extracts the real and imaginary parts of each complex number 
-    in the input vector, converts them to strings, and concatenates them with 
-    'j' as the delimiter. The first real number of the input vector is treated 
-    as an identifier (ID) and is converted separately.
-
-    :param complex_vector: A numpy array of complex numbers where the first 
-        element is an ID.
-    :type complex_vector: np.ndarray
-    :return: A string representation of the ID followed by the complex numbers 
-        in the vector.
-    :rtype: str
-
-    The returned string format is 'ID,real1jimag1,real2jimag2,...' where ID is 
-    the integer ID, and realN and imagN are the real and imaginary parts of the
-    Nth complex number, respectively.
-    """
+def complex2str(complex_vector):
     reals = complex_vector.real[1:]
     comps = complex_vector.imag[1:]
     id = complex_vector.real[0].astype(int)
     m = len(reals)
     complex_string_vector = np.zeros([m], dtype = object)
     for ind in range(m):
         complex_string_vector[ind] = str(reals[ind]) + 'j' + str(comps[ind])
     
     return( str(id) + ',' + ','.join(complex_string_vector))
 
-def str2complex(strsplit: list) -> np.ndarray:
-    """
-    Convert a list of strings into a numpy array of complex numbers, where the
-    first string is treated as an identifier (ID) and the subsequent strings 
-    represent complex numbers.
-
-    The function splits each string by 'j' to separate the real and imaginary 
-    parts of each complex number, then constructs a numpy array of complex 
-    numbers from these parts. The first element of the array is the ID.
-
-    :param strsplit: A list of strings, where the first string is an ID and the 
-        remaining strings represent complex numbers in 'realjimag' format.
-    :type strsplit: list
-    :return: A numpy array of complex numbers with the ID as the first element.
-    :rtype: np.ndarray
-
-    Note that the input list should follow the format ['ID', 'real1jimag1', 
-    'real2jimag2', ...], where 'ID' is an integer identifier, and 'realNjimagN' 
-    are the real and imaginary parts of the Nth complex number.
-    """
+def str2complex(strsplit):
+    '''
+    '''
     # strsplit = line.split(',')
     id = int(strsplit[0])
     m = len(strsplit)
     complex_vector = np.zeros([m], dtype = complex)
     complex_vector[0] = id
     for ind in range(1,m):
         realvalue, complexvalue = strsplit[ind].split('j')
         complex_vector[ind] = complex(float(realvalue), float(complexvalue))
     
     return(complex_vector)
         
-def append_coefficients(
-        prjfile: str, tensor: np.ndarray, CP: str = None, dt : float = 1.0 
-    ):
-    """
-    Appends coefficients to a project file based on the provided tensor, 
-    optionally using a line identifier.
-
-    This function reads a project file, appending new coefficients derived from 
-    a tensor to it. The coefficients are appended based on a line identifier 
-    (`CP`), which specifies the type of modeling (e.g., 'C' for stiffness, 'P' 
-    for permittivity). The function also appends the time step (`dt`) for each 
-    modeling type specified by `CP`.
-
-    :param prjfile: The path to the project file to be modified.
-    :type prjfile: str
-    :param tensor: A numpy array containing the tensor coefficients to append.
-    :type tensor: np.ndarray
-    :param CP: The line identifier indicating the type of modeling 
-        ('C' or 'P'), optional.
-    :type CP: str, optional
-    :param dt: The time step to append for the modeling type, defaults to 1.
-    :type dt: float
-    :return: None
-
-    Note:
-    - The project file is updated in place, with the original file replaced by 
-      the modified one.
-    - The `tensor` can be either a complex or a real numpy array. The function 
-      handles these differently when appending to the file.
-    - This function relies on an external command (`mv`) to replace the 
-      original file, which requires that the script has permissions to execute 
-      system commands.
-    """
+def append_coefficients(prjfile, tensor, CP = None, dt=1 ):
+    '''
+    
+    # CP is the line identifier (C - stiffness, P - permittivity). This has the
+    # ability to be optional since there will is a difference between a 2nd
+    # order tensor and a 4th order tensor in regards to length but we might
+    # want to include other types of modeling in the future.
+    '''
     newfile = 'newfile.txt'
 
-    with open(prjfile, 'r') as ogprj, open(newfile, 'a') as temp:
-        # Determine modeling type based on CP
-        mt = 'S' if CP == 'C' else 'E'
-
-        for line in ogprj.readlines():
-            if line.startswith(CP):
-                line = line.strip().split(',')
-                if np.iscomplexobj(tensor):
-                    temp.write(
-                        CP + ',' + \
-                            complex2str(tensor[int(float(line[1])), :]) + \
-                                '\n'
-                    )
-                else:
-                    temp.write(
-                        CP + ',' + \
-                            ','.join(map(str, tensor[int(float(line[1])), :])) + \
-                                '\n'
-                    )
-            elif line.startswith(mt) and line[2:4] == 'dt':
-                temp.write(mt + ',dt,' + str(dt) + '\n')
+    ogprj = open(prjfile, 'r')
+    temp = open(newfile, 'a')
+    # We need to append the dt for each modeling type
+    if CP == 'C':
+        mt = 'S'
+    else:
+        mt = 'E'
+
+    for line in ogprj.readlines():
+        if line[0] == CP:
+            line = line.split(',')
+            if np.iscomplexobj(tensor):
+                temp.write( 
+                    CP + ',' + complex2str(tensor[int(float(line[1])),:]) + '\n'
+                )
             else:
-                temp.write(line)
+                temp.write(
+                    CP + ',' + \
+                        ','.join(tensor[ int(float(line[1])),:].astype(str)) \
+                            + '\n' )
+        elif line[0] == mt and line[2:4] == 'dt':
+            temp.write( mt + ',dt,' + str(dt) + '\n' )
+        else:
+            temp.write(line)
+
+        # if line[0] == mt:
+        # 	line = line.split(',')
+        # 	if line[1] == 'dt':
+        # 		temp.write( mt + ',dt,' + str(dt) + '\n' )
 
-    # Replace the original project file with the new file
-    call('mv ' + newfile + ' ' + prjfile, shell=True)
+    call('mv ' + newfile + ' ' + prjfile, shell = True)
 
 # =============================================================================
 # ========================= Read/Assign Project File ==========================
 # =============================================================================
-# -----------------------------------------------------------------------------
-def loadproject(
-        project_file: str, 
-        domain: Domain, material: Material, seismic: Model, electromag: Model
-    ) -> tuple[Domain, Material, Model, Model]:
-    """
-    Loads project settings from a project file and assigns values to domain, 
-    material, seismic, and electromagnetic objects.
-
-    This function parses a specified project file, reading configurations and parameters
-    for the domain, materials, seismic modeling, and electromagnetic properties. These
-    parameters are then assigned to the provided objects.
-
-    :param project_file: The path to the project configuration file.
-    :type project_file: str
-    :param domain: An object to hold domain-specific parameters and configurations.
-    :param material: An object to hold material-specific parameters and configurations.
-    :param seismic: An object to hold seismic modeling parameters and configurations.
-    :param electromag: An object to hold electromagnetic modeling parameters and configurations.
-    :return: A tuple containing the updated domain, material, seismic, and electromagnetic objects.
-    :rtype: tuple
-
-    The function assumes the project file contains specific prefixes for different
-    types of configurations (e.g., 'I' for images, 'D' for domain configurations, 'S' for
-    seismic modeling parameters, etc.).
-    """
+def loadproject(project_file, domain, material, seismic, electromag):
     # domain, material, seismic, electromag are the objects that we will assign
     # values to
     f = open(project_file)
 
     # Let the if train begin
     for line in f:
         if line[0] == 'I':
@@ -739,14 +456,15 @@
             # if temp[1] == 'write':
             #     domain.write = temp[2].rsplit()
             if temp[1] == 'nmats':
                 domain.nmats = int( (temp[2].rsplit())[0])
             if temp[1] == 'cpml_alpha':
                 domain.cpml_attenuation = float( (temp[2].rsplit())[0])
             
+
         if line[0] == 'S':
             temp = line.split(',')
             if temp[1] == 'dt':
                 try :
                     seismic.dt = float( (temp[2].rsplit())[0])
                 except:
                     pass
@@ -866,114 +584,66 @@
                 seismic.attenuation_coefficients = np.array(
                     temp[5:8], dtype = float
                 )
                 
             electromag.fref = float(temp[8])
             seismic.fref = float(temp[9])
 
+
+
     f.close()
     return domain, material, seismic, electromag
 
 
 # -----------------------------------------------------------------------------
 # Make sure variables are in the correct type for Fortran
-def prepme(
-        model_object: Model, 
-        domain: Domain, 
-        complex_tensor: bool = True
-    ) -> tuple:
-    """
-    Prepare modeling objects and domain configurations for simulation, ensuring
-    that all parameters are in the correct format for Fortran processing.
-
-    This function adjusts the type of various parameters in the modeling and domain objects,
-    such as converting time steps to integers or ensuring that tensor coefficients are in the
-    correct numerical format (complex or float). Additionally, it arranges source and domain
-    parameters in the correct order based on the dimensionality of the domain.
-
-    :param model_object: The modeling object containing simulation parameters and configurations.
-    :param domain: The domain object containing spatial configurations and parameters.
-    :param complex_tensor: A flag indicating whether the tensor coefficients should be treated as complex numbers.
-    :type complex_tensor: bool
-    :return: A tuple containing the updated modeling object and domain object.
-    :rtype: tuple
-
-    The function specifically adjusts parameters for compatibility with Fortran-based
-    simulation engines, accounting for differences in array indexing and data types.
-    """
+def prepme(modobj, domain, complex_tensor = True):
     # Check if there are no errors and the coefficients have been computed
-    model_object.time_steps = int(model_object.time_steps)
-    model_object.f0 = float(model_object.f0)
-    model_object.theta = float(model_object.theta)
-    model_object.x = float(model_object.x)
-    model_object.z = float(model_object.z)
+    modobj.time_steps = int(modobj.time_steps)
+    modobj.f0 = float(modobj.f0)
+    modobj.theta = float(modobj.theta)
+    modobj.x = float(modobj.x)
+    modobj.z = float(modobj.z)
     if complex_tensor:
-        model_object.tensor_coefficients = model_object.tensor_coefficients.astype(complex)
+        modobj.tensor_coefficients = modobj.tensor_coefficients.astype(complex)
     else:
-        model_object.tensor_coefficients = model_object.tensor_coefficients.astype(float)
+        modobj.tensor_coefficients = modobj.tensor_coefficients.astype(float)
     
     # Put source and domain parameters in correct order
     if domain.dim == 2.5:
         # There are additional values we need to assign
         domain.ny = int(domain.ny)
         domain.dy = float(domain.dy)
-        model_object.y = float(model_object.y)
-        model_object.phi = float(model_object.phi)
+        modobj.y = float(modobj.y)
+        modobj.phi = float(modobj.phi)
 
-        model_object.src = np.array(
+        modobj.src = np.array(
             [
-                model_object.x/domain.dx,
-                model_object.y/domain.dy,
-                model_object.z/domain.dz
+                modobj.x/domain.dx,
+                modobj.y/domain.dy,
+                modobj.z/domain.dz
             ]
         ).astype(int)
     else:
-        model_object.src = np.array(
+        modobj.src = np.array(
             [
-                model_object.x/domain.dx,
-                model_object.z/domain.dz
+                modobj.x/domain.dx,
+                modobj.z/domain.dz
             ]
         ).astype(int)
 
-    return(model_object, domain)
+    return(modobj, domain)
 
-# -----------------------------------------------------------------------------
+# ----------------------
 # Append coefficients
-def coefs2prj(model_object, material, domain, modeltype):
+def coefs2prj(modobj, matobj, domobj, modtype):
     pass
 
 
-# -----------------------------------------------------------------------------
-def airsurf(material: Material, domain: Domain, N: int = 2) -> np.ndarray:
-    """
-    Generates a gradient matrix to simulate the air surface in a domain, based 
-    on material properties.
-
-    This function calculates a gradient matrix representing the transition 
-    between air and non-air materials within a domain. It is particularly 
-    useful for creating a surface with variable density or other properties 
-    near the air-material interface.
-
-    :param material: The material object containing material lists and 
-        properties.
-    :type material: Material
-    :param domain: The domain object containing the geometry of the simulation 
-        area.
-    :type domain: Domain
-    :param N: The number of gradational steps in the air surface simulation, 
-        defaults to 2.
-    :type N: int
-    :return: A gradient matrix representing the air surface within the domain.
-    :rtype: np.ndarray
-
-    The function uses the domain's geometry to determine air interfaces and 
-    applies a gradational approach to simulate the air surface effect. The 
-    gradient matrix can be used to adjust physical properties like density near 
-    the surface.
-    """
+def airsurf(material, domain, N = 2):
     # This can be generalized a little better, but for now...
     airnum = material.material_list[material.material_list[:,1] == 'air', 0]
 
     if airnum:
         airnum = int(airnum[0])
         gradmatrix = (domain.geometry != airnum).astype(int)
         # Take the gradient in both directions
@@ -1017,95 +687,32 @@
 
         gradcomp[ gradcomp == 0] = 1
     else:
         gradcomp = np.ones([int(domain.nx), int(domain.nz) ])
 
     return(gradcomp)
 
-# -----------------------------------------------------------------------------
-def rcxgen(
-        rgb: list, 
-        domain: Domain, material: Material, 
-        filename: str = 'receivers.xyz'
-    ):
+#===============================
+def rcxgen(rgb, domain, material, filename = 'receivers.xyz'):
     """
-    Creates a receiver list from a specified RGB value found in the model 
-    image, outputting to a CSV file.
-    
-    This function searches the domain's geometry for occurrences of a given RGB 
-    value (specified as a list of integers representing red, green, and blue 
-    components). It then generates a list of receiver coordinates based on the 
-    locations where the RGB value is found. Currently, the function is set up 
-    for 2D receivers only, with Y-coordinates set to zero.
-
-    :param rgb: A list of three integers representing the RGB value to search 
-        for in the domain's geometry.
-    :type rgb: list
-    :param domain: An object representing the domain, including its geometry 
-        and spatial discretization parameters (dz, dx).
-    :param material: An object containing the material list and associated RGB 
-        values.
-    :param filename: The name of the output CSV file containing the receiver 
-        coordinates, defaults to 'receivers.xyz'.
-    :type filename: str
-    :return: A numpy array of receiver coordinates where each row represents 
-        [Z, Y, X] coordinates.
-    :rtype: np.ndarray
-
-    The function converts the RGB list into a string format, looks up the 
-        corresponding integer value from the
-    material list, finds all occurrences in the domain's geometry, and outputs 
-        the coordinates to a specified CSV file.
+    Create a receiver list from a given rgb value found in the model image.
+    This is only setup for 2D receivers
     """
     rgb = '/'.join(np.array(rgb).astype(str))
     rgbint = int(material.material_list[material.rgb == rgb,0])
     z,x = np.where(domain.geometry == rgbint)
     y = np.zeros([len(x)])
     xyz = np.stack([z*domain.dz,y,x*domain.dx], axis = 1)
     df = pd.DataFrame(xyz, columns = ['X', 'Y', 'Z'])
     df.to_csv(filename, index = False)
     return(xyz)
 
 
 # ============================== Source Functions =============================
-# -----------------------------------------------------------------------------
-def coherdt(
-        alpha: float, 
-        v: float, 
-        n: int, 
-        dx: float, 
-        loc: str = 'left'
-    ) -> np.ndarray:
-    """
-    Calculates a vector of time delays based on the angle of incidence, 
-    velocity, and spatial discretization.
-
-    This function determines the time delay for coherent addition of traces 
-    based on the propagation angle (alpha), velocity (v), and the 
-    discretization in space (dx) along the domain length.
-
-    :param alpha: The angle of incidence in degrees, counter clockwise from the 
-        x-plane. Range: (-90, 90).
-    :type alpha: float
-    :param v: Velocity in meters/second.
-    :type v: float
-    :param n: The number of spatial points in the domain.
-    :type n: int
-    :param dx: The spatial discretization in meters.
-    :type dx: float
-    :param loc: Specifies the reference point's location for time delay 
-        calculation, defaults to 'left'.
-    :type loc: str
-    :return: A numpy array containing the time delays for each spatial point in 
-        the domain.
-    :rtype: np.ndarray
-
-    The function adjusts angles outside the (-90, 90) range and calculates time 
-    delays accordingly.
-    """
+def coherdt(alpha, v, n, dx, loc = 'left'):
     # Return a vector of time delays along the length of the domain. The angle
     # alpha, given in degrees between 90 and -90, is counter clockwise from the
     # x plane. Velocity and dx are in meters/second and meters, respectively.
     if alpha < 0:
         self.dz = None
         self.cpml = None
         self.write = None
@@ -1124,186 +731,80 @@
         print('Alpha must be on the interval (-90,90)')
         quit()
 
     x = np.arange(0, n*dx, dx)
     dt = x * np.sin( np.deg2rad(alpha) ) / v
     return(dt)
 
-# -----------------------------------------------------------------------------
-def coherstf(
-        timediff: np.ndarray, 
-        source_function: np.ndarray, 
-        dt: float, 
-        m: int, n: int, cpml: int, 
-        bottom: bool = False
-    ) -> None:
-    """
-    Applies time shifts to a source time function along the domain and saves it 
-    as an m-by-n-by-p matrix.
-
-    :param timediff: A numpy array containing time differences for time 
-        shifting the source function.
-    :type timediff: np.ndarray
-    :param sf: The source time function as a numpy array.
-    :type sf: np.ndarray
-    :param dt: The time interval between successive samples in the source 
-        function.
-    :type dt: float
-    :param m: Number of indices in the y-direction (height of the domain).
-    :type m: int
-    :param n: Number of indices in the x-direction (width of the domain).
-    :type n: int
-    :param cpml: The size of the Convolutional Perfectly Matched Layer (CPML) 
-        padding.
-    :type cpml: int
-    :param bottom: Specifies whether to place the source at the bottom of the 
-        domain. Defaults to False.
-    :type bottom: bool
-    :return: None
-
-    This function time shifts the source time function for each node in the 
-    x-direction, considering CPML adjustments.
-    
-    'topleft' origin is (0,0), 
-    'topright' origin is (x_n, 0)
-    'bottomleft' origin is (0, y_n), 
-    'bottomright' origin is (x_n, y_n)
-    """
-    p = len(source_function)
+def coherstf( timediff, sf, dt, m, n, cpml, bottom=False,):
+    # 'topleft' origin is (0,0), 'topright' origin is (x_n, 0)
+    # 'bottomleft' origin is (0, y_n), 'bottomright' origin is (x_n, y_n)
+    #
+    # timediff is the vector output of coherdt,
+    # sf - is the source time function
+    # dt is the time interval
+    #
+    # We want to time shift the source time function for each node along the
+    # x-direction then save the file as an m-by-n-by-p matrix
+    p = len(sf)
     sfmat = np.zeros([m, n, p], order='F') # m indices are in the y-direction
     cpmlmat = np.zeros([2*cpml + m, 2*cpml + n, p])
     sfarray = np.zeros([m, p])  # p indices are in the t-direction
     ndiff = int(np.round(timediff/dt))
     for ind in range(0, m):
-        sfarray[ind,:] = np.roll(source_function, timediff[i])
+        sfarray[ind,:] = np.roll(sf, timediff[i])
         sfarray[ind,0:timediff[i]] == 0
     if bottom == True:
         sfmat[m,:,:] = sfarray[:]
     else:
         sfmat[0,:,:] = sfarray[:]
     cpmlmat[cpml:,cpml:,:] = sfmat[:,:,:]
     cpmlmat.T.tofile('sourcefunctionmatrix.dat')
 
-# -----------------------------------------------------------------------------
-def stfvec2mat(
-        source_function: np.ndarray, 
-        xind: int, zind: int, 
-        m: int, n: int, 
-        cpml: int, 
-        yind: int = None
-    ) -> None:
-    """
-    Converts a source time function vector to a matrix for 2D or 3D 
-    simulations.
-
-    :param sf: The source time function vector.
-    :type sf: np.ndarray
-    :param xind: The index in the x-direction where the source is located.
-    :type xind: int
-    :param zind: The index in the z-direction where the source is located.
-    :type zind: int
-    :param m: The number of indices in the y-direction (height of the domain).
-    :type m: int
-    :param n: The number of indices in the x-direction (width of the domain).
-    :type n: int
-    :param cpml: The size of the Convolutional Perfectly Matched Layer (CPML) 
-        padding.
-    :type cpml: int
-    :param yind: The index in the y-direction where the source is located, for 
-        3D simulations. Defaults to None for 2D simulations.
-    :type yind: Optional[int]
-    :return: None
-
-    This function arranges the source time function in the spatial domain and applies CPML padding.
-    """
+def stfvec2mat(sf,xind,zind, m,n, cpml,yind=None):
     # If 2D, y = None. So far we only have 2D. 3D will be implemented later
     p = len(st)
     sfmat = np.zeros([m,n,p], order = 'F')
-    sfmat[zind, xind,:] = source_function[:]
+    sfmat[zind, xind,:] = sf[:]
     cpmlmat = np.zeros([2*cpml + m, 2*cpml + n, p], order = 'F')
     cpmlmat[cpml:,cpml:,:] = sfmat[:,:,:]
     cpmlmat.T.tofile('sourcefunctionmatrix.dat')
 
-# -----------------------------------------------------------------------------
-def movingsrc(sf: np.ndarray, txlocs: np.ndarray) -> None:
-    """
-    Simulates a moving source given a stationary source time function.
-
-    :param sf: The stationary source time function as a numpy array.
-    :type sf: np.ndarray
-    :param txlocs: A numpy array containing the transmission locations over time.
-    :type txlocs: np.ndarray
-    :return: None
-    
-    This function is intended as a placeholder to simulate a moving source by manipulating the stationary source time function according to the provided transmission locations.
-    """
-    pass  # Implementation yet to be done or specified.
+def movingsrc(st, txlocs):
+    # simulate a moving source given a stationary source function
+    pass
 
 # ----------------------------- Plotting Functions ----------------------------
-def indvar(
-        model_object: Model, domain: Domain
-    ) -> tuple[np.ndarray, Optional[np.ndarray], np.ndarray, np.ndarray]:
-    """
-    Generates spatial and temporal grids based on domain and model object 
-    attributes.
-
-    :param model_object: An object containing model-specific parameters, including 
-        time steps and time interval (dt).
-    :param domain: An object containing domain-specific parameters such as 
-        spatial dimensions (nx, ny, nz) and discretizations (dx, dy, dz).
-    :return: A tuple of numpy arrays representing the grids in x, y (None if ny 
-        is not set), z, and t dimensions.
-    :rtype: tuple
-
-    The function calculates the spatial grid points in the x, z, and optionally 
-    y dimensions, and temporal grid points based on the provided domain and 
-    model parameters. The y-dimension grid is generated only if the domain 
-    parameters include 'ny'.
-    """
+def indvar(modobj, domain):
     nx = int(domain.nx[0])
     nz = int(domain.nz[0])
     dx = float(domain.dx[0])
     dz = float(domain.dz[0])
-    dt = float(model_object.dt[0])
-    nt = int(model_object.time_steps[0])
+    dt = float(modobj.dt[0])
+    nt = int(modobj.time_steps[0])
 
     x = np.linspace(0, dx * (nx - 1), nx)
     z = np.linspace(0, dz * (nz - 1), nz)
     t = np.linspace(0, dt * (nt - 1), nt)
     try:
         y = np.linspace(
             0, float(domain.dy[0]) * (int(domain.ny) - 1), int(domain.ny)
         )
     except:
         y = None
 
     return(x,y,z,t)
 
+
+
 # ---------------------------- Processing functions ---------------------------
 def agc(ts, k, agctype):
-    """
-    Applies auto-gain control (AGC) normalization to a time series using a 
-    specified window length and type.
-
-    :param ts: The input time series as a numpy array.
-    :type ts: np.ndarray
-    :param k: The length of the window used for normalization.
-    :type k: int
-    :param agctype: The type of normalization to apply, choices are "std", 
-        "mean", or "median".
-    :type agctype: str
-    :return: The time series after applying AGC normalization.
-    :rtype: np.ndarray
-
-    This function normalizes the input time series using a running window 
-    approach, with the normalization type determined by `agctype`. It supports 
-    standard deviation ("std"), mean ("mean"), or median ("median") based 
-    normalization. The function modifies the series to have a uniform amplitude 
-    characteristic over time.
-    """
+    # Auto-gain normalization using a running window
+    # k is the window length
+    # agctype is either mean, rms, median
     n = len(ts)
 
     k2 = int(k/2) # This will floor the number if k is even; (k-1)/2
     if np.mod(k, 2) == 0: # even numbers need will not have a centered window
         k = int( k + 1)
 
     stat = np.ones([n])
```

## Comparing `seidart-0.0.19.dist-info/RECORD` & `seidart-0.0.9.dist-info/RECORD`

 * *Files 12% similar despite different names*

```diff
@@ -1,28 +1,28 @@
-seidart-0.0.19.dist-info/RECORD,,
-seidart-0.0.19.dist-info/METADATA,sha256=RJwm3rhQIWmKjFoJr-80f5jzhVs4p3wIqSISXuBru6Y,44777
-seidart-0.0.19.dist-info/WHEEL,sha256=ZxHZRaViQXGefXlICKrWgK6Fz65XQ-TroyhTaUgL4RI,148
-seidart-0.0.19.dist-info/top_level.txt,sha256=M8E1K6tlpjukvjp2DWa9jKXRnBorH-dxJ7QQpTb7TQI,8
-seidart-0.0.19.dist-info/LICENSE.txt,sha256=OXLcl0T2SZ8Pmy2_dmlvKuetivmyPd5m1q-Gyd-zaYY,35149
 seidart/__init__.py,sha256=DnEUasaiggbiJ4MwpudHjtTiJ1AKIfuQiLKpJeLcC8w,100
-seidart/visualization/vtkbuild.py,sha256=cvSC4WF4Kx5Wnc6vw7hEGpRAcpcWCVbEK8RQQCjOPfc,3959
-seidart/visualization/im2anim.py,sha256=6zoBEBtilTFBhGoypkjRppNJVxko-bUcLx38cKQX04A,5082
-seidart/visualization/rcxdisplay.py,sha256=PcaxDMDQowd4Rf-MeM0btXG1Uda9mGDBhIfhby0XNSE,3764
-seidart/visualization/imgen.py,sha256=KY9H_TxVhhdqhfyrG0zRCkO1mMlIkDvDOR6CgWfUqbM,10931
-seidart/visualization/slice25d.py,sha256=mWXg5kQInCTsRW332orkpuZk4c0Znab9QkmIXxkq9VU,5014
-seidart/visualization/implot.py,sha256=mjXg2H2adSvlvTcKGEPWqiMSrInZD-H3HBwTkSL3_bw,1244
-seidart/visualization/wiggleplot.py,sha256=DqEZHGLO05Z3MLQJm8p3t4fqv_H91WKLG1Fgv7Zj8ls,6094
 seidart/fortran/__init__.py,sha256=Il5Q9ATdX8yXqVxtP_nYqUhExzxPC_qk_WXQ_4h0exg,16
-seidart/fortran/cpmlfdtd.cpython-311-i386-linux-gnu.so,sha256=RPJ4f-UihaLWoMaa5peDQFDakTVMd0NNZKX4srHd0Aw,584781
-seidart/routines/materials.py,sha256=eaRcQm9Zn4H0tUdXqtjKx-I60giGu9TngOdLB48SdgM,33977
-seidart/routines/sourcefunction.py,sha256=0LCzDwIwsJP3eLcRauj0e9DeE7E63FRf8xLn1XCl0MM,9535
-seidart/routines/prjrun.py,sha256=5xC8_2v40eSRAae49DcBXQZz2izcH2zttQykIONRaIM,21025
+seidart/fortran/cpmlfdtd.cpython-311-x86_64-linux-gnu.so,sha256=L_MgBjwhQcrZsSdtMBOBAx92Ex5oIB2QnC9Ck_oZUD4,527737
 seidart/routines/__init__.py,sha256=3EUaQp9ZCw4IvB4REGNBJpZb8XefsHW4ukqjTYR2NDk,224
-seidart/routines/arraybuild.py,sha256=R_xDWajg4y_MhOqkTV55KcDFLuLX5bsBT-hLz3x8_s4,16910
+seidart/routines/arraybuild.py,sha256=Fk29sdtzMxoVEmC0lJiGblPTmtdpy7XhyBMnO5L-52U,15149
+seidart/routines/definitions.py,sha256=i0Y2coM_7lKLLPe2F7z0a5XT7mSRZELlP7dLpH0dSZQ,28906
+seidart/routines/materials.py,sha256=-jmbtqYE5eVTbCdPzSzvOOX_-KXF7BqB-ZTBpDPLmzI,28134
 seidart/routines/orientation_tensor.py,sha256=2_F5feEqfxrnRai82WoJoOl2ODVLNL2pt6NYUqjMtYQ,2816
-seidart/routines/prjbuild.py,sha256=YOnhbo-TGpfVSkzaVip5hBjaMbCd5VmYKTU7hh-yncM,9459
-seidart/routines/definitions.py,sha256=a2eQKZ4RdO2h8Kd9JOB63OFu2cOL04D0vSp3bmE7OZ0,50433
+seidart/routines/prjbuild.py,sha256=_5YRmLotV9PmBCz5h3RBnZjxZ9bhKJfpqdQp_iS54XY,10278
+seidart/routines/prjrun.py,sha256=wVMHGO7fnfcoECPCtBaRpPcvXF7DaHqT__PIyuQvvp8,15800
+seidart/routines/sourcefunction.py,sha256=IHDNQl0j1PvsSl3VwX-OhY1b5iK1SkMGC5KCoSrGOVM,6527
 seidart/routines/test_adaptive_mesh.py,sha256=QNsdPdfNtwt05g-aKeAQ33OLpKMukHLXHfbz6LB7EMU,2145
-seidart/simulations/common_offset.py,sha256=67fcHFR0S2CjWJ9D17wkZwsAi0equWNHN8wczKiZNxE,1357
 seidart/simulations/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-seidart.libs/libquadmath-e2ac3af2.so.0.0.0,sha256=jfMFeZZPrFzTE93qT655xOMT-94XAlANEB1aTfOvv18,362301
-seidart.libs/libgfortran-a8535147.so.5.0.0,sha256=Q2DWESDD9Zo_A8duz8t6a0c2x-UZkTMzR_ThvJVtG7k,2491809
+seidart/simulations/common_offset.py,sha256=67fcHFR0S2CjWJ9D17wkZwsAi0equWNHN8wczKiZNxE,1357
+seidart/visualization/im2anim.py,sha256=tDfJCueLGx7pYQv8CZ-mf2H9WlEjw1d76XRJRIAlDt0,4062
+seidart/visualization/imgen.py,sha256=foks2CNojYcB-YetxQrlashxPw9wB1URPa7Kl9y54fE,11224
+seidart/visualization/implot.py,sha256=mjXg2H2adSvlvTcKGEPWqiMSrInZD-H3HBwTkSL3_bw,1244
+seidart/visualization/rcxdisplay.py,sha256=Sqrk3oYlLRLnfHBw3WXyt8r7WTzEIzpZsReIC7n2pnc,3606
+seidart/visualization/slice25d.py,sha256=mWXg5kQInCTsRW332orkpuZk4c0Znab9QkmIXxkq9VU,5014
+seidart/visualization/vtkbuild.py,sha256=cvSC4WF4Kx5Wnc6vw7hEGpRAcpcWCVbEK8RQQCjOPfc,3959
+seidart/visualization/wiggleplot.py,sha256=DqEZHGLO05Z3MLQJm8p3t4fqv_H91WKLG1Fgv7Zj8ls,6094
+seidart-0.0.9.dist-info/LICENSE.txt,sha256=OXLcl0T2SZ8Pmy2_dmlvKuetivmyPd5m1q-Gyd-zaYY,35149
+seidart-0.0.9.dist-info/METADATA,sha256=10CH5JpNJFfNGt5JoK_gLPQqZkf22eqc6vHfM_jtflM,49360
+seidart-0.0.9.dist-info/WHEEL,sha256=FrRrfsr8n4oDiu2RQ4P_GNkwaRm2j8S009nGoQPBEBk,114
+seidart-0.0.9.dist-info/top_level.txt,sha256=M8E1K6tlpjukvjp2DWa9jKXRnBorH-dxJ7QQpTb7TQI,8
+seidart-0.0.9.dist-info/RECORD,,
+seidart.libs/libgfortran-0a5141d4.so.5.0.0,sha256=2Q1GtvcjHiNzARQYOEXwnDulvyUE3rfdnIqSy2tJs0c,6986481
+seidart.libs/libquadmath-7463de5d.so.0.0.0,sha256=mVpujZmU8nm61USpmAu7ekLQIge2IxAZqU0uoWGBHNI,788369
```

## Comparing `seidart-0.0.19.dist-info/METADATA` & `seidart-0.0.9.dist-info/METADATA`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: seidart
-Version: 0.0.19
+Version: 0.0.9
 Summary: seidarT is a 2 and 2.5d seismic and electromagnetic modeling suite.
 Author-email: Steven Bernsen <spbernsen@alaska.edu>, Christopher Gerbi <christopher.gerbi@maine.edu>
 Maintainer-email: Steven Bernsen <spbernsen@alaska.edu>, Christopher Gerbi <christopher.gerbi@maine.edu>
 License: GNU GENERAL PUBLIC LICENSE
                                Version 3, 29 June 2007
         
          Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
@@ -711,27 +711,171 @@
 
 [comment]: ======================================================================
 
 ## Introduction <a name="introduction"></a>
 
 The Seismic and Radar Toolbox (SeidarT) is a collaboration between researchers at the Universities of Maine and Washington to provide an open source platform for forward modeling mechanical and electromagnetic wave propagation. The major objective of the project is to easily and quickly implement isotropic and anisotropic complex geometries and/or velocity structures to develop prior constraints for - not limited too - investigating, estimating, and imaging englacial ice structure, sub-glacial boundary conditions on the sub-regional scale. Larger problems would require the curvature of the Earth to be taken into consideration, but many glacier seismic and radar experiments do not expand into regional parameter estimation and velocity modeling.
 
-Much of the Staggered Grid FDTD code has been adopted from the *SEISMIC_CPML* software provided by [Computational Infrastucture for Geophysics (CIG)](https://geodynamics.org/cig/software/). Further details to the backend numerical code can be found in the [References](#references) section below.
+Much of this code has been adopted from the *SEISMIC_CPML* software provided by [Computational Infrastucture for Geophysics (CIG)](https://geodynamics.org/cig/software/). Further details to the backend numerical code can be found in the [References](#references) section below.
 
 ## Installation <a name="install"></a>
 
-The dynamical programming language of **Python3** is used as a command line interface to run the more computationally extensive modeling schemes in **Fortran**. There are a number of ways to install this software depending on your desired level of control over the process. Most users should be fine with the "automatic installation" in the [section below](#auto-install).
+The dynamical programming language of **Python3** is used as a front end to run the more computationally extensive modeling schemes in **Fortran**. There are a number of ways to install this software depending on your desired level of control over the process. Most users should be fine with the "automatic installation" in the [section below](#auto-install).
 
-SeidarT package binaries are publicly availble on the [PyPi repository](https://pypi.org/project/seidart/) and source code can be found at github (not yet public). 
+### "Auto" Installation <a name="auto-install"></a>
 
-### "Auto" installation <a name="auto-install"></a>
+First, some background:
 
-There are 2 install scripts, *full_install.sh* and *full_install.bat*, which will cover Linux, MacOS, and Windows, respectively. It's not necessary to know or do much more than execute a few command line entries via a bash terminal or powershell terminal. A virtual environment is created using the Miniconda/Anaconda package manager. This conda environment is basically a way to create an virtual Python configuration that will run but not affect your system's Python configuration. This will avoid causing system incompatibilities and complicated software dependencies. Documentation for managing conda environments with Miniconda or Anaconda can be found [here](https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html). The full Anaconda release has a GUI called Navigator for managing environments. This can be found [here](https://docs.anaconda.com/free/navigator/tutorials/manage-environments/)
+This method will install SeidarT on most Unix-based systems using a combination of Anaconda and Fortran compilation. It's not necessary to know or do much more than execute a few command line entries. However, it will help to know that the installer will create what's called a "virtual environment" or more specifically an "Anaconda environment". Without getting into details, this conda environment is basically a way to create a virtual Python configuration that will let this software run but not affect your system's Python configuration, which is a fancy way of saying that conda will avoid causing cascading bad effects on your computer. In short: conda is nice because it plays nicely with various systems. Note well that **you will have to activate this conda environment whenever you wish to run SeidarT.** This is not hard but it is critical. Read on for instructions on how to both install and activate your SeidarT conda environment.
 
+1. First, make sure you have the proper prerequisites. On Debian/Ubuntu systems, open a Terminal window and do
 
+    ~~~
+    sudo apt update
+    sudo apt install gcc-9 gfortran git
+    ~~~
+
+    **or** in a Mac OS X Terminal window with [Homebrew](https://brew.sh), copy/paste/enter the following
+
+    ~~~
+    brew update
+    brew install gcc git
+    ~~~
+
+    *Note to OS X users: you may have to install [Homebrew](https://brew.sh) if you do not have it.*
+
+2. Now, change to the directory where you'd like SeidarT to go, clone it from GitHub, and change into the SeidarT directory created by Git
+
+    ~~~
+    cd /path/to/parent/directory
+    git clone https://github.com/sbernsen/SeidarT
+    cd SeidarT
+    ~~~
+
+3. Run the auto-installer script and follow the prompts
+
+    ~~~
+    bash install.sh
+    ~~~
+
+    This script will first check if Anaconda or Miniconda already exists on your system. It will download and install Miniconda if necessary. It will also add conda to your `$PATH`, which is to say that it will tell your computer where to look to use the conda software. Then, it will use conda to create a SeidarT environment and install the rest of the requirements into that environment. Finally, it will compile the Fortran code in this repository.
+
+4. Activate the SeidarT environment (you will have to do this whenever you want to use SeidarT)
+
+    ~~~
+    conda activate SeidarT
+    ~~~
+
+    *Note: you may have to open a new Terminal window for your system to recognize `conda` as a valid command.*
+
+5. You should now be ready to run SeidarT scripts!
+
+    Remember that whenever you would like to use SeidarT in the future, you will have to activate the SeidarT conda environment first by using the command in step 4.
 
 [comment]: ======================================================================
-### Manual installation via pip <a name="manual-install-pip"></a>
+### Manual Installation Instructions <a name="manual-install"></a>
+
+This is the more involved and less sure-fire installation method, probably best left for intermediate level Unix users and up. The following system dependencies are required:
+
+**Python3, Fortran95, GCC, pip, git, dos2unix, ghostscript, imageMagick**
+
+and additionally, the **Python** dependencies: *numpy*, *scipy*, *matplotlib*, *mplstereonet* (optional for viewing fabric distributions).
+
+First, install what you will need to compile the Fortran code. This can be done via **apt** with
+~~~
+sudo apt update
+sudo apt install gcc-10 git dos2unix ghostscript imagemagick python3.8 python3-numpy python3-vtk python3-pip
+~~~
+
+and with homebrew using the commands
+
+~~~
+brew update
+brew install gcc git dos2unix ghostscript imagemagick numpy vtk python pip
+~~~
+
+Then, install the rest of the dependencies using pip
+
+~~~
+pip3 install -U matplotlib scipy pyevtk vtk mplstereonet
+~~~
+
+Anaconda installation:
+
+~~~
+conda create -n seidart python=3 pip git ghostscript imagemagick numpy matplotlib scipy pyevtk vtk
+conda activate seidart
+pip install mplstereonet
+~~~
+
+To download the software, open a terminal (*Ctrl-Alt-t* for Ubuntu and *Ctrl-Opt-Shift-t* for Mac) and change directories
+
+~~~
+cd /path/to/parent/directory
+~~~
+
+to where you would like SeidarT to be located then clone the files from *github*
+
+~~~
+git clone git@github.com:sbernsen/SeidarT.git
+~~~
+
+This will create a folder named **SeidarT** that contains all executables and modules. Change directories to the **SeidarT** folder
+
+~~~
+cd SeidarT
+~~~
+
+and run the install file
+
+~~~
+bash noconda_install.sh
+~~~
+
+When the compilation is finished, we can add the folder to the path directory and the python path directory. Currently, this software is supported with **bash** so append the following lines to the *.bashrc* if using Ubuntu
+
+~~~
+export PATH=$PATH:/path/to/SeidarT/bin
+
+export PYTHONPATH=$PYTHONPATH:/path/to/SeidarT/bin
+~~~
+
+and if Python 2 is the default version create an alias in the *.bashrc* file by adding the line in the alias section
+
+~~~
+alias python=python3
+~~~
+
+Depending on the OS release (El Capitan, High Sierra, Mojave, etc.) and whether you have *Anaconda* installed appending a path might be different. Anaconda may set aliases so troubleshooting on a Mac can be cumbersome. Before editing the */etc/path*, *.bash_profile*, *.profile* or *.bashrc* file it is a good idea to create a backup especially if you are not familiar with either or any of those files. To do this copy the original to a new name. For example,
+
+~~~
+cp <location/of/path/definitions> <location/of/path/definitions>_original
+~~~
+
+that way you can always revert back to the working script.
+
+
+There are a variety of ways to edit the documents but for simplicity change directories to the home folder
+
+~~~
+cd ~
+~~~
+
+and input into the command line
+
+~~~
+sudo nano .bashrc
+~~~
+
+or either
 
+~~~
+sudo nano /etc/paths
+sudo nano ~/.profile
+~~~
 
-### Manual installation via github source files <a name="manual-install-github"></a>
+then scroll down to the bottom of the file and append the path. Save and close (*Ctrl-x* then *Y* and enter) the file then check to make sure it is included in the path
 
+~~~
+echo $PATH
+echo $PYTHONPATH
+~~~
```

## Comparing `seidart-0.0.19.dist-info/LICENSE.txt` & `seidart-0.0.9.dist-info/LICENSE.txt`

 * *Files identical despite different names*

